var ig = Object.defineProperty;
var rg = (w, g, _) => g in w ? ig(w, g, { enumerable: !0, configurable: !0, writable: !0, value: _ }) : w[g] = _;
var Eu = (w, g, _) => rg(w, typeof g != "symbol" ? g + "" : g, _);
import { Map as ng, accessToken as sg } from "mapbox-gl";
var ag = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Hp = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.4.0/LICENSE.txt
 */
(function(w, g) {
  (function(_, x) {
    w.exports = x();
  })(ag, function() {
    var _ = {}, x = {};
    function I(v, o, D) {
      if (x[v] = D, v === "index") {
        var j = "var sharedModule = {}; (" + x.shared + ")(sharedModule); (" + x.worker + ")(sharedModule);", V = {};
        return x.shared(V), x.index(_, V), typeof window < "u" && _.setWorkerUrl(window.URL.createObjectURL(new Blob([j], { type: "text/javascript" }))), _;
      }
    }
    I("shared", ["exports"], function(v) {
      function o(i, e, r, a) {
        return new (r || (r = Promise))(function(h, d) {
          function y(M) {
            try {
              k(a.next(M));
            } catch (F) {
              d(F);
            }
          }
          function S(M) {
            try {
              k(a.throw(M));
            } catch (F) {
              d(F);
            }
          }
          function k(M) {
            var F;
            M.done ? h(M.value) : (F = M.value, F instanceof r ? F : new r(function(O) {
              O(F);
            })).then(y, S);
          }
          k((a = a.apply(i, e || [])).next());
        });
      }
      function D(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var j = V;
      function V(i, e) {
        this.x = i, this.y = e;
      }
      V.prototype = { clone: function() {
        return new V(this.x, this.y);
      }, add: function(i) {
        return this.clone()._add(i);
      }, sub: function(i) {
        return this.clone()._sub(i);
      }, multByPoint: function(i) {
        return this.clone()._multByPoint(i);
      }, divByPoint: function(i) {
        return this.clone()._divByPoint(i);
      }, mult: function(i) {
        return this.clone()._mult(i);
      }, div: function(i) {
        return this.clone()._div(i);
      }, rotate: function(i) {
        return this.clone()._rotate(i);
      }, rotateAround: function(i, e) {
        return this.clone()._rotateAround(i, e);
      }, matMult: function(i) {
        return this.clone()._matMult(i);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(i) {
        return this.x === i.x && this.y === i.y;
      }, dist: function(i) {
        return Math.sqrt(this.distSqr(i));
      }, distSqr: function(i) {
        var e = i.x - this.x, r = i.y - this.y;
        return e * e + r * r;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(i) {
        return Math.atan2(this.y - i.y, this.x - i.x);
      }, angleWith: function(i) {
        return this.angleWithSep(i.x, i.y);
      }, angleWithSep: function(i, e) {
        return Math.atan2(this.x * e - this.y * i, this.x * i + this.y * e);
      }, _matMult: function(i) {
        var e = i[2] * this.x + i[3] * this.y;
        return this.x = i[0] * this.x + i[1] * this.y, this.y = e, this;
      }, _add: function(i) {
        return this.x += i.x, this.y += i.y, this;
      }, _sub: function(i) {
        return this.x -= i.x, this.y -= i.y, this;
      }, _mult: function(i) {
        return this.x *= i, this.y *= i, this;
      }, _div: function(i) {
        return this.x /= i, this.y /= i, this;
      }, _multByPoint: function(i) {
        return this.x *= i.x, this.y *= i.y, this;
      }, _divByPoint: function(i) {
        return this.x /= i.x, this.y /= i.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var i = this.y;
        return this.y = this.x, this.x = -i, this;
      }, _rotate: function(i) {
        var e = Math.cos(i), r = Math.sin(i), a = r * this.x + e * this.y;
        return this.x = e * this.x - r * this.y, this.y = a, this;
      }, _rotateAround: function(i, e) {
        var r = Math.cos(i), a = Math.sin(i), h = e.y + a * (this.x - e.x) + r * (this.y - e.y);
        return this.x = e.x + r * (this.x - e.x) - a * (this.y - e.y), this.y = h, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, V.convert = function(i) {
        return i instanceof V ? i : Array.isArray(i) ? new V(i[0], i[1]) : i;
      };
      var q = D(j), U = B;
      function B(i, e, r, a) {
        this.cx = 3 * i, this.bx = 3 * (r - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (a - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = e, this.p2x = r, this.p2y = a;
      }
      B.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, e) {
        if (e === void 0 && (e = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var r = i, a = 0; a < 8; a++) {
          var h = this.sampleCurveX(r) - i;
          if (Math.abs(h) < e) return r;
          var d = this.sampleCurveDerivativeX(r);
          if (Math.abs(d) < 1e-6) break;
          r -= h / d;
        }
        var y = 0, S = 1;
        for (r = i, a = 0; a < 20 && (h = this.sampleCurveX(r), !(Math.abs(h - i) < e)); a++) i > h ? y = r : S = r, r = 0.5 * (S - y) + y;
        return r;
      }, solve: function(i, e) {
        return this.sampleCurveY(this.solveCurveX(i, e));
      } };
      var ye = D(U);
      let oe, xe;
      function se() {
        return oe == null && (oe = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), oe;
      }
      function ve() {
        if (xe == null && (xe = !1, se())) {
          const e = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
          if (e) {
            for (let a = 0; a < 5 * 5; a++) {
              const h = 4 * a;
              e.fillStyle = `rgb(${h},${h + 1},${h + 2})`, e.fillRect(a % 5, Math.floor(a / 5), 1, 1);
            }
            const r = e.getImageData(0, 0, 5, 5).data;
            for (let a = 0; a < 5 * 5 * 4; a++) if (a % 4 != 3 && r[a] !== a) {
              xe = !0;
              break;
            }
          }
        }
        return xe || !1;
      }
      function Fe(i, e, r, a) {
        const h = new ye(i, e, r, a);
        return (d) => h.solve(d);
      }
      const it = Fe(0.25, 0.1, 0.25, 1);
      function Ke(i, e, r) {
        return Math.min(r, Math.max(e, i));
      }
      function gt(i, e, r) {
        const a = r - e, h = ((i - e) % a + a) % a + e;
        return h === e ? r : h;
      }
      function $e(i, ...e) {
        for (const r of e) for (const a in r) i[a] = r[a];
        return i;
      }
      let Le = 1;
      function dt(i, e, r) {
        const a = {};
        for (const h in i) a[h] = e.call(this, i[h], h, i);
        return a;
      }
      function at(i, e, r) {
        const a = {};
        for (const h in i) e.call(this, i[h], h, i) && (a[h] = i[h]);
        return a;
      }
      function ae(i) {
        return Array.isArray(i) ? i.map(ae) : typeof i == "object" && i ? dt(i, ae) : i;
      }
      const he = {};
      function Ie(i) {
        he[i] || (typeof console < "u" && console.warn(i), he[i] = !0);
      }
      function Se(i, e, r) {
        return (r.y - i.y) * (e.x - i.x) > (e.y - i.y) * (r.x - i.x);
      }
      function et(i) {
        return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope;
      }
      let Qe = null;
      function rt(i) {
        return typeof ImageBitmap < "u" && i instanceof ImageBitmap;
      }
      const Ze = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function ct(i, e, r, a, h) {
        return o(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
          const d = new VideoFrame(i, { timestamp: 0 });
          try {
            const y = d == null ? void 0 : d.format;
            if (!y || !y.startsWith("BGR") && !y.startsWith("RGB")) throw new Error(`Unrecognized format ${y}`);
            const S = y.startsWith("BGR"), k = new Uint8ClampedArray(a * h * 4);
            if (yield d.copyTo(k, function(M, F, O, $, Y) {
              const ee = 4 * Math.max(-F, 0), re = (Math.max(0, O) - O) * $ * 4 + ee, me = 4 * $, be = Math.max(0, F), Re = Math.max(0, O);
              return { rect: { x: be, y: Re, width: Math.min(M.width, F + $) - be, height: Math.min(M.height, O + Y) - Re }, layout: [{ offset: re, stride: me }] };
            }(i, e, r, a, h)), S) for (let M = 0; M < k.length; M += 4) {
              const F = k[M];
              k[M] = k[M + 2], k[M + 2] = F;
            }
            return k;
          } finally {
            d.close();
          }
        });
      }
      let nt, wt;
      const K = "AbortError";
      function ge() {
        return new Error(K);
      }
      const we = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function Ee(i) {
        return we.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))];
      }
      const Be = "global-dispatcher";
      class Ve extends Error {
        constructor(e, r, a, h) {
          super(`AJAXError: ${r} (${e}): ${a}`), this.status = e, this.statusText = r, this.url = a, this.body = h;
        }
      }
      const We = () => et(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Ye = function(i, e) {
        if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
          const a = Ee(i.url);
          if (a) return a(i, e);
          if (et(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, targetMapId: Be }, e);
        }
        if (!(/^file:/.test(r = i.url) || /^file:/.test(We()) && !/^\w+:/.test(r))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(a, h) {
            return o(this, void 0, void 0, function* () {
              const d = new Request(a.url, { method: a.method || "GET", body: a.body, credentials: a.credentials, headers: a.headers, cache: a.cache, referrer: We(), signal: h.signal });
              a.type !== "json" || d.headers.has("Accept") || d.headers.set("Accept", "application/json");
              const y = yield fetch(d);
              if (!y.ok) {
                const M = yield y.blob();
                throw new Ve(y.status, y.statusText, a.url, M);
              }
              let S;
              S = a.type === "arrayBuffer" || a.type === "image" ? y.arrayBuffer() : a.type === "json" ? y.json() : y.text();
              const k = yield S;
              if (h.signal.aborted) throw ge();
              return { data: k, cacheControl: y.headers.get("Cache-Control"), expires: y.headers.get("Expires") };
            });
          }(i, e);
          if (et(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, mustQueue: !0, targetMapId: Be }, e);
        }
        var r;
        return function(a, h) {
          return new Promise((d, y) => {
            var S;
            const k = new XMLHttpRequest();
            k.open(a.method || "GET", a.url, !0), a.type !== "arrayBuffer" && a.type !== "image" || (k.responseType = "arraybuffer");
            for (const M in a.headers) k.setRequestHeader(M, a.headers[M]);
            a.type === "json" && (k.responseType = "text", !((S = a.headers) === null || S === void 0) && S.Accept || k.setRequestHeader("Accept", "application/json")), k.withCredentials = a.credentials === "include", k.onerror = () => {
              y(new Error(k.statusText));
            }, k.onload = () => {
              if (!h.signal.aborted) if ((k.status >= 200 && k.status < 300 || k.status === 0) && k.response !== null) {
                let M = k.response;
                if (a.type === "json") try {
                  M = JSON.parse(k.response);
                } catch (F) {
                  return void y(F);
                }
                d({ data: M, cacheControl: k.getResponseHeader("Cache-Control"), expires: k.getResponseHeader("Expires") });
              } else {
                const M = new Blob([k.response], { type: k.getResponseHeader("Content-Type") });
                y(new Ve(k.status, k.statusText, a.url, M));
              }
            }, h.signal.addEventListener("abort", () => {
              k.abort(), y(ge());
            }), k.send(a.body);
          });
        }(i, e);
      };
      function bt(i) {
        if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
        const e = new URL(i), r = window.location;
        return e.protocol === r.protocol && e.host === r.host;
      }
      function xt(i, e, r) {
        r[i] && r[i].indexOf(e) !== -1 || (r[i] = r[i] || [], r[i].push(e));
      }
      function kt(i, e, r) {
        if (r && r[i]) {
          const a = r[i].indexOf(e);
          a !== -1 && r[i].splice(a, 1);
        }
      }
      class zt {
        constructor(e, r = {}) {
          $e(this, r), this.type = e;
        }
      }
      class Ut extends zt {
        constructor(e, r = {}) {
          super("error", $e({ error: e }, r));
        }
      }
      class st {
        on(e, r) {
          return this._listeners = this._listeners || {}, xt(e, r, this._listeners), this;
        }
        off(e, r) {
          return kt(e, r, this._listeners), kt(e, r, this._oneTimeListeners), this;
        }
        once(e, r) {
          return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, xt(e, r, this._oneTimeListeners), this) : new Promise((a) => this.once(e, a));
        }
        fire(e, r) {
          typeof e == "string" && (e = new zt(e, r || {}));
          const a = e.type;
          if (this.listens(a)) {
            e.target = this;
            const h = this._listeners && this._listeners[a] ? this._listeners[a].slice() : [];
            for (const S of h) S.call(this, e);
            const d = this._oneTimeListeners && this._oneTimeListeners[a] ? this._oneTimeListeners[a].slice() : [];
            for (const S of d) kt(a, S, this._oneTimeListeners), S.call(this, e);
            const y = this._eventedParent;
            y && ($e(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), y.fire(e));
          } else e instanceof Ut && console.error(e.error);
          return this;
        }
        listens(e) {
          return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
        }
        setEventedParent(e, r) {
          return this._eventedParent = e, this._eventedParentData = r, this;
        }
      }
      var te = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const hi = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function Ht(i, e) {
        const r = {};
        for (const a in i) a !== "ref" && (r[a] = i[a]);
        return hi.forEach((a) => {
          a in e && (r[a] = e[a]);
        }), r;
      }
      function ut(i, e) {
        if (Array.isArray(i)) {
          if (!Array.isArray(e) || i.length !== e.length) return !1;
          for (let r = 0; r < i.length; r++) if (!ut(i[r], e[r])) return !1;
          return !0;
        }
        if (typeof i == "object" && i !== null && e !== null) {
          if (typeof e != "object" || Object.keys(i).length !== Object.keys(e).length) return !1;
          for (const r in i) if (!ut(i[r], e[r])) return !1;
          return !0;
        }
        return i === e;
      }
      function _t(i, e) {
        i.push(e);
      }
      function Lt(i, e, r) {
        _t(r, { command: "addSource", args: [i, e[i]] });
      }
      function Ct(i, e, r) {
        _t(e, { command: "removeSource", args: [i] }), r[i] = !0;
      }
      function ei(i, e, r, a) {
        Ct(i, r, a), Lt(i, e, r);
      }
      function pi(i, e, r) {
        let a;
        for (a in i[r]) if (Object.prototype.hasOwnProperty.call(i[r], a) && a !== "data" && !ut(i[r][a], e[r][a])) return !1;
        for (a in e[r]) if (Object.prototype.hasOwnProperty.call(e[r], a) && a !== "data" && !ut(i[r][a], e[r][a])) return !1;
        return !0;
      }
      function fi(i, e, r, a, h, d) {
        i = i || {}, e = e || {};
        for (const y in i) Object.prototype.hasOwnProperty.call(i, y) && (ut(i[y], e[y]) || r.push({ command: d, args: [a, y, e[y], h] }));
        for (const y in e) Object.prototype.hasOwnProperty.call(e, y) && !Object.prototype.hasOwnProperty.call(i, y) && (ut(i[y], e[y]) || r.push({ command: d, args: [a, y, e[y], h] }));
      }
      function wi(i) {
        return i.id;
      }
      function Ci(i, e) {
        return i[e.id] = e, i;
      }
      class pt {
        constructor(e, r, a, h) {
          this.message = (e ? `${e}: ` : "") + a, h && (this.identifier = h), r != null && r.__line__ && (this.line = r.__line__);
        }
      }
      function Jt(i, ...e) {
        for (const r of e) for (const a in r) i[a] = r[a];
        return i;
      }
      class ui extends Error {
        constructor(e, r) {
          super(r), this.message = r, this.key = e;
        }
      }
      class Dt {
        constructor(e, r = []) {
          this.parent = e, this.bindings = {};
          for (const [a, h] of r) this.bindings[a] = h;
        }
        concat(e) {
          return new Dt(this, e);
        }
        get(e) {
          if (this.bindings[e]) return this.bindings[e];
          if (this.parent) return this.parent.get(e);
          throw new Error(`${e} not found in scope.`);
        }
        has(e) {
          return !!this.bindings[e] || !!this.parent && this.parent.has(e);
        }
      }
      const gr = { kind: "null" }, lt = { kind: "number" }, li = { kind: "string" }, Bt = { kind: "boolean" }, ki = { kind: "color" }, lr = { kind: "object" }, Ft = { kind: "value" }, nn = { kind: "collator" }, Oi = { kind: "formatted" }, $i = { kind: "padding" }, de = { kind: "resolvedImage" }, Z = { kind: "variableAnchorOffsetCollection" };
      function W(i, e) {
        return { kind: "array", itemType: i, N: e };
      }
      function J(i) {
        if (i.kind === "array") {
          const e = J(i.itemType);
          return typeof i.N == "number" ? `array<${e}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${e}>`;
        }
        return i.kind;
      }
      const fe = [gr, lt, li, Bt, ki, Oi, lr, W(Ft), $i, de, Z];
      function Ae(i, e) {
        if (e.kind === "error") return null;
        if (i.kind === "array") {
          if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !Ae(i.itemType, e.itemType)) && (typeof i.N != "number" || i.N === e.N)) return null;
        } else {
          if (i.kind === e.kind) return null;
          if (i.kind === "value") {
            for (const r of fe) if (!Ae(r, e)) return null;
          }
        }
        return `Expected ${J(i)} but found ${J(e)} instead.`;
      }
      function Ce(i, e) {
        return e.some((r) => r.kind === i.kind);
      }
      function Me(i, e) {
        return e.some((r) => r === "null" ? i === null : r === "array" ? Array.isArray(i) : r === "object" ? i && !Array.isArray(i) && typeof i == "object" : r === typeof i);
      }
      function pe(i, e) {
        return i.kind === "array" && e.kind === "array" ? i.itemType.kind === e.itemType.kind && typeof i.N == "number" : i.kind === e.kind;
      }
      const Oe = 0.96422, ot = 0.82521, Je = 4 / 29, Ge = 6 / 29, It = 3 * Ge * Ge, Nt = Ge * Ge * Ge, gi = Math.PI / 180, ti = 180 / Math.PI;
      function mi(i) {
        return (i %= 360) < 0 && (i += 360), i;
      }
      function Ii([i, e, r, a]) {
        let h, d;
        const y = Ui((0.2225045 * (i = Ei(i)) + 0.7168786 * (e = Ei(e)) + 0.0606169 * (r = Ei(r))) / 1);
        i === e && e === r ? h = d = y : (h = Ui((0.4360747 * i + 0.3850649 * e + 0.1430804 * r) / Oe), d = Ui((0.0139322 * i + 0.0971045 * e + 0.7141733 * r) / ot));
        const S = 116 * y - 16;
        return [S < 0 ? 0 : S, 500 * (h - y), 200 * (y - d), a];
      }
      function Ei(i) {
        return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
      }
      function Ui(i) {
        return i > Nt ? Math.pow(i, 1 / 3) : i / It + Je;
      }
      function ai([i, e, r, a]) {
        let h = (i + 16) / 116, d = isNaN(e) ? h : h + e / 500, y = isNaN(r) ? h : h - r / 200;
        return h = 1 * er(h), d = Oe * er(d), y = ot * er(y), [Fi(3.1338561 * d - 1.6168667 * h - 0.4906146 * y), Fi(-0.9787684 * d + 1.9161415 * h + 0.033454 * y), Fi(0.0719453 * d - 0.2289914 * h + 1.4052427 * y), a];
      }
      function Fi(i) {
        return (i = i <= 304e-5 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055) < 0 ? 0 : i > 1 ? 1 : i;
      }
      function er(i) {
        return i > Ge ? i * i * i : It * (i - Je);
      }
      function Mr(i) {
        return parseInt(i.padEnd(2, i), 16) / 255;
      }
      function Nr(i, e) {
        return cr(e ? i / 100 : i, 0, 1);
      }
      function cr(i, e, r) {
        return Math.min(Math.max(e, i), r);
      }
      function Jn(i) {
        return !i.some(Number.isNaN);
      }
      const Qo = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      class Ri {
        constructor(e, r, a, h = 1, d = !0) {
          this.r = e, this.g = r, this.b = a, this.a = h, d || (this.r *= h, this.g *= h, this.b *= h, h || this.overwriteGetter("rgb", [e, r, a, h]));
        }
        static parse(e) {
          if (e instanceof Ri) return e;
          if (typeof e != "string") return;
          const r = function(a) {
            if ((a = a.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
            const h = Qo[a];
            if (h) {
              const [y, S, k] = h;
              return [y / 255, S / 255, k / 255, 1];
            }
            if (a.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)) {
              const y = a.length < 6 ? 1 : 2;
              let S = 1;
              return [Mr(a.slice(S, S += y)), Mr(a.slice(S, S += y)), Mr(a.slice(S, S += y)), Mr(a.slice(S, S + y) || "ff")];
            }
            if (a.startsWith("rgb")) {
              const y = a.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (y) {
                const [S, k, M, F, O, $, Y, ee, re, me, be, Re] = y, Pe = [F || " ", Y || " ", me].join("");
                if (Pe === "  " || Pe === "  /" || Pe === ",," || Pe === ",,,") {
                  const ze = [M, $, re].join(""), Xe = ze === "%%%" ? 100 : ze === "" ? 255 : 0;
                  if (Xe) {
                    const mt = [cr(+k / Xe, 0, 1), cr(+O / Xe, 0, 1), cr(+ee / Xe, 0, 1), be ? Nr(+be, Re) : 1];
                    if (Jn(mt)) return mt;
                  }
                }
                return;
              }
            }
            const d = a.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (d) {
              const [y, S, k, M, F, O, $, Y, ee] = d, re = [k || " ", F || " ", $].join("");
              if (re === "  " || re === "  /" || re === ",," || re === ",,,") {
                const me = [+S, cr(+M, 0, 100), cr(+O, 0, 100), Y ? Nr(+Y, ee) : 1];
                if (Jn(me)) return function([be, Re, Pe, ze]) {
                  function Xe(mt) {
                    const At = (mt + be / 30) % 12, Kt = Re * Math.min(Pe, 1 - Pe);
                    return Pe - Kt * Math.max(-1, Math.min(At - 3, 9 - At, 1));
                  }
                  return be = mi(be), Re /= 100, Pe /= 100, [Xe(0), Xe(8), Xe(4), ze];
                }(me);
              }
            }
          }(e);
          return r ? new Ri(...r, !1) : void 0;
        }
        get rgb() {
          const { r: e, g: r, b: a, a: h } = this, d = h || 1 / 0;
          return this.overwriteGetter("rgb", [e / d, r / d, a / d, h]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(e) {
            const [r, a, h, d] = Ii(e), y = Math.sqrt(a * a + h * h);
            return [Math.round(1e4 * y) ? mi(Math.atan2(h, a) * ti) : NaN, y, r, d];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", Ii(this.rgb));
        }
        overwriteGetter(e, r) {
          return Object.defineProperty(this, e, { value: r }), r;
        }
        toString() {
          const [e, r, a, h] = this.rgb;
          return `rgba(${[e, r, a].map((d) => Math.round(255 * d)).join(",")},${h})`;
        }
      }
      Ri.black = new Ri(0, 0, 0, 1), Ri.white = new Ri(1, 1, 1, 1), Ri.transparent = new Ri(0, 0, 0, 0), Ri.red = new Ri(1, 0, 0, 1);
      class Co {
        constructor(e, r, a) {
          this.sensitivity = e ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = a, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(e, r) {
          return this.collator.compare(e, r);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class ea {
        constructor(e, r, a, h, d) {
          this.text = e, this.image = r, this.scale = a, this.fontStack = h, this.textColor = d;
        }
      }
      class Yr {
        constructor(e) {
          this.sections = e;
        }
        static fromString(e) {
          return new Yr([new ea(e, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
        }
        static factory(e) {
          return e instanceof Yr ? e : Yr.fromString(e);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
        }
      }
      class Jr {
        constructor(e) {
          this.values = e.slice();
        }
        static parse(e) {
          if (e instanceof Jr) return e;
          if (typeof e == "number") return new Jr([e, e, e, e]);
          if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
            for (const r of e) if (typeof r != "number") return;
            switch (e.length) {
              case 1:
                e = [e[0], e[0], e[0], e[0]];
                break;
              case 2:
                e = [e[0], e[1], e[0], e[1]];
                break;
              case 3:
                e = [e[0], e[1], e[2], e[1]];
            }
            return new Jr(e);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const Cs = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class Kr {
        constructor(e) {
          this.values = e.slice();
        }
        static parse(e) {
          if (e instanceof Kr) return e;
          if (Array.isArray(e) && !(e.length < 1) && e.length % 2 == 0) {
            for (let r = 0; r < e.length; r += 2) {
              const a = e[r], h = e[r + 1];
              if (typeof a != "string" || !Cs.has(a) || !Array.isArray(h) || h.length !== 2 || typeof h[0] != "number" || typeof h[1] != "number") return;
            }
            return new Kr(e);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class sn {
        constructor(e) {
          this.name = e.name, this.available = e.available;
        }
        toString() {
          return this.name;
        }
        static fromString(e) {
          return e ? new sn({ name: e, available: !1 }) : null;
        }
      }
      function el(i, e, r, a) {
        return typeof i == "number" && i >= 0 && i <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[i, e, r, a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a == "number" ? [i, e, r, a] : [i, e, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function cn(i) {
        if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof Ri || i instanceof Co || i instanceof Yr || i instanceof Jr || i instanceof Kr || i instanceof sn) return !0;
        if (Array.isArray(i)) {
          for (const e of i) if (!cn(e)) return !1;
          return !0;
        }
        if (typeof i == "object") {
          for (const e in i) if (!cn(i[e])) return !1;
          return !0;
        }
        return !1;
      }
      function yr(i) {
        if (i === null) return gr;
        if (typeof i == "string") return li;
        if (typeof i == "boolean") return Bt;
        if (typeof i == "number") return lt;
        if (i instanceof Ri) return ki;
        if (i instanceof Co) return nn;
        if (i instanceof Yr) return Oi;
        if (i instanceof Jr) return $i;
        if (i instanceof Kr) return Z;
        if (i instanceof sn) return de;
        if (Array.isArray(i)) {
          const e = i.length;
          let r;
          for (const a of i) {
            const h = yr(a);
            if (r) {
              if (r === h) continue;
              r = Ft;
              break;
            }
            r = h;
          }
          return W(r || Ft, e);
        }
        return lr;
      }
      function tr(i) {
        const e = typeof i;
        return i === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(i) : i instanceof Ri || i instanceof Yr || i instanceof Jr || i instanceof Kr || i instanceof sn ? i.toString() : JSON.stringify(i);
      }
      class us {
        constructor(e, r) {
          this.type = e, this.value = r;
        }
        static parse(e, r) {
          if (e.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (!cn(e[1])) return r.error("invalid value");
          const a = e[1];
          let h = yr(a);
          const d = r.expectedType;
          return h.kind !== "array" || h.N !== 0 || !d || d.kind !== "array" || typeof d.N == "number" && d.N !== 0 || (h = d), new us(h, a);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      class ir {
        constructor(e) {
          this.name = "ExpressionEvaluationError", this.message = e;
        }
        toJSON() {
          return this.message;
        }
      }
      const ds = { string: li, number: lt, boolean: Bt, object: lr };
      class an {
        constructor(e, r) {
          this.type = e, this.args = r;
        }
        static parse(e, r) {
          if (e.length < 2) return r.error("Expected at least one argument.");
          let a, h = 1;
          const d = e[0];
          if (d === "array") {
            let S, k;
            if (e.length > 2) {
              const M = e[1];
              if (typeof M != "string" || !(M in ds) || M === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
              S = ds[M], h++;
            } else S = Ft;
            if (e.length > 3) {
              if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
              k = e[2], h++;
            }
            a = W(S, k);
          } else {
            if (!ds[d]) throw new Error(`Types doesn't contain name = ${d}`);
            a = ds[d];
          }
          const y = [];
          for (; h < e.length; h++) {
            const S = r.parse(e[h], h, Ft);
            if (!S) return null;
            y.push(S);
          }
          return new an(a, y);
        }
        evaluate(e) {
          for (let r = 0; r < this.args.length; r++) {
            const a = this.args[r].evaluate(e);
            if (!Ae(this.type, yr(a))) return a;
            if (r === this.args.length - 1) throw new ir(`Expected value to be of type ${J(this.type)}, but found ${J(yr(a))} instead.`);
          }
          throw new Error();
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      }
      const Ga = { "to-boolean": Bt, "to-color": ki, "to-number": lt, "to-string": li };
      class Ar {
        constructor(e, r) {
          this.type = e, this.args = r;
        }
        static parse(e, r) {
          if (e.length < 2) return r.error("Expected at least one argument.");
          const a = e[0];
          if (!Ga[a]) throw new Error(`Can't parse ${a} as it is not part of the known types`);
          if ((a === "to-boolean" || a === "to-string") && e.length !== 2) return r.error("Expected one argument.");
          const h = Ga[a], d = [];
          for (let y = 1; y < e.length; y++) {
            const S = r.parse(e[y], y, Ft);
            if (!S) return null;
            d.push(S);
          }
          return new Ar(h, d);
        }
        evaluate(e) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(e);
            case "color": {
              let r, a;
              for (const h of this.args) {
                if (r = h.evaluate(e), a = null, r instanceof Ri) return r;
                if (typeof r == "string") {
                  const d = e.parseColor(r);
                  if (d) return d;
                } else if (Array.isArray(r) && (a = r.length < 3 || r.length > 4 ? `Invalid rbga value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : el(r[0], r[1], r[2], r[3]), !a)) return new Ri(r[0] / 255, r[1] / 255, r[2] / 255, r[3]);
              }
              throw new ir(a || `Could not parse color from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
            }
            case "padding": {
              let r;
              for (const a of this.args) {
                r = a.evaluate(e);
                const h = Jr.parse(r);
                if (h) return h;
              }
              throw new ir(`Could not parse padding from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let r;
              for (const a of this.args) {
                r = a.evaluate(e);
                const h = Kr.parse(r);
                if (h) return h;
              }
              throw new ir(`Could not parse variableAnchorOffsetCollection from value '${typeof r == "string" ? r : JSON.stringify(r)}'`);
            }
            case "number": {
              let r = null;
              for (const a of this.args) {
                if (r = a.evaluate(e), r === null) return 0;
                const h = Number(r);
                if (!isNaN(h)) return h;
              }
              throw new ir(`Could not convert ${JSON.stringify(r)} to number.`);
            }
            case "formatted":
              return Yr.fromString(tr(this.args[0].evaluate(e)));
            case "resolvedImage":
              return sn.fromString(tr(this.args[0].evaluate(e)));
            default:
              return tr(this.args[0].evaluate(e));
          }
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      }
      const ta = ["Unknown", "Point", "LineString", "Polygon"];
      class Dr {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? ta[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(e) {
          let r = this._parseColorCache[e];
          return r || (r = this._parseColorCache[e] = Ri.parse(e)), r;
        }
      }
      class Mi {
        constructor(e, r, a = [], h, d = new Dt(), y = []) {
          this.registry = e, this.path = a, this.key = a.map((S) => `[${S}]`).join(""), this.scope = d, this.errors = y, this.expectedType = h, this._isConstant = r;
        }
        parse(e, r, a, h, d = {}) {
          return r ? this.concat(r, a, h)._parse(e, d) : this._parse(e, d);
        }
        _parse(e, r) {
          function a(h, d, y) {
            return y === "assert" ? new an(d, [h]) : y === "coerce" ? new Ar(d, [h]) : h;
          }
          if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
            if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const h = e[0];
            if (typeof h != "string") return this.error(`Expression name must be a string, but found ${typeof h} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const d = this.registry[h];
            if (d) {
              let y = d.parse(e, this);
              if (!y) return null;
              if (this.expectedType) {
                const S = this.expectedType, k = y.type;
                if (S.kind !== "string" && S.kind !== "number" && S.kind !== "boolean" && S.kind !== "object" && S.kind !== "array" || k.kind !== "value") if (S.kind !== "color" && S.kind !== "formatted" && S.kind !== "resolvedImage" || k.kind !== "value" && k.kind !== "string") if (S.kind !== "padding" || k.kind !== "value" && k.kind !== "number" && k.kind !== "array") if (S.kind !== "variableAnchorOffsetCollection" || k.kind !== "value" && k.kind !== "array") {
                  if (this.checkSubtype(S, k)) return null;
                } else y = a(y, S, r.typeAnnotation || "coerce");
                else y = a(y, S, r.typeAnnotation || "coerce");
                else y = a(y, S, r.typeAnnotation || "coerce");
                else y = a(y, S, r.typeAnnotation || "assert");
              }
              if (!(y instanceof us) && y.type.kind !== "resolvedImage" && this._isConstant(y)) {
                const S = new Dr();
                try {
                  y = new us(y.type, y.evaluate(S));
                } catch (k) {
                  return this.error(k.message), null;
                }
              }
              return y;
            }
            return this.error(`Unknown expression "${h}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
        }
        concat(e, r, a) {
          const h = typeof e == "number" ? this.path.concat(e) : this.path, d = a ? this.scope.concat(a) : this.scope;
          return new Mi(this.registry, this._isConstant, h, r || null, d, this.errors);
        }
        error(e, ...r) {
          const a = `${this.key}${r.map((h) => `[${h}]`).join("")}`;
          this.errors.push(new ui(a, e));
        }
        checkSubtype(e, r) {
          const a = Ae(e, r);
          return a && this.error(a), a;
        }
      }
      class Ta {
        constructor(e, r) {
          this.type = r.type, this.bindings = [].concat(e), this.result = r;
        }
        evaluate(e) {
          return this.result.evaluate(e);
        }
        eachChild(e) {
          for (const r of this.bindings) e(r[1]);
          e(this.result);
        }
        static parse(e, r) {
          if (e.length < 4) return r.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
          const a = [];
          for (let d = 1; d < e.length - 1; d += 2) {
            const y = e[d];
            if (typeof y != "string") return r.error(`Expected string, but found ${typeof y} instead.`, d);
            if (/[^a-zA-Z0-9_]/.test(y)) return r.error("Variable names must contain only alphanumeric characters or '_'.", d);
            const S = r.parse(e[d + 1], d + 1);
            if (!S) return null;
            a.push([y, S]);
          }
          const h = r.parse(e[e.length - 1], e.length - 1, r.expectedType, a);
          return h ? new Ta(a, h) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class ia {
        constructor(e, r) {
          this.type = r.type, this.name = e, this.boundExpression = r;
        }
        static parse(e, r) {
          if (e.length !== 2 || typeof e[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
          const a = e[1];
          return r.scope.has(a) ? new ia(a, r.scope.get(a)) : r.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(e) {
          return this.boundExpression.evaluate(e);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class Ha {
        constructor(e, r, a) {
          this.type = e, this.index = r, this.input = a;
        }
        static parse(e, r) {
          if (e.length !== 3) return r.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const a = r.parse(e[1], 1, lt), h = r.parse(e[2], 2, W(r.expectedType || Ft));
          return a && h ? new Ha(h.type.itemType, a, h) : null;
        }
        evaluate(e) {
          const r = this.index.evaluate(e), a = this.input.evaluate(e);
          if (r < 0) throw new ir(`Array index out of bounds: ${r} < 0.`);
          if (r >= a.length) throw new ir(`Array index out of bounds: ${r} > ${a.length - 1}.`);
          if (r !== Math.floor(r)) throw new ir(`Array index must be an integer, but found ${r} instead.`);
          return a[r];
        }
        eachChild(e) {
          e(this.index), e(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Xa {
        constructor(e, r) {
          this.type = Bt, this.needle = e, this.haystack = r;
        }
        static parse(e, r) {
          if (e.length !== 3) return r.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const a = r.parse(e[1], 1, Ft), h = r.parse(e[2], 2, Ft);
          return a && h ? Ce(a.type, [Bt, li, lt, gr, Ft]) ? new Xa(a, h) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${J(a.type)} instead`) : null;
        }
        evaluate(e) {
          const r = this.needle.evaluate(e), a = this.haystack.evaluate(e);
          if (!a) return !1;
          if (!Me(r, ["boolean", "string", "number", "null"])) throw new ir(`Expected first argument to be of type boolean, string, number or null, but found ${J(yr(r))} instead.`);
          if (!Me(a, ["string", "array"])) throw new ir(`Expected second argument to be of type array or string, but found ${J(yr(a))} instead.`);
          return a.indexOf(r) >= 0;
        }
        eachChild(e) {
          e(this.needle), e(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class ra {
        constructor(e, r, a) {
          this.type = lt, this.needle = e, this.haystack = r, this.fromIndex = a;
        }
        static parse(e, r) {
          if (e.length <= 2 || e.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const a = r.parse(e[1], 1, Ft), h = r.parse(e[2], 2, Ft);
          if (!a || !h) return null;
          if (!Ce(a.type, [Bt, li, lt, gr, Ft])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${J(a.type)} instead`);
          if (e.length === 4) {
            const d = r.parse(e[3], 3, lt);
            return d ? new ra(a, h, d) : null;
          }
          return new ra(a, h);
        }
        evaluate(e) {
          const r = this.needle.evaluate(e), a = this.haystack.evaluate(e);
          if (!Me(r, ["boolean", "string", "number", "null"])) throw new ir(`Expected first argument to be of type boolean, string, number or null, but found ${J(yr(r))} instead.`);
          if (!Me(a, ["string", "array"])) throw new ir(`Expected second argument to be of type array or string, but found ${J(yr(a))} instead.`);
          if (this.fromIndex) {
            const h = this.fromIndex.evaluate(e);
            return a.indexOf(r, h);
          }
          return a.indexOf(r);
        }
        eachChild(e) {
          e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class Eo {
        constructor(e, r, a, h, d, y) {
          this.inputType = e, this.type = r, this.input = a, this.cases = h, this.outputs = d, this.otherwise = y;
        }
        static parse(e, r) {
          if (e.length < 5) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 1) return r.error("Expected an even number of arguments.");
          let a, h;
          r.expectedType && r.expectedType.kind !== "value" && (h = r.expectedType);
          const d = {}, y = [];
          for (let M = 2; M < e.length - 1; M += 2) {
            let F = e[M];
            const O = e[M + 1];
            Array.isArray(F) || (F = [F]);
            const $ = r.concat(M);
            if (F.length === 0) return $.error("Expected at least one branch label.");
            for (const ee of F) {
              if (typeof ee != "number" && typeof ee != "string") return $.error("Branch labels must be numbers or strings.");
              if (typeof ee == "number" && Math.abs(ee) > Number.MAX_SAFE_INTEGER) return $.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof ee == "number" && Math.floor(ee) !== ee) return $.error("Numeric branch labels must be integer values.");
              if (a) {
                if ($.checkSubtype(a, yr(ee))) return null;
              } else a = yr(ee);
              if (d[String(ee)] !== void 0) return $.error("Branch labels must be unique.");
              d[String(ee)] = y.length;
            }
            const Y = r.parse(O, M, h);
            if (!Y) return null;
            h = h || Y.type, y.push(Y);
          }
          const S = r.parse(e[1], 1, Ft);
          if (!S) return null;
          const k = r.parse(e[e.length - 1], e.length - 1, h);
          return k ? S.type.kind !== "value" && r.concat(1).checkSubtype(a, S.type) ? null : new Eo(a, h, S, d, y, k) : null;
        }
        evaluate(e) {
          const r = this.input.evaluate(e);
          return (yr(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(e);
        }
        eachChild(e) {
          e(this.input), this.outputs.forEach(e), e(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class na {
        constructor(e, r, a) {
          this.type = e, this.branches = r, this.otherwise = a;
        }
        static parse(e, r) {
          if (e.length < 4) return r.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 0) return r.error("Expected an odd number of arguments.");
          let a;
          r.expectedType && r.expectedType.kind !== "value" && (a = r.expectedType);
          const h = [];
          for (let y = 1; y < e.length - 1; y += 2) {
            const S = r.parse(e[y], y, Bt);
            if (!S) return null;
            const k = r.parse(e[y + 1], y + 1, a);
            if (!k) return null;
            h.push([S, k]), a = a || k.type;
          }
          const d = r.parse(e[e.length - 1], e.length - 1, a);
          if (!d) return null;
          if (!a) throw new Error("Can't infer output type");
          return new na(a, h, d);
        }
        evaluate(e) {
          for (const [r, a] of this.branches) if (r.evaluate(e)) return a.evaluate(e);
          return this.otherwise.evaluate(e);
        }
        eachChild(e) {
          for (const [r, a] of this.branches) e(r), e(a);
          e(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([e, r]) => r.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class ka {
        constructor(e, r, a, h) {
          this.type = e, this.input = r, this.beginIndex = a, this.endIndex = h;
        }
        static parse(e, r) {
          if (e.length <= 2 || e.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const a = r.parse(e[1], 1, Ft), h = r.parse(e[2], 2, lt);
          if (!a || !h) return null;
          if (!Ce(a.type, [W(Ft), li, Ft])) return r.error(`Expected first argument to be of type array or string, but found ${J(a.type)} instead`);
          if (e.length === 4) {
            const d = r.parse(e[3], 3, lt);
            return d ? new ka(a.type, a, h, d) : null;
          }
          return new ka(a.type, a, h);
        }
        evaluate(e) {
          const r = this.input.evaluate(e), a = this.beginIndex.evaluate(e);
          if (!Me(r, ["string", "array"])) throw new ir(`Expected first argument to be of type array or string, but found ${J(yr(r))} instead.`);
          if (this.endIndex) {
            const h = this.endIndex.evaluate(e);
            return r.slice(a, h);
          }
          return r.slice(a);
        }
        eachChild(e) {
          e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function Ya(i, e) {
        const r = i.length - 1;
        let a, h, d = 0, y = r, S = 0;
        for (; d <= y; ) if (S = Math.floor((d + y) / 2), a = i[S], h = i[S + 1], a <= e) {
          if (S === r || e < h) return S;
          d = S + 1;
        } else {
          if (!(a > e)) throw new ir("Input is not a number.");
          y = S - 1;
        }
        return 0;
      }
      class La {
        constructor(e, r, a) {
          this.type = e, this.input = r, this.labels = [], this.outputs = [];
          for (const [h, d] of a) this.labels.push(h), this.outputs.push(d);
        }
        static parse(e, r) {
          if (e.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
          const a = r.parse(e[1], 1, lt);
          if (!a) return null;
          const h = [];
          let d = null;
          r.expectedType && r.expectedType.kind !== "value" && (d = r.expectedType);
          for (let y = 1; y < e.length; y += 2) {
            const S = y === 1 ? -1 / 0 : e[y], k = e[y + 1], M = y, F = y + 1;
            if (typeof S != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', M);
            if (h.length && h[h.length - 1][0] >= S) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', M);
            const O = r.parse(k, F, d);
            if (!O) return null;
            d = d || O.type, h.push([S, O]);
          }
          return new La(d, a, h);
        }
        evaluate(e) {
          const r = this.labels, a = this.outputs;
          if (r.length === 1) return a[0].evaluate(e);
          const h = this.input.evaluate(e);
          if (h <= r[0]) return a[0].evaluate(e);
          const d = r.length;
          return h >= r[d - 1] ? a[d - 1].evaluate(e) : a[Ya(r, h)].evaluate(e);
        }
        eachChild(e) {
          e(this.input);
          for (const r of this.outputs) e(r);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
      }
      function Es(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      var Ja = sa;
      function sa(i, e, r, a) {
        this.cx = 3 * i, this.bx = 3 * (r - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (a - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = e, this.p2x = r, this.p2y = a;
      }
      sa.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, e) {
        if (e === void 0 && (e = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var r = i, a = 0; a < 8; a++) {
          var h = this.sampleCurveX(r) - i;
          if (Math.abs(h) < e) return r;
          var d = this.sampleCurveDerivativeX(r);
          if (Math.abs(d) < 1e-6) break;
          r -= h / d;
        }
        var y = 0, S = 1;
        for (r = i, a = 0; a < 20 && (h = this.sampleCurveX(r), !(Math.abs(h - i) < e)); a++) i > h ? y = r : S = r, r = 0.5 * (S - y) + y;
        return r;
      }, solve: function(i, e) {
        return this.sampleCurveY(this.solveCurveX(i, e));
      } };
      var Mo = Es(Ja);
      function _r(i, e, r) {
        return i + r * (e - i);
      }
      function Ka(i, e, r) {
        return i.map((a, h) => _r(a, e[h], r));
      }
      const Rr = { number: _r, color: function(i, e, r, a = "rgb") {
        switch (a) {
          case "rgb": {
            const [h, d, y, S] = Ka(i.rgb, e.rgb, r);
            return new Ri(h, d, y, S, !1);
          }
          case "hcl": {
            const [h, d, y, S] = i.hcl, [k, M, F, O] = e.hcl;
            let $, Y;
            if (isNaN(h) || isNaN(k)) isNaN(h) ? isNaN(k) ? $ = NaN : ($ = k, y !== 1 && y !== 0 || (Y = M)) : ($ = h, F !== 1 && F !== 0 || (Y = d));
            else {
              let Re = k - h;
              k > h && Re > 180 ? Re -= 360 : k < h && h - k > 180 && (Re += 360), $ = h + r * Re;
            }
            const [ee, re, me, be] = function([Re, Pe, ze, Xe]) {
              return Re = isNaN(Re) ? 0 : Re * gi, ai([ze, Math.cos(Re) * Pe, Math.sin(Re) * Pe, Xe]);
            }([$, Y ?? _r(d, M, r), _r(y, F, r), _r(S, O, r)]);
            return new Ri(ee, re, me, be, !1);
          }
          case "lab": {
            const [h, d, y, S] = ai(Ka(i.lab, e.lab, r));
            return new Ri(h, d, y, S, !1);
          }
        }
      }, array: Ka, padding: function(i, e, r) {
        return new Jr(Ka(i.values, e.values, r));
      }, variableAnchorOffsetCollection: function(i, e, r) {
        const a = i.values, h = e.values;
        if (a.length !== h.length) throw new ir(`Cannot interpolate values of different length. from: ${i.toString()}, to: ${e.toString()}`);
        const d = [];
        for (let y = 0; y < a.length; y += 2) {
          if (a[y] !== h[y]) throw new ir(`Cannot interpolate values containing mismatched anchors. from[${y}]: ${a[y]}, to[${y}]: ${h[y]}`);
          d.push(a[y]);
          const [S, k] = a[y + 1], [M, F] = h[y + 1];
          d.push([_r(S, M, r), _r(k, F, r)]);
        }
        return new Kr(d);
      } };
      class ri {
        constructor(e, r, a, h, d) {
          this.type = e, this.operator = r, this.interpolation = a, this.input = h, this.labels = [], this.outputs = [];
          for (const [y, S] of d) this.labels.push(y), this.outputs.push(S);
        }
        static interpolationFactor(e, r, a, h) {
          let d = 0;
          if (e.name === "exponential") d = Do(r, e.base, a, h);
          else if (e.name === "linear") d = Do(r, 1, a, h);
          else if (e.name === "cubic-bezier") {
            const y = e.controlPoints;
            d = new Mo(y[0], y[1], y[2], y[3]).solve(Do(r, 1, a, h));
          }
          return d;
        }
        static parse(e, r) {
          let [a, h, d, ...y] = e;
          if (!Array.isArray(h) || h.length === 0) return r.error("Expected an interpolation type expression.", 1);
          if (h[0] === "linear") h = { name: "linear" };
          else if (h[0] === "exponential") {
            const M = h[1];
            if (typeof M != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
            h = { name: "exponential", base: M };
          } else {
            if (h[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(h[0])}`, 1, 0);
            {
              const M = h.slice(1);
              if (M.length !== 4 || M.some((F) => typeof F != "number" || F < 0 || F > 1)) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              h = { name: "cubic-bezier", controlPoints: M };
            }
          }
          if (e.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
          if (d = r.parse(d, 2, lt), !d) return null;
          const S = [];
          let k = null;
          a === "interpolate-hcl" || a === "interpolate-lab" ? k = ki : r.expectedType && r.expectedType.kind !== "value" && (k = r.expectedType);
          for (let M = 0; M < y.length; M += 2) {
            const F = y[M], O = y[M + 1], $ = M + 3, Y = M + 4;
            if (typeof F != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', $);
            if (S.length && S[S.length - 1][0] >= F) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', $);
            const ee = r.parse(O, Y, k);
            if (!ee) return null;
            k = k || ee.type, S.push([F, ee]);
          }
          return pe(k, lt) || pe(k, ki) || pe(k, $i) || pe(k, Z) || pe(k, W(lt)) ? new ri(k, a, h, d, S) : r.error(`Type ${J(k)} is not interpolatable.`);
        }
        evaluate(e) {
          const r = this.labels, a = this.outputs;
          if (r.length === 1) return a[0].evaluate(e);
          const h = this.input.evaluate(e);
          if (h <= r[0]) return a[0].evaluate(e);
          const d = r.length;
          if (h >= r[d - 1]) return a[d - 1].evaluate(e);
          const y = Ya(r, h), S = ri.interpolationFactor(this.interpolation, h, r[y], r[y + 1]), k = a[y].evaluate(e), M = a[y + 1].evaluate(e);
          switch (this.operator) {
            case "interpolate":
              return Rr[this.type.kind](k, M, S);
            case "interpolate-hcl":
              return Rr.color(k, M, S, "hcl");
            case "interpolate-lab":
              return Rr.color(k, M, S, "lab");
          }
        }
        eachChild(e) {
          e(this.input);
          for (const r of this.outputs) e(r);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
      }
      function Do(i, e, r, a) {
        const h = a - r, d = i - r;
        return h === 0 ? 0 : e === 1 ? d / h : (Math.pow(e, d) - 1) / (Math.pow(e, h) - 1);
      }
      class Qa {
        constructor(e, r) {
          this.type = e, this.args = r;
        }
        static parse(e, r) {
          if (e.length < 2) return r.error("Expectected at least one argument.");
          let a = null;
          const h = r.expectedType;
          h && h.kind !== "value" && (a = h);
          const d = [];
          for (const S of e.slice(1)) {
            const k = r.parse(S, 1 + d.length, a, void 0, { typeAnnotation: "omit" });
            if (!k) return null;
            a = a || k.type, d.push(k);
          }
          if (!a) throw new Error("No output type");
          const y = h && d.some((S) => Ae(h, S.type));
          return new Qa(y ? Ft : a, d);
        }
        evaluate(e) {
          let r, a = null, h = 0;
          for (const d of this.args) if (h++, a = d.evaluate(e), a && a instanceof sn && !a.available && (r || (r = a.name), a = null, h === this.args.length && (a = r)), a !== null) break;
          return a;
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      }
      function En(i, e) {
        return i === "==" || i === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
      }
      function eo(i, e, r, a) {
        return a.compare(e, r) === 0;
      }
      function Ms(i, e, r) {
        const a = i !== "==" && i !== "!=";
        return class Xp {
          constructor(d, y, S) {
            this.type = Bt, this.lhs = d, this.rhs = y, this.collator = S, this.hasUntypedArgument = d.type.kind === "value" || y.type.kind === "value";
          }
          static parse(d, y) {
            if (d.length !== 3 && d.length !== 4) return y.error("Expected two or three arguments.");
            const S = d[0];
            let k = y.parse(d[1], 1, Ft);
            if (!k) return null;
            if (!En(S, k.type)) return y.concat(1).error(`"${S}" comparisons are not supported for type '${J(k.type)}'.`);
            let M = y.parse(d[2], 2, Ft);
            if (!M) return null;
            if (!En(S, M.type)) return y.concat(2).error(`"${S}" comparisons are not supported for type '${J(M.type)}'.`);
            if (k.type.kind !== M.type.kind && k.type.kind !== "value" && M.type.kind !== "value") return y.error(`Cannot compare types '${J(k.type)}' and '${J(M.type)}'.`);
            a && (k.type.kind === "value" && M.type.kind !== "value" ? k = new an(M.type, [k]) : k.type.kind !== "value" && M.type.kind === "value" && (M = new an(k.type, [M])));
            let F = null;
            if (d.length === 4) {
              if (k.type.kind !== "string" && M.type.kind !== "string" && k.type.kind !== "value" && M.type.kind !== "value") return y.error("Cannot use collator to compare non-string types.");
              if (F = y.parse(d[3], 3, nn), !F) return null;
            }
            return new Xp(k, M, F);
          }
          evaluate(d) {
            const y = this.lhs.evaluate(d), S = this.rhs.evaluate(d);
            if (a && this.hasUntypedArgument) {
              const k = yr(y), M = yr(S);
              if (k.kind !== M.kind || k.kind !== "string" && k.kind !== "number") throw new ir(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${k.kind}, ${M.kind}) instead.`);
            }
            if (this.collator && !a && this.hasUntypedArgument) {
              const k = yr(y), M = yr(S);
              if (k.kind !== "string" || M.kind !== "string") return e(d, y, S);
            }
            return this.collator ? r(d, y, S, this.collator.evaluate(d)) : e(d, y, S);
          }
          eachChild(d) {
            d(this.lhs), d(this.rhs), this.collator && d(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const to = Ms("==", function(i, e, r) {
        return e === r;
      }, eo), io = Ms("!=", function(i, e, r) {
        return e !== r;
      }, function(i, e, r, a) {
        return !eo(0, e, r, a);
      }), tl = Ms("<", function(i, e, r) {
        return e < r;
      }, function(i, e, r, a) {
        return a.compare(e, r) < 0;
      }), kl = Ms(">", function(i, e, r) {
        return e > r;
      }, function(i, e, r, a) {
        return a.compare(e, r) > 0;
      }), Ll = Ms("<=", function(i, e, r) {
        return e <= r;
      }, function(i, e, r, a) {
        return a.compare(e, r) <= 0;
      }), zo = Ms(">=", function(i, e, r) {
        return e >= r;
      }, function(i, e, r, a) {
        return a.compare(e, r) >= 0;
      });
      class ps {
        constructor(e, r, a) {
          this.type = nn, this.locale = a, this.caseSensitive = e, this.diacriticSensitive = r;
        }
        static parse(e, r) {
          if (e.length !== 2) return r.error("Expected one argument.");
          const a = e[1];
          if (typeof a != "object" || Array.isArray(a)) return r.error("Collator options argument must be an object.");
          const h = r.parse(a["case-sensitive"] !== void 0 && a["case-sensitive"], 1, Bt);
          if (!h) return null;
          const d = r.parse(a["diacritic-sensitive"] !== void 0 && a["diacritic-sensitive"], 1, Bt);
          if (!d) return null;
          let y = null;
          return a.locale && (y = r.parse(a.locale, 1, li), !y) ? null : new ps(h, d, y);
        }
        evaluate(e) {
          return new Co(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
        }
        eachChild(e) {
          e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class fs {
        constructor(e, r, a, h, d) {
          this.type = li, this.number = e, this.locale = r, this.currency = a, this.minFractionDigits = h, this.maxFractionDigits = d;
        }
        static parse(e, r) {
          if (e.length !== 3) return r.error("Expected two arguments.");
          const a = r.parse(e[1], 1, lt);
          if (!a) return null;
          const h = e[2];
          if (typeof h != "object" || Array.isArray(h)) return r.error("NumberFormat options argument must be an object.");
          let d = null;
          if (h.locale && (d = r.parse(h.locale, 1, li), !d)) return null;
          let y = null;
          if (h.currency && (y = r.parse(h.currency, 1, li), !y)) return null;
          let S = null;
          if (h["min-fraction-digits"] && (S = r.parse(h["min-fraction-digits"], 1, lt), !S)) return null;
          let k = null;
          return h["max-fraction-digits"] && (k = r.parse(h["max-fraction-digits"], 1, lt), !k) ? null : new fs(a, d, y, S, k);
        }
        evaluate(e) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
        }
        eachChild(e) {
          e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class ro {
        constructor(e) {
          this.type = Oi, this.sections = e;
        }
        static parse(e, r) {
          if (e.length < 2) return r.error("Expected at least one argument.");
          const a = e[1];
          if (!Array.isArray(a) && typeof a == "object") return r.error("First argument must be an image or text section.");
          const h = [];
          let d = !1;
          for (let y = 1; y <= e.length - 1; ++y) {
            const S = e[y];
            if (d && typeof S == "object" && !Array.isArray(S)) {
              d = !1;
              let k = null;
              if (S["font-scale"] && (k = r.parse(S["font-scale"], 1, lt), !k)) return null;
              let M = null;
              if (S["text-font"] && (M = r.parse(S["text-font"], 1, W(li)), !M)) return null;
              let F = null;
              if (S["text-color"] && (F = r.parse(S["text-color"], 1, ki), !F)) return null;
              const O = h[h.length - 1];
              O.scale = k, O.font = M, O.textColor = F;
            } else {
              const k = r.parse(e[y], 1, Ft);
              if (!k) return null;
              const M = k.type.kind;
              if (M !== "string" && M !== "value" && M !== "null" && M !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              d = !0, h.push({ content: k, scale: null, font: null, textColor: null });
            }
          }
          return new ro(h);
        }
        evaluate(e) {
          return new Yr(this.sections.map((r) => {
            const a = r.content.evaluate(e);
            return yr(a) === de ? new ea("", a, null, null, null) : new ea(tr(a), null, r.scale ? r.scale.evaluate(e) : null, r.font ? r.font.evaluate(e).join(",") : null, r.textColor ? r.textColor.evaluate(e) : null);
          }));
        }
        eachChild(e) {
          for (const r of this.sections) e(r.content), r.scale && e(r.scale), r.font && e(r.font), r.textColor && e(r.textColor);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ds {
        constructor(e) {
          this.type = de, this.input = e;
        }
        static parse(e, r) {
          if (e.length !== 2) return r.error("Expected two arguments.");
          const a = r.parse(e[1], 1, li);
          return a ? new Ds(a) : r.error("No image name provided.");
        }
        evaluate(e) {
          const r = this.input.evaluate(e), a = sn.fromString(r);
          return a && e.availableImages && (a.available = e.availableImages.indexOf(r) > -1), a;
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class zs {
        constructor(e) {
          this.type = lt, this.input = e;
        }
        static parse(e, r) {
          if (e.length !== 2) return r.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
          const a = r.parse(e[1], 1);
          return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${J(a.type)} instead.`) : new zs(a) : null;
        }
        evaluate(e) {
          const r = this.input.evaluate(e);
          if (typeof r == "string" || Array.isArray(r)) return r.length;
          throw new ir(`Expected value to be of type string or array, but found ${J(yr(r))} instead.`);
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const Br = 8192;
      function zi(i, e) {
        const r = (180 + i[0]) / 360, a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360, h = Math.pow(2, e.z);
        return [Math.round(r * h * Br), Math.round(a * h * Br)];
      }
      function no(i, e) {
        const r = Math.pow(2, e.z);
        return [(h = (i[0] / Br + e.x) / r, 360 * h - 180), (a = (i[1] / Br + e.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90)];
        var a, h;
      }
      function aa(i, e) {
        i[0] = Math.min(i[0], e[0]), i[1] = Math.min(i[1], e[1]), i[2] = Math.max(i[2], e[0]), i[3] = Math.max(i[3], e[1]);
      }
      function oa(i, e) {
        return !(i[0] <= e[0] || i[2] >= e[2] || i[1] <= e[1] || i[3] >= e[3]);
      }
      function Fs(i, e, r) {
        const a = i[0] - e[0], h = i[1] - e[1], d = i[0] - r[0], y = i[1] - r[1];
        return a * y - d * h == 0 && a * d <= 0 && h * y <= 0;
      }
      function Kn(i, e, r, a) {
        return (h = [a[0] - r[0], a[1] - r[1]])[0] * (d = [e[0] - i[0], e[1] - i[1]])[1] - h[1] * d[0] != 0 && !(!il(i, e, r, a) || !il(r, a, i, e));
        var h, d;
      }
      function Cl(i, e, r) {
        for (const a of r) for (let h = 0; h < a.length - 1; ++h) if (Kn(i, e, a[h], a[h + 1])) return !0;
        return !1;
      }
      function wn(i, e, r = !1) {
        let a = !1;
        for (const S of e) for (let k = 0; k < S.length - 1; k++) {
          if (Fs(i, S[k], S[k + 1])) return r;
          (d = S[k])[1] > (h = i)[1] != (y = S[k + 1])[1] > h[1] && h[0] < (y[0] - d[0]) * (h[1] - d[1]) / (y[1] - d[1]) + d[0] && (a = !a);
        }
        var h, d, y;
        return a;
      }
      function Qn(i, e) {
        for (const r of e) if (wn(i, r)) return !0;
        return !1;
      }
      function so(i, e) {
        for (const r of i) if (!wn(r, e)) return !1;
        for (let r = 0; r < i.length - 1; ++r) if (Cl(i[r], i[r + 1], e)) return !1;
        return !0;
      }
      function Ca(i, e) {
        for (const r of e) if (so(i, r)) return !0;
        return !1;
      }
      function il(i, e, r, a) {
        const h = a[0] - r[0], d = a[1] - r[1], y = (i[0] - r[0]) * d - h * (i[1] - r[1]), S = (e[0] - r[0]) * d - h * (e[1] - r[1]);
        return y > 0 && S < 0 || y < 0 && S > 0;
      }
      function la(i, e, r) {
        const a = [];
        for (let h = 0; h < i.length; h++) {
          const d = [];
          for (let y = 0; y < i[h].length; y++) {
            const S = zi(i[h][y], r);
            aa(e, S), d.push(S);
          }
          a.push(d);
        }
        return a;
      }
      function rl(i, e, r) {
        const a = [];
        for (let h = 0; h < i.length; h++) {
          const d = la(i[h], e, r);
          a.push(d);
        }
        return a;
      }
      function ao(i, e, r, a) {
        if (i[0] < r[0] || i[0] > r[2]) {
          const h = 0.5 * a;
          let d = i[0] - r[0] > h ? -a : r[0] - i[0] > h ? a : 0;
          d === 0 && (d = i[0] - r[2] > h ? -a : r[2] - i[0] > h ? a : 0), i[0] += d;
        }
        aa(e, i);
      }
      function oo(i, e, r, a) {
        const h = Math.pow(2, a.z) * Br, d = [a.x * Br, a.y * Br], y = [];
        for (const S of i) for (const k of S) {
          const M = [k.x + d[0], k.y + d[1]];
          ao(M, e, r, h), y.push(M);
        }
        return y;
      }
      function Fo(i, e, r, a) {
        const h = Math.pow(2, a.z) * Br, d = [a.x * Br, a.y * Br], y = [];
        for (const k of i) {
          const M = [];
          for (const F of k) {
            const O = [F.x + d[0], F.y + d[1]];
            aa(e, O), M.push(O);
          }
          y.push(M);
        }
        if (e[2] - e[0] <= h / 2) {
          (S = e)[0] = S[1] = 1 / 0, S[2] = S[3] = -1 / 0;
          for (const k of y) for (const M of k) ao(M, e, r, h);
        }
        var S;
        return y;
      }
      class Mn {
        constructor(e, r) {
          this.type = Bt, this.geojson = e, this.geometries = r;
        }
        static parse(e, r) {
          if (e.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (cn(e[1])) {
            const a = e[1];
            if (a.type === "FeatureCollection") {
              const h = [];
              for (const d of a.features) {
                const { type: y, coordinates: S } = d.geometry;
                y === "Polygon" && h.push(S), y === "MultiPolygon" && h.push(...S);
              }
              if (h.length) return new Mn(a, { type: "MultiPolygon", coordinates: h });
            } else if (a.type === "Feature") {
              const h = a.geometry.type;
              if (h === "Polygon" || h === "MultiPolygon") return new Mn(a, a.geometry);
            } else if (a.type === "Polygon" || a.type === "MultiPolygon") return new Mn(a, a);
          }
          return r.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point") return function(r, a) {
              const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = r.canonicalID();
              if (a.type === "Polygon") {
                const S = la(a.coordinates, d, y), k = oo(r.geometry(), h, d, y);
                if (!oa(h, d)) return !1;
                for (const M of k) if (!wn(M, S)) return !1;
              }
              if (a.type === "MultiPolygon") {
                const S = rl(a.coordinates, d, y), k = oo(r.geometry(), h, d, y);
                if (!oa(h, d)) return !1;
                for (const M of k) if (!Qn(M, S)) return !1;
              }
              return !0;
            }(e, this.geometries);
            if (e.geometryType() === "LineString") return function(r, a) {
              const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = r.canonicalID();
              if (a.type === "Polygon") {
                const S = la(a.coordinates, d, y), k = Fo(r.geometry(), h, d, y);
                if (!oa(h, d)) return !1;
                for (const M of k) if (!so(M, S)) return !1;
              }
              if (a.type === "MultiPolygon") {
                const S = rl(a.coordinates, d, y), k = Fo(r.geometry(), h, d, y);
                if (!oa(h, d)) return !1;
                for (const M of k) if (!Ca(M, S)) return !1;
              }
              return !0;
            }(e, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      let lo = class {
        constructor(i = [], e = No) {
          if (this.data = i, this.length = this.data.length, this.compare = e, this.length > 0) for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);
        }
        push(i) {
          this.data.push(i), this.length++, this._up(this.length - 1);
        }
        pop() {
          if (this.length === 0) return;
          const i = this.data[0], e = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), i;
        }
        peek() {
          return this.data[0];
        }
        _up(i) {
          const { data: e, compare: r } = this, a = e[i];
          for (; i > 0; ) {
            const h = i - 1 >> 1, d = e[h];
            if (r(a, d) >= 0) break;
            e[i] = d, i = h;
          }
          e[i] = a;
        }
        _down(i) {
          const { data: e, compare: r } = this, a = this.length >> 1, h = e[i];
          for (; i < a; ) {
            let d = 1 + (i << 1), y = e[d];
            const S = d + 1;
            if (S < this.length && r(e[S], y) < 0 && (d = S, y = e[S]), r(y, h) >= 0) break;
            e[i] = y, i = d;
          }
          e[i] = h;
        }
      };
      function No(i, e) {
        return i < e ? -1 : i > e ? 1 : 0;
      }
      function nl(i, e, r, a, h) {
        sl(i, e, r, a || i.length - 1, h || Ea);
      }
      function sl(i, e, r, a, h) {
        for (; a > r; ) {
          if (a - r > 600) {
            var d = a - r + 1, y = e - r + 1, S = Math.log(d), k = 0.5 * Math.exp(2 * S / 3), M = 0.5 * Math.sqrt(S * k * (d - k) / d) * (y - d / 2 < 0 ? -1 : 1);
            sl(i, e, Math.max(r, Math.floor(e - y * k / d + M)), Math.min(a, Math.floor(e + (d - y) * k / d + M)), h);
          }
          var F = i[e], O = r, $ = a;
          for (ms(i, r, e), h(i[a], F) > 0 && ms(i, r, a); O < $; ) {
            for (ms(i, O, $), O++, $--; h(i[O], F) < 0; ) O++;
            for (; h(i[$], F) > 0; ) $--;
          }
          h(i[r], F) === 0 ? ms(i, r, $) : ms(i, ++$, a), $ <= e && (r = $ + 1), e <= $ && (a = $ - 1);
        }
      }
      function ms(i, e, r) {
        var a = i[e];
        i[e] = i[r], i[r] = a;
      }
      function Ea(i, e) {
        return i < e ? -1 : i > e ? 1 : 0;
      }
      function ca(i, e) {
        if (i.length <= 1) return [i];
        const r = [];
        let a, h;
        for (const d of i) {
          const y = Ro(d);
          y !== 0 && (d.area = Math.abs(y), h === void 0 && (h = y < 0), h === y < 0 ? (a && r.push(a), a = [d]) : a.push(d));
        }
        if (a && r.push(a), e > 1) for (let d = 0; d < r.length; d++) r[d].length <= e || (nl(r[d], e, 1, r[d].length - 1, ha), r[d] = r[d].slice(0, e));
        return r;
      }
      function ha(i, e) {
        return e.area - i.area;
      }
      function Ro(i) {
        let e = 0;
        for (let r, a, h = 0, d = i.length, y = d - 1; h < d; y = h++) r = i[h], a = i[y], e += (a.x - r.x) * (r.y + a.y);
        return e;
      }
      const L = 1 / 298.257223563, X = L * (2 - L), _e = Math.PI / 180;
      class ke {
        constructor(e) {
          const r = 6378.137 * _e * 1e3, a = Math.cos(e * _e), h = 1 / (1 - X * (1 - a * a)), d = Math.sqrt(h);
          this.kx = r * d * a, this.ky = r * d * h * (1 - X);
        }
        distance(e, r) {
          const a = this.wrap(e[0] - r[0]) * this.kx, h = (e[1] - r[1]) * this.ky;
          return Math.sqrt(a * a + h * h);
        }
        pointOnLine(e, r) {
          let a, h, d, y, S = 1 / 0;
          for (let k = 0; k < e.length - 1; k++) {
            let M = e[k][0], F = e[k][1], O = this.wrap(e[k + 1][0] - M) * this.kx, $ = (e[k + 1][1] - F) * this.ky, Y = 0;
            O === 0 && $ === 0 || (Y = (this.wrap(r[0] - M) * this.kx * O + (r[1] - F) * this.ky * $) / (O * O + $ * $), Y > 1 ? (M = e[k + 1][0], F = e[k + 1][1]) : Y > 0 && (M += O / this.kx * Y, F += $ / this.ky * Y)), O = this.wrap(r[0] - M) * this.kx, $ = (r[1] - F) * this.ky;
            const ee = O * O + $ * $;
            ee < S && (S = ee, a = M, h = F, d = k, y = Y);
          }
          return { point: [a, h], index: d, t: Math.max(0, Math.min(1, y)) };
        }
        wrap(e) {
          for (; e < -180; ) e += 360;
          for (; e > 180; ) e -= 360;
          return e;
        }
      }
      function je(i, e) {
        return e[0] - i[0];
      }
      function tt(i) {
        return i[1] - i[0] + 1;
      }
      function yt(i, e) {
        return i[1] >= i[0] && i[1] < e;
      }
      function jt(i, e) {
        if (i[0] > i[1]) return [null, null];
        const r = tt(i);
        if (e) {
          if (r === 2) return [i, null];
          const h = Math.floor(r / 2);
          return [[i[0], i[0] + h], [i[0] + h, i[1]]];
        }
        if (r === 1) return [i, null];
        const a = Math.floor(r / 2) - 1;
        return [[i[0], i[0] + a], [i[0] + a + 1, i[1]]];
      }
      function oi(i, e) {
        if (!yt(e, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let a = e[0]; a <= e[1]; ++a) aa(r, i[a]);
        return r;
      }
      function yi(i) {
        const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const r of i) for (const a of r) aa(e, a);
        return e;
      }
      function Yt(i) {
        return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0;
      }
      function Di(i, e, r) {
        if (!Yt(i) || !Yt(e)) return NaN;
        let a = 0, h = 0;
        return i[2] < e[0] && (a = e[0] - i[2]), i[0] > e[2] && (a = i[0] - e[2]), i[1] > e[3] && (h = i[1] - e[3]), i[3] < e[1] && (h = e[1] - i[3]), r.distance([0, 0], [a, h]);
      }
      function Zt(i, e, r) {
        const a = r.pointOnLine(e, i);
        return r.distance(i, a.point);
      }
      function rr(i, e, r, a, h) {
        const d = Math.min(Zt(i, [r, a], h), Zt(e, [r, a], h)), y = Math.min(Zt(r, [i, e], h), Zt(a, [i, e], h));
        return Math.min(d, y);
      }
      function Si(i, e, r, a, h) {
        if (!yt(e, i.length) || !yt(a, r.length)) return 1 / 0;
        let d = 1 / 0;
        for (let y = e[0]; y < e[1]; ++y) {
          const S = i[y], k = i[y + 1];
          for (let M = a[0]; M < a[1]; ++M) {
            const F = r[M], O = r[M + 1];
            if (Kn(S, k, F, O)) return 0;
            d = Math.min(d, rr(S, k, F, O, h));
          }
        }
        return d;
      }
      function Ai(i, e, r, a, h) {
        if (!yt(e, i.length) || !yt(a, r.length)) return NaN;
        let d = 1 / 0;
        for (let y = e[0]; y <= e[1]; ++y) for (let S = a[0]; S <= a[1]; ++S) if (d = Math.min(d, h.distance(i[y], r[S])), d === 0) return d;
        return d;
      }
      function br(i, e, r) {
        if (wn(i, e, !0)) return 0;
        let a = 1 / 0;
        for (const h of e) {
          const d = h[0], y = h[h.length - 1];
          if (d !== y && (a = Math.min(a, Zt(i, [y, d], r)), a === 0)) return a;
          const S = r.pointOnLine(h, i);
          if (a = Math.min(a, r.distance(i, S.point)), a === 0) return a;
        }
        return a;
      }
      function Dn(i, e, r, a) {
        if (!yt(e, i.length)) return NaN;
        for (let d = e[0]; d <= e[1]; ++d) if (wn(i[d], r, !0)) return 0;
        let h = 1 / 0;
        for (let d = e[0]; d < e[1]; ++d) {
          const y = i[d], S = i[d + 1];
          for (const k of r) for (let M = 0, F = k.length, O = F - 1; M < F; O = M++) {
            const $ = k[O], Y = k[M];
            if (Kn(y, S, $, Y)) return 0;
            h = Math.min(h, rr(y, S, $, Y, a));
          }
        }
        return h;
      }
      function hn(i, e) {
        for (const r of i) for (const a of r) if (wn(a, e, !0)) return !0;
        return !1;
      }
      function Ns(i, e, r, a = 1 / 0) {
        const h = yi(i), d = yi(e);
        if (a !== 1 / 0 && Di(h, d, r) >= a) return a;
        if (oa(h, d)) {
          if (hn(i, e)) return 0;
        } else if (hn(e, i)) return 0;
        let y = 1 / 0;
        for (const S of i) for (let k = 0, M = S.length, F = M - 1; k < M; F = k++) {
          const O = S[F], $ = S[k];
          for (const Y of e) for (let ee = 0, re = Y.length, me = re - 1; ee < re; me = ee++) {
            const be = Y[me], Re = Y[ee];
            if (Kn(O, $, be, Re)) return 0;
            y = Math.min(y, rr(O, $, be, Re, r));
          }
        }
        return y;
      }
      function Bo(i, e, r, a, h, d) {
        if (!d) return;
        const y = Di(oi(a, d), h, r);
        y < e && i.push([y, d, [0, 0]]);
      }
      function ua(i, e, r, a, h, d, y) {
        if (!d || !y) return;
        const S = Di(oi(a, d), oi(h, y), r);
        S < e && i.push([S, d, y]);
      }
      function da(i, e, r, a, h = 1 / 0) {
        let d = Math.min(a.distance(i[0], r[0][0]), h);
        if (d === 0) return d;
        const y = new lo([[0, [0, i.length - 1], [0, 0]]], je), S = yi(r);
        for (; y.length > 0; ) {
          const k = y.pop();
          if (k[0] >= d) continue;
          const M = k[1], F = e ? 50 : 100;
          if (tt(M) <= F) {
            if (!yt(M, i.length)) return NaN;
            if (e) {
              const O = Dn(i, M, r, a);
              if (isNaN(O) || O === 0) return O;
              d = Math.min(d, O);
            } else for (let O = M[0]; O <= M[1]; ++O) {
              const $ = br(i[O], r, a);
              if (d = Math.min(d, $), d === 0) return 0;
            }
          } else {
            const O = jt(M, e);
            Bo(y, d, a, i, S, O[0]), Bo(y, d, a, i, S, O[1]);
          }
        }
        return d;
      }
      function gs(i, e, r, a, h, d = 1 / 0) {
        let y = Math.min(d, h.distance(i[0], r[0]));
        if (y === 0) return y;
        const S = new lo([[0, [0, i.length - 1], [0, r.length - 1]]], je);
        for (; S.length > 0; ) {
          const k = S.pop();
          if (k[0] >= y) continue;
          const M = k[1], F = k[2], O = e ? 50 : 100, $ = a ? 50 : 100;
          if (tt(M) <= O && tt(F) <= $) {
            if (!yt(M, i.length) && yt(F, r.length)) return NaN;
            let Y;
            if (e && a) Y = Si(i, M, r, F, h), y = Math.min(y, Y);
            else if (e && !a) {
              const ee = i.slice(M[0], M[1] + 1);
              for (let re = F[0]; re <= F[1]; ++re) if (Y = Zt(r[re], ee, h), y = Math.min(y, Y), y === 0) return y;
            } else if (!e && a) {
              const ee = r.slice(F[0], F[1] + 1);
              for (let re = M[0]; re <= M[1]; ++re) if (Y = Zt(i[re], ee, h), y = Math.min(y, Y), y === 0) return y;
            } else Y = Ai(i, M, r, F, h), y = Math.min(y, Y);
          } else {
            const Y = jt(M, e), ee = jt(F, a);
            ua(S, y, h, i, r, Y[0], ee[0]), ua(S, y, h, i, r, Y[0], ee[1]), ua(S, y, h, i, r, Y[1], ee[0]), ua(S, y, h, i, r, Y[1], ee[1]);
          }
        }
        return y;
      }
      function pa(i) {
        return i.type === "MultiPolygon" ? i.coordinates.map((e) => ({ type: "Polygon", coordinates: e })) : i.type === "MultiLineString" ? i.coordinates.map((e) => ({ type: "LineString", coordinates: e })) : i.type === "MultiPoint" ? i.coordinates.map((e) => ({ type: "Point", coordinates: e })) : [i];
      }
      class zn {
        constructor(e, r) {
          this.type = lt, this.geojson = e, this.geometries = r;
        }
        static parse(e, r) {
          if (e.length !== 2) return r.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (cn(e[1])) {
            const a = e[1];
            if (a.type === "FeatureCollection") return new zn(a, a.features.map((h) => pa(h.geometry)).flat());
            if (a.type === "Feature") return new zn(a, pa(a.geometry));
            if ("type" in a && "coordinates" in a) return new zn(a, pa(a));
          }
          return r.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point") return function(r, a) {
              const h = r.geometry(), d = h.flat().map((k) => no([k.x, k.y], r.canonical));
              if (h.length === 0) return NaN;
              const y = new ke(d[0][1]);
              let S = 1 / 0;
              for (const k of a) {
                switch (k.type) {
                  case "Point":
                    S = Math.min(S, gs(d, !1, [k.coordinates], !1, y, S));
                    break;
                  case "LineString":
                    S = Math.min(S, gs(d, !1, k.coordinates, !0, y, S));
                    break;
                  case "Polygon":
                    S = Math.min(S, da(d, !1, k.coordinates, y, S));
                }
                if (S === 0) return S;
              }
              return S;
            }(e, this.geometries);
            if (e.geometryType() === "LineString") return function(r, a) {
              const h = r.geometry(), d = h.flat().map((k) => no([k.x, k.y], r.canonical));
              if (h.length === 0) return NaN;
              const y = new ke(d[0][1]);
              let S = 1 / 0;
              for (const k of a) {
                switch (k.type) {
                  case "Point":
                    S = Math.min(S, gs(d, !0, [k.coordinates], !1, y, S));
                    break;
                  case "LineString":
                    S = Math.min(S, gs(d, !0, k.coordinates, !0, y, S));
                    break;
                  case "Polygon":
                    S = Math.min(S, da(d, !0, k.coordinates, y, S));
                }
                if (S === 0) return S;
              }
              return S;
            }(e, this.geometries);
            if (e.geometryType() === "Polygon") return function(r, a) {
              const h = r.geometry();
              if (h.length === 0 || h[0].length === 0) return NaN;
              const d = ca(h, 0).map((k) => k.map((M) => M.map((F) => no([F.x, F.y], r.canonical)))), y = new ke(d[0][0][0][1]);
              let S = 1 / 0;
              for (const k of a) for (const M of d) {
                switch (k.type) {
                  case "Point":
                    S = Math.min(S, da([k.coordinates], !1, M, y, S));
                    break;
                  case "LineString":
                    S = Math.min(S, da(k.coordinates, !0, M, y, S));
                    break;
                  case "Polygon":
                    S = Math.min(S, Ns(M, k.coordinates, y, S));
                }
                if (S === 0) return S;
              }
              return S;
            }(e, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const Fn = { "==": to, "!=": io, ">": kl, "<": tl, ">=": zo, "<=": Ll, array: an, at: Ha, boolean: an, case: na, coalesce: Qa, collator: ps, format: ro, image: Ds, in: Xa, "index-of": ra, interpolate: ri, "interpolate-hcl": ri, "interpolate-lab": ri, length: zs, let: Ta, literal: us, match: Eo, number: an, "number-format": fs, object: an, slice: ka, step: La, string: an, "to-boolean": Ar, "to-color": Ar, "to-number": Ar, "to-string": Ar, var: ia, within: Mn, distance: zn };
      class Hi {
        constructor(e, r, a, h) {
          this.name = e, this.type = r, this._evaluate = a, this.args = h;
        }
        evaluate(e) {
          return this._evaluate(e, this.args);
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return !1;
        }
        static parse(e, r) {
          const a = e[0], h = Hi.definitions[a];
          if (!h) return r.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const d = Array.isArray(h) ? h[0] : h.type, y = Array.isArray(h) ? [[h[1], h[2]]] : h.overloads, S = y.filter(([M]) => !Array.isArray(M) || M.length === e.length - 1);
          let k = null;
          for (const [M, F] of S) {
            k = new Mi(r.registry, $r, r.path, null, r.scope);
            const O = [];
            let $ = !1;
            for (let Y = 1; Y < e.length; Y++) {
              const ee = e[Y], re = Array.isArray(M) ? M[Y - 1] : M.type, me = k.parse(ee, 1 + O.length, re);
              if (!me) {
                $ = !0;
                break;
              }
              O.push(me);
            }
            if (!$) if (Array.isArray(M) && M.length !== O.length) k.error(`Expected ${M.length} arguments, but found ${O.length} instead.`);
            else {
              for (let Y = 0; Y < O.length; Y++) {
                const ee = Array.isArray(M) ? M[Y] : M.type, re = O[Y];
                k.concat(Y + 1).checkSubtype(ee, re.type);
              }
              if (k.errors.length === 0) return new Hi(a, d, F, O);
            }
          }
          if (S.length === 1) r.errors.push(...k.errors);
          else {
            const M = (S.length ? S : y).map(([O]) => {
              return $ = O, Array.isArray($) ? `(${$.map(J).join(", ")})` : `(${J($.type)}...)`;
              var $;
            }).join(" | "), F = [];
            for (let O = 1; O < e.length; O++) {
              const $ = r.parse(e[O], 1 + F.length);
              if (!$) return null;
              F.push(J($.type));
            }
            r.error(`Expected arguments of type ${M}, but found (${F.join(", ")}) instead.`);
          }
          return null;
        }
        static register(e, r) {
          Hi.definitions = r;
          for (const a in r) e[a] = Hi;
        }
      }
      function Ma(i, [e, r, a, h]) {
        e = e.evaluate(i), r = r.evaluate(i), a = a.evaluate(i);
        const d = h ? h.evaluate(i) : 1, y = el(e, r, a, d);
        if (y) throw new ir(y);
        return new Ri(e / 255, r / 255, a / 255, d, !1);
      }
      function Da(i, e) {
        return i in e;
      }
      function fa(i, e) {
        const r = e[i];
        return r === void 0 ? null : r;
      }
      function es(i) {
        return { type: i };
      }
      function $r(i) {
        if (i instanceof ia) return $r(i.boundExpression);
        if (i instanceof Hi && i.name === "error" || i instanceof ps || i instanceof Mn || i instanceof zn) return !1;
        const e = i instanceof Ar || i instanceof an;
        let r = !0;
        return i.eachChild((a) => {
          r = e ? r && $r(a) : r && a instanceof us;
        }), !!r && co(i) && za(i, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function co(i) {
        if (i instanceof Hi && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof Mn || i instanceof zn) return !1;
        let e = !0;
        return i.eachChild((r) => {
          e && !co(r) && (e = !1);
        }), e;
      }
      function Rs(i) {
        if (i instanceof Hi && i.name === "feature-state") return !1;
        let e = !0;
        return i.eachChild((r) => {
          e && !Rs(r) && (e = !1);
        }), e;
      }
      function za(i, e) {
        if (i instanceof Hi && e.indexOf(i.name) >= 0) return !1;
        let r = !0;
        return i.eachChild((a) => {
          r && !za(a, e) && (r = !1);
        }), r;
      }
      function Sn(i) {
        return { result: "success", value: i };
      }
      function ts(i) {
        return { result: "error", value: i };
      }
      function is(i) {
        return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven";
      }
      function al(i) {
        return !!i.expression && i.expression.parameters.indexOf("zoom") > -1;
      }
      function rs(i) {
        return !!i.expression && i.expression.interpolated;
      }
      function _i(i) {
        return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i;
      }
      function Qr(i) {
        return typeof i == "object" && i !== null && !Array.isArray(i);
      }
      function ns(i) {
        return i;
      }
      function un(i, e) {
        const r = e.type === "color", a = i.stops && typeof i.stops[0][0] == "object", h = a || !(a || i.property !== void 0), d = i.type || (rs(e) ? "exponential" : "interval");
        if (r || e.type === "padding") {
          const F = r ? Ri.parse : Jr.parse;
          (i = Jt({}, i)).stops && (i.stops = i.stops.map((O) => [O[0], F(O[1])])), i.default = F(i.default ? i.default : e.default);
        }
        if (i.colorSpace && (y = i.colorSpace) !== "rgb" && y !== "hcl" && y !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
        var y;
        let S, k, M;
        if (d === "exponential") S = ga;
        else if (d === "interval") S = Nn;
        else if (d === "categorical") {
          S = ma, k = /* @__PURE__ */ Object.create(null);
          for (const F of i.stops) k[F[0]] = F[1];
          M = typeof i.stops[0][0];
        } else {
          if (d !== "identity") throw new Error(`Unknown function type "${d}"`);
          S = ya;
        }
        if (a) {
          const F = {}, O = [];
          for (let ee = 0; ee < i.stops.length; ee++) {
            const re = i.stops[ee], me = re[0].zoom;
            F[me] === void 0 && (F[me] = { zoom: me, type: i.type, property: i.property, default: i.default, stops: [] }, O.push(me)), F[me].stops.push([re[0].value, re[1]]);
          }
          const $ = [];
          for (const ee of O) $.push([F[ee].zoom, un(F[ee], e)]);
          const Y = { name: "linear" };
          return { kind: "composite", interpolationType: Y, interpolationFactor: ri.interpolationFactor.bind(void 0, Y), zoomStops: $.map((ee) => ee[0]), evaluate: ({ zoom: ee }, re) => ga({ stops: $, base: i.base }, e, ee).evaluate(ee, re) };
        }
        if (h) {
          const F = d === "exponential" ? { name: "exponential", base: i.base !== void 0 ? i.base : 1 } : null;
          return { kind: "camera", interpolationType: F, interpolationFactor: ri.interpolationFactor.bind(void 0, F), zoomStops: i.stops.map((O) => O[0]), evaluate: ({ zoom: O }) => S(i, e, O, k, M) };
        }
        return { kind: "source", evaluate(F, O) {
          const $ = O && O.properties ? O.properties[i.property] : void 0;
          return $ === void 0 ? dn(i.default, e.default) : S(i, e, $, k, M);
        } };
      }
      function dn(i, e, r) {
        return i !== void 0 ? i : e !== void 0 ? e : r !== void 0 ? r : void 0;
      }
      function ma(i, e, r, a, h) {
        return dn(typeof r === h ? a[r] : void 0, i.default, e.default);
      }
      function Nn(i, e, r) {
        if (_i(r) !== "number") return dn(i.default, e.default);
        const a = i.stops.length;
        if (a === 1 || r <= i.stops[0][0]) return i.stops[0][1];
        if (r >= i.stops[a - 1][0]) return i.stops[a - 1][1];
        const h = Ya(i.stops.map((d) => d[0]), r);
        return i.stops[h][1];
      }
      function ga(i, e, r) {
        const a = i.base !== void 0 ? i.base : 1;
        if (_i(r) !== "number") return dn(i.default, e.default);
        const h = i.stops.length;
        if (h === 1 || r <= i.stops[0][0]) return i.stops[0][1];
        if (r >= i.stops[h - 1][0]) return i.stops[h - 1][1];
        const d = Ya(i.stops.map((F) => F[0]), r), y = function(F, O, $, Y) {
          const ee = Y - $, re = F - $;
          return ee === 0 ? 0 : O === 1 ? re / ee : (Math.pow(O, re) - 1) / (Math.pow(O, ee) - 1);
        }(r, a, i.stops[d][0], i.stops[d + 1][0]), S = i.stops[d][1], k = i.stops[d + 1][1], M = Rr[e.type] || ns;
        return typeof S.evaluate == "function" ? { evaluate(...F) {
          const O = S.evaluate.apply(void 0, F), $ = k.evaluate.apply(void 0, F);
          if (O !== void 0 && $ !== void 0) return M(O, $, y, i.colorSpace);
        } } : M(S, k, y, i.colorSpace);
      }
      function ya(i, e, r) {
        switch (e.type) {
          case "color":
            r = Ri.parse(r);
            break;
          case "formatted":
            r = Yr.fromString(r.toString());
            break;
          case "resolvedImage":
            r = sn.fromString(r.toString());
            break;
          case "padding":
            r = Jr.parse(r);
            break;
          default:
            _i(r) === e.type || e.type === "enum" && e.values[r] || (r = void 0);
        }
        return dn(r, i.default, e.default);
      }
      Hi.register(Fn, { error: [{ kind: "error" }, [li], (i, [e]) => {
        throw new ir(e.evaluate(i));
      }], typeof: [li, [Ft], (i, [e]) => J(yr(e.evaluate(i)))], "to-rgba": [W(lt, 4), [ki], (i, [e]) => {
        const [r, a, h, d] = e.evaluate(i).rgb;
        return [255 * r, 255 * a, 255 * h, d];
      }], rgb: [ki, [lt, lt, lt], Ma], rgba: [ki, [lt, lt, lt, lt], Ma], has: { type: Bt, overloads: [[[li], (i, [e]) => Da(e.evaluate(i), i.properties())], [[li, lr], (i, [e, r]) => Da(e.evaluate(i), r.evaluate(i))]] }, get: { type: Ft, overloads: [[[li], (i, [e]) => fa(e.evaluate(i), i.properties())], [[li, lr], (i, [e, r]) => fa(e.evaluate(i), r.evaluate(i))]] }, "feature-state": [Ft, [li], (i, [e]) => fa(e.evaluate(i), i.featureState || {})], properties: [lr, [], (i) => i.properties()], "geometry-type": [li, [], (i) => i.geometryType()], id: [Ft, [], (i) => i.id()], zoom: [lt, [], (i) => i.globals.zoom], "heatmap-density": [lt, [], (i) => i.globals.heatmapDensity || 0], "line-progress": [lt, [], (i) => i.globals.lineProgress || 0], accumulated: [Ft, [], (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated], "+": [lt, es(lt), (i, e) => {
        let r = 0;
        for (const a of e) r += a.evaluate(i);
        return r;
      }], "*": [lt, es(lt), (i, e) => {
        let r = 1;
        for (const a of e) r *= a.evaluate(i);
        return r;
      }], "-": { type: lt, overloads: [[[lt, lt], (i, [e, r]) => e.evaluate(i) - r.evaluate(i)], [[lt], (i, [e]) => -e.evaluate(i)]] }, "/": [lt, [lt, lt], (i, [e, r]) => e.evaluate(i) / r.evaluate(i)], "%": [lt, [lt, lt], (i, [e, r]) => e.evaluate(i) % r.evaluate(i)], ln2: [lt, [], () => Math.LN2], pi: [lt, [], () => Math.PI], e: [lt, [], () => Math.E], "^": [lt, [lt, lt], (i, [e, r]) => Math.pow(e.evaluate(i), r.evaluate(i))], sqrt: [lt, [lt], (i, [e]) => Math.sqrt(e.evaluate(i))], log10: [lt, [lt], (i, [e]) => Math.log(e.evaluate(i)) / Math.LN10], ln: [lt, [lt], (i, [e]) => Math.log(e.evaluate(i))], log2: [lt, [lt], (i, [e]) => Math.log(e.evaluate(i)) / Math.LN2], sin: [lt, [lt], (i, [e]) => Math.sin(e.evaluate(i))], cos: [lt, [lt], (i, [e]) => Math.cos(e.evaluate(i))], tan: [lt, [lt], (i, [e]) => Math.tan(e.evaluate(i))], asin: [lt, [lt], (i, [e]) => Math.asin(e.evaluate(i))], acos: [lt, [lt], (i, [e]) => Math.acos(e.evaluate(i))], atan: [lt, [lt], (i, [e]) => Math.atan(e.evaluate(i))], min: [lt, es(lt), (i, e) => Math.min(...e.map((r) => r.evaluate(i)))], max: [lt, es(lt), (i, e) => Math.max(...e.map((r) => r.evaluate(i)))], abs: [lt, [lt], (i, [e]) => Math.abs(e.evaluate(i))], round: [lt, [lt], (i, [e]) => {
        const r = e.evaluate(i);
        return r < 0 ? -Math.round(-r) : Math.round(r);
      }], floor: [lt, [lt], (i, [e]) => Math.floor(e.evaluate(i))], ceil: [lt, [lt], (i, [e]) => Math.ceil(e.evaluate(i))], "filter-==": [Bt, [li, Ft], (i, [e, r]) => i.properties()[e.value] === r.value], "filter-id-==": [Bt, [Ft], (i, [e]) => i.id() === e.value], "filter-type-==": [Bt, [li], (i, [e]) => i.geometryType() === e.value], "filter-<": [Bt, [li, Ft], (i, [e, r]) => {
        const a = i.properties()[e.value], h = r.value;
        return typeof a == typeof h && a < h;
      }], "filter-id-<": [Bt, [Ft], (i, [e]) => {
        const r = i.id(), a = e.value;
        return typeof r == typeof a && r < a;
      }], "filter->": [Bt, [li, Ft], (i, [e, r]) => {
        const a = i.properties()[e.value], h = r.value;
        return typeof a == typeof h && a > h;
      }], "filter-id->": [Bt, [Ft], (i, [e]) => {
        const r = i.id(), a = e.value;
        return typeof r == typeof a && r > a;
      }], "filter-<=": [Bt, [li, Ft], (i, [e, r]) => {
        const a = i.properties()[e.value], h = r.value;
        return typeof a == typeof h && a <= h;
      }], "filter-id-<=": [Bt, [Ft], (i, [e]) => {
        const r = i.id(), a = e.value;
        return typeof r == typeof a && r <= a;
      }], "filter->=": [Bt, [li, Ft], (i, [e, r]) => {
        const a = i.properties()[e.value], h = r.value;
        return typeof a == typeof h && a >= h;
      }], "filter-id->=": [Bt, [Ft], (i, [e]) => {
        const r = i.id(), a = e.value;
        return typeof r == typeof a && r >= a;
      }], "filter-has": [Bt, [Ft], (i, [e]) => e.value in i.properties()], "filter-has-id": [Bt, [], (i) => i.id() !== null && i.id() !== void 0], "filter-type-in": [Bt, [W(li)], (i, [e]) => e.value.indexOf(i.geometryType()) >= 0], "filter-id-in": [Bt, [W(Ft)], (i, [e]) => e.value.indexOf(i.id()) >= 0], "filter-in-small": [Bt, [li, W(Ft)], (i, [e, r]) => r.value.indexOf(i.properties()[e.value]) >= 0], "filter-in-large": [Bt, [li, W(Ft)], (i, [e, r]) => function(a, h, d, y) {
        for (; d <= y; ) {
          const S = d + y >> 1;
          if (h[S] === a) return !0;
          h[S] > a ? y = S - 1 : d = S + 1;
        }
        return !1;
      }(i.properties()[e.value], r.value, 0, r.value.length - 1)], all: { type: Bt, overloads: [[[Bt, Bt], (i, [e, r]) => e.evaluate(i) && r.evaluate(i)], [es(Bt), (i, e) => {
        for (const r of e) if (!r.evaluate(i)) return !1;
        return !0;
      }]] }, any: { type: Bt, overloads: [[[Bt, Bt], (i, [e, r]) => e.evaluate(i) || r.evaluate(i)], [es(Bt), (i, e) => {
        for (const r of e) if (r.evaluate(i)) return !0;
        return !1;
      }]] }, "!": [Bt, [Bt], (i, [e]) => !e.evaluate(i)], "is-supported-script": [Bt, [li], (i, [e]) => {
        const r = i.globals && i.globals.isSupportedScript;
        return !r || r(e.evaluate(i));
      }], upcase: [li, [li], (i, [e]) => e.evaluate(i).toUpperCase()], downcase: [li, [li], (i, [e]) => e.evaluate(i).toLowerCase()], concat: [li, es(Ft), (i, e) => e.map((r) => tr(r.evaluate(i))).join("")], "resolved-locale": [li, [nn], (i, [e]) => e.evaluate(i).resolvedLocale()] });
      class ys {
        constructor(e, r) {
          var a;
          this.expression = e, this._warningHistory = {}, this._evaluator = new Dr(), this._defaultValue = r ? (a = r).type === "color" && Qr(a.default) ? new Ri(0, 0, 0, 0) : a.type === "color" ? Ri.parse(a.default) || null : a.type === "padding" ? Jr.parse(a.default) || null : a.type === "variableAnchorOffsetCollection" ? Kr.parse(a.default) || null : a.default === void 0 ? null : a.default : null, this._enumValues = r && r.type === "enum" ? r.values : null;
        }
        evaluateWithoutErrorHandling(e, r, a, h, d, y) {
          return this._evaluator.globals = e, this._evaluator.feature = r, this._evaluator.featureState = a, this._evaluator.canonical = h, this._evaluator.availableImages = d || null, this._evaluator.formattedSection = y, this.expression.evaluate(this._evaluator);
        }
        evaluate(e, r, a, h, d, y) {
          this._evaluator.globals = e, this._evaluator.feature = r || null, this._evaluator.featureState = a || null, this._evaluator.canonical = h, this._evaluator.availableImages = d || null, this._evaluator.formattedSection = y || null;
          try {
            const S = this.expression.evaluate(this._evaluator);
            if (S == null || typeof S == "number" && S != S) return this._defaultValue;
            if (this._enumValues && !(S in this._enumValues)) throw new ir(`Expected value to be one of ${Object.keys(this._enumValues).map((k) => JSON.stringify(k)).join(", ")}, but found ${JSON.stringify(S)} instead.`);
            return S;
          } catch (S) {
            return this._warningHistory[S.message] || (this._warningHistory[S.message] = !0, typeof console < "u" && console.warn(S.message)), this._defaultValue;
          }
        }
      }
      function pn(i) {
        return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in Fn;
      }
      function Rn(i, e) {
        const r = new Mi(Fn, $r, [], e ? function(h) {
          const d = { color: ki, string: li, number: lt, enum: li, boolean: Bt, formatted: Oi, padding: $i, resolvedImage: de, variableAnchorOffsetCollection: Z };
          return h.type === "array" ? W(d[h.value] || Ft, h.length) : d[h.type];
        }(e) : void 0), a = r.parse(i, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return a ? Sn(new ys(a, e)) : ts(r.errors);
      }
      class Bs {
        constructor(e, r) {
          this.kind = e, this._styleExpression = r, this.isStateDependent = e !== "constant" && !Rs(r.expression);
        }
        evaluateWithoutErrorHandling(e, r, a, h, d, y) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, r, a, h, d, y);
        }
        evaluate(e, r, a, h, d, y) {
          return this._styleExpression.evaluate(e, r, a, h, d, y);
        }
      }
      class _a {
        constructor(e, r, a, h) {
          this.kind = e, this.zoomStops = a, this._styleExpression = r, this.isStateDependent = e !== "camera" && !Rs(r.expression), this.interpolationType = h;
        }
        evaluateWithoutErrorHandling(e, r, a, h, d, y) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, r, a, h, d, y);
        }
        evaluate(e, r, a, h, d, y) {
          return this._styleExpression.evaluate(e, r, a, h, d, y);
        }
        interpolationFactor(e, r, a) {
          return this.interpolationType ? ri.interpolationFactor(this.interpolationType, e, r, a) : 0;
        }
      }
      function ss(i, e) {
        const r = Rn(i, e);
        if (r.result === "error") return r;
        const a = r.value.expression, h = co(a);
        if (!h && !is(e)) return ts([new ui("", "data expressions not supported")]);
        const d = za(a, ["zoom"]);
        if (!d && !al(e)) return ts([new ui("", "zoom expressions not supported")]);
        const y = Pr(a);
        return y || d ? y instanceof ui ? ts([y]) : y instanceof ri && !rs(e) ? ts([new ui("", '"interpolate" expressions cannot be used with this property')]) : Sn(y ? new _a(h ? "camera" : "composite", r.value, y.labels, y instanceof ri ? y.interpolation : void 0) : new Bs(h ? "constant" : "source", r.value)) : ts([new ui("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class fn {
        constructor(e, r) {
          this._parameters = e, this._specification = r, Jt(this, un(this._parameters, this._specification));
        }
        static deserialize(e) {
          return new fn(e._parameters, e._specification);
        }
        static serialize(e) {
          return { _parameters: e._parameters, _specification: e._specification };
        }
      }
      function Pr(i) {
        let e = null;
        if (i instanceof Ta) e = Pr(i.result);
        else if (i instanceof Qa) {
          for (const r of i.args) if (e = Pr(r), e) break;
        } else (i instanceof La || i instanceof ri) && i.input instanceof Hi && i.input.name === "zoom" && (e = i);
        return e instanceof ui || i.eachChild((r) => {
          const a = Pr(r);
          a instanceof ui ? e = a : !e && a ? e = new ui("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && a && e !== a && (e = new ui("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e;
      }
      function Or(i) {
        if (i === !0 || i === !1) return !0;
        if (!Array.isArray(i) || i.length === 0) return !1;
        switch (i[0]) {
          case "has":
            return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
          case "in":
            return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
          case "any":
          case "all":
            for (const e of i.slice(1)) if (!Or(e) && typeof e != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      const _s = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function Zi(i) {
        if (i == null) return { filter: () => !0, needGeometry: !1 };
        Or(i) || (i = pr(i));
        const e = Rn(i, _s);
        if (e.result === "error") throw new Error(e.value.map((r) => `${r.key}: ${r.message}`).join(", "));
        return { filter: (r, a, h) => e.value.evaluate(r, a, {}, h), needGeometry: Ki(i) };
      }
      function Ji(i, e) {
        return i < e ? -1 : i > e ? 1 : 0;
      }
      function Ki(i) {
        if (!Array.isArray(i)) return !1;
        if (i[0] === "within" || i[0] === "distance") return !0;
        for (let e = 1; e < i.length; e++) if (Ki(i[e])) return !0;
        return !1;
      }
      function pr(i) {
        if (!i) return !0;
        const e = i[0];
        return i.length <= 1 ? e !== "any" : e === "==" ? An(i[1], i[2], "==") : e === "!=" ? Fa(An(i[1], i[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? An(i[1], i[2], e) : e === "any" ? (r = i.slice(1), ["any"].concat(r.map(pr))) : e === "all" ? ["all"].concat(i.slice(1).map(pr)) : e === "none" ? ["all"].concat(i.slice(1).map(pr).map(Fa)) : e === "in" ? Os(i[1], i.slice(2)) : e === "!in" ? Fa(Os(i[1], i.slice(2))) : e === "has" ? js(i[1]) : e !== "!has" || Fa(js(i[1]));
        var r;
      }
      function An(i, e, r) {
        switch (i) {
          case "$type":
            return [`filter-type-${r}`, e];
          case "$id":
            return [`filter-id-${r}`, e];
          default:
            return [`filter-${r}`, i, e];
        }
      }
      function Os(i, e) {
        if (e.length === 0) return !1;
        switch (i) {
          case "$type":
            return ["filter-type-in", ["literal", e]];
          case "$id":
            return ["filter-id-in", ["literal", e]];
          default:
            return e.length > 200 && !e.some((r) => typeof r != typeof e[0]) ? ["filter-in-large", i, ["literal", e.sort(Ji)]] : ["filter-in-small", i, ["literal", e]];
        }
      }
      function js(i) {
        switch (i) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", i];
        }
      }
      function Fa(i) {
        return ["!", i];
      }
      function va(i) {
        const e = typeof i;
        if (e === "number" || e === "boolean" || e === "string" || i == null) return JSON.stringify(i);
        if (Array.isArray(i)) {
          let h = "[";
          for (const d of i) h += `${va(d)},`;
          return `${h}]`;
        }
        const r = Object.keys(i).sort();
        let a = "{";
        for (let h = 0; h < r.length; h++) a += `${JSON.stringify(r[h])}:${va(i[r[h]])},`;
        return `${a}}`;
      }
      function rc(i) {
        let e = "";
        for (const r of hi) e += `/${va(i[r])}`;
        return e;
      }
      function Oo(i) {
        const e = i.value;
        return e ? [new pt(i.key, e, "constants have been deprecated as of v8")] : [];
      }
      function hr(i) {
        return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i;
      }
      function vs(i) {
        if (Array.isArray(i)) return i.map(vs);
        if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
          const e = {};
          for (const r in i) e[r] = vs(i[r]);
          return e;
        }
        return hr(i);
      }
      function mn(i) {
        const e = i.key, r = i.value, a = i.valueSpec || {}, h = i.objectElementValidators || {}, d = i.style, y = i.styleSpec, S = i.validateSpec;
        let k = [];
        const M = _i(r);
        if (M !== "object") return [new pt(e, r, `object expected, ${M} found`)];
        for (const F in r) {
          const O = F.split(".")[0], $ = a[O] || a["*"];
          let Y;
          if (h[O]) Y = h[O];
          else if (a[O]) Y = S;
          else if (h["*"]) Y = h["*"];
          else {
            if (!a["*"]) {
              k.push(new pt(e, r[F], `unknown property "${F}"`));
              continue;
            }
            Y = S;
          }
          k = k.concat(Y({ key: (e && `${e}.`) + F, value: r[F], valueSpec: $, style: d, styleSpec: y, object: r, objectKey: F, validateSpec: S }, r));
        }
        for (const F in a) h[F] || a[F].required && a[F].default === void 0 && r[F] === void 0 && k.push(new pt(e, r, `missing required property "${F}"`));
        return k;
      }
      function ho(i) {
        const e = i.value, r = i.valueSpec, a = i.style, h = i.styleSpec, d = i.key, y = i.arrayElementValidator || i.validateSpec;
        if (_i(e) !== "array") return [new pt(d, e, `array expected, ${_i(e)} found`)];
        if (r.length && e.length !== r.length) return [new pt(d, e, `array length ${r.length} expected, length ${e.length} found`)];
        if (r["min-length"] && e.length < r["min-length"]) return [new pt(d, e, `array length at least ${r["min-length"]} expected, length ${e.length} found`)];
        let S = { type: r.value, values: r.values };
        h.$version < 7 && (S.function = r.function), _i(r.value) === "object" && (S = r.value);
        let k = [];
        for (let M = 0; M < e.length; M++) k = k.concat(y({ array: e, arrayIndex: M, value: e[M], valueSpec: S, validateSpec: i.validateSpec, style: a, styleSpec: h, key: `${d}[${M}]` }));
        return k;
      }
      function uo(i) {
        const e = i.key, r = i.value, a = i.valueSpec;
        let h = _i(r);
        return h === "number" && r != r && (h = "NaN"), h !== "number" ? [new pt(e, r, `number expected, ${h} found`)] : "minimum" in a && r < a.minimum ? [new pt(e, r, `${r} is less than the minimum value ${a.minimum}`)] : "maximum" in a && r > a.maximum ? [new pt(e, r, `${r} is greater than the maximum value ${a.maximum}`)] : [];
      }
      function en(i) {
        const e = i.valueSpec, r = hr(i.value.type);
        let a, h, d, y = {};
        const S = r !== "categorical" && i.value.property === void 0, k = !S, M = _i(i.value.stops) === "array" && _i(i.value.stops[0]) === "array" && _i(i.value.stops[0][0]) === "object", F = mn({ key: i.key, value: i.value, valueSpec: i.styleSpec.function, validateSpec: i.validateSpec, style: i.style, styleSpec: i.styleSpec, objectElementValidators: { stops: function(Y) {
          if (r === "identity") return [new pt(Y.key, Y.value, 'identity function may not have a "stops" property')];
          let ee = [];
          const re = Y.value;
          return ee = ee.concat(ho({ key: Y.key, value: re, valueSpec: Y.valueSpec, validateSpec: Y.validateSpec, style: Y.style, styleSpec: Y.styleSpec, arrayElementValidator: O })), _i(re) === "array" && re.length === 0 && ee.push(new pt(Y.key, re, "array must have at least one stop")), ee;
        }, default: function(Y) {
          return Y.validateSpec({ key: Y.key, value: Y.value, valueSpec: e, validateSpec: Y.validateSpec, style: Y.style, styleSpec: Y.styleSpec });
        } } });
        return r === "identity" && S && F.push(new pt(i.key, i.value, 'missing required property "property"')), r === "identity" || i.value.stops || F.push(new pt(i.key, i.value, 'missing required property "stops"')), r === "exponential" && i.valueSpec.expression && !rs(i.valueSpec) && F.push(new pt(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (k && !is(i.valueSpec) ? F.push(new pt(i.key, i.value, "property functions not supported")) : S && !al(i.valueSpec) && F.push(new pt(i.key, i.value, "zoom functions not supported"))), r !== "categorical" && !M || i.value.property !== void 0 || F.push(new pt(i.key, i.value, '"property" property is required')), F;
        function O(Y) {
          let ee = [];
          const re = Y.value, me = Y.key;
          if (_i(re) !== "array") return [new pt(me, re, `array expected, ${_i(re)} found`)];
          if (re.length !== 2) return [new pt(me, re, `array length 2 expected, length ${re.length} found`)];
          if (M) {
            if (_i(re[0]) !== "object") return [new pt(me, re, `object expected, ${_i(re[0])} found`)];
            if (re[0].zoom === void 0) return [new pt(me, re, "object stop key must have zoom")];
            if (re[0].value === void 0) return [new pt(me, re, "object stop key must have value")];
            if (d && d > hr(re[0].zoom)) return [new pt(me, re[0].zoom, "stop zoom values must appear in ascending order")];
            hr(re[0].zoom) !== d && (d = hr(re[0].zoom), h = void 0, y = {}), ee = ee.concat(mn({ key: `${me}[0]`, value: re[0], valueSpec: { zoom: {} }, validateSpec: Y.validateSpec, style: Y.style, styleSpec: Y.styleSpec, objectElementValidators: { zoom: uo, value: $ } }));
          } else ee = ee.concat($({ key: `${me}[0]`, value: re[0], valueSpec: {}, validateSpec: Y.validateSpec, style: Y.style, styleSpec: Y.styleSpec }, re));
          return pn(vs(re[1])) ? ee.concat([new pt(`${me}[1]`, re[1], "expressions are not allowed in function stops.")]) : ee.concat(Y.validateSpec({ key: `${me}[1]`, value: re[1], valueSpec: e, validateSpec: Y.validateSpec, style: Y.style, styleSpec: Y.styleSpec }));
        }
        function $(Y, ee) {
          const re = _i(Y.value), me = hr(Y.value), be = Y.value !== null ? Y.value : ee;
          if (a) {
            if (re !== a) return [new pt(Y.key, be, `${re} stop domain type must match previous stop domain type ${a}`)];
          } else a = re;
          if (re !== "number" && re !== "string" && re !== "boolean") return [new pt(Y.key, be, "stop domain value must be a number, string, or boolean")];
          if (re !== "number" && r !== "categorical") {
            let Re = `number expected, ${re} found`;
            return is(e) && r === void 0 && (Re += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new pt(Y.key, be, Re)];
          }
          return r !== "categorical" || re !== "number" || isFinite(me) && Math.floor(me) === me ? r !== "categorical" && re === "number" && h !== void 0 && me < h ? [new pt(Y.key, be, "stop domain values must appear in ascending order")] : (h = me, r === "categorical" && me in y ? [new pt(Y.key, be, "stop domain values must be unique")] : (y[me] = !0, [])) : [new pt(Y.key, be, `integer expected, found ${me}`)];
        }
      }
      function Ir(i) {
        const e = (i.expressionContext === "property" ? ss : Rn)(vs(i.value), i.valueSpec);
        if (e.result === "error") return e.value.map((a) => new pt(`${i.key}${a.key}`, i.value, a.message));
        const r = e.value.expression || e.value._styleExpression.expression;
        if (i.expressionContext === "property" && i.propertyKey === "text-font" && !r.outputDefined()) return [new pt(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (i.expressionContext === "property" && i.propertyType === "layout" && !Rs(r)) return [new pt(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (i.expressionContext === "filter" && !Rs(r)) return [new pt(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
        if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
          if (!za(r, ["zoom", "feature-state"])) return [new pt(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (i.expressionContext === "cluster-initial" && !co(r)) return [new pt(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function qs(i) {
        const e = i.key, r = i.value, a = i.valueSpec, h = [];
        return Array.isArray(a.values) ? a.values.indexOf(hr(r)) === -1 && h.push(new pt(e, r, `expected one of [${a.values.join(", ")}], ${JSON.stringify(r)} found`)) : Object.keys(a.values).indexOf(hr(r)) === -1 && h.push(new pt(e, r, `expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(r)} found`)), h;
      }
      function Na(i) {
        return Or(vs(i.value)) ? Ir(Jt({}, i, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : ol(i);
      }
      function ol(i) {
        const e = i.value, r = i.key;
        if (_i(e) !== "array") return [new pt(r, e, `array expected, ${_i(e)} found`)];
        const a = i.styleSpec;
        let h, d = [];
        if (e.length < 1) return [new pt(r, e, "filter array must have at least 1 element")];
        switch (d = d.concat(qs({ key: `${r}[0]`, value: e[0], valueSpec: a.filter_operator, style: i.style, styleSpec: i.styleSpec })), hr(e[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e.length >= 2 && hr(e[1]) === "$type" && d.push(new pt(r, e, `"$type" cannot be use with operator "${e[0]}"`));
          case "==":
          case "!=":
            e.length !== 3 && d.push(new pt(r, e, `filter array for operator "${e[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e.length >= 2 && (h = _i(e[1]), h !== "string" && d.push(new pt(`${r}[1]`, e[1], `string expected, ${h} found`)));
            for (let y = 2; y < e.length; y++) h = _i(e[y]), hr(e[1]) === "$type" ? d = d.concat(qs({ key: `${r}[${y}]`, value: e[y], valueSpec: a.geometry_type, style: i.style, styleSpec: i.styleSpec })) : h !== "string" && h !== "number" && h !== "boolean" && d.push(new pt(`${r}[${y}]`, e[y], `string, number, or boolean expected, ${h} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let y = 1; y < e.length; y++) d = d.concat(ol({ key: `${r}[${y}]`, value: e[y], style: i.style, styleSpec: i.styleSpec }));
            break;
          case "has":
          case "!has":
            h = _i(e[1]), e.length !== 2 ? d.push(new pt(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : h !== "string" && d.push(new pt(`${r}[1]`, e[1], `string expected, ${h} found`));
        }
        return d;
      }
      function po(i, e) {
        const r = i.key, a = i.validateSpec, h = i.style, d = i.styleSpec, y = i.value, S = i.objectKey, k = d[`${e}_${i.layerType}`];
        if (!k) return [];
        const M = S.match(/^(.*)-transition$/);
        if (e === "paint" && M && k[M[1]] && k[M[1]].transition) return a({ key: r, value: y, valueSpec: d.transition, style: h, styleSpec: d });
        const F = i.valueSpec || k[S];
        if (!F) return [new pt(r, y, `unknown property "${S}"`)];
        let O;
        if (_i(y) === "string" && is(F) && !F.tokens && (O = /^{([^}]+)}$/.exec(y))) return [new pt(r, y, `"${S}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(O[1])} }\`.`)];
        const $ = [];
        return i.layerType === "symbol" && (S === "text-field" && h && !h.glyphs && $.push(new pt(r, y, 'use of "text-field" requires a style "glyphs" property')), S === "text-font" && Qr(vs(y)) && hr(y.type) === "identity" && $.push(new pt(r, y, '"text-font" does not support identity functions'))), $.concat(a({ key: i.key, value: y, valueSpec: F, style: h, styleSpec: d, expressionContext: "property", propertyType: e, propertyKey: S }));
      }
      function Ra(i) {
        return po(i, "paint");
      }
      function jo(i) {
        return po(i, "layout");
      }
      function El(i) {
        let e = [];
        const r = i.value, a = i.key, h = i.style, d = i.styleSpec;
        r.type || r.ref || e.push(new pt(a, r, 'either "type" or "ref" is required'));
        let y = hr(r.type);
        const S = hr(r.ref);
        if (r.id) {
          const k = hr(r.id);
          for (let M = 0; M < i.arrayIndex; M++) {
            const F = h.layers[M];
            hr(F.id) === k && e.push(new pt(a, r.id, `duplicate layer id "${r.id}", previously used at line ${F.id.__line__}`));
          }
        }
        if ("ref" in r) {
          let k;
          ["type", "source", "source-layer", "filter", "layout"].forEach((M) => {
            M in r && e.push(new pt(a, r[M], `"${M}" is prohibited for ref layers`));
          }), h.layers.forEach((M) => {
            hr(M.id) === S && (k = M);
          }), k ? k.ref ? e.push(new pt(a, r.ref, "ref cannot reference another ref layer")) : y = hr(k.type) : e.push(new pt(a, r.ref, `ref layer "${S}" not found`));
        } else if (y !== "background") if (r.source) {
          const k = h.sources && h.sources[r.source], M = k && hr(k.type);
          k ? M === "vector" && y === "raster" ? e.push(new pt(a, r.source, `layer "${r.id}" requires a raster source`)) : M !== "raster-dem" && y === "hillshade" ? e.push(new pt(a, r.source, `layer "${r.id}" requires a raster-dem source`)) : M === "raster" && y !== "raster" ? e.push(new pt(a, r.source, `layer "${r.id}" requires a vector source`)) : M !== "vector" || r["source-layer"] ? M === "raster-dem" && y !== "hillshade" ? e.push(new pt(a, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : y !== "line" || !r.paint || !r.paint["line-gradient"] || M === "geojson" && k.lineMetrics || e.push(new pt(a, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new pt(a, r, `layer "${r.id}" must specify a "source-layer"`)) : e.push(new pt(a, r.source, `source "${r.source}" not found`));
        } else e.push(new pt(a, r, 'missing required property "source"'));
        return e = e.concat(mn({ key: a, value: r, valueSpec: d.layer, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, objectElementValidators: { "*": () => [], type: () => i.validateSpec({ key: `${a}.type`, value: r.type, valueSpec: d.layer.type, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, object: r, objectKey: "type" }), filter: Na, layout: (k) => mn({ layer: r, key: k.key, value: k.value, style: k.style, styleSpec: k.styleSpec, validateSpec: k.validateSpec, objectElementValidators: { "*": (M) => jo(Jt({ layerType: y }, M)) } }), paint: (k) => mn({ layer: r, key: k.key, value: k.value, style: k.style, styleSpec: k.styleSpec, validateSpec: k.validateSpec, objectElementValidators: { "*": (M) => Ra(Jt({ layerType: y }, M)) } }) } })), e;
      }
      function xs(i) {
        const e = i.value, r = i.key, a = _i(e);
        return a !== "string" ? [new pt(r, e, `string expected, ${a} found`)] : [];
      }
      const ll = { promoteId: function({ key: i, value: e }) {
        if (_i(e) === "string") return xs({ key: i, value: e });
        {
          const r = [];
          for (const a in e) r.push(...xs({ key: `${i}.${a}`, value: e[a] }));
          return r;
        }
      } };
      function fo(i) {
        const e = i.value, r = i.key, a = i.styleSpec, h = i.style, d = i.validateSpec;
        if (!e.type) return [new pt(r, e, '"type" is required')];
        const y = hr(e.type);
        let S;
        switch (y) {
          case "vector":
          case "raster":
            return S = mn({ key: r, value: e, valueSpec: a[`source_${y.replace("-", "_")}`], style: i.style, styleSpec: a, objectElementValidators: ll, validateSpec: d }), S;
          case "raster-dem":
            return S = function(k) {
              var M;
              const F = (M = k.sourceName) !== null && M !== void 0 ? M : "", O = k.value, $ = k.styleSpec, Y = $.source_raster_dem, ee = k.style;
              let re = [];
              const me = _i(O);
              if (O === void 0) return re;
              if (me !== "object") return re.push(new pt("source_raster_dem", O, `object expected, ${me} found`)), re;
              const be = hr(O.encoding) === "custom", Re = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Pe = k.value.encoding ? `"${k.value.encoding}"` : "Default";
              for (const ze in O) !be && Re.includes(ze) ? re.push(new pt(ze, O[ze], `In "${F}": "${ze}" is only valid when "encoding" is set to "custom". ${Pe} encoding found`)) : Y[ze] ? re = re.concat(k.validateSpec({ key: ze, value: O[ze], valueSpec: Y[ze], validateSpec: k.validateSpec, style: ee, styleSpec: $ })) : re.push(new pt(ze, O[ze], `unknown property "${ze}"`));
              return re;
            }({ sourceName: r, value: e, style: i.style, styleSpec: a, validateSpec: d }), S;
          case "geojson":
            if (S = mn({ key: r, value: e, valueSpec: a.source_geojson, style: h, styleSpec: a, validateSpec: d, objectElementValidators: ll }), e.cluster) for (const k in e.clusterProperties) {
              const [M, F] = e.clusterProperties[k], O = typeof M == "string" ? [M, ["accumulated"], ["get", k]] : M;
              S.push(...Ir({ key: `${r}.${k}.map`, value: F, validateSpec: d, expressionContext: "cluster-map" })), S.push(...Ir({ key: `${r}.${k}.reduce`, value: O, validateSpec: d, expressionContext: "cluster-reduce" }));
            }
            return S;
          case "video":
            return mn({ key: r, value: e, valueSpec: a.source_video, style: h, validateSpec: d, styleSpec: a });
          case "image":
            return mn({ key: r, value: e, valueSpec: a.source_image, style: h, validateSpec: d, styleSpec: a });
          case "canvas":
            return [new pt(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return qs({ key: `${r}.type`, value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: h, validateSpec: d, styleSpec: a });
        }
      }
      function qo(i) {
        const e = i.value, r = i.styleSpec, a = r.light, h = i.style;
        let d = [];
        const y = _i(e);
        if (e === void 0) return d;
        if (y !== "object") return d = d.concat([new pt("light", e, `object expected, ${y} found`)]), d;
        for (const S in e) {
          const k = S.match(/^(.*)-transition$/);
          d = d.concat(k && a[k[1]] && a[k[1]].transition ? i.validateSpec({ key: S, value: e[S], valueSpec: r.transition, validateSpec: i.validateSpec, style: h, styleSpec: r }) : a[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: a[S], validateSpec: i.validateSpec, style: h, styleSpec: r }) : [new pt(S, e[S], `unknown property "${S}"`)]);
        }
        return d;
      }
      function Ml(i) {
        const e = i.value, r = i.styleSpec, a = r.sky, h = i.style, d = _i(e);
        if (e === void 0) return [];
        if (d !== "object") return [new pt("sky", e, `object expected, ${d} found`)];
        let y = [];
        for (const S in e) y = y.concat(a[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: a[S], style: h, styleSpec: r }) : [new pt(S, e[S], `unknown property "${S}"`)]);
        return y;
      }
      function nc(i) {
        const e = i.value, r = i.styleSpec, a = r.terrain, h = i.style;
        let d = [];
        const y = _i(e);
        if (e === void 0) return d;
        if (y !== "object") return d = d.concat([new pt("terrain", e, `object expected, ${y} found`)]), d;
        for (const S in e) d = d.concat(a[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: a[S], validateSpec: i.validateSpec, style: h, styleSpec: r }) : [new pt(S, e[S], `unknown property "${S}"`)]);
        return d;
      }
      function Dl(i) {
        let e = [];
        const r = i.value, a = i.key;
        if (Array.isArray(r)) {
          const h = [], d = [];
          for (const y in r) r[y].id && h.includes(r[y].id) && e.push(new pt(a, r, `all the sprites' ids must be unique, but ${r[y].id} is duplicated`)), h.push(r[y].id), r[y].url && d.includes(r[y].url) && e.push(new pt(a, r, `all the sprites' URLs must be unique, but ${r[y].url} is duplicated`)), d.push(r[y].url), e = e.concat(mn({ key: `${a}[${y}]`, value: r[y], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: i.validateSpec }));
          return e;
        }
        return xs({ key: a, value: r });
      }
      const zl = { "*": () => [], array: ho, boolean: function(i) {
        const e = i.value, r = i.key, a = _i(e);
        return a !== "boolean" ? [new pt(r, e, `boolean expected, ${a} found`)] : [];
      }, number: uo, color: function(i) {
        const e = i.key, r = i.value, a = _i(r);
        return a !== "string" ? [new pt(e, r, `color expected, ${a} found`)] : Ri.parse(String(r)) ? [] : [new pt(e, r, `color expected, "${r}" found`)];
      }, constants: Oo, enum: qs, filter: Na, function: en, layer: El, object: mn, source: fo, light: qo, sky: Ml, terrain: nc, projection: function(i) {
        const e = i.value, r = i.styleSpec, a = r.projection, h = i.style, d = _i(e);
        if (e === void 0) return [];
        if (d !== "object") return [new pt("projection", e, `object expected, ${d} found`)];
        let y = [];
        for (const S in e) y = y.concat(a[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: a[S], style: h, styleSpec: r }) : [new pt(S, e[S], `unknown property "${S}"`)]);
        return y;
      }, string: xs, formatted: function(i) {
        return xs(i).length === 0 ? [] : Ir(i);
      }, resolvedImage: function(i) {
        return xs(i).length === 0 ? [] : Ir(i);
      }, padding: function(i) {
        const e = i.key, r = i.value;
        if (_i(r) === "array") {
          if (r.length < 1 || r.length > 4) return [new pt(e, r, `padding requires 1 to 4 values; ${r.length} values found`)];
          const a = { type: "number" };
          let h = [];
          for (let d = 0; d < r.length; d++) h = h.concat(i.validateSpec({ key: `${e}[${d}]`, value: r[d], validateSpec: i.validateSpec, valueSpec: a }));
          return h;
        }
        return uo({ key: e, value: r, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(i) {
        const e = i.key, r = i.value, a = _i(r), h = i.styleSpec;
        if (a !== "array" || r.length < 1 || r.length % 2 != 0) return [new pt(e, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let d = [];
        for (let y = 0; y < r.length; y += 2) d = d.concat(qs({ key: `${e}[${y}]`, value: r[y], valueSpec: h.layout_symbol["text-anchor"] })), d = d.concat(ho({ key: `${e}[${y + 1}]`, value: r[y + 1], valueSpec: { length: 2, value: "number" }, validateSpec: i.validateSpec, style: i.style, styleSpec: h }));
        return d;
      }, sprite: Dl };
      function mo(i) {
        const e = i.value, r = i.valueSpec, a = i.styleSpec;
        return i.validateSpec = mo, r.expression && Qr(hr(e)) ? en(i) : r.expression && pn(vs(e)) ? Ir(i) : r.type && zl[r.type] ? zl[r.type](i) : mn(Jt({}, i, { valueSpec: r.type ? a[r.type] : r }));
      }
      function Fl(i) {
        const e = i.value, r = i.key, a = xs(i);
        return a.length || (e.indexOf("{fontstack}") === -1 && a.push(new pt(r, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && a.push(new pt(r, e, '"glyphs" url must include a "{range}" token'))), a;
      }
      function Bn(i, e = te) {
        let r = [];
        return r = r.concat(mo({ key: "", value: i, valueSpec: e.$root, styleSpec: e, style: i, validateSpec: mo, objectElementValidators: { glyphs: Fl, "*": () => [] } })), i.constants && (r = r.concat(Oo({ key: "constants", value: i.constants, style: i, styleSpec: e, validateSpec: mo }))), cl(r);
      }
      function Pn(i) {
        return function(e) {
          return i({ ...e, validateSpec: mo });
        };
      }
      function cl(i) {
        return [].concat(i).sort((e, r) => e.line - r.line);
      }
      function gn(i) {
        return function(...e) {
          return cl(i.apply(this, e));
        };
      }
      Bn.source = gn(Pn(fo)), Bn.sprite = gn(Pn(Dl)), Bn.glyphs = gn(Pn(Fl)), Bn.light = gn(Pn(qo)), Bn.sky = gn(Pn(Ml)), Bn.terrain = gn(Pn(nc)), Bn.layer = gn(Pn(El)), Bn.filter = gn(Pn(Na)), Bn.paintProperty = gn(Pn(Ra)), Bn.layoutProperty = gn(Pn(jo));
      const Us = Bn, Cc = Us.light, sc = Us.paintProperty, Nl = Us.layoutProperty;
      function Rl(i, e) {
        let r = !1;
        if (e && e.length) for (const a of e) i.fire(new Ut(new Error(a.message))), r = !0;
        return r;
      }
      class Uo {
        constructor(e, r, a) {
          const h = this.cells = [];
          if (e instanceof ArrayBuffer) {
            this.arrayBuffer = e;
            const y = new Int32Array(this.arrayBuffer);
            e = y[0], this.d = (r = y[1]) + 2 * (a = y[2]);
            for (let k = 0; k < this.d * this.d; k++) {
              const M = y[3 + k], F = y[3 + k + 1];
              h.push(M === F ? null : y.subarray(M, F));
            }
            const S = y[3 + h.length + 1];
            this.keys = y.subarray(y[3 + h.length], S), this.bboxes = y.subarray(S), this.insert = this._insertReadonly;
          } else {
            this.d = r + 2 * a;
            for (let y = 0; y < this.d * this.d; y++) h.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = r, this.extent = e, this.padding = a, this.scale = r / e, this.uid = 0;
          const d = a / r * e;
          this.min = -d, this.max = e + d;
        }
        insert(e, r, a, h, d) {
          this._forEachCell(r, a, h, d, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(r), this.bboxes.push(a), this.bboxes.push(h), this.bboxes.push(d);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(e, r, a, h, d, y) {
          this.cells[d].push(y);
        }
        query(e, r, a, h, d) {
          const y = this.min, S = this.max;
          if (e <= y && r <= y && S <= a && S <= h && !d) return Array.prototype.slice.call(this.keys);
          {
            const k = [];
            return this._forEachCell(e, r, a, h, this._queryCell, k, {}, d), k;
          }
        }
        _queryCell(e, r, a, h, d, y, S, k) {
          const M = this.cells[d];
          if (M !== null) {
            const F = this.keys, O = this.bboxes;
            for (let $ = 0; $ < M.length; $++) {
              const Y = M[$];
              if (S[Y] === void 0) {
                const ee = 4 * Y;
                (k ? k(O[ee + 0], O[ee + 1], O[ee + 2], O[ee + 3]) : e <= O[ee + 2] && r <= O[ee + 3] && a >= O[ee + 0] && h >= O[ee + 1]) ? (S[Y] = !0, y.push(F[Y])) : S[Y] = !1;
              }
            }
          }
        }
        _forEachCell(e, r, a, h, d, y, S, k) {
          const M = this._convertToCellCoord(e), F = this._convertToCellCoord(r), O = this._convertToCellCoord(a), $ = this._convertToCellCoord(h);
          for (let Y = M; Y <= O; Y++) for (let ee = F; ee <= $; ee++) {
            const re = this.d * ee + Y;
            if ((!k || k(this._convertFromCellCoord(Y), this._convertFromCellCoord(ee), this._convertFromCellCoord(Y + 1), this._convertFromCellCoord(ee + 1))) && d.call(this, e, r, a, h, re, y, S, k)) return;
          }
        }
        _convertFromCellCoord(e) {
          return (e - this.padding) / this.scale;
        }
        _convertToCellCoord(e) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const e = this.cells, r = 3 + this.cells.length + 1 + 1;
          let a = 0;
          for (let y = 0; y < this.cells.length; y++) a += this.cells[y].length;
          const h = new Int32Array(r + a + this.keys.length + this.bboxes.length);
          h[0] = this.extent, h[1] = this.n, h[2] = this.padding;
          let d = r;
          for (let y = 0; y < e.length; y++) {
            const S = e[y];
            h[3 + y] = d, h.set(S, d), d += S.length;
          }
          return h[3 + e.length] = d, h.set(this.keys, d), d += this.keys.length, h[3 + e.length + 1] = d, h.set(this.bboxes, d), d += this.bboxes.length, h.buffer;
        }
        static serialize(e, r) {
          const a = e.toArrayBuffer();
          return r && r.push(a), { buffer: a };
        }
        static deserialize(e) {
          return new Uo(e.buffer);
        }
      }
      const xa = {};
      function Rt(i, e, r = {}) {
        if (xa[i]) throw new Error(`${i} is already registered.`);
        Object.defineProperty(e, "_classRegistryKey", { value: i, writeable: !1 }), xa[i] = { klass: e, omit: r.omit || [], shallow: r.shallow || [] };
      }
      Rt("Object", Object), Rt("TransferableGridIndex", Uo), Rt("Color", Ri), Rt("Error", Error), Rt("AJAXError", Ve), Rt("ResolvedImage", sn), Rt("StylePropertyFunction", fn), Rt("StyleExpression", ys, { omit: ["_evaluator"] }), Rt("ZoomDependentExpression", _a), Rt("ZoomConstantExpression", Bs), Rt("CompoundExpression", Hi, { omit: ["_evaluate"] });
      for (const i in Fn) Fn[i]._classRegistryKey || Rt(`Expression_${i}`, Fn[i]);
      function Vs(i) {
        return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer");
      }
      function on(i, e) {
        if (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error) return i;
        if (Vs(i) || rt(i)) return e && e.push(i), i;
        if (ArrayBuffer.isView(i)) {
          const r = i;
          return e && e.push(r.buffer), r;
        }
        if (i instanceof ImageData) return e && e.push(i.data.buffer), i;
        if (Array.isArray(i)) {
          const r = [];
          for (const a of i) r.push(on(a, e));
          return r;
        }
        if (typeof i == "object") {
          const r = i.constructor, a = r._classRegistryKey;
          if (!a) throw new Error(`can't serialize object of unregistered class ${r.name}`);
          if (!xa[a]) throw new Error(`${a} is not registered.`);
          const h = r.serialize ? r.serialize(i, e) : {};
          if (r.serialize) {
            if (e && h === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const d in i) {
              if (!i.hasOwnProperty(d) || xa[a].omit.indexOf(d) >= 0) continue;
              const y = i[d];
              h[d] = xa[a].shallow.indexOf(d) >= 0 ? y : on(y, e);
            }
            i instanceof Error && (h.message = i.message);
          }
          if (h.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return a !== "Object" && (h.$name = a), h;
        }
        throw new Error("can't serialize object of type " + typeof i);
      }
      function jr(i) {
        if (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || Vs(i) || rt(i) || ArrayBuffer.isView(i) || i instanceof ImageData) return i;
        if (Array.isArray(i)) return i.map(jr);
        if (typeof i == "object") {
          const e = i.$name || "Object";
          if (!xa[e]) throw new Error(`can't deserialize unregistered class ${e}`);
          const { klass: r } = xa[e];
          if (!r) throw new Error(`can't deserialize unregistered class ${e}`);
          if (r.deserialize) return r.deserialize(i);
          const a = Object.create(r.prototype);
          for (const h of Object.keys(i)) {
            if (h === "$name") continue;
            const d = i[h];
            a[h] = xa[e].shallow.indexOf(h) >= 0 ? d : jr(d);
          }
          return a;
        }
        throw new Error("can't deserialize object of type " + typeof i);
      }
      class ac {
        constructor() {
          this.first = !0;
        }
        update(e, r) {
          const a = Math.floor(e);
          return this.first ? (this.first = !1, this.lastIntegerZoom = a, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = a, !0) : (this.lastFloorZoom > a ? (this.lastIntegerZoom = a + 1, this.lastIntegerZoomTime = r) : this.lastFloorZoom < a && (this.lastIntegerZoom = a, this.lastIntegerZoomTime = r), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = a, !0));
        }
      }
      const Pt = { "Latin-1 Supplement": (i) => i >= 128 && i <= 255, Arabic: (i) => i >= 1536 && i <= 1791, "Arabic Supplement": (i) => i >= 1872 && i <= 1919, "Arabic Extended-A": (i) => i >= 2208 && i <= 2303, "Hangul Jamo": (i) => i >= 4352 && i <= 4607, "Unified Canadian Aboriginal Syllabics": (i) => i >= 5120 && i <= 5759, Khmer: (i) => i >= 6016 && i <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (i) => i >= 6320 && i <= 6399, "General Punctuation": (i) => i >= 8192 && i <= 8303, "Letterlike Symbols": (i) => i >= 8448 && i <= 8527, "Number Forms": (i) => i >= 8528 && i <= 8591, "Miscellaneous Technical": (i) => i >= 8960 && i <= 9215, "Control Pictures": (i) => i >= 9216 && i <= 9279, "Optical Character Recognition": (i) => i >= 9280 && i <= 9311, "Enclosed Alphanumerics": (i) => i >= 9312 && i <= 9471, "Geometric Shapes": (i) => i >= 9632 && i <= 9727, "Miscellaneous Symbols": (i) => i >= 9728 && i <= 9983, "Miscellaneous Symbols and Arrows": (i) => i >= 11008 && i <= 11263, "CJK Radicals Supplement": (i) => i >= 11904 && i <= 12031, "Kangxi Radicals": (i) => i >= 12032 && i <= 12255, "Ideographic Description Characters": (i) => i >= 12272 && i <= 12287, "CJK Symbols and Punctuation": (i) => i >= 12288 && i <= 12351, Hiragana: (i) => i >= 12352 && i <= 12447, Katakana: (i) => i >= 12448 && i <= 12543, Bopomofo: (i) => i >= 12544 && i <= 12591, "Hangul Compatibility Jamo": (i) => i >= 12592 && i <= 12687, Kanbun: (i) => i >= 12688 && i <= 12703, "Bopomofo Extended": (i) => i >= 12704 && i <= 12735, "CJK Strokes": (i) => i >= 12736 && i <= 12783, "Katakana Phonetic Extensions": (i) => i >= 12784 && i <= 12799, "Enclosed CJK Letters and Months": (i) => i >= 12800 && i <= 13055, "CJK Compatibility": (i) => i >= 13056 && i <= 13311, "CJK Unified Ideographs Extension A": (i) => i >= 13312 && i <= 19903, "Yijing Hexagram Symbols": (i) => i >= 19904 && i <= 19967, "CJK Unified Ideographs": (i) => i >= 19968 && i <= 40959, "Yi Syllables": (i) => i >= 40960 && i <= 42127, "Yi Radicals": (i) => i >= 42128 && i <= 42191, "Hangul Jamo Extended-A": (i) => i >= 43360 && i <= 43391, "Hangul Syllables": (i) => i >= 44032 && i <= 55215, "Hangul Jamo Extended-B": (i) => i >= 55216 && i <= 55295, "Private Use Area": (i) => i >= 57344 && i <= 63743, "CJK Compatibility Ideographs": (i) => i >= 63744 && i <= 64255, "Arabic Presentation Forms-A": (i) => i >= 64336 && i <= 65023, "Vertical Forms": (i) => i >= 65040 && i <= 65055, "CJK Compatibility Forms": (i) => i >= 65072 && i <= 65103, "Small Form Variants": (i) => i >= 65104 && i <= 65135, "Arabic Presentation Forms-B": (i) => i >= 65136 && i <= 65279, "Halfwidth and Fullwidth Forms": (i) => i >= 65280 && i <= 65519 };
      function bs(i) {
        for (const e of i) if (Bl(e.charCodeAt(0))) return !0;
        return !1;
      }
      function On(i) {
        for (const e of i) if (!oc(e.charCodeAt(0))) return !1;
        return !0;
      }
      function oc(i) {
        return !(Pt.Arabic(i) || Pt["Arabic Supplement"](i) || Pt["Arabic Extended-A"](i) || Pt["Arabic Presentation Forms-A"](i) || Pt["Arabic Presentation Forms-B"](i));
      }
      function Bl(i) {
        return !(i !== 746 && i !== 747 && (i < 4352 || !(Pt["Bopomofo Extended"](i) || Pt.Bopomofo(i) || Pt["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || Pt["CJK Compatibility Ideographs"](i) || Pt["CJK Compatibility"](i) || Pt["CJK Radicals Supplement"](i) || Pt["CJK Strokes"](i) || !(!Pt["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || Pt["CJK Unified Ideographs Extension A"](i) || Pt["CJK Unified Ideographs"](i) || Pt["Enclosed CJK Letters and Months"](i) || Pt["Hangul Compatibility Jamo"](i) || Pt["Hangul Jamo Extended-A"](i) || Pt["Hangul Jamo Extended-B"](i) || Pt["Hangul Jamo"](i) || Pt["Hangul Syllables"](i) || Pt.Hiragana(i) || Pt["Ideographic Description Characters"](i) || Pt.Kanbun(i) || Pt["Kangxi Radicals"](i) || Pt["Katakana Phonetic Extensions"](i) || Pt.Katakana(i) && i !== 12540 || !(!Pt["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!Pt["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || Pt["Unified Canadian Aboriginal Syllabics"](i) || Pt["Unified Canadian Aboriginal Syllabics Extended"](i) || Pt["Vertical Forms"](i) || Pt["Yijing Hexagram Symbols"](i) || Pt["Yi Syllables"](i) || Pt["Yi Radicals"](i))));
      }
      function Ol(i) {
        return !(Bl(i) || function(e) {
          return !!(Pt["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || Pt["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || Pt["Letterlike Symbols"](e) || Pt["Number Forms"](e) || Pt["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || Pt["Control Pictures"](e) && e !== 9251 || Pt["Optical Character Recognition"](e) || Pt["Enclosed Alphanumerics"](e) || Pt["Geometric Shapes"](e) || Pt["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || Pt["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || Pt["CJK Symbols and Punctuation"](e) || Pt.Katakana(e) || Pt["Private Use Area"](e) || Pt["CJK Compatibility Forms"](e) || Pt["Small Form Variants"](e) || Pt["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533);
        }(i));
      }
      function $s(i) {
        return i >= 1424 && i <= 2303 || Pt["Arabic Presentation Forms-A"](i) || Pt["Arabic Presentation Forms-B"](i);
      }
      function jl(i, e) {
        return !(!e && $s(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || Pt.Khmer(i));
      }
      function hl(i) {
        for (const e of i) if ($s(e.charCodeAt(0))) return !0;
        return !1;
      }
      const ba = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(i) {
          this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(i) {
          this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      }();
      class ji {
        constructor(e, r) {
          this.zoom = e, r ? (this.now = r.now, this.fadeDuration = r.fadeDuration, this.zoomHistory = r.zoomHistory, this.transition = r.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ac(), this.transition = {});
        }
        isSupportedScript(e) {
          return function(r, a) {
            for (const h of r) if (!jl(h.charCodeAt(0), a)) return !1;
            return !0;
          }(e, ba.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const e = this.zoom, r = e - Math.floor(e), a = this.crossFadingFactor();
          return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: r + (1 - r) * a } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - a) * r };
        }
      }
      class Ba {
        constructor(e, r) {
          this.property = e, this.value = r, this.expression = function(a, h) {
            if (Qr(a)) return new fn(a, h);
            if (pn(a)) {
              const d = ss(a, h);
              if (d.result === "error") throw new Error(d.value.map((y) => `${y.key}: ${y.message}`).join(", "));
              return d.value;
            }
            {
              let d = a;
              return h.type === "color" && typeof a == "string" ? d = Ri.parse(a) : h.type !== "padding" || typeof a != "number" && !Array.isArray(a) ? h.type === "variableAnchorOffsetCollection" && Array.isArray(a) && (d = Kr.parse(a)) : d = Jr.parse(a), { kind: "constant", evaluate: () => d };
            }
          }(r === void 0 ? e.specification.default : r, e.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(e, r, a) {
          return this.property.possiblyEvaluate(this, e, r, a);
        }
      }
      class ws {
        constructor(e) {
          this.property = e, this.value = new Ba(e, void 0);
        }
        transitioned(e, r) {
          return new ql(this.property, this.value, r, $e({}, e.transition, this.transition), e.now);
        }
        untransitioned() {
          return new ql(this.property, this.value, null, {}, 0);
        }
      }
      class wa {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues);
        }
        getValue(e) {
          return ae(this._values[e].value.value);
        }
        setValue(e, r) {
          Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new ws(this._values[e].property)), this._values[e].value = new Ba(this._values[e].property, r === null ? void 0 : ae(r));
        }
        getTransition(e) {
          return ae(this._values[e].transition);
        }
        setTransition(e, r) {
          Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new ws(this._values[e].property)), this._values[e].transition = ae(r) || void 0;
        }
        serialize() {
          const e = {};
          for (const r of Object.keys(this._values)) {
            const a = this.getValue(r);
            a !== void 0 && (e[r] = a);
            const h = this.getTransition(r);
            h !== void 0 && (e[`${r}-transition`] = h);
          }
          return e;
        }
        transitioned(e, r) {
          const a = new Ul(this._properties);
          for (const h of Object.keys(this._values)) a._values[h] = this._values[h].transitioned(e, r._values[h]);
          return a;
        }
        untransitioned() {
          const e = new Ul(this._properties);
          for (const r of Object.keys(this._values)) e._values[r] = this._values[r].untransitioned();
          return e;
        }
      }
      class ql {
        constructor(e, r, a, h, d) {
          this.property = e, this.value = r, this.begin = d + h.delay || 0, this.end = this.begin + h.duration || 0, e.specification.transition && (h.delay || h.duration) && (this.prior = a);
        }
        possiblyEvaluate(e, r, a) {
          const h = e.now || 0, d = this.value.possiblyEvaluate(e, r, a), y = this.prior;
          if (y) {
            if (h > this.end) return this.prior = null, d;
            if (this.value.isDataDriven()) return this.prior = null, d;
            if (h < this.begin) return y.possiblyEvaluate(e, r, a);
            {
              const S = (h - this.begin) / (this.end - this.begin);
              return this.property.interpolate(y.possiblyEvaluate(e, r, a), d, function(k) {
                if (k <= 0) return 0;
                if (k >= 1) return 1;
                const M = k * k, F = M * k;
                return 4 * (k < 0.5 ? F : 3 * (k - M) + F - 0.75);
              }(S));
            }
          }
          return d;
        }
      }
      class Ul {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(e, r, a) {
          const h = new ul(this._properties);
          for (const d of Object.keys(this._values)) h._values[d] = this._values[d].possiblyEvaluate(e, r, a);
          return h;
        }
        hasTransition() {
          for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
          return !1;
        }
      }
      class go {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultPropertyValues);
        }
        hasValue(e) {
          return this._values[e].value !== void 0;
        }
        getValue(e) {
          return ae(this._values[e].value);
        }
        setValue(e, r) {
          this._values[e] = new Ba(this._values[e].property, r === null ? void 0 : ae(r));
        }
        serialize() {
          const e = {};
          for (const r of Object.keys(this._values)) {
            const a = this.getValue(r);
            a !== void 0 && (e[r] = a);
          }
          return e;
        }
        possiblyEvaluate(e, r, a) {
          const h = new ul(this._properties);
          for (const d of Object.keys(this._values)) h._values[d] = this._values[d].possiblyEvaluate(e, r, a);
          return h;
        }
      }
      class Ss {
        constructor(e, r, a) {
          this.property = e, this.value = r, this.parameters = a;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(e) {
          return this.value.kind === "constant" ? this.value.value : e;
        }
        evaluate(e, r, a, h) {
          return this.property.evaluate(this.value, this.parameters, e, r, a, h);
        }
      }
      class ul {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
        }
        get(e) {
          return this._values[e];
        }
      }
      class Vt {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, r) {
          if (e.isDataDriven()) throw new Error("Value should not be data driven");
          return e.expression.evaluate(r);
        }
        interpolate(e, r, a) {
          const h = Rr[this.specification.type];
          return h ? h(e, r, a) : e;
        }
      }
      class ni {
        constructor(e, r) {
          this.specification = e, this.overrides = r;
        }
        possiblyEvaluate(e, r, a, h) {
          return new Ss(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(r, null, {}, a, h) } : e.expression, r);
        }
        interpolate(e, r, a) {
          if (e.value.kind !== "constant" || r.value.kind !== "constant") return e;
          if (e.value.value === void 0 || r.value.value === void 0) return new Ss(this, { kind: "constant", value: void 0 }, e.parameters);
          const h = Rr[this.specification.type];
          if (h) {
            const d = h(e.value.value, r.value.value, a);
            return new Ss(this, { kind: "constant", value: d }, e.parameters);
          }
          return e;
        }
        evaluate(e, r, a, h, d, y) {
          return e.kind === "constant" ? e.value : e.evaluate(r, a, h, d, y);
        }
      }
      class f extends ni {
        possiblyEvaluate(e, r, a, h) {
          if (e.value === void 0) return new Ss(this, { kind: "constant", value: void 0 }, r);
          if (e.expression.kind === "constant") {
            const d = e.expression.evaluate(r, null, {}, a, h), y = e.property.specification.type === "resolvedImage" && typeof d != "string" ? d.name : d, S = this._calculate(y, y, y, r);
            return new Ss(this, { kind: "constant", value: S }, r);
          }
          if (e.expression.kind === "camera") {
            const d = this._calculate(e.expression.evaluate({ zoom: r.zoom - 1 }), e.expression.evaluate({ zoom: r.zoom }), e.expression.evaluate({ zoom: r.zoom + 1 }), r);
            return new Ss(this, { kind: "constant", value: d }, r);
          }
          return new Ss(this, e.expression, r);
        }
        evaluate(e, r, a, h, d, y) {
          if (e.kind === "source") {
            const S = e.evaluate(r, a, h, d, y);
            return this._calculate(S, S, S, r);
          }
          return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(r.zoom) - 1 }, a, h), e.evaluate({ zoom: Math.floor(r.zoom) }, a, h), e.evaluate({ zoom: Math.floor(r.zoom) + 1 }, a, h), r) : e.value;
        }
        _calculate(e, r, a, h) {
          return h.zoom > h.zoomHistory.lastIntegerZoom ? { from: e, to: r } : { from: a, to: r };
        }
        interpolate(e) {
          return e;
        }
      }
      class t {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, r, a, h) {
          if (e.value !== void 0) {
            if (e.expression.kind === "constant") {
              const d = e.expression.evaluate(r, null, {}, a, h);
              return this._calculate(d, d, d, r);
            }
            return this._calculate(e.expression.evaluate(new ji(Math.floor(r.zoom - 1), r)), e.expression.evaluate(new ji(Math.floor(r.zoom), r)), e.expression.evaluate(new ji(Math.floor(r.zoom + 1), r)), r);
          }
        }
        _calculate(e, r, a, h) {
          return h.zoom > h.zoomHistory.lastIntegerZoom ? { from: e, to: r } : { from: a, to: r };
        }
        interpolate(e) {
          return e;
        }
      }
      class n {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, r, a, h) {
          return !!e.expression.evaluate(r, null, {}, a, h);
        }
        interpolate() {
          return !1;
        }
      }
      class c {
        constructor(e) {
          this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const r in e) {
            const a = e[r];
            a.specification.overridable && this.overridableProperties.push(r);
            const h = this.defaultPropertyValues[r] = new Ba(a, void 0), d = this.defaultTransitionablePropertyValues[r] = new ws(a);
            this.defaultTransitioningPropertyValues[r] = d.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = h.possiblyEvaluate({});
          }
        }
      }
      Rt("DataDrivenProperty", ni), Rt("DataConstantProperty", Vt), Rt("CrossFadedDataDrivenProperty", f), Rt("CrossFadedProperty", t), Rt("ColorRampProperty", n);
      const u = "-transition";
      class m extends st {
        constructor(e, r) {
          if (super(), this.id = e.id, this.type = e.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, e.type !== "custom" && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), r.layout && (this._unevaluatedLayout = new go(r.layout)), r.paint)) {
            this._transitionablePaint = new wa(r.paint);
            for (const a in e.paint) this.setPaintProperty(a, e.paint[a], { validate: !1 });
            for (const a in e.layout) this.setLayoutProperty(a, e.layout[a], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ul(r.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(e) {
          return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
        }
        setLayoutProperty(e, r, a = {}) {
          r != null && this._validate(Nl, `layers.${this.id}.layout.${e}`, e, r, a) || (e !== "visibility" ? this._unevaluatedLayout.setValue(e, r) : this.visibility = r);
        }
        getPaintProperty(e) {
          return e.endsWith(u) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
        }
        setPaintProperty(e, r, a = {}) {
          if (r != null && this._validate(sc, `layers.${this.id}.paint.${e}`, e, r, a)) return !1;
          if (e.endsWith(u)) return this._transitionablePaint.setTransition(e.slice(0, -11), r || void 0), !1;
          {
            const h = this._transitionablePaint._values[e], d = h.property.specification["property-type"] === "cross-faded-data-driven", y = h.value.isDataDriven(), S = h.value;
            this._transitionablePaint.setValue(e, r), this._handleSpecialPaintPropertyUpdate(e);
            const k = this._transitionablePaint._values[e].value;
            return k.isDataDriven() || y || d || this._handleOverridablePaintPropertyUpdate(e, S, k);
          }
        }
        _handleSpecialPaintPropertyUpdate(e) {
        }
        _handleOverridablePaintPropertyUpdate(e, r, a) {
          return !1;
        }
        isHidden(e) {
          return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(e) {
          this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(e, r) {
          e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, r);
        }
        serialize() {
          const e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), at(e, (r, a) => !(r === void 0 || a === "layout" && !Object.keys(r).length || a === "paint" && !Object.keys(r).length));
        }
        _validate(e, r, a, h, d = {}) {
          return (!d || d.validate !== !1) && Rl(this, e.call(Us, { key: r, layerType: this.type, objectKey: a, value: h, styleSpec: te, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const e in this.paint._values) {
            const r = this.paint.get(e);
            if (r instanceof Ss && is(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0;
          }
          return !1;
        }
      }
      const T = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class s {
        constructor(e, r) {
          this._structArray = e, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class l {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(e, r) {
          return e._trim(), r && (e.isTransferred = !0, r.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
        }
        static deserialize(e) {
          const r = Object.create(this.prototype);
          return r.arrayBuffer = e.arrayBuffer, r.length = e.length, r.capacity = e.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(e) {
          this.reserve(e), this.length = e;
        }
        reserve(e) {
          if (e > this.capacity) {
            this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const r = this.uint8;
            this._refreshViews(), r && this.uint8.set(r);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function p(i, e = 1) {
        let r = 0, a = 0;
        return { members: i.map((h) => {
          const d = T[h.type].BYTES_PER_ELEMENT, y = r = b(r, Math.max(e, d)), S = h.components || 1;
          return a = Math.max(a, d), r += d * S, { name: h.name, type: h.type, components: S, offset: y };
        }), size: b(r, Math.max(a, e)), alignment: e };
      }
      function b(i, e) {
        return Math.ceil(i / e) * e;
      }
      class P extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, r) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, e, r);
        }
        emplace(e, r, a) {
          const h = 2 * e;
          return this.int16[h + 0] = r, this.int16[h + 1] = a, e;
        }
      }
      P.prototype.bytesPerElement = 4, Rt("StructArrayLayout2i4", P);
      class C extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, e, r, a);
        }
        emplace(e, r, a, h) {
          const d = 3 * e;
          return this.int16[d + 0] = r, this.int16[d + 1] = a, this.int16[d + 2] = h, e;
        }
      }
      C.prototype.bytesPerElement = 6, Rt("StructArrayLayout3i6", C);
      class E extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, e, r, a, h);
        }
        emplace(e, r, a, h, d) {
          const y = 4 * e;
          return this.int16[y + 0] = r, this.int16[y + 1] = a, this.int16[y + 2] = h, this.int16[y + 3] = d, e;
        }
      }
      E.prototype.bytesPerElement = 8, Rt("StructArrayLayout4i8", E);
      class z extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h, d, y) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, r, a, h, d, y);
        }
        emplace(e, r, a, h, d, y, S) {
          const k = 6 * e;
          return this.int16[k + 0] = r, this.int16[k + 1] = a, this.int16[k + 2] = h, this.int16[k + 3] = d, this.int16[k + 4] = y, this.int16[k + 5] = S, e;
        }
      }
      z.prototype.bytesPerElement = 12, Rt("StructArrayLayout2i4i12", z);
      class N extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h, d, y) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, r, a, h, d, y);
        }
        emplace(e, r, a, h, d, y, S) {
          const k = 4 * e, M = 8 * e;
          return this.int16[k + 0] = r, this.int16[k + 1] = a, this.uint8[M + 4] = h, this.uint8[M + 5] = d, this.uint8[M + 6] = y, this.uint8[M + 7] = S, e;
        }
      }
      N.prototype.bytesPerElement = 8, Rt("StructArrayLayout2i4ub8", N);
      class R extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, r) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, e, r);
        }
        emplace(e, r, a) {
          const h = 2 * e;
          return this.float32[h + 0] = r, this.float32[h + 1] = a, e;
        }
      }
      R.prototype.bytesPerElement = 8, Rt("StructArrayLayout2f8", R);
      class G extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h, d, y, S, k, M, F) {
          const O = this.length;
          return this.resize(O + 1), this.emplace(O, e, r, a, h, d, y, S, k, M, F);
        }
        emplace(e, r, a, h, d, y, S, k, M, F, O) {
          const $ = 10 * e;
          return this.uint16[$ + 0] = r, this.uint16[$ + 1] = a, this.uint16[$ + 2] = h, this.uint16[$ + 3] = d, this.uint16[$ + 4] = y, this.uint16[$ + 5] = S, this.uint16[$ + 6] = k, this.uint16[$ + 7] = M, this.uint16[$ + 8] = F, this.uint16[$ + 9] = O, e;
        }
      }
      G.prototype.bytesPerElement = 20, Rt("StructArrayLayout10ui20", G);
      class ie extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h, d, y, S, k, M, F, O, $) {
          const Y = this.length;
          return this.resize(Y + 1), this.emplace(Y, e, r, a, h, d, y, S, k, M, F, O, $);
        }
        emplace(e, r, a, h, d, y, S, k, M, F, O, $, Y) {
          const ee = 12 * e;
          return this.int16[ee + 0] = r, this.int16[ee + 1] = a, this.int16[ee + 2] = h, this.int16[ee + 3] = d, this.uint16[ee + 4] = y, this.uint16[ee + 5] = S, this.uint16[ee + 6] = k, this.uint16[ee + 7] = M, this.int16[ee + 8] = F, this.int16[ee + 9] = O, this.int16[ee + 10] = $, this.int16[ee + 11] = Y, e;
        }
      }
      ie.prototype.bytesPerElement = 24, Rt("StructArrayLayout4i4ui4i24", ie);
      class H extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, e, r, a);
        }
        emplace(e, r, a, h) {
          const d = 3 * e;
          return this.float32[d + 0] = r, this.float32[d + 1] = a, this.float32[d + 2] = h, e;
        }
      }
      H.prototype.bytesPerElement = 12, Rt("StructArrayLayout3f12", H);
      class Q extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, e);
        }
        emplace(e, r) {
          return this.uint32[1 * e + 0] = r, e;
        }
      }
      Q.prototype.bytesPerElement = 4, Rt("StructArrayLayout1ul4", Q);
      class ue extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h, d, y, S, k, M) {
          const F = this.length;
          return this.resize(F + 1), this.emplace(F, e, r, a, h, d, y, S, k, M);
        }
        emplace(e, r, a, h, d, y, S, k, M, F) {
          const O = 10 * e, $ = 5 * e;
          return this.int16[O + 0] = r, this.int16[O + 1] = a, this.int16[O + 2] = h, this.int16[O + 3] = d, this.int16[O + 4] = y, this.int16[O + 5] = S, this.uint32[$ + 3] = k, this.uint16[O + 8] = M, this.uint16[O + 9] = F, e;
        }
      }
      ue.prototype.bytesPerElement = 20, Rt("StructArrayLayout6i1ul2ui20", ue);
      class ce extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h, d, y) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, r, a, h, d, y);
        }
        emplace(e, r, a, h, d, y, S) {
          const k = 6 * e;
          return this.int16[k + 0] = r, this.int16[k + 1] = a, this.int16[k + 2] = h, this.int16[k + 3] = d, this.int16[k + 4] = y, this.int16[k + 5] = S, e;
        }
      }
      ce.prototype.bytesPerElement = 12, Rt("StructArrayLayout2i2i2i12", ce);
      class ne extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h, d) {
          const y = this.length;
          return this.resize(y + 1), this.emplace(y, e, r, a, h, d);
        }
        emplace(e, r, a, h, d, y) {
          const S = 4 * e, k = 8 * e;
          return this.float32[S + 0] = r, this.float32[S + 1] = a, this.float32[S + 2] = h, this.int16[k + 6] = d, this.int16[k + 7] = y, e;
        }
      }
      ne.prototype.bytesPerElement = 16, Rt("StructArrayLayout2f1f2i16", ne);
      class le extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h, d, y) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, r, a, h, d, y);
        }
        emplace(e, r, a, h, d, y, S) {
          const k = 16 * e, M = 4 * e, F = 8 * e;
          return this.uint8[k + 0] = r, this.uint8[k + 1] = a, this.float32[M + 1] = h, this.float32[M + 2] = d, this.int16[F + 6] = y, this.int16[F + 7] = S, e;
        }
      }
      le.prototype.bytesPerElement = 16, Rt("StructArrayLayout2ub2f2i16", le);
      class De extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, e, r, a);
        }
        emplace(e, r, a, h) {
          const d = 3 * e;
          return this.uint16[d + 0] = r, this.uint16[d + 1] = a, this.uint16[d + 2] = h, e;
        }
      }
      De.prototype.bytesPerElement = 6, Rt("StructArrayLayout3ui6", De);
      class Ne extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h, d, y, S, k, M, F, O, $, Y, ee, re, me, be) {
          const Re = this.length;
          return this.resize(Re + 1), this.emplace(Re, e, r, a, h, d, y, S, k, M, F, O, $, Y, ee, re, me, be);
        }
        emplace(e, r, a, h, d, y, S, k, M, F, O, $, Y, ee, re, me, be, Re) {
          const Pe = 24 * e, ze = 12 * e, Xe = 48 * e;
          return this.int16[Pe + 0] = r, this.int16[Pe + 1] = a, this.uint16[Pe + 2] = h, this.uint16[Pe + 3] = d, this.uint32[ze + 2] = y, this.uint32[ze + 3] = S, this.uint32[ze + 4] = k, this.uint16[Pe + 10] = M, this.uint16[Pe + 11] = F, this.uint16[Pe + 12] = O, this.float32[ze + 7] = $, this.float32[ze + 8] = Y, this.uint8[Xe + 36] = ee, this.uint8[Xe + 37] = re, this.uint8[Xe + 38] = me, this.uint32[ze + 10] = be, this.int16[Pe + 22] = Re, e;
        }
      }
      Ne.prototype.bytesPerElement = 48, Rt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ne);
      class Te extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h, d, y, S, k, M, F, O, $, Y, ee, re, me, be, Re, Pe, ze, Xe, mt, At, Kt, Et, St, Gt, qt) {
          const Ot = this.length;
          return this.resize(Ot + 1), this.emplace(Ot, e, r, a, h, d, y, S, k, M, F, O, $, Y, ee, re, me, be, Re, Pe, ze, Xe, mt, At, Kt, Et, St, Gt, qt);
        }
        emplace(e, r, a, h, d, y, S, k, M, F, O, $, Y, ee, re, me, be, Re, Pe, ze, Xe, mt, At, Kt, Et, St, Gt, qt, Ot) {
          const ht = 32 * e, Xt = 16 * e;
          return this.int16[ht + 0] = r, this.int16[ht + 1] = a, this.int16[ht + 2] = h, this.int16[ht + 3] = d, this.int16[ht + 4] = y, this.int16[ht + 5] = S, this.int16[ht + 6] = k, this.int16[ht + 7] = M, this.uint16[ht + 8] = F, this.uint16[ht + 9] = O, this.uint16[ht + 10] = $, this.uint16[ht + 11] = Y, this.uint16[ht + 12] = ee, this.uint16[ht + 13] = re, this.uint16[ht + 14] = me, this.uint16[ht + 15] = be, this.uint16[ht + 16] = Re, this.uint16[ht + 17] = Pe, this.uint16[ht + 18] = ze, this.uint16[ht + 19] = Xe, this.uint16[ht + 20] = mt, this.uint16[ht + 21] = At, this.uint16[ht + 22] = Kt, this.uint32[Xt + 12] = Et, this.float32[Xt + 13] = St, this.float32[Xt + 14] = Gt, this.uint16[ht + 30] = qt, this.uint16[ht + 31] = Ot, e;
        }
      }
      Te.prototype.bytesPerElement = 64, Rt("StructArrayLayout8i15ui1ul2f2ui64", Te);
      class qe extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, e);
        }
        emplace(e, r) {
          return this.float32[1 * e + 0] = r, e;
        }
      }
      qe.prototype.bytesPerElement = 4, Rt("StructArrayLayout1f4", qe);
      class He extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, e, r, a);
        }
        emplace(e, r, a, h) {
          const d = 3 * e;
          return this.uint16[6 * e + 0] = r, this.float32[d + 1] = a, this.float32[d + 2] = h, e;
        }
      }
      He.prototype.bytesPerElement = 12, Rt("StructArrayLayout1ui2f12", He);
      class vt extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, e, r, a);
        }
        emplace(e, r, a, h) {
          const d = 4 * e;
          return this.uint32[2 * e + 0] = r, this.uint16[d + 2] = a, this.uint16[d + 3] = h, e;
        }
      }
      vt.prototype.bytesPerElement = 8, Rt("StructArrayLayout1ul2ui8", vt);
      class Ue extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, r) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, e, r);
        }
        emplace(e, r, a) {
          const h = 2 * e;
          return this.uint16[h + 0] = r, this.uint16[h + 1] = a, e;
        }
      }
      Ue.prototype.bytesPerElement = 4, Rt("StructArrayLayout2ui4", Ue);
      class ft extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, e);
        }
        emplace(e, r) {
          return this.uint16[1 * e + 0] = r, e;
        }
      }
      ft.prototype.bytesPerElement = 2, Rt("StructArrayLayout1ui2", ft);
      class Tt extends l {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, r, a, h) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, e, r, a, h);
        }
        emplace(e, r, a, h, d) {
          const y = 4 * e;
          return this.float32[y + 0] = r, this.float32[y + 1] = a, this.float32[y + 2] = h, this.float32[y + 3] = d, e;
        }
      }
      Tt.prototype.bytesPerElement = 16, Rt("StructArrayLayout4f16", Tt);
      class ii extends s {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new q(this.anchorPointX, this.anchorPointY);
        }
      }
      ii.prototype.size = 20;
      class Mt extends ue {
        get(e) {
          return new ii(this, e);
        }
      }
      Rt("CollisionBoxArray", Mt);
      class Wt extends s {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(e) {
          this._structArray.uint8[this._pos1 + 37] = e;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(e) {
          this._structArray.uint8[this._pos1 + 38] = e;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 10] = e;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      Wt.prototype.size = 48;
      class ci extends Ne {
        get(e) {
          return new Wt(this, e);
        }
      }
      Rt("PlacedSymbolArray", ci);
      class si extends s {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 12] = e;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      si.prototype.size = 64;
      class qi extends Te {
        get(e) {
          return new si(this, e);
        }
      }
      Rt("SymbolInstanceArray", qi);
      class Ti extends qe {
        getoffsetX(e) {
          return this.float32[1 * e + 0];
        }
      }
      Rt("GlyphOffsetArray", Ti);
      class Ni extends C {
        getx(e) {
          return this.int16[3 * e + 0];
        }
        gety(e) {
          return this.int16[3 * e + 1];
        }
        gettileUnitDistanceFromAnchor(e) {
          return this.int16[3 * e + 2];
        }
      }
      Rt("SymbolLineVertexArray", Ni);
      class Wi extends s {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      Wi.prototype.size = 12;
      class bi extends He {
        get(e) {
          return new Wi(this, e);
        }
      }
      Rt("TextAnchorOffsetArray", bi);
      class Gi extends s {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      Gi.prototype.size = 8;
      class fr extends vt {
        get(e) {
          return new Gi(this, e);
        }
      }
      Rt("FeatureIndexArray", fr);
      class ur extends P {
      }
      class Tr extends P {
      }
      class kr extends P {
      }
      class qr extends z {
      }
      class In extends N {
      }
      class Lr extends R {
      }
      class nr extends G {
      }
      class Zr extends ie {
      }
      class Tn extends H {
      }
      class kn extends Q {
      }
      class Li extends ce {
      }
      class Ur extends le {
      }
      class zr extends De {
      }
      class sr extends Ue {
      }
      const Zs = p([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Oa } = Zs;
      class vr {
        constructor(e = []) {
          this.segments = e;
        }
        prepareSegment(e, r, a, h) {
          let d = this.segments[this.segments.length - 1];
          return e > vr.MAX_VERTEX_ARRAY_LENGTH && Ie(`Max vertices per segment is ${vr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!d || d.vertexLength + e > vr.MAX_VERTEX_ARRAY_LENGTH || d.sortKey !== h) && (d = { vertexOffset: r.length, primitiveOffset: a.length, vertexLength: 0, primitiveLength: 0 }, h !== void 0 && (d.sortKey = h), this.segments.push(d)), d;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const e of this.segments) for (const r in e.vaos) e.vaos[r].destroy();
        }
        static simpleSegment(e, r, a, h) {
          return new vr([{ vertexOffset: e, primitiveOffset: r, vertexLength: a, primitiveLength: h, vaos: {}, sortKey: 0 }]);
        }
      }
      function jn(i, e) {
        return 256 * (i = Ke(Math.floor(i), 0, 255)) + Ke(Math.floor(e), 0, 255);
      }
      vr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Rt("SegmentVector", vr);
      const Ws = p([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var Gs = { exports: {} }, Hs = { exports: {} };
      Hs.exports = function(i, e) {
        var r, a, h, d, y, S, k, M;
        for (a = i.length - (r = 3 & i.length), h = e, y = 3432918353, S = 461845907, M = 0; M < a; ) k = 255 & i.charCodeAt(M) | (255 & i.charCodeAt(++M)) << 8 | (255 & i.charCodeAt(++M)) << 16 | (255 & i.charCodeAt(++M)) << 24, ++M, h = 27492 + (65535 & (d = 5 * (65535 & (h = (h ^= k = (65535 & (k = (k = (65535 & k) * y + (((k >>> 16) * y & 65535) << 16) & 4294967295) << 15 | k >>> 17)) * S + (((k >>> 16) * S & 65535) << 16) & 4294967295) << 13 | h >>> 19)) + ((5 * (h >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (d >>> 16) & 65535) << 16);
        switch (k = 0, r) {
          case 3:
            k ^= (255 & i.charCodeAt(M + 2)) << 16;
          case 2:
            k ^= (255 & i.charCodeAt(M + 1)) << 8;
          case 1:
            h ^= k = (65535 & (k = (k = (65535 & (k ^= 255 & i.charCodeAt(M))) * y + (((k >>> 16) * y & 65535) << 16) & 4294967295) << 15 | k >>> 17)) * S + (((k >>> 16) * S & 65535) << 16) & 4294967295;
        }
        return h ^= i.length, h = 2246822507 * (65535 & (h ^= h >>> 16)) + ((2246822507 * (h >>> 16) & 65535) << 16) & 4294967295, h = 3266489909 * (65535 & (h ^= h >>> 13)) + ((3266489909 * (h >>> 16) & 65535) << 16) & 4294967295, (h ^= h >>> 16) >>> 0;
      };
      var Vo = Hs.exports, dl = { exports: {} };
      dl.exports = function(i, e) {
        for (var r, a = i.length, h = e ^ a, d = 0; a >= 4; ) r = 1540483477 * (65535 & (r = 255 & i.charCodeAt(d) | (255 & i.charCodeAt(++d)) << 8 | (255 & i.charCodeAt(++d)) << 16 | (255 & i.charCodeAt(++d)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), a -= 4, ++d;
        switch (a) {
          case 3:
            h ^= (255 & i.charCodeAt(d + 2)) << 16;
          case 2:
            h ^= (255 & i.charCodeAt(d + 1)) << 8;
          case 1:
            h = 1540483477 * (65535 & (h ^= 255 & i.charCodeAt(d))) + ((1540483477 * (h >>> 16) & 65535) << 16);
        }
        return h = 1540483477 * (65535 & (h ^= h >>> 13)) + ((1540483477 * (h >>> 16) & 65535) << 16), (h ^= h >>> 15) >>> 0;
      };
      var yo = Vo, $o = dl.exports;
      Gs.exports = yo, Gs.exports.murmur3 = yo, Gs.exports.murmur2 = $o;
      var ja = D(Gs.exports);
      class As {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(e, r, a, h) {
          this.ids.push(sh(e)), this.positions.push(r, a, h);
        }
        getPositions(e) {
          if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
          const r = sh(e);
          let a = 0, h = this.ids.length - 1;
          for (; a < h; ) {
            const y = a + h >> 1;
            this.ids[y] >= r ? h = y : a = y + 1;
          }
          const d = [];
          for (; this.ids[a] === r; ) d.push({ index: this.positions[3 * a], start: this.positions[3 * a + 1], end: this.positions[3 * a + 2] }), a++;
          return d;
        }
        static serialize(e, r) {
          const a = new Float64Array(e.ids), h = new Uint32Array(e.positions);
          return Ec(a, h, 0, a.length - 1), r && r.push(a.buffer, h.buffer), { ids: a, positions: h };
        }
        static deserialize(e) {
          const r = new As();
          return r.ids = e.ids, r.positions = e.positions, r.indexed = !0, r;
        }
      }
      function sh(i) {
        const e = +i;
        return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : ja(String(i));
      }
      function Ec(i, e, r, a) {
        for (; r < a; ) {
          const h = i[r + a >> 1];
          let d = r - 1, y = a + 1;
          for (; ; ) {
            do
              d++;
            while (i[d] < h);
            do
              y--;
            while (i[y] > h);
            if (d >= y) break;
            pl(i, d, y), pl(e, 3 * d, 3 * y), pl(e, 3 * d + 1, 3 * y + 1), pl(e, 3 * d + 2, 3 * y + 2);
          }
          y - r < a - y ? (Ec(i, e, r, y), r = y + 1) : (Ec(i, e, y + 1, a), a = y);
        }
      }
      function pl(i, e, r) {
        const a = i[e];
        i[e] = i[r], i[r] = a;
      }
      Rt("FeaturePositionMap", As);
      class qn {
        constructor(e, r) {
          this.gl = e.gl, this.location = r;
        }
      }
      class lc extends qn {
        constructor(e, r) {
          super(e, r), this.current = 0;
        }
        set(e) {
          this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
        }
      }
      class ah extends qn {
        constructor(e, r) {
          super(e, r), this.current = [0, 0, 0, 0];
        }
        set(e) {
          e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] && e[3] === this.current[3] || (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
        }
      }
      class oh extends qn {
        constructor(e, r) {
          super(e, r), this.current = Ri.transparent;
        }
        set(e) {
          e.r === this.current.r && e.g === this.current.g && e.b === this.current.b && e.a === this.current.a || (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
        }
      }
      const lh = new Float32Array(16);
      function fl(i) {
        return [jn(255 * i.r, 255 * i.g), jn(255 * i.b, 255 * i.a)];
      }
      class ml {
        constructor(e, r, a) {
          this.value = e, this.uniformNames = r.map((h) => `u_${h}`), this.type = a;
        }
        setUniform(e, r, a) {
          e.set(a.constantOr(this.value));
        }
        getBinding(e, r, a) {
          return this.type === "color" ? new oh(e, r) : new lc(e, r);
        }
      }
      class Zo {
        constructor(e, r) {
          this.uniformNames = r.map((a) => `u_${a}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(e, r) {
          this.pixelRatioFrom = r.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = r.tlbr, this.patternTo = e.tlbr;
        }
        setUniform(e, r, a, h) {
          const d = h === "u_pattern_to" ? this.patternTo : h === "u_pattern_from" ? this.patternFrom : h === "u_pixel_ratio_to" ? this.pixelRatioTo : h === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          d && e.set(d);
        }
        getBinding(e, r, a) {
          return a.substr(0, 9) === "u_pattern" ? new ah(e, r) : new lc(e, r);
        }
      }
      class Ps {
        constructor(e, r, a, h) {
          this.expression = e, this.type = a, this.maxValue = 0, this.paintVertexAttributes = r.map((d) => ({ name: `a_${d}`, type: "Float32", components: a === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new h();
        }
        populatePaintArray(e, r, a, h, d) {
          const y = this.paintVertexArray.length, S = this.expression.evaluate(new ji(0), r, {}, h, [], d);
          this.paintVertexArray.resize(e), this._setPaintValue(y, e, S);
        }
        updatePaintArray(e, r, a, h) {
          const d = this.expression.evaluate({ zoom: 0 }, a, h);
          this._setPaintValue(e, r, d);
        }
        _setPaintValue(e, r, a) {
          if (this.type === "color") {
            const h = fl(a);
            for (let d = e; d < r; d++) this.paintVertexArray.emplace(d, h[0], h[1]);
          } else {
            for (let h = e; h < r; h++) this.paintVertexArray.emplace(h, a);
            this.maxValue = Math.max(this.maxValue, Math.abs(a));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class as {
        constructor(e, r, a, h, d, y) {
          this.expression = e, this.uniformNames = r.map((S) => `u_${S}_t`), this.type = a, this.useIntegerZoom = h, this.zoom = d, this.maxValue = 0, this.paintVertexAttributes = r.map((S) => ({ name: `a_${S}`, type: "Float32", components: a === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new y();
        }
        populatePaintArray(e, r, a, h, d) {
          const y = this.expression.evaluate(new ji(this.zoom), r, {}, h, [], d), S = this.expression.evaluate(new ji(this.zoom + 1), r, {}, h, [], d), k = this.paintVertexArray.length;
          this.paintVertexArray.resize(e), this._setPaintValue(k, e, y, S);
        }
        updatePaintArray(e, r, a, h) {
          const d = this.expression.evaluate({ zoom: this.zoom }, a, h), y = this.expression.evaluate({ zoom: this.zoom + 1 }, a, h);
          this._setPaintValue(e, r, d, y);
        }
        _setPaintValue(e, r, a, h) {
          if (this.type === "color") {
            const d = fl(a), y = fl(h);
            for (let S = e; S < r; S++) this.paintVertexArray.emplace(S, d[0], d[1], y[0], y[1]);
          } else {
            for (let d = e; d < r; d++) this.paintVertexArray.emplace(d, a, h);
            this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(h));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(e, r) {
          const a = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, h = Ke(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1);
          e.set(h);
        }
        getBinding(e, r, a) {
          return new lc(e, r);
        }
      }
      class Is {
        constructor(e, r, a, h, d, y) {
          this.expression = e, this.type = r, this.useIntegerZoom = a, this.zoom = h, this.layerId = y, this.zoomInPaintVertexArray = new d(), this.zoomOutPaintVertexArray = new d();
        }
        populatePaintArray(e, r, a) {
          const h = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(h, e, r.patterns && r.patterns[this.layerId], a);
        }
        updatePaintArray(e, r, a, h, d) {
          this._setPaintValues(e, r, a.patterns && a.patterns[this.layerId], d);
        }
        _setPaintValues(e, r, a, h) {
          if (!h || !a) return;
          const { min: d, mid: y, max: S } = a, k = h[d], M = h[y], F = h[S];
          if (k && M && F) for (let O = e; O < r; O++) this.zoomInPaintVertexArray.emplace(O, M.tl[0], M.tl[1], M.br[0], M.br[1], k.tl[0], k.tl[1], k.br[0], k.br[1], M.pixelRatio, k.pixelRatio), this.zoomOutPaintVertexArray.emplace(O, M.tl[0], M.tl[1], M.br[0], M.br[1], F.tl[0], F.tl[1], F.br[0], F.br[1], M.pixelRatio, F.pixelRatio);
        }
        upload(e) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, Ws.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, Ws.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class Mc {
        constructor(e, r, a) {
          this.binders = {}, this._buffers = [];
          const h = [];
          for (const d in e.paint._values) {
            if (!a(d)) continue;
            const y = e.paint.get(d);
            if (!(y instanceof Ss && is(y.property.specification))) continue;
            const S = cc(d, e.type), k = y.value, M = y.property.specification.type, F = y.property.useIntegerZoom, O = y.property.specification["property-type"], $ = O === "cross-faded" || O === "cross-faded-data-driven";
            if (k.kind === "constant") this.binders[d] = $ ? new Zo(k.value, S) : new ml(k.value, S, M), h.push(`/u_${d}`);
            else if (k.kind === "source" || $) {
              const Y = Dc(d, M, "source");
              this.binders[d] = $ ? new Is(k, M, F, r, Y, e.id) : new Ps(k, S, M, Y), h.push(`/a_${d}`);
            } else {
              const Y = Dc(d, M, "composite");
              this.binders[d] = new as(k, S, M, F, r, Y), h.push(`/z_${d}`);
            }
          }
          this.cacheKey = h.sort().join("");
        }
        getMaxValue(e) {
          const r = this.binders[e];
          return r instanceof Ps || r instanceof as ? r.maxValue : 0;
        }
        populatePaintArrays(e, r, a, h, d) {
          for (const y in this.binders) {
            const S = this.binders[y];
            (S instanceof Ps || S instanceof as || S instanceof Is) && S.populatePaintArray(e, r, a, h, d);
          }
        }
        setConstantPatternPositions(e, r) {
          for (const a in this.binders) {
            const h = this.binders[a];
            h instanceof Zo && h.setConstantPatternPositions(e, r);
          }
        }
        updatePaintArrays(e, r, a, h, d) {
          let y = !1;
          for (const S in e) {
            const k = r.getPositions(S);
            for (const M of k) {
              const F = a.feature(M.index);
              for (const O in this.binders) {
                const $ = this.binders[O];
                if (($ instanceof Ps || $ instanceof as || $ instanceof Is) && $.expression.isStateDependent === !0) {
                  const Y = h.paint.get(O);
                  $.expression = Y.value, $.updatePaintArray(M.start, M.end, F, e[S], d), y = !0;
                }
              }
            }
          }
          return y;
        }
        defines() {
          const e = [];
          for (const r in this.binders) {
            const a = this.binders[r];
            (a instanceof ml || a instanceof Zo) && e.push(...a.uniformNames.map((h) => `#define HAS_UNIFORM_${h}`));
          }
          return e;
        }
        getBinderAttributes() {
          const e = [];
          for (const r in this.binders) {
            const a = this.binders[r];
            if (a instanceof Ps || a instanceof as) for (let h = 0; h < a.paintVertexAttributes.length; h++) e.push(a.paintVertexAttributes[h].name);
            else if (a instanceof Is) for (let h = 0; h < Ws.members.length; h++) e.push(Ws.members[h].name);
          }
          return e;
        }
        getBinderUniforms() {
          const e = [];
          for (const r in this.binders) {
            const a = this.binders[r];
            if (a instanceof ml || a instanceof Zo || a instanceof as) for (const h of a.uniformNames) e.push(h);
          }
          return e;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(e, r) {
          const a = [];
          for (const h in this.binders) {
            const d = this.binders[h];
            if (d instanceof ml || d instanceof Zo || d instanceof as) {
              for (const y of d.uniformNames) if (r[y]) {
                const S = d.getBinding(e, r[y], y);
                a.push({ name: y, property: h, binding: S });
              }
            }
          }
          return a;
        }
        setUniforms(e, r, a, h) {
          for (const { name: d, property: y, binding: S } of r) this.binders[y].setUniform(S, h, a.get(y), d);
        }
        updatePaintBuffers(e) {
          this._buffers = [];
          for (const r in this.binders) {
            const a = this.binders[r];
            if (e && a instanceof Is) {
              const h = e.fromScale === 2 ? a.zoomInPaintVertexBuffer : a.zoomOutPaintVertexBuffer;
              h && this._buffers.push(h);
            } else (a instanceof Ps || a instanceof as) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer);
          }
        }
        upload(e) {
          for (const r in this.binders) {
            const a = this.binders[r];
            (a instanceof Ps || a instanceof as || a instanceof Is) && a.upload(e);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const e in this.binders) {
            const r = this.binders[e];
            (r instanceof Ps || r instanceof as || r instanceof Is) && r.destroy();
          }
        }
      }
      class Wo {
        constructor(e, r, a = () => !0) {
          this.programConfigurations = {};
          for (const h of e) this.programConfigurations[h.id] = new Mc(h, r, a);
          this.needsUpload = !1, this._featureMap = new As(), this._bufferOffset = 0;
        }
        populatePaintArrays(e, r, a, h, d, y) {
          for (const S in this.programConfigurations) this.programConfigurations[S].populatePaintArrays(e, r, h, d, y);
          r.id !== void 0 && this._featureMap.add(r.id, a, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0;
        }
        updatePaintArrays(e, r, a, h) {
          for (const d of a) this.needsUpload = this.programConfigurations[d.id].updatePaintArrays(e, this._featureMap, r, d, h) || this.needsUpload;
        }
        get(e) {
          return this.programConfigurations[e];
        }
        upload(e) {
          if (this.needsUpload) {
            for (const r in this.programConfigurations) this.programConfigurations[r].upload(e);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
        }
      }
      function cc(i, e) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[i] || [i.replace(`${e}-`, "").replace(/-/g, "_")];
      }
      function Dc(i, e, r) {
        const a = { color: { source: R, composite: Tt }, number: { source: qe, composite: R } }, h = function(d) {
          return { "line-pattern": { source: nr, composite: nr }, "fill-pattern": { source: nr, composite: nr }, "fill-extrusion-pattern": { source: nr, composite: nr } }[d];
        }(i);
        return h && h[r] || a[e][r];
      }
      Rt("ConstantBinder", ml), Rt("CrossFadedConstantBinder", Zo), Rt("SourceExpressionBinder", Ps), Rt("CrossFadedCompositeBinder", Is), Rt("CompositeExpressionBinder", as), Rt("ProgramConfiguration", Mc, { omit: ["_buffers"] }), Rt("ProgramConfigurationSet", Wo);
      const xr = 8192, Sa = Math.pow(2, 14) - 1, zc = -Sa - 1;
      function _o(i) {
        const e = xr / i.extent, r = i.loadGeometry();
        for (let a = 0; a < r.length; a++) {
          const h = r[a];
          for (let d = 0; d < h.length; d++) {
            const y = h[d], S = Math.round(y.x * e), k = Math.round(y.y * e);
            y.x = Ke(S, zc, Sa), y.y = Ke(k, zc, Sa), (S < y.x || S > y.x + 1 || k < y.y || k > y.y + 1) && Ie("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return r;
      }
      function Go(i, e) {
        return { type: i.type, id: i.id, properties: i.properties, geometry: e ? _o(i) : [] };
      }
      function Vl(i, e, r, a, h) {
        i.emplaceBack(2 * e + (a + 1) / 2, 2 * r + (h + 1) / 2);
      }
      class vo {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((r) => r.id), this.index = e.index, this.hasPattern = !1, this.layoutVertexArray = new Tr(), this.indexArray = new zr(), this.segments = new vr(), this.programConfigurations = new Wo(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id);
        }
        populate(e, r, a) {
          const h = this.layers[0], d = [];
          let y = null, S = !1;
          h.type === "circle" && (y = h.layout.get("circle-sort-key"), S = !y.isConstant());
          for (const { feature: k, id: M, index: F, sourceLayerIndex: O } of e) {
            const $ = this.layers[0]._featureFilter.needGeometry, Y = Go(k, $);
            if (!this.layers[0]._featureFilter.filter(new ji(this.zoom), Y, a)) continue;
            const ee = S ? y.evaluate(Y, {}, a) : void 0, re = { id: M, properties: k.properties, type: k.type, sourceLayerIndex: O, index: F, geometry: $ ? Y.geometry : _o(k), patterns: {}, sortKey: ee };
            d.push(re);
          }
          S && d.sort((k, M) => k.sortKey - M.sortKey);
          for (const k of d) {
            const { geometry: M, index: F, sourceLayerIndex: O } = k, $ = e[F].feature;
            this.addFeature(k, M, F, a), r.featureIndex.insert($, M, F, O, this.index);
          }
        }
        update(e, r, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Oa), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(e, r, a, h) {
          for (const d of r) for (const y of d) {
            const S = y.x, k = y.y;
            if (S < 0 || S >= xr || k < 0 || k >= xr) continue;
            const M = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), F = M.vertexLength;
            Vl(this.layoutVertexArray, S, k, -1, -1), Vl(this.layoutVertexArray, S, k, 1, -1), Vl(this.layoutVertexArray, S, k, 1, 1), Vl(this.layoutVertexArray, S, k, -1, 1), this.indexArray.emplaceBack(F, F + 1, F + 2), this.indexArray.emplaceBack(F, F + 3, F + 2), M.vertexLength += 4, M.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, {}, h);
        }
      }
      function ch(i, e) {
        for (let r = 0; r < i.length; r++) if (os(e, i[r])) return !0;
        for (let r = 0; r < e.length; r++) if (os(i, e[r])) return !0;
        return !!Fc(i, e);
      }
      function hh(i, e, r) {
        return !!os(i, e) || !!Zl(e, i, r);
      }
      function uh(i, e) {
        if (i.length === 1) return Aa(e, i[0]);
        for (let r = 0; r < e.length; r++) {
          const a = e[r];
          for (let h = 0; h < a.length; h++) if (os(i, a[h])) return !0;
        }
        for (let r = 0; r < i.length; r++) if (Aa(e, i[r])) return !0;
        for (let r = 0; r < e.length; r++) if (Fc(i, e[r])) return !0;
        return !1;
      }
      function dh(i, e, r) {
        if (i.length > 1) {
          if (Fc(i, e)) return !0;
          for (let a = 0; a < e.length; a++) if (Zl(e[a], i, r)) return !0;
        }
        for (let a = 0; a < i.length; a++) if (Zl(i[a], e, r)) return !0;
        return !1;
      }
      function Fc(i, e) {
        if (i.length === 0 || e.length === 0) return !1;
        for (let r = 0; r < i.length - 1; r++) {
          const a = i[r], h = i[r + 1];
          for (let d = 0; d < e.length - 1; d++) if ($l(a, h, e[d], e[d + 1])) return !0;
        }
        return !1;
      }
      function $l(i, e, r, a) {
        return Se(i, r, a) !== Se(e, r, a) && Se(i, e, r) !== Se(i, e, a);
      }
      function Zl(i, e, r) {
        const a = r * r;
        if (e.length === 1) return i.distSqr(e[0]) < a;
        for (let h = 1; h < e.length; h++) if (Wl(i, e[h - 1], e[h]) < a) return !0;
        return !1;
      }
      function Wl(i, e, r) {
        const a = e.distSqr(r);
        if (a === 0) return i.distSqr(e);
        const h = ((i.x - e.x) * (r.x - e.x) + (i.y - e.y) * (r.y - e.y)) / a;
        return i.distSqr(h < 0 ? e : h > 1 ? r : r.sub(e)._mult(h)._add(e));
      }
      function Aa(i, e) {
        let r, a, h, d = !1;
        for (let y = 0; y < i.length; y++) {
          r = i[y];
          for (let S = 0, k = r.length - 1; S < r.length; k = S++) a = r[S], h = r[k], a.y > e.y != h.y > e.y && e.x < (h.x - a.x) * (e.y - a.y) / (h.y - a.y) + a.x && (d = !d);
        }
        return d;
      }
      function os(i, e) {
        let r = !1;
        for (let a = 0, h = i.length - 1; a < i.length; h = a++) {
          const d = i[a], y = i[h];
          d.y > e.y != y.y > e.y && e.x < (y.x - d.x) * (e.y - d.y) / (y.y - d.y) + d.x && (r = !r);
        }
        return r;
      }
      function xo(i, e, r) {
        const a = r[0], h = r[2];
        if (i.x < a.x && e.x < a.x || i.x > h.x && e.x > h.x || i.y < a.y && e.y < a.y || i.y > h.y && e.y > h.y) return !1;
        const d = Se(i, e, r[0]);
        return d !== Se(i, e, r[1]) || d !== Se(i, e, r[2]) || d !== Se(i, e, r[3]);
      }
      function bo(i, e, r) {
        const a = e.paint.get(i).value;
        return a.kind === "constant" ? a.value : r.programConfigurations.get(e.id).getMaxValue(i);
      }
      function gl(i) {
        return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
      }
      function Gl(i, e, r, a, h) {
        if (!e[0] && !e[1]) return i;
        const d = q.convert(e)._mult(h);
        r === "viewport" && d._rotate(-a);
        const y = [];
        for (let S = 0; S < i.length; S++) y.push(i[S].sub(d));
        return y;
      }
      let ph, hc;
      Rt("CircleBucket", vo, { omit: ["layers"] });
      var Nc = { get paint() {
        return hc = hc || new c({ "circle-radius": new ni(te.paint_circle["circle-radius"]), "circle-color": new ni(te.paint_circle["circle-color"]), "circle-blur": new ni(te.paint_circle["circle-blur"]), "circle-opacity": new ni(te.paint_circle["circle-opacity"]), "circle-translate": new Vt(te.paint_circle["circle-translate"]), "circle-translate-anchor": new Vt(te.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Vt(te.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Vt(te.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ni(te.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ni(te.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ni(te.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return ph = ph || new c({ "circle-sort-key": new ni(te.layout_circle["circle-sort-key"]) });
      } }, Un = 1e-6, uc = typeof Float32Array < "u" ? Float32Array : Array;
      function Gh(i) {
        return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }
      function ed(i, e, r) {
        var a = e[0], h = e[1], d = e[2], y = e[3], S = e[4], k = e[5], M = e[6], F = e[7], O = e[8], $ = e[9], Y = e[10], ee = e[11], re = e[12], me = e[13], be = e[14], Re = e[15], Pe = r[0], ze = r[1], Xe = r[2], mt = r[3];
        return i[0] = Pe * a + ze * S + Xe * O + mt * re, i[1] = Pe * h + ze * k + Xe * $ + mt * me, i[2] = Pe * d + ze * M + Xe * Y + mt * be, i[3] = Pe * y + ze * F + Xe * ee + mt * Re, i[4] = (Pe = r[4]) * a + (ze = r[5]) * S + (Xe = r[6]) * O + (mt = r[7]) * re, i[5] = Pe * h + ze * k + Xe * $ + mt * me, i[6] = Pe * d + ze * M + Xe * Y + mt * be, i[7] = Pe * y + ze * F + Xe * ee + mt * Re, i[8] = (Pe = r[8]) * a + (ze = r[9]) * S + (Xe = r[10]) * O + (mt = r[11]) * re, i[9] = Pe * h + ze * k + Xe * $ + mt * me, i[10] = Pe * d + ze * M + Xe * Y + mt * be, i[11] = Pe * y + ze * F + Xe * ee + mt * Re, i[12] = (Pe = r[12]) * a + (ze = r[13]) * S + (Xe = r[14]) * O + (mt = r[15]) * re, i[13] = Pe * h + ze * k + Xe * $ + mt * me, i[14] = Pe * d + ze * M + Xe * Y + mt * be, i[15] = Pe * y + ze * F + Xe * ee + mt * Re, i;
      }
      Math.hypot || (Math.hypot = function() {
        for (var i = 0, e = arguments.length; e--; ) i += arguments[e] * arguments[e];
        return Math.sqrt(i);
      });
      var Rc, gf = ed;
      function fh(i, e, r) {
        var a = e[0], h = e[1], d = e[2], y = e[3];
        return i[0] = r[0] * a + r[4] * h + r[8] * d + r[12] * y, i[1] = r[1] * a + r[5] * h + r[9] * d + r[13] * y, i[2] = r[2] * a + r[6] * h + r[10] * d + r[14] * y, i[3] = r[3] * a + r[7] * h + r[11] * d + r[15] * y, i;
      }
      Rc = new uc(4), uc != Float32Array && (Rc[0] = 0, Rc[1] = 0, Rc[2] = 0, Rc[3] = 0);
      class yf extends m {
        constructor(e) {
          super(e, Nc);
        }
        createBucket(e) {
          return new vo(e);
        }
        queryRadius(e) {
          const r = e;
          return bo("circle-radius", this, r) + bo("circle-stroke-width", this, r) + gl(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(e, r, a, h, d, y, S, k) {
          const M = Gl(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), y.angle, S), F = this.paint.get("circle-radius").evaluate(r, a) + this.paint.get("circle-stroke-width").evaluate(r, a), O = this.paint.get("circle-pitch-alignment") === "map", $ = O ? M : function(ee, re) {
            return ee.map((me) => td(me, re));
          }(M, k), Y = O ? F * S : F;
          for (const ee of h) for (const re of ee) {
            const me = O ? re : td(re, k);
            let be = Y;
            const Re = fh([], [re.x, re.y, 0, 1], k);
            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? be *= Re[3] / y.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (be *= y.cameraToCenterDistance / Re[3]), hh($, me, be)) return !0;
          }
          return !1;
        }
      }
      function td(i, e) {
        const r = fh([], [i.x, i.y, 0, 1], e);
        return new q(r[0] / r[3], r[1] / r[3]);
      }
      class id extends vo {
      }
      let rd;
      Rt("HeatmapBucket", id, { omit: ["layers"] });
      var _f = { get paint() {
        return rd = rd || new c({ "heatmap-radius": new ni(te.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ni(te.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Vt(te.paint_heatmap["heatmap-intensity"]), "heatmap-color": new n(te.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Vt(te.paint_heatmap["heatmap-opacity"]) });
      } };
      function Hh(i, { width: e, height: r }, a, h) {
        if (h) {
          if (h instanceof Uint8ClampedArray) h = new Uint8Array(h.buffer);
          else if (h.length !== e * r * a) throw new RangeError(`mismatched image size. expected: ${h.length} but got: ${e * r * a}`);
        } else h = new Uint8Array(e * r * a);
        return i.width = e, i.height = r, i.data = h, i;
      }
      function nd(i, { width: e, height: r }, a) {
        if (e === i.width && r === i.height) return;
        const h = Hh({}, { width: e, height: r }, a);
        Xh(i, h, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(i.width, e), height: Math.min(i.height, r) }, a), i.width = e, i.height = r, i.data = h.data;
      }
      function Xh(i, e, r, a, h, d) {
        if (h.width === 0 || h.height === 0) return e;
        if (h.width > i.width || h.height > i.height || r.x > i.width - h.width || r.y > i.height - h.height) throw new RangeError("out of range source coordinates for image copy");
        if (h.width > e.width || h.height > e.height || a.x > e.width - h.width || a.y > e.height - h.height) throw new RangeError("out of range destination coordinates for image copy");
        const y = i.data, S = e.data;
        if (y === S) throw new Error("srcData equals dstData, so image is already copied");
        for (let k = 0; k < h.height; k++) {
          const M = ((r.y + k) * i.width + r.x) * d, F = ((a.y + k) * e.width + a.x) * d;
          for (let O = 0; O < h.width * d; O++) S[F + O] = y[M + O];
        }
        return e;
      }
      class Bc {
        constructor(e, r) {
          Hh(this, e, 1, r);
        }
        resize(e) {
          nd(this, e, 1);
        }
        clone() {
          return new Bc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, r, a, h, d) {
          Xh(e, r, a, h, d, 1);
        }
      }
      class Xs {
        constructor(e, r) {
          Hh(this, e, 4, r);
        }
        resize(e) {
          nd(this, e, 4);
        }
        replace(e, r) {
          r ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
        }
        clone() {
          return new Xs({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, r, a, h, d) {
          Xh(e, r, a, h, d, 4);
        }
      }
      function sd(i) {
        const e = {}, r = i.resolution || 256, a = i.clips ? i.clips.length : 1, h = i.image || new Xs({ width: r, height: a });
        if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`);
        const d = (y, S, k) => {
          e[i.evaluationKey] = k;
          const M = i.expression.evaluate(e);
          h.data[y + S + 0] = Math.floor(255 * M.r / M.a), h.data[y + S + 1] = Math.floor(255 * M.g / M.a), h.data[y + S + 2] = Math.floor(255 * M.b / M.a), h.data[y + S + 3] = Math.floor(255 * M.a);
        };
        if (i.clips) for (let y = 0, S = 0; y < a; ++y, S += 4 * r) for (let k = 0, M = 0; k < r; k++, M += 4) {
          const F = k / (r - 1), { start: O, end: $ } = i.clips[y];
          d(S, M, O * (1 - F) + $ * F);
        }
        else for (let y = 0, S = 0; y < r; y++, S += 4) d(0, S, y / (r - 1));
        return h;
      }
      Rt("AlphaImage", Bc), Rt("RGBAImage", Xs);
      class vf extends m {
        createBucket(e) {
          return new id(e);
        }
        constructor(e) {
          super(e, _f), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(e) {
          e === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = sd({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let ad;
      var xf = { get paint() {
        return ad = ad || new c({ "hillshade-illumination-direction": new Vt(te.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Vt(te.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Vt(te.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Vt(te.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Vt(te.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Vt(te.paint_hillshade["hillshade-accent-color"]) });
      } };
      class bf extends m {
        constructor(e) {
          super(e, xf);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const wf = p([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Sf } = wf;
      var Yh = { exports: {} };
      function mh(i, e, r) {
        r = r || 2;
        var a, h, d, y, S, k, M, F = e && e.length, O = F ? e[0] * r : i.length, $ = od(i, 0, O, r, !0), Y = [];
        if (!$ || $.next === $.prev) return Y;
        if (F && ($ = function(re, me, be, Re) {
          var Pe, ze, Xe, mt = [];
          for (Pe = 0, ze = me.length; Pe < ze; Pe++) (Xe = od(re, me[Pe] * Re, Pe < ze - 1 ? me[Pe + 1] * Re : re.length, Re, !1)) === Xe.next && (Xe.steiner = !0), mt.push(Ef(Xe));
          for (mt.sort(kf), Pe = 0; Pe < mt.length; Pe++) be = Lf(mt[Pe], be);
          return be;
        }(i, e, $, r)), i.length > 80 * r) {
          a = d = i[0], h = y = i[1];
          for (var ee = r; ee < O; ee += r) (S = i[ee]) < a && (a = S), (k = i[ee + 1]) < h && (h = k), S > d && (d = S), k > y && (y = k);
          M = (M = Math.max(d - a, y - h)) !== 0 ? 32767 / M : 0;
        }
        return Oc($, Y, r, a, h, M, 0), Y;
      }
      function od(i, e, r, a, h) {
        var d, y;
        if (h === Qh(i, e, r, a) > 0) for (d = e; d < r; d += a) y = hd(d, i[d], i[d + 1], y);
        else for (d = r - a; d >= e; d -= a) y = hd(d, i[d], i[d + 1], y);
        return y && gh(y, y.next) && (qc(y), y = y.next), y;
      }
      function Hl(i, e) {
        if (!i) return i;
        e || (e = i);
        var r, a = i;
        do
          if (r = !1, a.steiner || !gh(a, a.next) && Fr(a.prev, a, a.next) !== 0) a = a.next;
          else {
            if (qc(a), (a = e = a.prev) === a.next) break;
            r = !0;
          }
        while (r || a !== e);
        return e;
      }
      function Oc(i, e, r, a, h, d, y) {
        if (i) {
          !y && d && function(F, O, $, Y) {
            var ee = F;
            do
              ee.z === 0 && (ee.z = Jh(ee.x, ee.y, O, $, Y)), ee.prevZ = ee.prev, ee.nextZ = ee.next, ee = ee.next;
            while (ee !== F);
            ee.prevZ.nextZ = null, ee.prevZ = null, function(re) {
              var me, be, Re, Pe, ze, Xe, mt, At, Kt = 1;
              do {
                for (be = re, re = null, ze = null, Xe = 0; be; ) {
                  for (Xe++, Re = be, mt = 0, me = 0; me < Kt && (mt++, Re = Re.nextZ); me++) ;
                  for (At = Kt; mt > 0 || At > 0 && Re; ) mt !== 0 && (At === 0 || !Re || be.z <= Re.z) ? (Pe = be, be = be.nextZ, mt--) : (Pe = Re, Re = Re.nextZ, At--), ze ? ze.nextZ = Pe : re = Pe, Pe.prevZ = ze, ze = Pe;
                  be = Re;
                }
                ze.nextZ = null, Kt *= 2;
              } while (Xe > 1);
            }(ee);
          }(i, a, h, d);
          for (var S, k, M = i; i.prev !== i.next; ) if (S = i.prev, k = i.next, d ? Pf(i, a, h, d) : Af(i)) e.push(S.i / r | 0), e.push(i.i / r | 0), e.push(k.i / r | 0), qc(i), i = k.next, M = k.next;
          else if ((i = k) === M) {
            y ? y === 1 ? Oc(i = If(Hl(i), e, r), e, r, a, h, d, 2) : y === 2 && Tf(i, e, r, a, h, d) : Oc(Hl(i), e, r, a, h, d, 1);
            break;
          }
        }
      }
      function Af(i) {
        var e = i.prev, r = i, a = i.next;
        if (Fr(e, r, a) >= 0) return !1;
        for (var h = e.x, d = r.x, y = a.x, S = e.y, k = r.y, M = a.y, F = h < d ? h < y ? h : y : d < y ? d : y, O = S < k ? S < M ? S : M : k < M ? k : M, $ = h > d ? h > y ? h : y : d > y ? d : y, Y = S > k ? S > M ? S : M : k > M ? k : M, ee = a.next; ee !== e; ) {
          if (ee.x >= F && ee.x <= $ && ee.y >= O && ee.y <= Y && dc(h, S, d, k, y, M, ee.x, ee.y) && Fr(ee.prev, ee, ee.next) >= 0) return !1;
          ee = ee.next;
        }
        return !0;
      }
      function Pf(i, e, r, a) {
        var h = i.prev, d = i, y = i.next;
        if (Fr(h, d, y) >= 0) return !1;
        for (var S = h.x, k = d.x, M = y.x, F = h.y, O = d.y, $ = y.y, Y = S < k ? S < M ? S : M : k < M ? k : M, ee = F < O ? F < $ ? F : $ : O < $ ? O : $, re = S > k ? S > M ? S : M : k > M ? k : M, me = F > O ? F > $ ? F : $ : O > $ ? O : $, be = Jh(Y, ee, e, r, a), Re = Jh(re, me, e, r, a), Pe = i.prevZ, ze = i.nextZ; Pe && Pe.z >= be && ze && ze.z <= Re; ) {
          if (Pe.x >= Y && Pe.x <= re && Pe.y >= ee && Pe.y <= me && Pe !== h && Pe !== y && dc(S, F, k, O, M, $, Pe.x, Pe.y) && Fr(Pe.prev, Pe, Pe.next) >= 0 || (Pe = Pe.prevZ, ze.x >= Y && ze.x <= re && ze.y >= ee && ze.y <= me && ze !== h && ze !== y && dc(S, F, k, O, M, $, ze.x, ze.y) && Fr(ze.prev, ze, ze.next) >= 0)) return !1;
          ze = ze.nextZ;
        }
        for (; Pe && Pe.z >= be; ) {
          if (Pe.x >= Y && Pe.x <= re && Pe.y >= ee && Pe.y <= me && Pe !== h && Pe !== y && dc(S, F, k, O, M, $, Pe.x, Pe.y) && Fr(Pe.prev, Pe, Pe.next) >= 0) return !1;
          Pe = Pe.prevZ;
        }
        for (; ze && ze.z <= Re; ) {
          if (ze.x >= Y && ze.x <= re && ze.y >= ee && ze.y <= me && ze !== h && ze !== y && dc(S, F, k, O, M, $, ze.x, ze.y) && Fr(ze.prev, ze, ze.next) >= 0) return !1;
          ze = ze.nextZ;
        }
        return !0;
      }
      function If(i, e, r) {
        var a = i;
        do {
          var h = a.prev, d = a.next.next;
          !gh(h, d) && ld(h, a, a.next, d) && jc(h, d) && jc(d, h) && (e.push(h.i / r | 0), e.push(a.i / r | 0), e.push(d.i / r | 0), qc(a), qc(a.next), a = i = d), a = a.next;
        } while (a !== i);
        return Hl(a);
      }
      function Tf(i, e, r, a, h, d) {
        var y = i;
        do {
          for (var S = y.next.next; S !== y.prev; ) {
            if (y.i !== S.i && Mf(y, S)) {
              var k = cd(y, S);
              return y = Hl(y, y.next), k = Hl(k, k.next), Oc(y, e, r, a, h, d, 0), void Oc(k, e, r, a, h, d, 0);
            }
            S = S.next;
          }
          y = y.next;
        } while (y !== i);
      }
      function kf(i, e) {
        return i.x - e.x;
      }
      function Lf(i, e) {
        var r = function(h, d) {
          var y, S = d, k = h.x, M = h.y, F = -1 / 0;
          do {
            if (M <= S.y && M >= S.next.y && S.next.y !== S.y) {
              var O = S.x + (M - S.y) * (S.next.x - S.x) / (S.next.y - S.y);
              if (O <= k && O > F && (F = O, y = S.x < S.next.x ? S : S.next, O === k)) return y;
            }
            S = S.next;
          } while (S !== d);
          if (!y) return null;
          var $, Y = y, ee = y.x, re = y.y, me = 1 / 0;
          S = y;
          do
            k >= S.x && S.x >= ee && k !== S.x && dc(M < re ? k : F, M, ee, re, M < re ? F : k, M, S.x, S.y) && ($ = Math.abs(M - S.y) / (k - S.x), jc(S, h) && ($ < me || $ === me && (S.x > y.x || S.x === y.x && Cf(y, S))) && (y = S, me = $)), S = S.next;
          while (S !== Y);
          return y;
        }(i, e);
        if (!r) return e;
        var a = cd(r, i);
        return Hl(a, a.next), Hl(r, r.next);
      }
      function Cf(i, e) {
        return Fr(i.prev, i, e.prev) < 0 && Fr(e.next, i, i.next) < 0;
      }
      function Jh(i, e, r, a, h) {
        return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - r) * h | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - a) * h | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
      }
      function Ef(i) {
        var e = i, r = i;
        do
          (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
        while (e !== i);
        return r;
      }
      function dc(i, e, r, a, h, d, y, S) {
        return (h - y) * (e - S) >= (i - y) * (d - S) && (i - y) * (a - S) >= (r - y) * (e - S) && (r - y) * (d - S) >= (h - y) * (a - S);
      }
      function Mf(i, e) {
        return i.next.i !== e.i && i.prev.i !== e.i && !function(r, a) {
          var h = r;
          do {
            if (h.i !== r.i && h.next.i !== r.i && h.i !== a.i && h.next.i !== a.i && ld(h, h.next, r, a)) return !0;
            h = h.next;
          } while (h !== r);
          return !1;
        }(i, e) && (jc(i, e) && jc(e, i) && function(r, a) {
          var h = r, d = !1, y = (r.x + a.x) / 2, S = (r.y + a.y) / 2;
          do
            h.y > S != h.next.y > S && h.next.y !== h.y && y < (h.next.x - h.x) * (S - h.y) / (h.next.y - h.y) + h.x && (d = !d), h = h.next;
          while (h !== r);
          return d;
        }(i, e) && (Fr(i.prev, i, e.prev) || Fr(i, e.prev, e)) || gh(i, e) && Fr(i.prev, i, i.next) > 0 && Fr(e.prev, e, e.next) > 0);
      }
      function Fr(i, e, r) {
        return (e.y - i.y) * (r.x - e.x) - (e.x - i.x) * (r.y - e.y);
      }
      function gh(i, e) {
        return i.x === e.x && i.y === e.y;
      }
      function ld(i, e, r, a) {
        var h = _h(Fr(i, e, r)), d = _h(Fr(i, e, a)), y = _h(Fr(r, a, i)), S = _h(Fr(r, a, e));
        return h !== d && y !== S || !(h !== 0 || !yh(i, r, e)) || !(d !== 0 || !yh(i, a, e)) || !(y !== 0 || !yh(r, i, a)) || !(S !== 0 || !yh(r, e, a));
      }
      function yh(i, e, r) {
        return e.x <= Math.max(i.x, r.x) && e.x >= Math.min(i.x, r.x) && e.y <= Math.max(i.y, r.y) && e.y >= Math.min(i.y, r.y);
      }
      function _h(i) {
        return i > 0 ? 1 : i < 0 ? -1 : 0;
      }
      function jc(i, e) {
        return Fr(i.prev, i, i.next) < 0 ? Fr(i, e, i.next) >= 0 && Fr(i, i.prev, e) >= 0 : Fr(i, e, i.prev) < 0 || Fr(i, i.next, e) < 0;
      }
      function cd(i, e) {
        var r = new Kh(i.i, i.x, i.y), a = new Kh(e.i, e.x, e.y), h = i.next, d = e.prev;
        return i.next = e, e.prev = i, r.next = h, h.prev = r, a.next = r, r.prev = a, d.next = a, a.prev = d, a;
      }
      function hd(i, e, r, a) {
        var h = new Kh(i, e, r);
        return a ? (h.next = a.next, h.prev = a, a.next.prev = h, a.next = h) : (h.prev = h, h.next = h), h;
      }
      function qc(i) {
        i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
      }
      function Kh(i, e, r) {
        this.i = i, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
      }
      function Qh(i, e, r, a) {
        for (var h = 0, d = e, y = r - a; d < r; d += a) h += (i[y] - i[d]) * (i[d + 1] + i[y + 1]), y = d;
        return h;
      }
      Yh.exports = mh, Yh.exports.default = mh, mh.deviation = function(i, e, r, a) {
        var h = e && e.length, d = Math.abs(Qh(i, 0, h ? e[0] * r : i.length, r));
        if (h) for (var y = 0, S = e.length; y < S; y++) d -= Math.abs(Qh(i, e[y] * r, y < S - 1 ? e[y + 1] * r : i.length, r));
        var k = 0;
        for (y = 0; y < a.length; y += 3) {
          var M = a[y] * r, F = a[y + 1] * r, O = a[y + 2] * r;
          k += Math.abs((i[M] - i[O]) * (i[F + 1] - i[M + 1]) - (i[M] - i[F]) * (i[O + 1] - i[M + 1]));
        }
        return d === 0 && k === 0 ? 0 : Math.abs((k - d) / d);
      }, mh.flatten = function(i) {
        for (var e = i[0][0].length, r = { vertices: [], holes: [], dimensions: e }, a = 0, h = 0; h < i.length; h++) {
          for (var d = 0; d < i[h].length; d++) for (var y = 0; y < e; y++) r.vertices.push(i[h][d][y]);
          h > 0 && r.holes.push(a += i[h - 1].length);
        }
        return r;
      };
      var ud = D(Yh.exports);
      function eu(i, e, r) {
        const a = r.patternDependencies;
        let h = !1;
        for (const d of e) {
          const y = d.paint.get(`${i}-pattern`);
          y.isConstant() || (h = !0);
          const S = y.constantOr(null);
          S && (h = !0, a[S.to] = !0, a[S.from] = !0);
        }
        return h;
      }
      function tu(i, e, r, a, h) {
        const d = h.patternDependencies;
        for (const y of e) {
          const S = y.paint.get(`${i}-pattern`).value;
          if (S.kind !== "constant") {
            let k = S.evaluate({ zoom: a - 1 }, r, {}, h.availableImages), M = S.evaluate({ zoom: a }, r, {}, h.availableImages), F = S.evaluate({ zoom: a + 1 }, r, {}, h.availableImages);
            k = k && k.name ? k.name : k, M = M && M.name ? M.name : M, F = F && F.name ? F.name : F, d[k] = !0, d[M] = !0, d[F] = !0, r.patterns[y.id] = { min: k, mid: M, max: F };
          }
        }
        return r;
      }
      class iu {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((r) => r.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new kr(), this.indexArray = new zr(), this.indexArray2 = new sr(), this.programConfigurations = new Wo(e.layers, e.zoom), this.segments = new vr(), this.segments2 = new vr(), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id);
        }
        populate(e, r, a) {
          this.hasPattern = eu("fill", this.layers, r);
          const h = this.layers[0].layout.get("fill-sort-key"), d = !h.isConstant(), y = [];
          for (const { feature: S, id: k, index: M, sourceLayerIndex: F } of e) {
            const O = this.layers[0]._featureFilter.needGeometry, $ = Go(S, O);
            if (!this.layers[0]._featureFilter.filter(new ji(this.zoom), $, a)) continue;
            const Y = d ? h.evaluate($, {}, a, r.availableImages) : void 0, ee = { id: k, properties: S.properties, type: S.type, sourceLayerIndex: F, index: M, geometry: O ? $.geometry : _o(S), patterns: {}, sortKey: Y };
            y.push(ee);
          }
          d && y.sort((S, k) => S.sortKey - k.sortKey);
          for (const S of y) {
            const { geometry: k, index: M, sourceLayerIndex: F } = S;
            if (this.hasPattern) {
              const O = tu("fill", this.layers, S, this.zoom, r);
              this.patternFeatures.push(O);
            } else this.addFeature(S, k, M, a, {});
            r.featureIndex.insert(e[M].feature, k, M, F, this.index);
          }
        }
        update(e, r, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, a);
        }
        addFeatures(e, r, a) {
          for (const h of this.patternFeatures) this.addFeature(h, h.geometry, h.index, r, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Sf), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(e, r, a, h, d) {
          for (const y of ca(r, 500)) {
            let S = 0;
            for (const Y of y) S += Y.length;
            const k = this.segments.prepareSegment(S, this.layoutVertexArray, this.indexArray), M = k.vertexLength, F = [], O = [];
            for (const Y of y) {
              if (Y.length === 0) continue;
              Y !== y[0] && O.push(F.length / 2);
              const ee = this.segments2.prepareSegment(Y.length, this.layoutVertexArray, this.indexArray2), re = ee.vertexLength;
              this.layoutVertexArray.emplaceBack(Y[0].x, Y[0].y), this.indexArray2.emplaceBack(re + Y.length - 1, re), F.push(Y[0].x), F.push(Y[0].y);
              for (let me = 1; me < Y.length; me++) this.layoutVertexArray.emplaceBack(Y[me].x, Y[me].y), this.indexArray2.emplaceBack(re + me - 1, re + me), F.push(Y[me].x), F.push(Y[me].y);
              ee.vertexLength += Y.length, ee.primitiveLength += Y.length;
            }
            const $ = ud(F, O);
            for (let Y = 0; Y < $.length; Y += 3) this.indexArray.emplaceBack(M + $[Y], M + $[Y + 1], M + $[Y + 2]);
            k.vertexLength += S, k.primitiveLength += $.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, d, h);
        }
      }
      let dd, pd;
      Rt("FillBucket", iu, { omit: ["layers", "patternFeatures"] });
      var Df = { get paint() {
        return pd = pd || new c({ "fill-antialias": new Vt(te.paint_fill["fill-antialias"]), "fill-opacity": new ni(te.paint_fill["fill-opacity"]), "fill-color": new ni(te.paint_fill["fill-color"]), "fill-outline-color": new ni(te.paint_fill["fill-outline-color"]), "fill-translate": new Vt(te.paint_fill["fill-translate"]), "fill-translate-anchor": new Vt(te.paint_fill["fill-translate-anchor"]), "fill-pattern": new f(te.paint_fill["fill-pattern"]) });
      }, get layout() {
        return dd = dd || new c({ "fill-sort-key": new ni(te.layout_fill["fill-sort-key"]) });
      } };
      class zf extends m {
        constructor(e) {
          super(e, Df);
        }
        recalculate(e, r) {
          super.recalculate(e, r);
          const a = this.paint._values["fill-outline-color"];
          a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(e) {
          return new iu(e);
        }
        queryRadius() {
          return gl(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(e, r, a, h, d, y, S) {
          return uh(Gl(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), y.angle, S), h);
        }
        isTileClipped() {
          return !0;
        }
      }
      const Ff = p([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Nf = p([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Rf } = Ff;
      var yl = {}, Bf = j, fd = pc;
      function pc(i, e, r, a, h) {
        this.properties = {}, this.extent = r, this.type = 0, this._pbf = i, this._geometry = -1, this._keys = a, this._values = h, i.readFields(Of, this, e);
      }
      function Of(i, e, r) {
        i == 1 ? e.id = r.readVarint() : i == 2 ? function(a, h) {
          for (var d = a.readVarint() + a.pos; a.pos < d; ) {
            var y = h._keys[a.readVarint()], S = h._values[a.readVarint()];
            h.properties[y] = S;
          }
        }(r, e) : i == 3 ? e.type = r.readVarint() : i == 4 && (e._geometry = r.pos);
      }
      function jf(i) {
        for (var e, r, a = 0, h = 0, d = i.length, y = d - 1; h < d; y = h++) a += ((r = i[y]).x - (e = i[h]).x) * (e.y + r.y);
        return a;
      }
      pc.types = ["Unknown", "Point", "LineString", "Polygon"], pc.prototype.loadGeometry = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var e, r = i.readVarint() + i.pos, a = 1, h = 0, d = 0, y = 0, S = []; i.pos < r; ) {
          if (h <= 0) {
            var k = i.readVarint();
            a = 7 & k, h = k >> 3;
          }
          if (h--, a === 1 || a === 2) d += i.readSVarint(), y += i.readSVarint(), a === 1 && (e && S.push(e), e = []), e.push(new Bf(d, y));
          else {
            if (a !== 7) throw new Error("unknown command " + a);
            e && e.push(e[0].clone());
          }
        }
        return e && S.push(e), S;
      }, pc.prototype.bbox = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var e = i.readVarint() + i.pos, r = 1, a = 0, h = 0, d = 0, y = 1 / 0, S = -1 / 0, k = 1 / 0, M = -1 / 0; i.pos < e; ) {
          if (a <= 0) {
            var F = i.readVarint();
            r = 7 & F, a = F >> 3;
          }
          if (a--, r === 1 || r === 2) (h += i.readSVarint()) < y && (y = h), h > S && (S = h), (d += i.readSVarint()) < k && (k = d), d > M && (M = d);
          else if (r !== 7) throw new Error("unknown command " + r);
        }
        return [y, k, S, M];
      }, pc.prototype.toGeoJSON = function(i, e, r) {
        var a, h, d = this.extent * Math.pow(2, r), y = this.extent * i, S = this.extent * e, k = this.loadGeometry(), M = pc.types[this.type];
        function F(Y) {
          for (var ee = 0; ee < Y.length; ee++) {
            var re = Y[ee];
            Y[ee] = [360 * (re.x + y) / d - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (re.y + S) / d) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var O = [];
            for (a = 0; a < k.length; a++) O[a] = k[a][0];
            F(k = O);
            break;
          case 2:
            for (a = 0; a < k.length; a++) F(k[a]);
            break;
          case 3:
            for (k = function(Y) {
              var ee = Y.length;
              if (ee <= 1) return [Y];
              for (var re, me, be = [], Re = 0; Re < ee; Re++) {
                var Pe = jf(Y[Re]);
                Pe !== 0 && (me === void 0 && (me = Pe < 0), me === Pe < 0 ? (re && be.push(re), re = [Y[Re]]) : re.push(Y[Re]));
              }
              return re && be.push(re), be;
            }(k), a = 0; a < k.length; a++) for (h = 0; h < k[a].length; h++) F(k[a][h]);
        }
        k.length === 1 ? k = k[0] : M = "Multi" + M;
        var $ = { type: "Feature", geometry: { type: M, coordinates: k }, properties: this.properties };
        return "id" in this && ($.id = this.id), $;
      };
      var qf = fd, md = gd;
      function gd(i, e) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = i, this._keys = [], this._values = [], this._features = [], i.readFields(Uf, this, e), this.length = this._features.length;
      }
      function Uf(i, e, r) {
        i === 15 ? e.version = r.readVarint() : i === 1 ? e.name = r.readString() : i === 5 ? e.extent = r.readVarint() : i === 2 ? e._features.push(r.pos) : i === 3 ? e._keys.push(r.readString()) : i === 4 && e._values.push(function(a) {
          for (var h = null, d = a.readVarint() + a.pos; a.pos < d; ) {
            var y = a.readVarint() >> 3;
            h = y === 1 ? a.readString() : y === 2 ? a.readFloat() : y === 3 ? a.readDouble() : y === 4 ? a.readVarint64() : y === 5 ? a.readVarint() : y === 6 ? a.readSVarint() : y === 7 ? a.readBoolean() : null;
          }
          return h;
        }(r));
      }
      gd.prototype.feature = function(i) {
        if (i < 0 || i >= this._features.length) throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[i];
        var e = this._pbf.readVarint() + this._pbf.pos;
        return new qf(this._pbf, e, this.extent, this._keys, this._values);
      };
      var Vf = md;
      function $f(i, e, r) {
        if (i === 3) {
          var a = new Vf(r, r.readVarint() + r.pos);
          a.length && (e[a.name] = a);
        }
      }
      yl.VectorTile = function(i, e) {
        this.layers = i.readFields($f, {}, e);
      }, yl.VectorTileFeature = fd, yl.VectorTileLayer = md;
      const Zf = yl.VectorTileFeature.types, ru = Math.pow(2, 13);
      function Uc(i, e, r, a, h, d, y, S) {
        i.emplaceBack(e, r, 2 * Math.floor(a * ru) + y, h * ru * 2, d * ru * 2, Math.round(S));
      }
      class nu {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((r) => r.id), this.index = e.index, this.hasPattern = !1, this.layoutVertexArray = new qr(), this.centroidVertexArray = new ur(), this.indexArray = new zr(), this.programConfigurations = new Wo(e.layers, e.zoom), this.segments = new vr(), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id);
        }
        populate(e, r, a) {
          this.features = [], this.hasPattern = eu("fill-extrusion", this.layers, r);
          for (const { feature: h, id: d, index: y, sourceLayerIndex: S } of e) {
            const k = this.layers[0]._featureFilter.needGeometry, M = Go(h, k);
            if (!this.layers[0]._featureFilter.filter(new ji(this.zoom), M, a)) continue;
            const F = { id: d, sourceLayerIndex: S, index: y, geometry: k ? M.geometry : _o(h), properties: h.properties, type: h.type, patterns: {} };
            this.hasPattern ? this.features.push(tu("fill-extrusion", this.layers, F, this.zoom, r)) : this.addFeature(F, F.geometry, y, a, {}), r.featureIndex.insert(h, F.geometry, y, S, this.index, !0);
          }
        }
        addFeatures(e, r, a) {
          for (const h of this.features) {
            const { geometry: d } = h;
            this.addFeature(h, d, h.index, r, a);
          }
        }
        update(e, r, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Rf), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Nf.members, !0), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(e, r, a, h, d) {
          for (const y of ca(r, 500)) {
            const S = { x: 0, y: 0, vertexCount: 0 };
            let k = 0;
            for (const ee of y) k += ee.length;
            let M = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const ee of y) {
              if (ee.length === 0 || Gf(ee)) continue;
              let re = 0;
              for (let me = 0; me < ee.length; me++) {
                const be = ee[me];
                if (me >= 1) {
                  const Re = ee[me - 1];
                  if (!Wf(be, Re)) {
                    M.vertexLength + 4 > vr.MAX_VERTEX_ARRAY_LENGTH && (M = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const Pe = be.sub(Re)._perp()._unit(), ze = Re.dist(be);
                    re + ze > 32768 && (re = 0), Uc(this.layoutVertexArray, be.x, be.y, Pe.x, Pe.y, 0, 0, re), Uc(this.layoutVertexArray, be.x, be.y, Pe.x, Pe.y, 0, 1, re), S.x += 2 * be.x, S.y += 2 * be.y, S.vertexCount += 2, re += ze, Uc(this.layoutVertexArray, Re.x, Re.y, Pe.x, Pe.y, 0, 0, re), Uc(this.layoutVertexArray, Re.x, Re.y, Pe.x, Pe.y, 0, 1, re), S.x += 2 * Re.x, S.y += 2 * Re.y, S.vertexCount += 2;
                    const Xe = M.vertexLength;
                    this.indexArray.emplaceBack(Xe, Xe + 2, Xe + 1), this.indexArray.emplaceBack(Xe + 1, Xe + 2, Xe + 3), M.vertexLength += 4, M.primitiveLength += 2;
                  }
                }
              }
            }
            if (M.vertexLength + k > vr.MAX_VERTEX_ARRAY_LENGTH && (M = this.segments.prepareSegment(k, this.layoutVertexArray, this.indexArray)), Zf[e.type] !== "Polygon") continue;
            const F = [], O = [], $ = M.vertexLength;
            for (const ee of y) if (ee.length !== 0) {
              ee !== y[0] && O.push(F.length / 2);
              for (let re = 0; re < ee.length; re++) {
                const me = ee[re];
                Uc(this.layoutVertexArray, me.x, me.y, 0, 0, 1, 1, 0), S.x += me.x, S.y += me.y, S.vertexCount += 1, F.push(me.x), F.push(me.y);
              }
            }
            const Y = ud(F, O);
            for (let ee = 0; ee < Y.length; ee += 3) this.indexArray.emplaceBack($ + Y[ee], $ + Y[ee + 2], $ + Y[ee + 1]);
            M.primitiveLength += Y.length / 3, M.vertexLength += k;
            for (let ee = 0; ee < S.vertexCount; ee++) {
              const re = Math.floor(S.x / S.vertexCount), me = Math.floor(S.y / S.vertexCount);
              this.centroidVertexArray.emplaceBack(re, me);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, d, h);
        }
      }
      function Wf(i, e) {
        return i.x === e.x && (i.x < 0 || i.x > xr) || i.y === e.y && (i.y < 0 || i.y > xr);
      }
      function Gf(i) {
        return i.every((e) => e.x < 0) || i.every((e) => e.x > xr) || i.every((e) => e.y < 0) || i.every((e) => e.y > xr);
      }
      let yd;
      Rt("FillExtrusionBucket", nu, { omit: ["layers", "features"] });
      var Hf = { get paint() {
        return yd = yd || new c({ "fill-extrusion-opacity": new Vt(te["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ni(te["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Vt(te["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Vt(te["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new f(te["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ni(te["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ni(te["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Vt(te["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class Xf extends m {
        constructor(e) {
          super(e, Hf);
        }
        createBucket(e) {
          return new nu(e);
        }
        queryRadius() {
          return gl(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(e, r, a, h, d, y, S, k) {
          const M = Gl(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), y.angle, S), F = this.paint.get("fill-extrusion-height").evaluate(r, a), O = this.paint.get("fill-extrusion-base").evaluate(r, a), $ = function(ee, re, me, be) {
            const Re = [];
            for (const Pe of ee) {
              const ze = [Pe.x, Pe.y, 0, 1];
              fh(ze, ze, re), Re.push(new q(ze[0] / ze[3], ze[1] / ze[3]));
            }
            return Re;
          }(M, k), Y = function(ee, re, me, be) {
            const Re = [], Pe = [], ze = be[8] * re, Xe = be[9] * re, mt = be[10] * re, At = be[11] * re, Kt = be[8] * me, Et = be[9] * me, St = be[10] * me, Gt = be[11] * me;
            for (const qt of ee) {
              const Ot = [], ht = [];
              for (const Xt of qt) {
                const $t = Xt.x, di = Xt.y, Qi = be[0] * $t + be[4] * di + be[12], Yi = be[1] * $t + be[5] * di + be[13], tn = be[2] * $t + be[6] * di + be[14], Pa = be[3] * $t + be[7] * di + be[15], _n = tn + mt, Cr = Pa + At, Vn = Qi + Kt, $n = Yi + Et, Zn = tn + St, Er = Pa + Gt, rn = new q((Qi + ze) / Cr, (Yi + Xe) / Cr);
                rn.z = _n / Cr, Ot.push(rn);
                const Ln = new q(Vn / Er, $n / Er);
                Ln.z = Zn / Er, ht.push(Ln);
              }
              Re.push(Ot), Pe.push(ht);
            }
            return [Re, Pe];
          }(h, O, F, k);
          return function(ee, re, me) {
            let be = 1 / 0;
            uh(me, re) && (be = _d(me, re[0]));
            for (let Re = 0; Re < re.length; Re++) {
              const Pe = re[Re], ze = ee[Re];
              for (let Xe = 0; Xe < Pe.length - 1; Xe++) {
                const mt = Pe[Xe], At = [mt, Pe[Xe + 1], ze[Xe + 1], ze[Xe], mt];
                ch(me, At) && (be = Math.min(be, _d(me, At)));
              }
            }
            return be !== 1 / 0 && be;
          }(Y[0], Y[1], $);
        }
      }
      function Vc(i, e) {
        return i.x * e.x + i.y * e.y;
      }
      function _d(i, e) {
        if (i.length === 1) {
          let r = 0;
          const a = e[r++];
          let h;
          for (; !h || a.equals(h); ) if (h = e[r++], !h) return 1 / 0;
          for (; r < e.length; r++) {
            const d = e[r], y = i[0], S = h.sub(a), k = d.sub(a), M = y.sub(a), F = Vc(S, S), O = Vc(S, k), $ = Vc(k, k), Y = Vc(M, S), ee = Vc(M, k), re = F * $ - O * O, me = ($ * Y - O * ee) / re, be = (F * ee - O * Y) / re, Re = a.z * (1 - me - be) + h.z * me + d.z * be;
            if (isFinite(Re)) return Re;
          }
          return 1 / 0;
        }
        {
          let r = 1 / 0;
          for (const a of e) r = Math.min(r, a.z);
          return r;
        }
      }
      const Yf = p([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Jf } = Yf, Kf = p([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Qf } = Kf, em = yl.VectorTileFeature.types, tm = Math.cos(Math.PI / 180 * 37.5), vd = Math.pow(2, 14) / 0.5;
      class su {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((r) => r.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r) => {
            this.gradients[r.id] = {};
          }), this.layoutVertexArray = new In(), this.layoutVertexArray2 = new Lr(), this.indexArray = new zr(), this.programConfigurations = new Wo(e.layers, e.zoom), this.segments = new vr(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id);
        }
        populate(e, r, a) {
          this.hasPattern = eu("line", this.layers, r);
          const h = this.layers[0].layout.get("line-sort-key"), d = !h.isConstant(), y = [];
          for (const { feature: S, id: k, index: M, sourceLayerIndex: F } of e) {
            const O = this.layers[0]._featureFilter.needGeometry, $ = Go(S, O);
            if (!this.layers[0]._featureFilter.filter(new ji(this.zoom), $, a)) continue;
            const Y = d ? h.evaluate($, {}, a) : void 0, ee = { id: k, properties: S.properties, type: S.type, sourceLayerIndex: F, index: M, geometry: O ? $.geometry : _o(S), patterns: {}, sortKey: Y };
            y.push(ee);
          }
          d && y.sort((S, k) => S.sortKey - k.sortKey);
          for (const S of y) {
            const { geometry: k, index: M, sourceLayerIndex: F } = S;
            if (this.hasPattern) {
              const O = tu("line", this.layers, S, this.zoom, r);
              this.patternFeatures.push(O);
            } else this.addFeature(S, k, M, a, {});
            r.featureIndex.insert(e[M].feature, k, M, F, this.index);
          }
        }
        update(e, r, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, r, this.stateDependentLayers, a);
        }
        addFeatures(e, r, a) {
          for (const h of this.patternFeatures) this.addFeature(h, h.geometry, h.index, r, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, Qf)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Jf), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(e) {
          if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
        }
        addFeature(e, r, a, h, d) {
          const y = this.layers[0].layout, S = y.get("line-join").evaluate(e, {}), k = y.get("line-cap"), M = y.get("line-miter-limit"), F = y.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(e);
          for (const O of r) this.addLine(O, e, S, k, M, F);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, d, h);
        }
        addLine(e, r, a, h, d, y) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let be = 0; be < e.length - 1; be++) this.totalDistance += e[be].dist(e[be + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const S = em[r.type] === "Polygon";
          let k = e.length;
          for (; k >= 2 && e[k - 1].equals(e[k - 2]); ) k--;
          let M = 0;
          for (; M < k - 1 && e[M].equals(e[M + 1]); ) M++;
          if (k < (S ? 3 : 2)) return;
          a === "bevel" && (d = 1.05);
          const F = this.overscaling <= 16 ? 15 * xr / (512 * this.overscaling) : 0, O = this.segments.prepareSegment(10 * k, this.layoutVertexArray, this.indexArray);
          let $, Y, ee, re, me;
          this.e1 = this.e2 = -1, S && ($ = e[k - 2], me = e[M].sub($)._unit()._perp());
          for (let be = M; be < k; be++) {
            if (ee = be === k - 1 ? S ? e[M + 1] : void 0 : e[be + 1], ee && e[be].equals(ee)) continue;
            me && (re = me), $ && (Y = $), $ = e[be], me = ee ? ee.sub($)._unit()._perp() : re, re = re || me;
            let Re = re.add(me);
            Re.x === 0 && Re.y === 0 || Re._unit();
            const Pe = re.x * me.x + re.y * me.y, ze = Re.x * me.x + Re.y * me.y, Xe = ze !== 0 ? 1 / ze : 1 / 0, mt = 2 * Math.sqrt(2 - 2 * ze), At = ze < tm && Y && ee, Kt = re.x * me.y - re.y * me.x > 0;
            if (At && be > M) {
              const Gt = $.dist(Y);
              if (Gt > 2 * F) {
                const qt = $.sub($.sub(Y)._mult(F / Gt)._round());
                this.updateDistance(Y, qt), this.addCurrentVertex(qt, re, 0, 0, O), Y = qt;
              }
            }
            const Et = Y && ee;
            let St = Et ? a : S ? "butt" : h;
            if (Et && St === "round" && (Xe < y ? St = "miter" : Xe <= 2 && (St = "fakeround")), St === "miter" && Xe > d && (St = "bevel"), St === "bevel" && (Xe > 2 && (St = "flipbevel"), Xe < d && (St = "miter")), Y && this.updateDistance(Y, $), St === "miter") Re._mult(Xe), this.addCurrentVertex($, Re, 0, 0, O);
            else if (St === "flipbevel") {
              if (Xe > 100) Re = me.mult(-1);
              else {
                const Gt = Xe * re.add(me).mag() / re.sub(me).mag();
                Re._perp()._mult(Gt * (Kt ? -1 : 1));
              }
              this.addCurrentVertex($, Re, 0, 0, O), this.addCurrentVertex($, Re.mult(-1), 0, 0, O);
            } else if (St === "bevel" || St === "fakeround") {
              const Gt = -Math.sqrt(Xe * Xe - 1), qt = Kt ? Gt : 0, Ot = Kt ? 0 : Gt;
              if (Y && this.addCurrentVertex($, re, qt, Ot, O), St === "fakeround") {
                const ht = Math.round(180 * mt / Math.PI / 20);
                for (let Xt = 1; Xt < ht; Xt++) {
                  let $t = Xt / ht;
                  if ($t !== 0.5) {
                    const Qi = $t - 0.5;
                    $t += $t * Qi * ($t - 1) * ((1.0904 + Pe * (Pe * (3.55645 - 1.43519 * Pe) - 3.2452)) * Qi * Qi + (0.848013 + Pe * (0.215638 * Pe - 1.06021)));
                  }
                  const di = me.sub(re)._mult($t)._add(re)._unit()._mult(Kt ? -1 : 1);
                  this.addHalfVertex($, di.x, di.y, !1, Kt, 0, O);
                }
              }
              ee && this.addCurrentVertex($, me, -qt, -Ot, O);
            } else if (St === "butt") this.addCurrentVertex($, Re, 0, 0, O);
            else if (St === "square") {
              const Gt = Y ? 1 : -1;
              this.addCurrentVertex($, Re, Gt, Gt, O);
            } else St === "round" && (Y && (this.addCurrentVertex($, re, 0, 0, O), this.addCurrentVertex($, re, 1, 1, O, !0)), ee && (this.addCurrentVertex($, me, -1, -1, O, !0), this.addCurrentVertex($, me, 0, 0, O)));
            if (At && be < k - 1) {
              const Gt = $.dist(ee);
              if (Gt > 2 * F) {
                const qt = $.add(ee.sub($)._mult(F / Gt)._round());
                this.updateDistance($, qt), this.addCurrentVertex(qt, me, 0, 0, O), $ = qt;
              }
            }
          }
        }
        addCurrentVertex(e, r, a, h, d, y = !1) {
          const S = r.y * h - r.x, k = -r.y - r.x * h;
          this.addHalfVertex(e, r.x + r.y * a, r.y - r.x * a, y, !1, a, d), this.addHalfVertex(e, S, k, y, !0, -h, d), this.distance > vd / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, r, a, h, d, y));
        }
        addHalfVertex({ x: e, y: r }, a, h, d, y, S, k) {
          const M = 0.5 * (this.lineClips ? this.scaledDistance * (vd - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((e << 1) + (d ? 1 : 0), (r << 1) + (y ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * h) + 128, 1 + (S === 0 ? 0 : S < 0 ? -1 : 1) | (63 & M) << 2, M >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const F = k.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, F), k.primitiveLength++), y ? this.e2 = F : this.e1 = F;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(e, r) {
          this.distance += e.dist(r), this.updateScaledDistance();
        }
      }
      let xd, bd;
      Rt("LineBucket", su, { omit: ["layers", "patternFeatures"] });
      var wd = { get paint() {
        return bd = bd || new c({ "line-opacity": new ni(te.paint_line["line-opacity"]), "line-color": new ni(te.paint_line["line-color"]), "line-translate": new Vt(te.paint_line["line-translate"]), "line-translate-anchor": new Vt(te.paint_line["line-translate-anchor"]), "line-width": new ni(te.paint_line["line-width"]), "line-gap-width": new ni(te.paint_line["line-gap-width"]), "line-offset": new ni(te.paint_line["line-offset"]), "line-blur": new ni(te.paint_line["line-blur"]), "line-dasharray": new t(te.paint_line["line-dasharray"]), "line-pattern": new f(te.paint_line["line-pattern"]), "line-gradient": new n(te.paint_line["line-gradient"]) });
      }, get layout() {
        return xd = xd || new c({ "line-cap": new Vt(te.layout_line["line-cap"]), "line-join": new ni(te.layout_line["line-join"]), "line-miter-limit": new Vt(te.layout_line["line-miter-limit"]), "line-round-limit": new Vt(te.layout_line["line-round-limit"]), "line-sort-key": new ni(te.layout_line["line-sort-key"]) });
      } };
      class im extends ni {
        possiblyEvaluate(e, r) {
          return r = new ji(Math.floor(r.zoom), { now: r.now, fadeDuration: r.fadeDuration, zoomHistory: r.zoomHistory, transition: r.transition }), super.possiblyEvaluate(e, r);
        }
        evaluate(e, r, a, h) {
          return r = $e({}, r, { zoom: Math.floor(r.zoom) }), super.evaluate(e, r, a, h);
        }
      }
      let vh;
      class rm extends m {
        constructor(e) {
          super(e, wd), this.gradientVersion = 0, vh || (vh = new im(wd.paint.properties["line-width"].specification), vh.useIntegerZoom = !0);
        }
        _handleSpecialPaintPropertyUpdate(e) {
          if (e === "line-gradient") {
            const r = this.gradientExpression();
            this.stepInterpolant = !!function(a) {
              return a._styleExpression !== void 0;
            }(r) && r._styleExpression.expression instanceof La, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(e, r) {
          super.recalculate(e, r), this.paint._values["line-floorwidth"] = vh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
        }
        createBucket(e) {
          return new su(e);
        }
        queryRadius(e) {
          const r = e, a = Sd(bo("line-width", this, r), bo("line-gap-width", this, r)), h = bo("line-offset", this, r);
          return a / 2 + Math.abs(h) + gl(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(e, r, a, h, d, y, S) {
          const k = Gl(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), y.angle, S), M = S / 2 * Sd(this.paint.get("line-width").evaluate(r, a), this.paint.get("line-gap-width").evaluate(r, a)), F = this.paint.get("line-offset").evaluate(r, a);
          return F && (h = function(O, $) {
            const Y = [];
            for (let ee = 0; ee < O.length; ee++) {
              const re = O[ee], me = [];
              for (let be = 0; be < re.length; be++) {
                const Re = re[be - 1], Pe = re[be], ze = re[be + 1], Xe = be === 0 ? new q(0, 0) : Pe.sub(Re)._unit()._perp(), mt = be === re.length - 1 ? new q(0, 0) : ze.sub(Pe)._unit()._perp(), At = Xe._add(mt)._unit(), Kt = At.x * mt.x + At.y * mt.y;
                Kt !== 0 && At._mult(1 / Kt), me.push(At._mult($)._add(Pe));
              }
              Y.push(me);
            }
            return Y;
          }(h, F * S)), function(O, $, Y) {
            for (let ee = 0; ee < $.length; ee++) {
              const re = $[ee];
              if (O.length >= 3) {
                for (let me = 0; me < re.length; me++) if (os(O, re[me])) return !0;
              }
              if (dh(O, re, Y)) return !0;
            }
            return !1;
          }(k, h, M);
        }
        isTileClipped() {
          return !0;
        }
      }
      function Sd(i, e) {
        return e > 0 ? e + 2 * i : i;
      }
      const nm = p([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), sm = p([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      p([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const am = p([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      p([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Ad = p([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), om = p([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function lm(i, e, r) {
        return i.sections.forEach((a) => {
          a.text = function(h, d, y) {
            const S = d.layout.get("text-transform").evaluate(y, {});
            return S === "uppercase" ? h = h.toLocaleUpperCase() : S === "lowercase" && (h = h.toLocaleLowerCase()), ba.applyArabicShaping && (h = ba.applyArabicShaping(h)), h;
          }(a.text, e, r);
        }), i;
      }
      p([{ name: "triangle", components: 3, type: "Uint16" }]), p([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), p([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), p([{ type: "Float32", name: "offsetX" }]), p([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), p([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const $c = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
      var Wr = 24, Pd = Xi, Id = function(i, e, r, a, h) {
        var d, y, S = 8 * h - a - 1, k = (1 << S) - 1, M = k >> 1, F = -7, O = h - 1, $ = -1, Y = i[e + O];
        for (O += $, d = Y & (1 << -F) - 1, Y >>= -F, F += S; F > 0; d = 256 * d + i[e + O], O += $, F -= 8) ;
        for (y = d & (1 << -F) - 1, d >>= -F, F += a; F > 0; y = 256 * y + i[e + O], O += $, F -= 8) ;
        if (d === 0) d = 1 - M;
        else {
          if (d === k) return y ? NaN : 1 / 0 * (Y ? -1 : 1);
          y += Math.pow(2, a), d -= M;
        }
        return (Y ? -1 : 1) * y * Math.pow(2, d - a);
      }, Td = function(i, e, r, a, h, d) {
        var y, S, k, M = 8 * d - h - 1, F = (1 << M) - 1, O = F >> 1, $ = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Y = 0, ee = 1, re = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (S = isNaN(e) ? 1 : 0, y = F) : (y = Math.floor(Math.log(e) / Math.LN2), e * (k = Math.pow(2, -y)) < 1 && (y--, k *= 2), (e += y + O >= 1 ? $ / k : $ * Math.pow(2, 1 - O)) * k >= 2 && (y++, k /= 2), y + O >= F ? (S = 0, y = F) : y + O >= 1 ? (S = (e * k - 1) * Math.pow(2, h), y += O) : (S = e * Math.pow(2, O - 1) * Math.pow(2, h), y = 0)); h >= 8; i[r + Y] = 255 & S, Y += ee, S /= 256, h -= 8) ;
        for (y = y << h | S, M += h; M > 0; i[r + Y] = 255 & y, Y += ee, y /= 256, M -= 8) ;
        i[r + Y - ee] |= 128 * re;
      };
      function Xi(i) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(i) ? i : new Uint8Array(i || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      Xi.Varint = 0, Xi.Fixed64 = 1, Xi.Bytes = 2, Xi.Fixed32 = 5;
      var au = 4294967296, kd = 1 / au, Ld = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
      function Ho(i) {
        return i.type === Xi.Bytes ? i.readVarint() + i.pos : i.pos + 1;
      }
      function fc(i, e, r) {
        return r ? 4294967296 * e + (i >>> 0) : 4294967296 * (e >>> 0) + (i >>> 0);
      }
      function Cd(i, e, r) {
        var a = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
        r.realloc(a);
        for (var h = r.pos - 1; h >= i; h--) r.buf[h + a] = r.buf[h];
      }
      function cm(i, e) {
        for (var r = 0; r < i.length; r++) e.writeVarint(i[r]);
      }
      function hm(i, e) {
        for (var r = 0; r < i.length; r++) e.writeSVarint(i[r]);
      }
      function um(i, e) {
        for (var r = 0; r < i.length; r++) e.writeFloat(i[r]);
      }
      function dm(i, e) {
        for (var r = 0; r < i.length; r++) e.writeDouble(i[r]);
      }
      function pm(i, e) {
        for (var r = 0; r < i.length; r++) e.writeBoolean(i[r]);
      }
      function fm(i, e) {
        for (var r = 0; r < i.length; r++) e.writeFixed32(i[r]);
      }
      function mm(i, e) {
        for (var r = 0; r < i.length; r++) e.writeSFixed32(i[r]);
      }
      function gm(i, e) {
        for (var r = 0; r < i.length; r++) e.writeFixed64(i[r]);
      }
      function ym(i, e) {
        for (var r = 0; r < i.length; r++) e.writeSFixed64(i[r]);
      }
      function xh(i, e) {
        return (i[e] | i[e + 1] << 8 | i[e + 2] << 16) + 16777216 * i[e + 3];
      }
      function mc(i, e, r) {
        i[r] = e, i[r + 1] = e >>> 8, i[r + 2] = e >>> 16, i[r + 3] = e >>> 24;
      }
      function Ed(i, e) {
        return (i[e] | i[e + 1] << 8 | i[e + 2] << 16) + (i[e + 3] << 24);
      }
      Xi.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(i, e, r) {
        for (r = r || this.length; this.pos < r; ) {
          var a = this.readVarint(), h = a >> 3, d = this.pos;
          this.type = 7 & a, i(h, e, this), this.pos === d && this.skip(a);
        }
        return e;
      }, readMessage: function(i, e) {
        return this.readFields(i, e, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var i = xh(this.buf, this.pos);
        return this.pos += 4, i;
      }, readSFixed32: function() {
        var i = Ed(this.buf, this.pos);
        return this.pos += 4, i;
      }, readFixed64: function() {
        var i = xh(this.buf, this.pos) + xh(this.buf, this.pos + 4) * au;
        return this.pos += 8, i;
      }, readSFixed64: function() {
        var i = xh(this.buf, this.pos) + Ed(this.buf, this.pos + 4) * au;
        return this.pos += 8, i;
      }, readFloat: function() {
        var i = Id(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, i;
      }, readDouble: function() {
        var i = Id(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, i;
      }, readVarint: function(i) {
        var e, r, a = this.buf;
        return e = 127 & (r = a[this.pos++]), r < 128 ? e : (e |= (127 & (r = a[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = a[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = a[this.pos++])) << 21, r < 128 ? e : function(h, d, y) {
          var S, k, M = y.buf;
          if (S = (112 & (k = M[y.pos++])) >> 4, k < 128 || (S |= (127 & (k = M[y.pos++])) << 3, k < 128) || (S |= (127 & (k = M[y.pos++])) << 10, k < 128) || (S |= (127 & (k = M[y.pos++])) << 17, k < 128) || (S |= (127 & (k = M[y.pos++])) << 24, k < 128) || (S |= (1 & (k = M[y.pos++])) << 31, k < 128)) return fc(h, S, d);
          throw new Error("Expected varint not more than 10 bytes");
        }(e |= (15 & (r = a[this.pos])) << 28, i, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var i = this.readVarint();
        return i % 2 == 1 ? (i + 1) / -2 : i / 2;
      }, readBoolean: function() {
        return !!this.readVarint();
      }, readString: function() {
        var i = this.readVarint() + this.pos, e = this.pos;
        return this.pos = i, i - e >= 12 && Ld ? function(r, a, h) {
          return Ld.decode(r.subarray(a, h));
        }(this.buf, e, i) : function(r, a, h) {
          for (var d = "", y = a; y < h; ) {
            var S, k, M, F = r[y], O = null, $ = F > 239 ? 4 : F > 223 ? 3 : F > 191 ? 2 : 1;
            if (y + $ > h) break;
            $ === 1 ? F < 128 && (O = F) : $ === 2 ? (192 & (S = r[y + 1])) == 128 && (O = (31 & F) << 6 | 63 & S) <= 127 && (O = null) : $ === 3 ? (k = r[y + 2], (192 & (S = r[y + 1])) == 128 && (192 & k) == 128 && ((O = (15 & F) << 12 | (63 & S) << 6 | 63 & k) <= 2047 || O >= 55296 && O <= 57343) && (O = null)) : $ === 4 && (k = r[y + 2], M = r[y + 3], (192 & (S = r[y + 1])) == 128 && (192 & k) == 128 && (192 & M) == 128 && ((O = (15 & F) << 18 | (63 & S) << 12 | (63 & k) << 6 | 63 & M) <= 65535 || O >= 1114112) && (O = null)), O === null ? (O = 65533, $ = 1) : O > 65535 && (O -= 65536, d += String.fromCharCode(O >>> 10 & 1023 | 55296), O = 56320 | 1023 & O), d += String.fromCharCode(O), y += $;
          }
          return d;
        }(this.buf, e, i);
      }, readBytes: function() {
        var i = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, i);
        return this.pos = i, e;
      }, readPackedVarint: function(i, e) {
        if (this.type !== Xi.Bytes) return i.push(this.readVarint(e));
        var r = Ho(this);
        for (i = i || []; this.pos < r; ) i.push(this.readVarint(e));
        return i;
      }, readPackedSVarint: function(i) {
        if (this.type !== Xi.Bytes) return i.push(this.readSVarint());
        var e = Ho(this);
        for (i = i || []; this.pos < e; ) i.push(this.readSVarint());
        return i;
      }, readPackedBoolean: function(i) {
        if (this.type !== Xi.Bytes) return i.push(this.readBoolean());
        var e = Ho(this);
        for (i = i || []; this.pos < e; ) i.push(this.readBoolean());
        return i;
      }, readPackedFloat: function(i) {
        if (this.type !== Xi.Bytes) return i.push(this.readFloat());
        var e = Ho(this);
        for (i = i || []; this.pos < e; ) i.push(this.readFloat());
        return i;
      }, readPackedDouble: function(i) {
        if (this.type !== Xi.Bytes) return i.push(this.readDouble());
        var e = Ho(this);
        for (i = i || []; this.pos < e; ) i.push(this.readDouble());
        return i;
      }, readPackedFixed32: function(i) {
        if (this.type !== Xi.Bytes) return i.push(this.readFixed32());
        var e = Ho(this);
        for (i = i || []; this.pos < e; ) i.push(this.readFixed32());
        return i;
      }, readPackedSFixed32: function(i) {
        if (this.type !== Xi.Bytes) return i.push(this.readSFixed32());
        var e = Ho(this);
        for (i = i || []; this.pos < e; ) i.push(this.readSFixed32());
        return i;
      }, readPackedFixed64: function(i) {
        if (this.type !== Xi.Bytes) return i.push(this.readFixed64());
        var e = Ho(this);
        for (i = i || []; this.pos < e; ) i.push(this.readFixed64());
        return i;
      }, readPackedSFixed64: function(i) {
        if (this.type !== Xi.Bytes) return i.push(this.readSFixed64());
        var e = Ho(this);
        for (i = i || []; this.pos < e; ) i.push(this.readSFixed64());
        return i;
      }, skip: function(i) {
        var e = 7 & i;
        if (e === Xi.Varint) for (; this.buf[this.pos++] > 127; ) ;
        else if (e === Xi.Bytes) this.pos = this.readVarint() + this.pos;
        else if (e === Xi.Fixed32) this.pos += 4;
        else {
          if (e !== Xi.Fixed64) throw new Error("Unimplemented type: " + e);
          this.pos += 8;
        }
      }, writeTag: function(i, e) {
        this.writeVarint(i << 3 | e);
      }, realloc: function(i) {
        for (var e = this.length || 16; e < this.pos + i; ) e *= 2;
        if (e !== this.length) {
          var r = new Uint8Array(e);
          r.set(this.buf), this.buf = r, this.length = e;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(i) {
        this.realloc(4), mc(this.buf, i, this.pos), this.pos += 4;
      }, writeSFixed32: function(i) {
        this.realloc(4), mc(this.buf, i, this.pos), this.pos += 4;
      }, writeFixed64: function(i) {
        this.realloc(8), mc(this.buf, -1 & i, this.pos), mc(this.buf, Math.floor(i * kd), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(i) {
        this.realloc(8), mc(this.buf, -1 & i, this.pos), mc(this.buf, Math.floor(i * kd), this.pos + 4), this.pos += 8;
      }, writeVarint: function(i) {
        (i = +i || 0) > 268435455 || i < 0 ? function(e, r) {
          var a, h;
          if (e >= 0 ? (a = e % 4294967296 | 0, h = e / 4294967296 | 0) : (h = ~(-e / 4294967296), 4294967295 ^ (a = ~(-e % 4294967296)) ? a = a + 1 | 0 : (a = 0, h = h + 1 | 0)), e >= 18446744073709552e3 || e < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
          r.realloc(10), function(d, y, S) {
            S.buf[S.pos++] = 127 & d | 128, d >>>= 7, S.buf[S.pos++] = 127 & d | 128, d >>>= 7, S.buf[S.pos++] = 127 & d | 128, d >>>= 7, S.buf[S.pos++] = 127 & d | 128, S.buf[S.pos] = 127 & (d >>>= 7);
          }(a, 0, r), function(d, y) {
            var S = (7 & d) << 4;
            y.buf[y.pos++] |= S | ((d >>>= 3) ? 128 : 0), d && (y.buf[y.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (y.buf[y.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (y.buf[y.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (y.buf[y.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (y.buf[y.pos++] = 127 & d)))));
          }(h, r);
        }(i, this) : (this.realloc(4), this.buf[this.pos++] = 127 & i | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = i >>> 7 & 127))));
      }, writeSVarint: function(i) {
        this.writeVarint(i < 0 ? 2 * -i - 1 : 2 * i);
      }, writeBoolean: function(i) {
        this.writeVarint(!!i);
      }, writeString: function(i) {
        i = String(i), this.realloc(4 * i.length), this.pos++;
        var e = this.pos;
        this.pos = function(a, h, d) {
          for (var y, S, k = 0; k < h.length; k++) {
            if ((y = h.charCodeAt(k)) > 55295 && y < 57344) {
              if (!S) {
                y > 56319 || k + 1 === h.length ? (a[d++] = 239, a[d++] = 191, a[d++] = 189) : S = y;
                continue;
              }
              if (y < 56320) {
                a[d++] = 239, a[d++] = 191, a[d++] = 189, S = y;
                continue;
              }
              y = S - 55296 << 10 | y - 56320 | 65536, S = null;
            } else S && (a[d++] = 239, a[d++] = 191, a[d++] = 189, S = null);
            y < 128 ? a[d++] = y : (y < 2048 ? a[d++] = y >> 6 | 192 : (y < 65536 ? a[d++] = y >> 12 | 224 : (a[d++] = y >> 18 | 240, a[d++] = y >> 12 & 63 | 128), a[d++] = y >> 6 & 63 | 128), a[d++] = 63 & y | 128);
          }
          return d;
        }(this.buf, i, this.pos);
        var r = this.pos - e;
        r >= 128 && Cd(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;
      }, writeFloat: function(i) {
        this.realloc(4), Td(this.buf, i, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(i) {
        this.realloc(8), Td(this.buf, i, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(i) {
        var e = i.length;
        this.writeVarint(e), this.realloc(e);
        for (var r = 0; r < e; r++) this.buf[this.pos++] = i[r];
      }, writeRawMessage: function(i, e) {
        this.pos++;
        var r = this.pos;
        i(e, this);
        var a = this.pos - r;
        a >= 128 && Cd(r, a, this), this.pos = r - 1, this.writeVarint(a), this.pos += a;
      }, writeMessage: function(i, e, r) {
        this.writeTag(i, Xi.Bytes), this.writeRawMessage(e, r);
      }, writePackedVarint: function(i, e) {
        e.length && this.writeMessage(i, cm, e);
      }, writePackedSVarint: function(i, e) {
        e.length && this.writeMessage(i, hm, e);
      }, writePackedBoolean: function(i, e) {
        e.length && this.writeMessage(i, pm, e);
      }, writePackedFloat: function(i, e) {
        e.length && this.writeMessage(i, um, e);
      }, writePackedDouble: function(i, e) {
        e.length && this.writeMessage(i, dm, e);
      }, writePackedFixed32: function(i, e) {
        e.length && this.writeMessage(i, fm, e);
      }, writePackedSFixed32: function(i, e) {
        e.length && this.writeMessage(i, mm, e);
      }, writePackedFixed64: function(i, e) {
        e.length && this.writeMessage(i, gm, e);
      }, writePackedSFixed64: function(i, e) {
        e.length && this.writeMessage(i, ym, e);
      }, writeBytesField: function(i, e) {
        this.writeTag(i, Xi.Bytes), this.writeBytes(e);
      }, writeFixed32Field: function(i, e) {
        this.writeTag(i, Xi.Fixed32), this.writeFixed32(e);
      }, writeSFixed32Field: function(i, e) {
        this.writeTag(i, Xi.Fixed32), this.writeSFixed32(e);
      }, writeFixed64Field: function(i, e) {
        this.writeTag(i, Xi.Fixed64), this.writeFixed64(e);
      }, writeSFixed64Field: function(i, e) {
        this.writeTag(i, Xi.Fixed64), this.writeSFixed64(e);
      }, writeVarintField: function(i, e) {
        this.writeTag(i, Xi.Varint), this.writeVarint(e);
      }, writeSVarintField: function(i, e) {
        this.writeTag(i, Xi.Varint), this.writeSVarint(e);
      }, writeStringField: function(i, e) {
        this.writeTag(i, Xi.Bytes), this.writeString(e);
      }, writeFloatField: function(i, e) {
        this.writeTag(i, Xi.Fixed32), this.writeFloat(e);
      }, writeDoubleField: function(i, e) {
        this.writeTag(i, Xi.Fixed64), this.writeDouble(e);
      }, writeBooleanField: function(i, e) {
        this.writeVarintField(i, !!e);
      } };
      var ou = D(Pd);
      const lu = 3;
      function _m(i, e, r) {
        i === 1 && r.readMessage(vm, e);
      }
      function vm(i, e, r) {
        if (i === 3) {
          const { id: a, bitmap: h, width: d, height: y, left: S, top: k, advance: M } = r.readMessage(xm, {});
          e.push({ id: a, bitmap: new Bc({ width: d + 2 * lu, height: y + 2 * lu }, h), metrics: { width: d, height: y, left: S, top: k, advance: M } });
        }
      }
      function xm(i, e, r) {
        i === 1 ? e.id = r.readVarint() : i === 2 ? e.bitmap = r.readBytes() : i === 3 ? e.width = r.readVarint() : i === 4 ? e.height = r.readVarint() : i === 5 ? e.left = r.readSVarint() : i === 6 ? e.top = r.readSVarint() : i === 7 && (e.advance = r.readVarint());
      }
      const Md = lu;
      function Dd(i) {
        let e = 0, r = 0;
        for (const y of i) e += y.w * y.h, r = Math.max(r, y.w);
        i.sort((y, S) => S.h - y.h);
        const a = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), r), h: 1 / 0 }];
        let h = 0, d = 0;
        for (const y of i) for (let S = a.length - 1; S >= 0; S--) {
          const k = a[S];
          if (!(y.w > k.w || y.h > k.h)) {
            if (y.x = k.x, y.y = k.y, d = Math.max(d, y.y + y.h), h = Math.max(h, y.x + y.w), y.w === k.w && y.h === k.h) {
              const M = a.pop();
              S < a.length && (a[S] = M);
            } else y.h === k.h ? (k.x += y.w, k.w -= y.w) : y.w === k.w ? (k.y += y.h, k.h -= y.h) : (a.push({ x: k.x + y.w, y: k.y, w: k.w - y.w, h: y.h }), k.y += y.h, k.h -= y.h);
            break;
          }
        }
        return { w: h, h: d, fill: e / (h * d) || 0 };
      }
      const ls = 1;
      class cu {
        constructor(e, { pixelRatio: r, version: a, stretchX: h, stretchY: d, content: y, textFitWidth: S, textFitHeight: k }) {
          this.paddedRect = e, this.pixelRatio = r, this.stretchX = h, this.stretchY = d, this.content = y, this.version = a, this.textFitWidth = S, this.textFitHeight = k;
        }
        get tl() {
          return [this.paddedRect.x + ls, this.paddedRect.y + ls];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - ls, this.paddedRect.y + this.paddedRect.h - ls];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * ls) / this.pixelRatio, (this.paddedRect.h - 2 * ls) / this.pixelRatio];
        }
      }
      class zd {
        constructor(e, r) {
          const a = {}, h = {};
          this.haveRenderCallbacks = [];
          const d = [];
          this.addImages(e, a, d), this.addImages(r, h, d);
          const { w: y, h: S } = Dd(d), k = new Xs({ width: y || 1, height: S || 1 });
          for (const M in e) {
            const F = e[M], O = a[M].paddedRect;
            Xs.copy(F.data, k, { x: 0, y: 0 }, { x: O.x + ls, y: O.y + ls }, F.data);
          }
          for (const M in r) {
            const F = r[M], O = h[M].paddedRect, $ = O.x + ls, Y = O.y + ls, ee = F.data.width, re = F.data.height;
            Xs.copy(F.data, k, { x: 0, y: 0 }, { x: $, y: Y }, F.data), Xs.copy(F.data, k, { x: 0, y: re - 1 }, { x: $, y: Y - 1 }, { width: ee, height: 1 }), Xs.copy(F.data, k, { x: 0, y: 0 }, { x: $, y: Y + re }, { width: ee, height: 1 }), Xs.copy(F.data, k, { x: ee - 1, y: 0 }, { x: $ - 1, y: Y }, { width: 1, height: re }), Xs.copy(F.data, k, { x: 0, y: 0 }, { x: $ + ee, y: Y }, { width: 1, height: re });
          }
          this.image = k, this.iconPositions = a, this.patternPositions = h;
        }
        addImages(e, r, a) {
          for (const h in e) {
            const d = e[h], y = { x: 0, y: 0, w: d.data.width + 2 * ls, h: d.data.height + 2 * ls };
            a.push(y), r[h] = new cu(y, d), d.hasRenderCallback && this.haveRenderCallbacks.push(h);
          }
        }
        patchUpdatedImages(e, r) {
          e.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const a in e.updatedImages) this.patchUpdatedImage(this.iconPositions[a], e.getImage(a), r), this.patchUpdatedImage(this.patternPositions[a], e.getImage(a), r);
        }
        patchUpdatedImage(e, r, a) {
          if (!e || !r || e.version === r.version) return;
          e.version = r.version;
          const [h, d] = e.tl;
          a.update(r.data, void 0, { x: h, y: d });
        }
      }
      var _l;
      Rt("ImagePosition", cu), Rt("ImageAtlas", zd), v.ah = void 0, (_l = v.ah || (v.ah = {}))[_l.none = 0] = "none", _l[_l.horizontal = 1] = "horizontal", _l[_l.vertical = 2] = "vertical", _l[_l.horizontalOnly = 3] = "horizontalOnly";
      const Zc = -17;
      class Wc {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(e, r) {
          const a = new Wc();
          return a.scale = e || 1, a.fontStack = r, a;
        }
        static forImage(e) {
          const r = new Wc();
          return r.imageName = e, r;
        }
      }
      class gc {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(e, r) {
          const a = new gc();
          for (let h = 0; h < e.sections.length; h++) {
            const d = e.sections[h];
            d.image ? a.addImageSection(d) : a.addTextSection(d, r);
          }
          return a;
        }
        length() {
          return this.text.length;
        }
        getSection(e) {
          return this.sections[this.sectionIndex[e]];
        }
        getSectionIndex(e) {
          return this.sectionIndex[e];
        }
        getCharCode(e) {
          return this.text.charCodeAt(e);
        }
        verticalizePunctuation() {
          this.text = function(e) {
            let r = "";
            for (let a = 0; a < e.length; a++) {
              const h = e.charCodeAt(a + 1) || null, d = e.charCodeAt(a - 1) || null;
              r += h && Ol(h) && !$c[e[a + 1]] || d && Ol(d) && !$c[e[a - 1]] || !$c[e[a]] ? e[a] : $c[e[a]];
            }
            return r;
          }(this.text);
        }
        trim() {
          let e = 0;
          for (let a = 0; a < this.text.length && wh[this.text.charCodeAt(a)]; a++) e++;
          let r = this.text.length;
          for (let a = this.text.length - 1; a >= 0 && a >= e && wh[this.text.charCodeAt(a)]; a--) r--;
          this.text = this.text.substring(e, r), this.sectionIndex = this.sectionIndex.slice(e, r);
        }
        substring(e, r) {
          const a = new gc();
          return a.text = this.text.substring(e, r), a.sectionIndex = this.sectionIndex.slice(e, r), a.sections = this.sections, a;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((e, r) => Math.max(e, this.sections[r].scale), 0);
        }
        addTextSection(e, r) {
          this.text += e.text, this.sections.push(Wc.forText(e.scale, e.fontStack || r));
          const a = this.sections.length - 1;
          for (let h = 0; h < e.text.length; ++h) this.sectionIndex.push(a);
        }
        addImageSection(e) {
          const r = e.image ? e.image.name : "";
          if (r.length === 0) return void Ie("Can't add FormattedSection with an empty image.");
          const a = this.getNextImageSectionCharCode();
          a ? (this.text += String.fromCharCode(a), this.sections.push(Wc.forImage(r)), this.sectionIndex.push(this.sections.length - 1)) : Ie("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function bh(i, e, r, a, h, d, y, S, k, M, F, O, $, Y, ee) {
        const re = gc.fromFeature(i, h);
        let me;
        O === v.ah.vertical && re.verticalizePunctuation();
        const { processBidirectionalText: be, processStyledBidirectionalText: Re } = ba;
        if (be && re.sections.length === 1) {
          me = [];
          const Xe = be(re.toString(), hu(re, M, d, e, a, Y));
          for (const mt of Xe) {
            const At = new gc();
            At.text = mt, At.sections = re.sections;
            for (let Kt = 0; Kt < mt.length; Kt++) At.sectionIndex.push(0);
            me.push(At);
          }
        } else if (Re) {
          me = [];
          const Xe = Re(re.text, re.sectionIndex, hu(re, M, d, e, a, Y));
          for (const mt of Xe) {
            const At = new gc();
            At.text = mt[0], At.sectionIndex = mt[1], At.sections = re.sections, me.push(At);
          }
        } else me = function(Xe, mt) {
          const At = [], Kt = Xe.text;
          let Et = 0;
          for (const St of mt) At.push(Xe.substring(Et, St)), Et = St;
          return Et < Kt.length && At.push(Xe.substring(Et, Kt.length)), At;
        }(re, hu(re, M, d, e, a, Y));
        const Pe = [], ze = { positionedLines: Pe, text: re.toString(), top: F[1], bottom: F[1], left: F[0], right: F[0], writingMode: O, iconsInText: !1, verticalizable: !1 };
        return function(Xe, mt, At, Kt, Et, St, Gt, qt, Ot, ht, Xt, $t) {
          let di = 0, Qi = Zc, Yi = 0, tn = 0;
          const Pa = qt === "right" ? 1 : qt === "left" ? 0 : 0.5;
          let _n = 0;
          for (const Er of Et) {
            Er.trim();
            const rn = Er.getMaxScale(), Ln = (rn - 1) * Wr, vn = { positionedGlyphs: [], lineOffset: 0 };
            Xe.positionedLines[_n] = vn;
            const Wn = vn.positionedGlyphs;
            let xn = 0;
            if (!Er.length()) {
              Qi += St, ++_n;
              continue;
            }
            for (let cs = 0; cs < Er.length(); cs++) {
              const Bi = Er.getSection(cs), ar = Er.getSectionIndex(cs), dr = Er.getCharCode(cs);
              let Ts = 0, wr = null, xc = null, So = null, Ao = Wr;
              const Ia = !(Ot === v.ah.horizontal || !Xt && !Bl(dr) || Xt && (wh[dr] || (Cr = dr, Pt.Arabic(Cr) || Pt["Arabic Supplement"](Cr) || Pt["Arabic Extended-A"](Cr) || Pt["Arabic Presentation Forms-A"](Cr) || Pt["Arabic Presentation Forms-B"](Cr))));
              if (Bi.imageName) {
                const Ks = Kt[Bi.imageName];
                if (!Ks) continue;
                So = Bi.imageName, Xe.iconsInText = Xe.iconsInText || !0, xc = Ks.paddedRect;
                const ln = Ks.displaySize;
                Bi.scale = Bi.scale * Wr / $t, wr = { width: ln[0], height: ln[1], left: ls, top: -Md, advance: Ia ? ln[1] : ln[0] }, Ts = Ln + (Wr - ln[1] * Bi.scale), Ao = wr.advance;
                const Xo = Ia ? ln[0] * Bi.scale - Wr * rn : ln[1] * Bi.scale - Wr * rn;
                Xo > 0 && Xo > xn && (xn = Xo);
              } else {
                const Ks = At[Bi.fontStack], ln = Ks && Ks[dr];
                if (ln && ln.rect) xc = ln.rect, wr = ln.metrics;
                else {
                  const Xo = mt[Bi.fontStack], Jc = Xo && Xo[dr];
                  if (!Jc) continue;
                  wr = Jc.metrics;
                }
                Ts = (rn - Bi.scale) * Wr;
              }
              Ia ? (Xe.verticalizable = !0, Wn.push({ glyph: dr, imageName: So, x: di, y: Qi + Ts, vertical: Ia, scale: Bi.scale, fontStack: Bi.fontStack, sectionIndex: ar, metrics: wr, rect: xc }), di += Ao * Bi.scale + ht) : (Wn.push({ glyph: dr, imageName: So, x: di, y: Qi + Ts, vertical: Ia, scale: Bi.scale, fontStack: Bi.fontStack, sectionIndex: ar, metrics: wr, rect: xc }), di += wr.advance * Bi.scale + ht);
            }
            Wn.length !== 0 && (Yi = Math.max(di - ht, Yi), Am(Wn, 0, Wn.length - 1, Pa, xn)), di = 0;
            const Js = St * rn + xn;
            vn.lineOffset = Math.max(xn, Ln), Qi += Js, tn = Math.max(Js, tn), ++_n;
          }
          var Cr;
          const Vn = Qi - Zc, { horizontalAlign: $n, verticalAlign: Zn } = uu(Gt);
          (function(Er, rn, Ln, vn, Wn, xn, Js, cs, Bi) {
            const ar = (rn - Ln) * Wn;
            let dr = 0;
            dr = xn !== Js ? -cs * vn - Zc : (-vn * Bi + 0.5) * Js;
            for (const Ts of Er) for (const wr of Ts.positionedGlyphs) wr.x += ar, wr.y += dr;
          })(Xe.positionedLines, Pa, $n, Zn, Yi, tn, St, Vn, Et.length), Xe.top += -Zn * Vn, Xe.bottom = Xe.top + Vn, Xe.left += -$n * Yi, Xe.right = Xe.left + Yi;
        }(ze, e, r, a, me, y, S, k, O, M, $, ee), !function(Xe) {
          for (const mt of Xe) if (mt.positionedGlyphs.length !== 0) return !1;
          return !0;
        }(Pe) && ze;
      }
      const wh = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, bm = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, wm = { 40: !0 };
      function Fd(i, e, r, a, h, d) {
        if (e.imageName) {
          const y = a[e.imageName];
          return y ? y.displaySize[0] * e.scale * Wr / d + h : 0;
        }
        {
          const y = r[e.fontStack], S = y && y[i];
          return S ? S.metrics.advance * e.scale + h : 0;
        }
      }
      function Nd(i, e, r, a) {
        const h = Math.pow(i - e, 2);
        return a ? i < e ? h / 2 : 2 * h : h + Math.abs(r) * r;
      }
      function Sm(i, e, r) {
        let a = 0;
        return i === 10 && (a -= 1e4), r && (a += 150), i !== 40 && i !== 65288 || (a += 50), e !== 41 && e !== 65289 || (a += 50), a;
      }
      function Rd(i, e, r, a, h, d) {
        let y = null, S = Nd(e, r, h, d);
        for (const k of a) {
          const M = Nd(e - k.x, r, h, d) + k.badness;
          M <= S && (y = k, S = M);
        }
        return { index: i, x: e, priorBreak: y, badness: S };
      }
      function Bd(i) {
        return i ? Bd(i.priorBreak).concat(i.index) : [];
      }
      function hu(i, e, r, a, h, d) {
        if (!i) return [];
        const y = [], S = function(O, $, Y, ee, re, me) {
          let be = 0;
          for (let Re = 0; Re < O.length(); Re++) {
            const Pe = O.getSection(Re);
            be += Fd(O.getCharCode(Re), Pe, ee, re, $, me);
          }
          return be / Math.max(1, Math.ceil(be / Y));
        }(i, e, r, a, h, d), k = i.text.indexOf("") >= 0;
        let M = 0;
        for (let O = 0; O < i.length(); O++) {
          const $ = i.getSection(O), Y = i.getCharCode(O);
          if (wh[Y] || (M += Fd(Y, $, a, h, e, d)), O < i.length() - 1) {
            const ee = !((F = Y) < 11904 || !(Pt["Bopomofo Extended"](F) || Pt.Bopomofo(F) || Pt["CJK Compatibility Forms"](F) || Pt["CJK Compatibility Ideographs"](F) || Pt["CJK Compatibility"](F) || Pt["CJK Radicals Supplement"](F) || Pt["CJK Strokes"](F) || Pt["CJK Symbols and Punctuation"](F) || Pt["CJK Unified Ideographs Extension A"](F) || Pt["CJK Unified Ideographs"](F) || Pt["Enclosed CJK Letters and Months"](F) || Pt["Halfwidth and Fullwidth Forms"](F) || Pt.Hiragana(F) || Pt["Ideographic Description Characters"](F) || Pt["Kangxi Radicals"](F) || Pt["Katakana Phonetic Extensions"](F) || Pt.Katakana(F) || Pt["Vertical Forms"](F) || Pt["Yi Radicals"](F) || Pt["Yi Syllables"](F)));
            (bm[Y] || ee || $.imageName || O !== i.length() - 2 && wm[i.getCharCode(O + 1)]) && y.push(Rd(O + 1, M, S, y, Sm(Y, i.getCharCode(O + 1), ee && k), !1));
          }
        }
        var F;
        return Bd(Rd(i.length(), M, S, y, 0, !0));
      }
      function uu(i) {
        let e = 0.5, r = 0.5;
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            e = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e = 0;
        }
        switch (i) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r = 0;
        }
        return { horizontalAlign: e, verticalAlign: r };
      }
      function Am(i, e, r, a, h) {
        if (!a && !h) return;
        const d = i[r], y = (i[r].x + d.metrics.advance * d.scale) * a;
        for (let S = e; S <= r; S++) i[S].x -= y, i[S].y += h;
      }
      function Pm(i, e, r) {
        const { horizontalAlign: a, verticalAlign: h } = uu(r), d = e[0] - i.displaySize[0] * a, y = e[1] - i.displaySize[1] * h;
        return { image: i, top: y, bottom: y + i.displaySize[1], left: d, right: d + i.displaySize[0] };
      }
      function Od(i) {
        var e, r;
        let a = i.left, h = i.top, d = i.right - a, y = i.bottom - h;
        const S = (e = i.image.textFitWidth) !== null && e !== void 0 ? e : "stretchOrShrink", k = (r = i.image.textFitHeight) !== null && r !== void 0 ? r : "stretchOrShrink", M = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
        if (k === "proportional") {
          if (S === "stretchOnly" && d / y < M || S === "proportional") {
            const F = Math.ceil(y * M);
            a *= F / d, d = F;
          }
        } else if (S === "proportional" && k === "stretchOnly" && M !== 0 && d / y > M) {
          const F = Math.ceil(d / M);
          h *= F / y, y = F;
        }
        return { x1: a, y1: h, x2: a + d, y2: h + y };
      }
      function jd(i, e, r, a, h, d) {
        const y = i.image;
        let S;
        if (y.content) {
          const me = y.content, be = y.pixelRatio || 1;
          S = [me[0] / be, me[1] / be, y.displaySize[0] - me[2] / be, y.displaySize[1] - me[3] / be];
        }
        const k = e.left * d, M = e.right * d;
        let F, O, $, Y;
        r === "width" || r === "both" ? (Y = h[0] + k - a[3], O = h[0] + M + a[1]) : (Y = h[0] + (k + M - y.displaySize[0]) / 2, O = Y + y.displaySize[0]);
        const ee = e.top * d, re = e.bottom * d;
        return r === "height" || r === "both" ? (F = h[1] + ee - a[0], $ = h[1] + re + a[2]) : (F = h[1] + (ee + re - y.displaySize[1]) / 2, $ = F + y.displaySize[1]), { image: y, top: F, right: O, bottom: $, left: Y, collisionPadding: S };
      }
      const Gc = 255, wo = 128, vl = Gc * wo;
      function qd(i, e) {
        const { expression: r } = e;
        if (r.kind === "constant") return { kind: "constant", layoutSize: r.evaluate(new ji(i + 1)) };
        if (r.kind === "source") return { kind: "source" };
        {
          const { zoomStops: a, interpolationType: h } = r;
          let d = 0;
          for (; d < a.length && a[d] <= i; ) d++;
          d = Math.max(0, d - 1);
          let y = d;
          for (; y < a.length && a[y] < i + 1; ) y++;
          y = Math.min(a.length - 1, y);
          const S = a[d], k = a[y];
          return r.kind === "composite" ? { kind: "composite", minZoom: S, maxZoom: k, interpolationType: h } : { kind: "camera", minZoom: S, maxZoom: k, minSize: r.evaluate(new ji(S)), maxSize: r.evaluate(new ji(k)), interpolationType: h };
        }
      }
      function du(i, e, r) {
        let a = "never";
        const h = i.get(e);
        return h ? a = h : i.get(r) && (a = "always"), a;
      }
      const Im = yl.VectorTileFeature.types, Tm = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Sh(i, e, r, a, h, d, y, S, k, M, F, O, $) {
        const Y = S ? Math.min(vl, Math.round(S[0])) : 0, ee = S ? Math.min(vl, Math.round(S[1])) : 0;
        i.emplaceBack(e, r, Math.round(32 * a), Math.round(32 * h), d, y, (Y << 1) + (k ? 1 : 0), ee, 16 * M, 16 * F, 256 * O, 256 * $);
      }
      function pu(i, e, r) {
        i.emplaceBack(e.x, e.y, r), i.emplaceBack(e.x, e.y, r), i.emplaceBack(e.x, e.y, r), i.emplaceBack(e.x, e.y, r);
      }
      function km(i) {
        for (const e of i.sections) if (hl(e.text)) return !0;
        return !1;
      }
      class fu {
        constructor(e) {
          this.layoutVertexArray = new Zr(), this.indexArray = new zr(), this.programConfigurations = e, this.segments = new vr(), this.dynamicLayoutVertexArray = new Tn(), this.opacityVertexArray = new kn(), this.hasVisibleVertices = !1, this.placedSymbolArray = new ci();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(e, r, a, h) {
          this.isEmpty() || (a && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, nm.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, sm.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, Tm, !0), this.opacityVertexBuffer.itemSize = 1), (a || h) && this.programConfigurations.upload(e));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      Rt("SymbolBuffers", fu);
      class mu {
        constructor(e, r, a) {
          this.layoutVertexArray = new e(), this.layoutAttributes = r, this.indexArray = new a(), this.segments = new vr(), this.collisionVertexArray = new Ur();
        }
        upload(e) {
          this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, am.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      Rt("CollisionBuffers", mu);
      class yc {
        constructor(e) {
          this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((y) => y.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Gh([]), this.placementViewportMatrix = Gh([]);
          const r = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = qd(this.zoom, r["text-size"]), this.iconSizeData = qd(this.zoom, r["icon-size"]);
          const a = this.layers[0].layout, h = a.get("symbol-sort-key"), d = a.get("symbol-z-order");
          this.canOverlap = du(a, "text-overlap", "text-allow-overlap") !== "never" || du(a, "icon-overlap", "icon-allow-overlap") !== "never" || a.get("text-ignore-placement") || a.get("icon-ignore-placement"), this.sortFeaturesByKey = d !== "viewport-y" && !h.isConstant(), this.sortFeaturesByY = (d === "viewport-y" || d === "auto" && !this.sortFeaturesByKey) && this.canOverlap, a.get("symbol-placement") === "point" && (this.writingModes = a.get("text-writing-mode").map((y) => v.ah[y])), this.stateDependentLayerIds = this.layers.filter((y) => y.isStateDependent()).map((y) => y.id), this.sourceID = e.sourceID;
        }
        createArrays() {
          this.text = new fu(new Wo(this.layers, this.zoom, (e) => /^text/.test(e))), this.icon = new fu(new Wo(this.layers, this.zoom, (e) => /^icon/.test(e))), this.glyphOffsetArray = new Ti(), this.lineVertexArray = new Ni(), this.symbolInstances = new qi(), this.textAnchorOffsets = new bi();
        }
        calculateGlyphDependencies(e, r, a, h, d) {
          for (let y = 0; y < e.length; y++) if (r[e.charCodeAt(y)] = !0, (a || h) && d) {
            const S = $c[e.charAt(y)];
            S && (r[S.charCodeAt(0)] = !0);
          }
        }
        populate(e, r, a) {
          const h = this.layers[0], d = h.layout, y = d.get("text-font"), S = d.get("text-field"), k = d.get("icon-image"), M = (S.value.kind !== "constant" || S.value.value instanceof Yr && !S.value.value.isEmpty() || S.value.value.toString().length > 0) && (y.value.kind !== "constant" || y.value.value.length > 0), F = k.value.kind !== "constant" || !!k.value.value || Object.keys(k.parameters).length > 0, O = d.get("symbol-sort-key");
          if (this.features = [], !M && !F) return;
          const $ = r.iconDependencies, Y = r.glyphDependencies, ee = r.availableImages, re = new ji(this.zoom);
          for (const { feature: me, id: be, index: Re, sourceLayerIndex: Pe } of e) {
            const ze = h._featureFilter.needGeometry, Xe = Go(me, ze);
            if (!h._featureFilter.filter(re, Xe, a)) continue;
            let mt, At;
            if (ze || (Xe.geometry = _o(me)), M) {
              const Et = h.getValueAndResolveTokens("text-field", Xe, a, ee), St = Yr.factory(Et), Gt = this.hasRTLText = this.hasRTLText || km(St);
              (!Gt || ba.getRTLTextPluginStatus() === "unavailable" || Gt && ba.isParsed()) && (mt = lm(St, h, Xe));
            }
            if (F) {
              const Et = h.getValueAndResolveTokens("icon-image", Xe, a, ee);
              At = Et instanceof sn ? Et : sn.fromString(Et);
            }
            if (!mt && !At) continue;
            const Kt = this.sortFeaturesByKey ? O.evaluate(Xe, {}, a) : void 0;
            if (this.features.push({ id: be, text: mt, icon: At, index: Re, sourceLayerIndex: Pe, geometry: Xe.geometry, properties: me.properties, type: Im[me.type], sortKey: Kt }), At && ($[At.name] = !0), mt) {
              const Et = y.evaluate(Xe, {}, a).join(","), St = d.get("text-rotation-alignment") !== "viewport" && d.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(v.ah.vertical) >= 0;
              for (const Gt of mt.sections) if (Gt.image) $[Gt.image.name] = !0;
              else {
                const qt = bs(mt.toString()), Ot = Gt.fontStack || Et, ht = Y[Ot] = Y[Ot] || {};
                this.calculateGlyphDependencies(Gt.text, ht, St, this.allowVerticalPlacement, qt);
              }
            }
          }
          d.get("symbol-placement") === "line" && (this.features = function(me) {
            const be = {}, Re = {}, Pe = [];
            let ze = 0;
            function Xe(Et) {
              Pe.push(me[Et]), ze++;
            }
            function mt(Et, St, Gt) {
              const qt = Re[Et];
              return delete Re[Et], Re[St] = qt, Pe[qt].geometry[0].pop(), Pe[qt].geometry[0] = Pe[qt].geometry[0].concat(Gt[0]), qt;
            }
            function At(Et, St, Gt) {
              const qt = be[St];
              return delete be[St], be[Et] = qt, Pe[qt].geometry[0].shift(), Pe[qt].geometry[0] = Gt[0].concat(Pe[qt].geometry[0]), qt;
            }
            function Kt(Et, St, Gt) {
              const qt = Gt ? St[0][St[0].length - 1] : St[0][0];
              return `${Et}:${qt.x}:${qt.y}`;
            }
            for (let Et = 0; Et < me.length; Et++) {
              const St = me[Et], Gt = St.geometry, qt = St.text ? St.text.toString() : null;
              if (!qt) {
                Xe(Et);
                continue;
              }
              const Ot = Kt(qt, Gt), ht = Kt(qt, Gt, !0);
              if (Ot in Re && ht in be && Re[Ot] !== be[ht]) {
                const Xt = At(Ot, ht, Gt), $t = mt(Ot, ht, Pe[Xt].geometry);
                delete be[Ot], delete Re[ht], Re[Kt(qt, Pe[$t].geometry, !0)] = $t, Pe[Xt].geometry = null;
              } else Ot in Re ? mt(Ot, ht, Gt) : ht in be ? At(Ot, ht, Gt) : (Xe(Et), be[Ot] = ze - 1, Re[ht] = ze - 1);
            }
            return Pe.filter((Et) => Et.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((me, be) => me.sortKey - be.sortKey);
        }
        update(e, r, a) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, r, this.layers, a), this.icon.programConfigurations.updatePaintArrays(e, r, this.layers, a));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(e) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(e, r) {
          const a = this.lineVertexArray.length;
          if (e.segment !== void 0) {
            let h = e.dist(r[e.segment + 1]), d = e.dist(r[e.segment]);
            const y = {};
            for (let S = e.segment + 1; S < r.length; S++) y[S] = { x: r[S].x, y: r[S].y, tileUnitDistanceFromAnchor: h }, S < r.length - 1 && (h += r[S + 1].dist(r[S]));
            for (let S = e.segment || 0; S >= 0; S--) y[S] = { x: r[S].x, y: r[S].y, tileUnitDistanceFromAnchor: d }, S > 0 && (d += r[S - 1].dist(r[S]));
            for (let S = 0; S < r.length; S++) {
              const k = y[S];
              this.lineVertexArray.emplaceBack(k.x, k.y, k.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: a, lineLength: this.lineVertexArray.length - a };
        }
        addSymbols(e, r, a, h, d, y, S, k, M, F, O, $) {
          const Y = e.indexArray, ee = e.layoutVertexArray, re = e.segments.prepareSegment(4 * r.length, ee, Y, this.canOverlap ? y.sortKey : void 0), me = this.glyphOffsetArray.length, be = re.vertexLength, Re = this.allowVerticalPlacement && S === v.ah.vertical ? Math.PI / 2 : 0, Pe = y.text && y.text.sections;
          for (let ze = 0; ze < r.length; ze++) {
            const { tl: Xe, tr: mt, bl: At, br: Kt, tex: Et, pixelOffsetTL: St, pixelOffsetBR: Gt, minFontScaleX: qt, minFontScaleY: Ot, glyphOffset: ht, isSDF: Xt, sectionIndex: $t } = r[ze], di = re.vertexLength, Qi = ht[1];
            Sh(ee, k.x, k.y, Xe.x, Qi + Xe.y, Et.x, Et.y, a, Xt, St.x, St.y, qt, Ot), Sh(ee, k.x, k.y, mt.x, Qi + mt.y, Et.x + Et.w, Et.y, a, Xt, Gt.x, St.y, qt, Ot), Sh(ee, k.x, k.y, At.x, Qi + At.y, Et.x, Et.y + Et.h, a, Xt, St.x, Gt.y, qt, Ot), Sh(ee, k.x, k.y, Kt.x, Qi + Kt.y, Et.x + Et.w, Et.y + Et.h, a, Xt, Gt.x, Gt.y, qt, Ot), pu(e.dynamicLayoutVertexArray, k, Re), Y.emplaceBack(di, di + 1, di + 2), Y.emplaceBack(di + 1, di + 2, di + 3), re.vertexLength += 4, re.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(ht[0]), ze !== r.length - 1 && $t === r[ze + 1].sectionIndex || e.programConfigurations.populatePaintArrays(ee.length, y, y.index, {}, $, Pe && Pe[$t]);
          }
          e.placedSymbolArray.emplaceBack(k.x, k.y, me, this.glyphOffsetArray.length - me, be, M, F, k.segment, a ? a[0] : 0, a ? a[1] : 0, h[0], h[1], S, 0, !1, 0, O);
        }
        _addCollisionDebugVertex(e, r, a, h, d, y) {
          return r.emplaceBack(0, 0), e.emplaceBack(a.x, a.y, h, d, Math.round(y.x), Math.round(y.y));
        }
        addCollisionDebugVertices(e, r, a, h, d, y, S) {
          const k = d.segments.prepareSegment(4, d.layoutVertexArray, d.indexArray), M = k.vertexLength, F = d.layoutVertexArray, O = d.collisionVertexArray, $ = S.anchorX, Y = S.anchorY;
          this._addCollisionDebugVertex(F, O, y, $, Y, new q(e, r)), this._addCollisionDebugVertex(F, O, y, $, Y, new q(a, r)), this._addCollisionDebugVertex(F, O, y, $, Y, new q(a, h)), this._addCollisionDebugVertex(F, O, y, $, Y, new q(e, h)), k.vertexLength += 4;
          const ee = d.indexArray;
          ee.emplaceBack(M, M + 1), ee.emplaceBack(M + 1, M + 2), ee.emplaceBack(M + 2, M + 3), ee.emplaceBack(M + 3, M), k.primitiveLength += 4;
        }
        addDebugCollisionBoxes(e, r, a, h) {
          for (let d = e; d < r; d++) {
            const y = this.collisionBoxArray.get(d);
            this.addCollisionDebugVertices(y.x1, y.y1, y.x2, y.y2, h ? this.textCollisionBox : this.iconCollisionBox, y.anchorPoint, a);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new mu(Li, Ad.members, sr), this.iconCollisionBox = new mu(Li, Ad.members, sr);
          for (let e = 0; e < this.symbolInstances.length; e++) {
            const r = this.symbolInstances.get(e);
            this.addDebugCollisionBoxes(r.textBoxStartIndex, r.textBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r, !0), this.addDebugCollisionBoxes(r.iconBoxStartIndex, r.iconBoxEndIndex, r, !1), this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex, r, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(e, r, a, h, d, y, S, k, M) {
          const F = {};
          for (let O = r; O < a; O++) {
            const $ = e.get(O);
            F.textBox = { x1: $.x1, y1: $.y1, x2: $.x2, y2: $.y2, anchorPointX: $.anchorPointX, anchorPointY: $.anchorPointY }, F.textFeatureIndex = $.featureIndex;
            break;
          }
          for (let O = h; O < d; O++) {
            const $ = e.get(O);
            F.verticalTextBox = { x1: $.x1, y1: $.y1, x2: $.x2, y2: $.y2, anchorPointX: $.anchorPointX, anchorPointY: $.anchorPointY }, F.verticalTextFeatureIndex = $.featureIndex;
            break;
          }
          for (let O = y; O < S; O++) {
            const $ = e.get(O);
            F.iconBox = { x1: $.x1, y1: $.y1, x2: $.x2, y2: $.y2, anchorPointX: $.anchorPointX, anchorPointY: $.anchorPointY }, F.iconFeatureIndex = $.featureIndex;
            break;
          }
          for (let O = k; O < M; O++) {
            const $ = e.get(O);
            F.verticalIconBox = { x1: $.x1, y1: $.y1, x2: $.x2, y2: $.y2, anchorPointX: $.anchorPointX, anchorPointY: $.anchorPointY }, F.verticalIconFeatureIndex = $.featureIndex;
            break;
          }
          return F;
        }
        deserializeCollisionBoxes(e) {
          this.collisionArrays = [];
          for (let r = 0; r < this.symbolInstances.length; r++) {
            const a = this.symbolInstances.get(r);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(e, r) {
          const a = e.placedSymbolArray.get(r), h = a.vertexStartIndex + 4 * a.numGlyphs;
          for (let d = a.vertexStartIndex; d < h; d += 4) e.indexArray.emplaceBack(d, d + 1, d + 2), e.indexArray.emplaceBack(d + 1, d + 2, d + 3);
        }
        getSortedSymbolIndexes(e) {
          if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const r = Math.sin(e), a = Math.cos(e), h = [], d = [], y = [];
          for (let S = 0; S < this.symbolInstances.length; ++S) {
            y.push(S);
            const k = this.symbolInstances.get(S);
            h.push(0 | Math.round(r * k.anchorX + a * k.anchorY)), d.push(k.featureIndex);
          }
          return y.sort((S, k) => h[S] - h[k] || d[k] - d[S]), y;
        }
        addToSortKeyRanges(e, r) {
          const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          a && a.sortKey === r ? a.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: r, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
        }
        sortFeatures(e) {
          if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const r of this.symbolInstanceIndexes) {
              const a = this.symbolInstances.get(r);
              this.featureSortOrder.push(a.featureIndex), [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach((h, d, y) => {
                h >= 0 && y.indexOf(h) === d && this.addIndicesForPlacedSymbol(this.text, h);
              }), a.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a.verticalPlacedTextSymbolIndex), a.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.placedIconSymbolIndex), a.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let Ud, Vd;
      Rt("SymbolBucket", yc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), yc.MAX_GLYPHS = 65535, yc.addDynamicAttributes = pu;
      var gu = { get paint() {
        return Vd = Vd || new c({ "icon-opacity": new ni(te.paint_symbol["icon-opacity"]), "icon-color": new ni(te.paint_symbol["icon-color"]), "icon-halo-color": new ni(te.paint_symbol["icon-halo-color"]), "icon-halo-width": new ni(te.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ni(te.paint_symbol["icon-halo-blur"]), "icon-translate": new Vt(te.paint_symbol["icon-translate"]), "icon-translate-anchor": new Vt(te.paint_symbol["icon-translate-anchor"]), "text-opacity": new ni(te.paint_symbol["text-opacity"]), "text-color": new ni(te.paint_symbol["text-color"], { runtimeType: ki, getOverride: (i) => i.textColor, hasOverride: (i) => !!i.textColor }), "text-halo-color": new ni(te.paint_symbol["text-halo-color"]), "text-halo-width": new ni(te.paint_symbol["text-halo-width"]), "text-halo-blur": new ni(te.paint_symbol["text-halo-blur"]), "text-translate": new Vt(te.paint_symbol["text-translate"]), "text-translate-anchor": new Vt(te.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return Ud = Ud || new c({ "symbol-placement": new Vt(te.layout_symbol["symbol-placement"]), "symbol-spacing": new Vt(te.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Vt(te.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ni(te.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Vt(te.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Vt(te.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Vt(te.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Vt(te.layout_symbol["icon-ignore-placement"]), "icon-optional": new Vt(te.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Vt(te.layout_symbol["icon-rotation-alignment"]), "icon-size": new ni(te.layout_symbol["icon-size"]), "icon-text-fit": new Vt(te.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Vt(te.layout_symbol["icon-text-fit-padding"]), "icon-image": new ni(te.layout_symbol["icon-image"]), "icon-rotate": new ni(te.layout_symbol["icon-rotate"]), "icon-padding": new ni(te.layout_symbol["icon-padding"]), "icon-keep-upright": new Vt(te.layout_symbol["icon-keep-upright"]), "icon-offset": new ni(te.layout_symbol["icon-offset"]), "icon-anchor": new ni(te.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Vt(te.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Vt(te.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Vt(te.layout_symbol["text-rotation-alignment"]), "text-field": new ni(te.layout_symbol["text-field"]), "text-font": new ni(te.layout_symbol["text-font"]), "text-size": new ni(te.layout_symbol["text-size"]), "text-max-width": new ni(te.layout_symbol["text-max-width"]), "text-line-height": new Vt(te.layout_symbol["text-line-height"]), "text-letter-spacing": new ni(te.layout_symbol["text-letter-spacing"]), "text-justify": new ni(te.layout_symbol["text-justify"]), "text-radial-offset": new ni(te.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Vt(te.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new ni(te.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new ni(te.layout_symbol["text-anchor"]), "text-max-angle": new Vt(te.layout_symbol["text-max-angle"]), "text-writing-mode": new Vt(te.layout_symbol["text-writing-mode"]), "text-rotate": new ni(te.layout_symbol["text-rotate"]), "text-padding": new Vt(te.layout_symbol["text-padding"]), "text-keep-upright": new Vt(te.layout_symbol["text-keep-upright"]), "text-transform": new ni(te.layout_symbol["text-transform"]), "text-offset": new ni(te.layout_symbol["text-offset"]), "text-allow-overlap": new Vt(te.layout_symbol["text-allow-overlap"]), "text-overlap": new Vt(te.layout_symbol["text-overlap"]), "text-ignore-placement": new Vt(te.layout_symbol["text-ignore-placement"]), "text-optional": new Vt(te.layout_symbol["text-optional"]) });
      } };
      class $d {
        constructor(e) {
          if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = e.property.overrides ? e.property.overrides.runtimeType : gr, this.defaultValue = e;
        }
        evaluate(e) {
          if (e.formattedSection) {
            const r = this.defaultValue.property.overrides;
            if (r && r.hasOverride(e.formattedSection)) return r.getOverride(e.formattedSection);
          }
          return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(e) {
          this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      Rt("FormatSectionOverride", $d, { omit: ["defaultValue"] });
      class Ah extends m {
        constructor(e) {
          super(e, gu);
        }
        recalculate(e, r) {
          if (super.recalculate(e, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const a = this.layout.get("text-writing-mode");
            if (a) {
              const h = [];
              for (const d of a) h.indexOf(d) < 0 && h.push(d);
              this.layout._values["text-writing-mode"] = h;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(e, r, a, h) {
          const d = this.layout.get(e).evaluate(r, {}, a, h), y = this._unevaluatedLayout._values[e];
          return y.isDataDriven() || pn(y.value) || !d ? d : function(S, k) {
            return k.replace(/{([^{}]+)}/g, (M, F) => S && F in S ? String(S[F]) : "");
          }(r.properties, d);
        }
        createBucket(e) {
          return new yc(e);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const e of gu.paint.overridableProperties) {
            if (!Ah.hasPaintOverride(this.layout, e)) continue;
            const r = this.paint.get(e), a = new $d(r), h = new ys(a, r.property.specification);
            let d = null;
            d = r.value.kind === "constant" || r.value.kind === "source" ? new Bs("source", h) : new _a("composite", h, r.value.zoomStops), this.paint._values[e] = new Ss(r.property, d, r.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(e, r, a) {
          return !(!this.layout || r.isDataDriven() || a.isDataDriven()) && Ah.hasPaintOverride(this.layout, e);
        }
        static hasPaintOverride(e, r) {
          const a = e.get("text-field"), h = gu.paint.properties[r];
          let d = !1;
          const y = (S) => {
            for (const k of S) if (h.overrides && h.overrides.hasOverride(k)) return void (d = !0);
          };
          if (a.value.kind === "constant" && a.value.value instanceof Yr) y(a.value.value.sections);
          else if (a.value.kind === "source") {
            const S = (M) => {
              d || (M instanceof us && yr(M.value) === Oi ? y(M.value.sections) : M instanceof ro ? y(M.sections) : M.eachChild(S));
            }, k = a.value;
            k._styleExpression && S(k._styleExpression.expression);
          }
          return d;
        }
      }
      let Zd;
      var Lm = { get paint() {
        return Zd = Zd || new c({ "background-color": new Vt(te.paint_background["background-color"]), "background-pattern": new t(te.paint_background["background-pattern"]), "background-opacity": new Vt(te.paint_background["background-opacity"]) });
      } };
      class Cm extends m {
        constructor(e) {
          super(e, Lm);
        }
      }
      let Wd;
      var Em = { get paint() {
        return Wd = Wd || new c({ "raster-opacity": new Vt(te.paint_raster["raster-opacity"]), "raster-hue-rotate": new Vt(te.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Vt(te.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Vt(te.paint_raster["raster-brightness-max"]), "raster-saturation": new Vt(te.paint_raster["raster-saturation"]), "raster-contrast": new Vt(te.paint_raster["raster-contrast"]), "raster-resampling": new Vt(te.paint_raster["raster-resampling"]), "raster-fade-duration": new Vt(te.paint_raster["raster-fade-duration"]) });
      } };
      class Mm extends m {
        constructor(e) {
          super(e, Em);
        }
      }
      class Dm extends m {
        constructor(e) {
          super(e, {}), this.onAdd = (r) => {
            this.implementation.onAdd && this.implementation.onAdd(r, r.painter.context.gl);
          }, this.onRemove = (r) => {
            this.implementation.onRemove && this.implementation.onRemove(r, r.painter.context.gl);
          }, this.implementation = e;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class zm {
        constructor(e) {
          this._methodToThrottle = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const yu = 63710088e-1;
      class xl {
        constructor(e, r) {
          if (isNaN(e) || isNaN(r)) throw new Error(`Invalid LngLat object: (${e}, ${r})`);
          if (this.lng = +e, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new xl(gt(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(e) {
          const r = Math.PI / 180, a = this.lat * r, h = e.lat * r, d = Math.sin(a) * Math.sin(h) + Math.cos(a) * Math.cos(h) * Math.cos((e.lng - this.lng) * r);
          return yu * Math.acos(Math.min(d, 1));
        }
        static convert(e) {
          if (e instanceof xl) return e;
          if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new xl(Number(e[0]), Number(e[1]));
          if (!Array.isArray(e) && typeof e == "object" && e !== null) return new xl(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Gd = 2 * Math.PI * yu;
      function Hd(i) {
        return Gd * Math.cos(i * Math.PI / 180);
      }
      function Xd(i) {
        return (180 + i) / 360;
      }
      function Yd(i) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360;
      }
      function Jd(i, e) {
        return i / Hd(e);
      }
      function _u(i) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90;
      }
      class Ph {
        constructor(e, r, a = 0) {
          this.x = +e, this.y = +r, this.z = +a;
        }
        static fromLngLat(e, r = 0) {
          const a = xl.convert(e);
          return new Ph(Xd(a.lng), Yd(a.lat), Jd(r, a.lat));
        }
        toLngLat() {
          return new xl(360 * this.x - 180, _u(this.y));
        }
        toAltitude() {
          return this.z * Hd(_u(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Gd * (e = _u(this.y), 1 / Math.cos(e * Math.PI / 180));
          var e;
        }
      }
      function Kd(i, e, r) {
        var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
        return [i * a - 2 * Math.PI * 6378137 / 2, e * a - 2 * Math.PI * 6378137 / 2];
      }
      class vu {
        constructor(e, r, a) {
          if (e < 0 || e > 25 || a < 0 || a >= Math.pow(2, e) || r < 0 || r >= Math.pow(2, e)) throw new Error(`x=${r}, y=${a}, z=${e} outside of bounds. 0<=x<${Math.pow(2, e)}, 0<=y<${Math.pow(2, e)} 0<=z<=25 `);
          this.z = e, this.x = r, this.y = a, this.key = Hc(0, e, e, r, a);
        }
        equals(e) {
          return this.z === e.z && this.x === e.x && this.y === e.y;
        }
        url(e, r, a) {
          const h = (y = this.y, S = this.z, k = Kd(256 * (d = this.x), 256 * (y = Math.pow(2, S) - y - 1), S), M = Kd(256 * (d + 1), 256 * (y + 1), S), k[0] + "," + k[1] + "," + M[0] + "," + M[1]);
          var d, y, S, k, M;
          const F = function(O, $, Y) {
            let ee, re = "";
            for (let me = O; me > 0; me--) ee = 1 << me - 1, re += ($ & ee ? 1 : 0) + (Y & ee ? 2 : 0);
            return re;
          }(this.z, this.x, this.y);
          return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, r > 1 ? "@2x" : "").replace(/{quadkey}/g, F).replace(/{bbox-epsg-3857}/g, h);
        }
        isChildOf(e) {
          const r = this.z - e.z;
          return r > 0 && e.x === this.x >> r && e.y === this.y >> r;
        }
        getTilePoint(e) {
          const r = Math.pow(2, this.z);
          return new q((e.x * r - this.x) * xr, (e.y * r - this.y) * xr);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Qd {
        constructor(e, r) {
          this.wrap = e, this.canonical = r, this.key = Hc(e, r.z, r.z, r.x, r.y);
        }
      }
      class Ys {
        constructor(e, r, a, h, d) {
          if (e < a) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${a}`);
          this.overscaledZ = e, this.wrap = r, this.canonical = new vu(a, +h, +d), this.key = Hc(r, e, a, h, d);
        }
        clone() {
          return new Ys(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(e) {
          return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
        }
        scaledTo(e) {
          if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
          const r = this.canonical.z - e;
          return e > this.canonical.z ? new Ys(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Ys(e, this.wrap, e, this.canonical.x >> r, this.canonical.y >> r);
        }
        calculateScaledKey(e, r) {
          if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
          const a = this.canonical.z - e;
          return e > this.canonical.z ? Hc(this.wrap * +r, e, this.canonical.z, this.canonical.x, this.canonical.y) : Hc(this.wrap * +r, e, e, this.canonical.x >> a, this.canonical.y >> a);
        }
        isChildOf(e) {
          if (e.wrap !== this.wrap) return !1;
          const r = this.canonical.z - e.canonical.z;
          return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> r && e.canonical.y === this.canonical.y >> r;
        }
        children(e) {
          if (this.overscaledZ >= e) return [new Ys(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const r = this.canonical.z + 1, a = 2 * this.canonical.x, h = 2 * this.canonical.y;
          return [new Ys(r, this.wrap, r, a, h), new Ys(r, this.wrap, r, a + 1, h), new Ys(r, this.wrap, r, a, h + 1), new Ys(r, this.wrap, r, a + 1, h + 1)];
        }
        isLessThan(e) {
          return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
        }
        wrapped() {
          return new Ys(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(e) {
          return new Ys(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Qd(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(e) {
          return this.canonical.getTilePoint(new Ph(e.x - this.wrap, e.y));
        }
      }
      function Hc(i, e, r, a, h) {
        (i *= 2) < 0 && (i = -1 * i - 1);
        const d = 1 << r;
        return (d * d * i + d * h + a).toString(36) + r.toString(36) + e.toString(36);
      }
      Rt("CanonicalTileID", vu), Rt("OverscaledTileID", Ys, { omit: ["posMatrix"] });
      class ep {
        constructor(e, r, a, h = 1, d = 1, y = 1, S = 0) {
          if (this.uid = e, r.height !== r.width) throw new RangeError("DEM tiles must be square");
          if (a && !["mapbox", "terrarium", "custom"].includes(a)) return void Ie(`"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = r.height;
          const k = this.dim = r.height - 2;
          switch (this.data = new Uint32Array(r.data.buffer), a) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = h, this.greenFactor = d, this.blueFactor = y, this.baseShift = S;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let M = 0; M < k; M++) this.data[this._idx(-1, M)] = this.data[this._idx(0, M)], this.data[this._idx(k, M)] = this.data[this._idx(k - 1, M)], this.data[this._idx(M, -1)] = this.data[this._idx(M, 0)], this.data[this._idx(M, k)] = this.data[this._idx(M, k - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(k, -1)] = this.data[this._idx(k - 1, 0)], this.data[this._idx(-1, k)] = this.data[this._idx(0, k - 1)], this.data[this._idx(k, k)] = this.data[this._idx(k - 1, k - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let M = 0; M < k; M++) for (let F = 0; F < k; F++) {
            const O = this.get(M, F);
            O > this.max && (this.max = O), O < this.min && (this.min = O);
          }
        }
        get(e, r) {
          const a = new Uint8Array(this.data.buffer), h = 4 * this._idx(e, r);
          return this.unpack(a[h], a[h + 1], a[h + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(e, r) {
          if (e < -1 || e >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (r + 1) * this.stride + (e + 1);
        }
        unpack(e, r, a) {
          return e * this.redFactor + r * this.greenFactor + a * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new Xs({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(e, r, a) {
          if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
          let h = r * this.dim, d = r * this.dim + this.dim, y = a * this.dim, S = a * this.dim + this.dim;
          switch (r) {
            case -1:
              h = d - 1;
              break;
            case 1:
              d = h + 1;
          }
          switch (a) {
            case -1:
              y = S - 1;
              break;
            case 1:
              S = y + 1;
          }
          const k = -r * this.dim, M = -a * this.dim;
          for (let F = y; F < S; F++) for (let O = h; O < d; O++) this.data[this._idx(O, F)] = e.data[this._idx(O + k, F + M)];
        }
      }
      Rt("DEMData", ep);
      class tp {
        constructor(e) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let r = 0; r < e.length; r++) {
            const a = e[r];
            this._stringToNumber[a] = r, this._numberToString[r] = a;
          }
        }
        encode(e) {
          return this._stringToNumber[e];
        }
        decode(e) {
          if (e >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[e];
        }
      }
      class ip {
        constructor(e, r, a, h, d) {
          this.type = "Feature", this._vectorTileFeature = e, e._z = r, e._x = a, e._y = h, this.properties = e.properties, this.id = d;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(e) {
          this._geometry = e;
        }
        toJSON() {
          const e = { geometry: this.geometry };
          for (const r in this) r !== "_geometry" && r !== "_vectorTileFeature" && (e[r] = this[r]);
          return e;
        }
      }
      class rp {
        constructor(e, r) {
          this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new Uo(xr, 16, 0), this.grid3D = new Uo(xr, 16, 0), this.featureIndexArray = new fr(), this.promoteId = r;
        }
        insert(e, r, a, h, d, y) {
          const S = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(a, h, d);
          const k = y ? this.grid3D : this.grid;
          for (let M = 0; M < r.length; M++) {
            const F = r[M], O = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let $ = 0; $ < F.length; $++) {
              const Y = F[$];
              O[0] = Math.min(O[0], Y.x), O[1] = Math.min(O[1], Y.y), O[2] = Math.max(O[2], Y.x), O[3] = Math.max(O[3], Y.y);
            }
            O[0] < xr && O[1] < xr && O[2] >= 0 && O[3] >= 0 && k.insert(S, O[0], O[1], O[2], O[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new yl.VectorTile(new ou(this.rawTileData)).layers, this.sourceLayerCoder = new tp(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(e, r, a, h) {
          this.loadVTLayers();
          const d = e.params || {}, y = xr / e.tileSize / e.scale, S = Zi(d.filter), k = e.queryGeometry, M = e.queryPadding * y, F = sp(k), O = this.grid.query(F.minX - M, F.minY - M, F.maxX + M, F.maxY + M), $ = sp(e.cameraQueryGeometry), Y = this.grid3D.query($.minX - M, $.minY - M, $.maxX + M, $.maxY + M, (me, be, Re, Pe) => function(ze, Xe, mt, At, Kt) {
            for (const St of ze) if (Xe <= St.x && mt <= St.y && At >= St.x && Kt >= St.y) return !0;
            const Et = [new q(Xe, mt), new q(Xe, Kt), new q(At, Kt), new q(At, mt)];
            if (ze.length > 2) {
              for (const St of Et) if (os(ze, St)) return !0;
            }
            for (let St = 0; St < ze.length - 1; St++) if (xo(ze[St], ze[St + 1], Et)) return !0;
            return !1;
          }(e.cameraQueryGeometry, me - M, be - M, Re + M, Pe + M));
          for (const me of Y) O.push(me);
          O.sort(Fm);
          const ee = {};
          let re;
          for (let me = 0; me < O.length; me++) {
            const be = O[me];
            if (be === re) continue;
            re = be;
            const Re = this.featureIndexArray.get(be);
            let Pe = null;
            this.loadMatchingFeature(ee, Re.bucketIndex, Re.sourceLayerIndex, Re.featureIndex, S, d.layers, d.availableImages, r, a, h, (ze, Xe, mt) => (Pe || (Pe = _o(ze)), Xe.queryIntersectsFeature(k, ze, mt, Pe, this.z, e.transform, y, e.pixelPosMatrix)));
          }
          return ee;
        }
        loadMatchingFeature(e, r, a, h, d, y, S, k, M, F, O) {
          const $ = this.bucketLayerIDs[r];
          if (y && !function(me, be) {
            for (let Re = 0; Re < me.length; Re++) if (be.indexOf(me[Re]) >= 0) return !0;
            return !1;
          }(y, $)) return;
          const Y = this.sourceLayerCoder.decode(a), ee = this.vtLayers[Y].feature(h);
          if (d.needGeometry) {
            const me = Go(ee, !0);
            if (!d.filter(new ji(this.tileID.overscaledZ), me, this.tileID.canonical)) return;
          } else if (!d.filter(new ji(this.tileID.overscaledZ), ee)) return;
          const re = this.getId(ee, Y);
          for (let me = 0; me < $.length; me++) {
            const be = $[me];
            if (y && y.indexOf(be) < 0) continue;
            const Re = k[be];
            if (!Re) continue;
            let Pe = {};
            re && F && (Pe = F.getState(Re.sourceLayer || "_geojsonTileLayer", re));
            const ze = $e({}, M[be]);
            ze.paint = np(ze.paint, Re.paint, ee, Pe, S), ze.layout = np(ze.layout, Re.layout, ee, Pe, S);
            const Xe = !O || O(ee, Re, Pe);
            if (!Xe) continue;
            const mt = new ip(ee, this.z, this.x, this.y, re);
            mt.layer = ze;
            let At = e[be];
            At === void 0 && (At = e[be] = []), At.push({ featureIndex: h, feature: mt, intersectionZ: Xe });
          }
        }
        lookupSymbolFeatures(e, r, a, h, d, y, S, k) {
          const M = {};
          this.loadVTLayers();
          const F = Zi(d);
          for (const O of e) this.loadMatchingFeature(M, a, h, O, F, y, S, k, r);
          return M;
        }
        hasLayer(e) {
          for (const r of this.bucketLayerIDs) for (const a of r) if (e === a) return !0;
          return !1;
        }
        getId(e, r) {
          let a = e.id;
          return this.promoteId && (a = e.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[r]], typeof a == "boolean" && (a = Number(a))), a;
        }
      }
      function np(i, e, r, a, h) {
        return dt(i, (d, y) => {
          const S = e instanceof ul ? e.get(y) : null;
          return S && S.evaluate ? S.evaluate(r, a, h) : S;
        });
      }
      function sp(i) {
        let e = 1 / 0, r = 1 / 0, a = -1 / 0, h = -1 / 0;
        for (const d of i) e = Math.min(e, d.x), r = Math.min(r, d.y), a = Math.max(a, d.x), h = Math.max(h, d.y);
        return { minX: e, minY: r, maxX: a, maxY: h };
      }
      function Fm(i, e) {
        return e - i;
      }
      function ap(i, e, r, a, h) {
        const d = [];
        for (let y = 0; y < i.length; y++) {
          const S = i[y];
          let k;
          for (let M = 0; M < S.length - 1; M++) {
            let F = S[M], O = S[M + 1];
            F.x < e && O.x < e || (F.x < e ? F = new q(e, F.y + (e - F.x) / (O.x - F.x) * (O.y - F.y))._round() : O.x < e && (O = new q(e, F.y + (e - F.x) / (O.x - F.x) * (O.y - F.y))._round()), F.y < r && O.y < r || (F.y < r ? F = new q(F.x + (r - F.y) / (O.y - F.y) * (O.x - F.x), r)._round() : O.y < r && (O = new q(F.x + (r - F.y) / (O.y - F.y) * (O.x - F.x), r)._round()), F.x >= a && O.x >= a || (F.x >= a ? F = new q(a, F.y + (a - F.x) / (O.x - F.x) * (O.y - F.y))._round() : O.x >= a && (O = new q(a, F.y + (a - F.x) / (O.x - F.x) * (O.y - F.y))._round()), F.y >= h && O.y >= h || (F.y >= h ? F = new q(F.x + (h - F.y) / (O.y - F.y) * (O.x - F.x), h)._round() : O.y >= h && (O = new q(F.x + (h - F.y) / (O.y - F.y) * (O.x - F.x), h)._round()), k && F.equals(k[k.length - 1]) || (k = [F], d.push(k)), k.push(O)))));
          }
        }
        return d;
      }
      Rt("FeatureIndex", rp, { omit: ["rawTileData", "sourceLayerCoder"] });
      class bl extends q {
        constructor(e, r, a, h) {
          super(e, r), this.angle = a, h !== void 0 && (this.segment = h);
        }
        clone() {
          return new bl(this.x, this.y, this.angle, this.segment);
        }
      }
      function op(i, e, r, a, h) {
        if (e.segment === void 0 || r === 0) return !0;
        let d = e, y = e.segment + 1, S = 0;
        for (; S > -r / 2; ) {
          if (y--, y < 0) return !1;
          S -= i[y].dist(d), d = i[y];
        }
        S += i[y].dist(i[y + 1]), y++;
        const k = [];
        let M = 0;
        for (; S < r / 2; ) {
          const F = i[y], O = i[y + 1];
          if (!O) return !1;
          let $ = i[y - 1].angleTo(F) - F.angleTo(O);
          for ($ = Math.abs(($ + 3 * Math.PI) % (2 * Math.PI) - Math.PI), k.push({ distance: S, angleDelta: $ }), M += $; S - k[0].distance > a; ) M -= k.shift().angleDelta;
          if (M > h) return !1;
          y++, S += F.dist(O);
        }
        return !0;
      }
      function lp(i) {
        let e = 0;
        for (let r = 0; r < i.length - 1; r++) e += i[r].dist(i[r + 1]);
        return e;
      }
      function cp(i, e, r) {
        return i ? 0.6 * e * r : 0;
      }
      function hp(i, e) {
        return Math.max(i ? i.right - i.left : 0, e ? e.right - e.left : 0);
      }
      function Nm(i, e, r, a, h, d) {
        const y = cp(r, h, d), S = hp(r, a) * d;
        let k = 0;
        const M = lp(i) / 2;
        for (let F = 0; F < i.length - 1; F++) {
          const O = i[F], $ = i[F + 1], Y = O.dist($);
          if (k + Y > M) {
            const ee = (M - k) / Y, re = Rr.number(O.x, $.x, ee), me = Rr.number(O.y, $.y, ee), be = new bl(re, me, $.angleTo(O), F);
            return be._round(), !y || op(i, be, S, y, e) ? be : void 0;
          }
          k += Y;
        }
      }
      function Rm(i, e, r, a, h, d, y, S, k) {
        const M = cp(a, d, y), F = hp(a, h), O = F * y, $ = i[0].x === 0 || i[0].x === k || i[0].y === 0 || i[0].y === k;
        return e - O < e / 4 && (e = O + e / 4), up(i, $ ? e / 2 * S % e : (F / 2 + 2 * d) * y * S % e, e, M, r, O, $, !1, k);
      }
      function up(i, e, r, a, h, d, y, S, k) {
        const M = d / 2, F = lp(i);
        let O = 0, $ = e - r, Y = [];
        for (let ee = 0; ee < i.length - 1; ee++) {
          const re = i[ee], me = i[ee + 1], be = re.dist(me), Re = me.angleTo(re);
          for (; $ + r < O + be; ) {
            $ += r;
            const Pe = ($ - O) / be, ze = Rr.number(re.x, me.x, Pe), Xe = Rr.number(re.y, me.y, Pe);
            if (ze >= 0 && ze < k && Xe >= 0 && Xe < k && $ - M >= 0 && $ + M <= F) {
              const mt = new bl(ze, Xe, Re, ee);
              mt._round(), a && !op(i, mt, d, a, h) || Y.push(mt);
            }
          }
          O += be;
        }
        return S || Y.length || y || (Y = up(i, O / 2, r, a, h, d, y, !0, k)), Y;
      }
      Rt("Anchor", bl);
      const _c = ls;
      function dp(i, e, r, a) {
        const h = [], d = i.image, y = d.pixelRatio, S = d.paddedRect.w - 2 * _c, k = d.paddedRect.h - 2 * _c;
        let M = { x1: i.left, y1: i.top, x2: i.right, y2: i.bottom };
        const F = d.stretchX || [[0, S]], O = d.stretchY || [[0, k]], $ = (ht, Xt) => ht + Xt[1] - Xt[0], Y = F.reduce($, 0), ee = O.reduce($, 0), re = S - Y, me = k - ee;
        let be = 0, Re = Y, Pe = 0, ze = ee, Xe = 0, mt = re, At = 0, Kt = me;
        if (d.content && a) {
          const ht = d.content, Xt = ht[2] - ht[0], $t = ht[3] - ht[1];
          (d.textFitWidth || d.textFitHeight) && (M = Od(i)), be = Ih(F, 0, ht[0]), Pe = Ih(O, 0, ht[1]), Re = Ih(F, ht[0], ht[2]), ze = Ih(O, ht[1], ht[3]), Xe = ht[0] - be, At = ht[1] - Pe, mt = Xt - Re, Kt = $t - ze;
        }
        const Et = M.x1, St = M.y1, Gt = M.x2 - Et, qt = M.y2 - St, Ot = (ht, Xt, $t, di) => {
          const Qi = Th(ht.stretch - be, Re, Gt, Et), Yi = kh(ht.fixed - Xe, mt, ht.stretch, Y), tn = Th(Xt.stretch - Pe, ze, qt, St), Pa = kh(Xt.fixed - At, Kt, Xt.stretch, ee), _n = Th($t.stretch - be, Re, Gt, Et), Cr = kh($t.fixed - Xe, mt, $t.stretch, Y), Vn = Th(di.stretch - Pe, ze, qt, St), $n = kh(di.fixed - At, Kt, di.stretch, ee), Zn = new q(Qi, tn), Er = new q(_n, tn), rn = new q(_n, Vn), Ln = new q(Qi, Vn), vn = new q(Yi / y, Pa / y), Wn = new q(Cr / y, $n / y), xn = e * Math.PI / 180;
          if (xn) {
            const Bi = Math.sin(xn), ar = Math.cos(xn), dr = [ar, -Bi, Bi, ar];
            Zn._matMult(dr), Er._matMult(dr), Ln._matMult(dr), rn._matMult(dr);
          }
          const Js = ht.stretch + ht.fixed, cs = Xt.stretch + Xt.fixed;
          return { tl: Zn, tr: Er, bl: Ln, br: rn, tex: { x: d.paddedRect.x + _c + Js, y: d.paddedRect.y + _c + cs, w: $t.stretch + $t.fixed - Js, h: di.stretch + di.fixed - cs }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: vn, pixelOffsetBR: Wn, minFontScaleX: mt / y / Gt, minFontScaleY: Kt / y / qt, isSDF: r };
        };
        if (a && (d.stretchX || d.stretchY)) {
          const ht = pp(F, re, Y), Xt = pp(O, me, ee);
          for (let $t = 0; $t < ht.length - 1; $t++) {
            const di = ht[$t], Qi = ht[$t + 1];
            for (let Yi = 0; Yi < Xt.length - 1; Yi++) h.push(Ot(di, Xt[Yi], Qi, Xt[Yi + 1]));
          }
        } else h.push(Ot({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: S + 1 }, { fixed: 0, stretch: k + 1 }));
        return h;
      }
      function Ih(i, e, r) {
        let a = 0;
        for (const h of i) a += Math.max(e, Math.min(r, h[1])) - Math.max(e, Math.min(r, h[0]));
        return a;
      }
      function pp(i, e, r) {
        const a = [{ fixed: -_c, stretch: 0 }];
        for (const [h, d] of i) {
          const y = a[a.length - 1];
          a.push({ fixed: h - y.stretch, stretch: y.stretch }), a.push({ fixed: h - y.stretch, stretch: y.stretch + (d - h) });
        }
        return a.push({ fixed: e + _c, stretch: r }), a;
      }
      function Th(i, e, r, a) {
        return i / e * r + a;
      }
      function kh(i, e, r, a) {
        return i - e * r / a;
      }
      class Lh {
        constructor(e, r, a, h, d, y, S, k, M, F) {
          var O;
          if (this.boxStartIndex = e.length, M) {
            let $ = y.top, Y = y.bottom;
            const ee = y.collisionPadding;
            ee && ($ -= ee[1], Y += ee[3]);
            let re = Y - $;
            re > 0 && (re = Math.max(10, re), this.circleDiameter = re);
          } else {
            const $ = !((O = y.image) === null || O === void 0) && O.content && (y.image.textFitWidth || y.image.textFitHeight) ? Od(y) : { x1: y.left, y1: y.top, x2: y.right, y2: y.bottom };
            $.y1 = $.y1 * S - k[0], $.y2 = $.y2 * S + k[2], $.x1 = $.x1 * S - k[3], $.x2 = $.x2 * S + k[1];
            const Y = y.collisionPadding;
            if (Y && ($.x1 -= Y[0] * S, $.y1 -= Y[1] * S, $.x2 += Y[2] * S, $.y2 += Y[3] * S), F) {
              const ee = new q($.x1, $.y1), re = new q($.x2, $.y1), me = new q($.x1, $.y2), be = new q($.x2, $.y2), Re = F * Math.PI / 180;
              ee._rotate(Re), re._rotate(Re), me._rotate(Re), be._rotate(Re), $.x1 = Math.min(ee.x, re.x, me.x, be.x), $.x2 = Math.max(ee.x, re.x, me.x, be.x), $.y1 = Math.min(ee.y, re.y, me.y, be.y), $.y2 = Math.max(ee.y, re.y, me.y, be.y);
            }
            e.emplaceBack(r.x, r.y, $.x1, $.y1, $.x2, $.y2, a, h, d);
          }
          this.boxEndIndex = e.length;
        }
      }
      class Bm {
        constructor(e = [], r = Om) {
          if (this.data = e, this.length = this.data.length, this.compare = r, this.length > 0) for (let a = (this.length >> 1) - 1; a >= 0; a--) this._down(a);
        }
        push(e) {
          this.data.push(e), this.length++, this._up(this.length - 1);
        }
        pop() {
          if (this.length === 0) return;
          const e = this.data[0], r = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = r, this._down(0)), e;
        }
        peek() {
          return this.data[0];
        }
        _up(e) {
          const { data: r, compare: a } = this, h = r[e];
          for (; e > 0; ) {
            const d = e - 1 >> 1, y = r[d];
            if (a(h, y) >= 0) break;
            r[e] = y, e = d;
          }
          r[e] = h;
        }
        _down(e) {
          const { data: r, compare: a } = this, h = this.length >> 1, d = r[e];
          for (; e < h; ) {
            let y = 1 + (e << 1), S = r[y];
            const k = y + 1;
            if (k < this.length && a(r[k], S) < 0 && (y = k, S = r[k]), a(S, d) >= 0) break;
            r[e] = S, e = y;
          }
          r[e] = d;
        }
      }
      function Om(i, e) {
        return i < e ? -1 : i > e ? 1 : 0;
      }
      function jm(i, e = 1, r = !1) {
        let a = 1 / 0, h = 1 / 0, d = -1 / 0, y = -1 / 0;
        const S = i[0];
        for (let Y = 0; Y < S.length; Y++) {
          const ee = S[Y];
          (!Y || ee.x < a) && (a = ee.x), (!Y || ee.y < h) && (h = ee.y), (!Y || ee.x > d) && (d = ee.x), (!Y || ee.y > y) && (y = ee.y);
        }
        const k = Math.min(d - a, y - h);
        let M = k / 2;
        const F = new Bm([], qm);
        if (k === 0) return new q(a, h);
        for (let Y = a; Y < d; Y += k) for (let ee = h; ee < y; ee += k) F.push(new vc(Y + M, ee + M, M, i));
        let O = function(Y) {
          let ee = 0, re = 0, me = 0;
          const be = Y[0];
          for (let Re = 0, Pe = be.length, ze = Pe - 1; Re < Pe; ze = Re++) {
            const Xe = be[Re], mt = be[ze], At = Xe.x * mt.y - mt.x * Xe.y;
            re += (Xe.x + mt.x) * At, me += (Xe.y + mt.y) * At, ee += 3 * At;
          }
          return new vc(re / ee, me / ee, 0, Y);
        }(i), $ = F.length;
        for (; F.length; ) {
          const Y = F.pop();
          (Y.d > O.d || !O.d) && (O = Y, r && console.log("found best %d after %d probes", Math.round(1e4 * Y.d) / 1e4, $)), Y.max - O.d <= e || (M = Y.h / 2, F.push(new vc(Y.p.x - M, Y.p.y - M, M, i)), F.push(new vc(Y.p.x + M, Y.p.y - M, M, i)), F.push(new vc(Y.p.x - M, Y.p.y + M, M, i)), F.push(new vc(Y.p.x + M, Y.p.y + M, M, i)), $ += 4);
        }
        return r && (console.log(`num probes: ${$}`), console.log(`best distance: ${O.d}`)), O.p;
      }
      function qm(i, e) {
        return e.max - i.max;
      }
      function vc(i, e, r, a) {
        this.p = new q(i, e), this.h = r, this.d = function(h, d) {
          let y = !1, S = 1 / 0;
          for (let k = 0; k < d.length; k++) {
            const M = d[k];
            for (let F = 0, O = M.length, $ = O - 1; F < O; $ = F++) {
              const Y = M[F], ee = M[$];
              Y.y > h.y != ee.y > h.y && h.x < (ee.x - Y.x) * (h.y - Y.y) / (ee.y - Y.y) + Y.x && (y = !y), S = Math.min(S, Wl(h, Y, ee));
            }
          }
          return (y ? 1 : -1) * Math.sqrt(S);
        }(this.p, a), this.max = this.d + this.h * Math.SQRT2;
      }
      var yn;
      v.aq = void 0, (yn = v.aq || (v.aq = {}))[yn.center = 1] = "center", yn[yn.left = 2] = "left", yn[yn.right = 3] = "right", yn[yn.top = 4] = "top", yn[yn.bottom = 5] = "bottom", yn[yn["top-left"] = 6] = "top-left", yn[yn["top-right"] = 7] = "top-right", yn[yn["bottom-left"] = 8] = "bottom-left", yn[yn["bottom-right"] = 9] = "bottom-right";
      const wl = 7, xu = Number.POSITIVE_INFINITY;
      function fp(i, e) {
        return e[1] !== xu ? function(r, a, h) {
          let d = 0, y = 0;
          switch (a = Math.abs(a), h = Math.abs(h), r) {
            case "top-right":
            case "top-left":
            case "top":
              y = h - wl;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              y = -h + wl;
          }
          switch (r) {
            case "top-right":
            case "bottom-right":
            case "right":
              d = -a;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              d = a;
          }
          return [d, y];
        }(i, e[0], e[1]) : function(r, a) {
          let h = 0, d = 0;
          a < 0 && (a = 0);
          const y = a / Math.SQRT2;
          switch (r) {
            case "top-right":
            case "top-left":
              d = y - wl;
              break;
            case "bottom-right":
            case "bottom-left":
              d = -y + wl;
              break;
            case "bottom":
              d = -a + wl;
              break;
            case "top":
              d = a - wl;
          }
          switch (r) {
            case "top-right":
            case "bottom-right":
              h = -y;
              break;
            case "top-left":
            case "bottom-left":
              h = y;
              break;
            case "left":
              h = a;
              break;
            case "right":
              h = -a;
          }
          return [h, d];
        }(i, e[0]);
      }
      function mp(i, e, r) {
        var a;
        const h = i.layout, d = (a = h.get("text-variable-anchor-offset")) === null || a === void 0 ? void 0 : a.evaluate(e, {}, r);
        if (d) {
          const S = d.values, k = [];
          for (let M = 0; M < S.length; M += 2) {
            const F = k[M] = S[M], O = S[M + 1].map(($) => $ * Wr);
            F.startsWith("top") ? O[1] -= wl : F.startsWith("bottom") && (O[1] += wl), k[M + 1] = O;
          }
          return new Kr(k);
        }
        const y = h.get("text-variable-anchor");
        if (y) {
          let S;
          S = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [h.get("text-radial-offset").evaluate(e, {}, r) * Wr, xu] : h.get("text-offset").evaluate(e, {}, r).map((M) => M * Wr);
          const k = [];
          for (const M of y) k.push(M, fp(M, S));
          return new Kr(k);
        }
        return null;
      }
      function bu(i) {
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Um(i, e, r, a, h, d, y, S, k, M, F) {
        let O = d.textMaxSize.evaluate(e, {});
        O === void 0 && (O = y);
        const $ = i.layers[0].layout, Y = $.get("icon-offset").evaluate(e, {}, F), ee = yp(r.horizontal), re = y / 24, me = i.tilePixelRatio * re, be = i.tilePixelRatio * O / 24, Re = i.tilePixelRatio * S, Pe = i.tilePixelRatio * $.get("symbol-spacing"), ze = $.get("text-padding") * i.tilePixelRatio, Xe = function(ht, Xt, $t, di = 1) {
          const Qi = ht.get("icon-padding").evaluate(Xt, {}, $t), Yi = Qi && Qi.values;
          return [Yi[0] * di, Yi[1] * di, Yi[2] * di, Yi[3] * di];
        }($, e, F, i.tilePixelRatio), mt = $.get("text-max-angle") / 180 * Math.PI, At = $.get("text-rotation-alignment") !== "viewport" && $.get("symbol-placement") !== "point", Kt = $.get("icon-rotation-alignment") === "map" && $.get("symbol-placement") !== "point", Et = $.get("symbol-placement"), St = Pe / 2, Gt = $.get("icon-text-fit");
        let qt;
        a && Gt !== "none" && (i.allowVerticalPlacement && r.vertical && (qt = jd(a, r.vertical, Gt, $.get("icon-text-fit-padding"), Y, re)), ee && (a = jd(a, ee, Gt, $.get("icon-text-fit-padding"), Y, re)));
        const Ot = (ht, Xt) => {
          Xt.x < 0 || Xt.x >= xr || Xt.y < 0 || Xt.y >= xr || function($t, di, Qi, Yi, tn, Pa, _n, Cr, Vn, $n, Zn, Er, rn, Ln, vn, Wn, xn, Js, cs, Bi, ar, dr, Ts, wr, xc) {
            const So = $t.addToLineVertexArray(di, Qi);
            let Ao, Ia, Ks, ln, Xo = 0, Jc = 0, bp = 0, wp = 0, Lu = -1, Cu = -1;
            const Yo = {};
            let Sp = ja("");
            if ($t.allowVerticalPlacement && Yi.vertical) {
              const Cn = Cr.layout.get("text-rotate").evaluate(ar, {}, wr) + 90;
              Ks = new Lh(Vn, di, $n, Zn, Er, Yi.vertical, rn, Ln, vn, Cn), _n && (ln = new Lh(Vn, di, $n, Zn, Er, _n, xn, Js, vn, Cn));
            }
            if (tn) {
              const Cn = Cr.layout.get("icon-rotate").evaluate(ar, {}), Qs = Cr.layout.get("icon-text-fit") !== "none", Xl = dp(tn, Cn, Ts, Qs), Ua = _n ? dp(_n, Cn, Ts, Qs) : void 0;
              Ia = new Lh(Vn, di, $n, Zn, Er, tn, xn, Js, !1, Cn), Xo = 4 * Xl.length;
              const Yl = $t.iconSizeData;
              let Po = null;
              Yl.kind === "source" ? (Po = [wo * Cr.layout.get("icon-size").evaluate(ar, {})], Po[0] > vl && Ie(`${$t.layerIds[0]}: Value for "icon-size" is >= ${Gc}. Reduce your "icon-size".`)) : Yl.kind === "composite" && (Po = [wo * dr.compositeIconSizes[0].evaluate(ar, {}, wr), wo * dr.compositeIconSizes[1].evaluate(ar, {}, wr)], (Po[0] > vl || Po[1] > vl) && Ie(`${$t.layerIds[0]}: Value for "icon-size" is >= ${Gc}. Reduce your "icon-size".`)), $t.addSymbols($t.icon, Xl, Po, Bi, cs, ar, v.ah.none, di, So.lineStartIndex, So.lineLength, -1, wr), Lu = $t.icon.placedSymbolArray.length - 1, Ua && (Jc = 4 * Ua.length, $t.addSymbols($t.icon, Ua, Po, Bi, cs, ar, v.ah.vertical, di, So.lineStartIndex, So.lineLength, -1, wr), Cu = $t.icon.placedSymbolArray.length - 1);
            }
            const Ap = Object.keys(Yi.horizontal);
            for (const Cn of Ap) {
              const Qs = Yi.horizontal[Cn];
              if (!Ao) {
                Sp = ja(Qs.text);
                const Ua = Cr.layout.get("text-rotate").evaluate(ar, {}, wr);
                Ao = new Lh(Vn, di, $n, Zn, Er, Qs, rn, Ln, vn, Ua);
              }
              const Xl = Qs.positionedLines.length === 1;
              if (bp += gp($t, di, Qs, Pa, Cr, vn, ar, Wn, So, Yi.vertical ? v.ah.horizontal : v.ah.horizontalOnly, Xl ? Ap : [Cn], Yo, Lu, dr, wr), Xl) break;
            }
            Yi.vertical && (wp += gp($t, di, Yi.vertical, Pa, Cr, vn, ar, Wn, So, v.ah.vertical, ["vertical"], Yo, Cu, dr, wr));
            const Zm = Ao ? Ao.boxStartIndex : $t.collisionBoxArray.length, Wm = Ao ? Ao.boxEndIndex : $t.collisionBoxArray.length, Gm = Ks ? Ks.boxStartIndex : $t.collisionBoxArray.length, Hm = Ks ? Ks.boxEndIndex : $t.collisionBoxArray.length, Xm = Ia ? Ia.boxStartIndex : $t.collisionBoxArray.length, Ym = Ia ? Ia.boxEndIndex : $t.collisionBoxArray.length, Jm = ln ? ln.boxStartIndex : $t.collisionBoxArray.length, Km = ln ? ln.boxEndIndex : $t.collisionBoxArray.length;
            let qa = -1;
            const Eh = (Cn, Qs) => Cn && Cn.circleDiameter ? Math.max(Cn.circleDiameter, Qs) : Qs;
            qa = Eh(Ao, qa), qa = Eh(Ks, qa), qa = Eh(Ia, qa), qa = Eh(ln, qa);
            const Pp = qa > -1 ? 1 : 0;
            Pp && (qa *= xc / Wr), $t.glyphOffsetArray.length >= yc.MAX_GLYPHS && Ie("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), ar.sortKey !== void 0 && $t.addToSortKeyRanges($t.symbolInstances.length, ar.sortKey);
            const Qm = mp(Cr, ar, wr), [eg, tg] = function(Cn, Qs) {
              const Xl = Cn.length, Ua = Qs == null ? void 0 : Qs.values;
              if ((Ua == null ? void 0 : Ua.length) > 0) for (let Yl = 0; Yl < Ua.length; Yl += 2) {
                const Po = Ua[Yl + 1];
                Cn.emplaceBack(v.aq[Ua[Yl]], Po[0], Po[1]);
              }
              return [Xl, Cn.length];
            }($t.textAnchorOffsets, Qm);
            $t.symbolInstances.emplaceBack(di.x, di.y, Yo.right >= 0 ? Yo.right : -1, Yo.center >= 0 ? Yo.center : -1, Yo.left >= 0 ? Yo.left : -1, Yo.vertical || -1, Lu, Cu, Sp, Zm, Wm, Gm, Hm, Xm, Ym, Jm, Km, $n, bp, wp, Xo, Jc, Pp, 0, rn, qa, eg, tg);
          }(i, Xt, ht, r, a, h, qt, i.layers[0], i.collisionBoxArray, e.index, e.sourceLayerIndex, i.index, me, [ze, ze, ze, ze], At, k, Re, Xe, Kt, Y, e, d, M, F, y);
        };
        if (Et === "line") for (const ht of ap(e.geometry, 0, 0, xr, xr)) {
          const Xt = Rm(ht, Pe, mt, r.vertical || ee, a, 24, be, i.overscaling, xr);
          for (const $t of Xt) ee && Vm(i, ee.text, St, $t) || Ot(ht, $t);
        }
        else if (Et === "line-center") {
          for (const ht of e.geometry) if (ht.length > 1) {
            const Xt = Nm(ht, mt, r.vertical || ee, a, 24, be);
            Xt && Ot(ht, Xt);
          }
        } else if (e.type === "Polygon") for (const ht of ca(e.geometry, 0)) {
          const Xt = jm(ht, 16);
          Ot(ht[0], new bl(Xt.x, Xt.y, 0));
        }
        else if (e.type === "LineString") for (const ht of e.geometry) Ot(ht, new bl(ht[0].x, ht[0].y, 0));
        else if (e.type === "Point") for (const ht of e.geometry) for (const Xt of ht) Ot([Xt], new bl(Xt.x, Xt.y, 0));
      }
      function gp(i, e, r, a, h, d, y, S, k, M, F, O, $, Y, ee) {
        const re = function(Re, Pe, ze, Xe, mt, At, Kt, Et) {
          const St = Xe.layout.get("text-rotate").evaluate(At, {}) * Math.PI / 180, Gt = [];
          for (const qt of Pe.positionedLines) for (const Ot of qt.positionedGlyphs) {
            if (!Ot.rect) continue;
            const ht = Ot.rect || {};
            let Xt = Md + 1, $t = !0, di = 1, Qi = 0;
            const Yi = (mt || Et) && Ot.vertical, tn = Ot.metrics.advance * Ot.scale / 2;
            if (Et && Pe.verticalizable && (Qi = qt.lineOffset / 2 - (Ot.imageName ? -(Wr - Ot.metrics.width * Ot.scale) / 2 : (Ot.scale - 1) * Wr)), Ot.imageName) {
              const Bi = Kt[Ot.imageName];
              $t = Bi.sdf, di = Bi.pixelRatio, Xt = ls / di;
            }
            const Pa = mt ? [Ot.x + tn, Ot.y] : [0, 0];
            let _n = mt ? [0, 0] : [Ot.x + tn + ze[0], Ot.y + ze[1] - Qi], Cr = [0, 0];
            Yi && (Cr = _n, _n = [0, 0]);
            const Vn = Ot.metrics.isDoubleResolution ? 2 : 1, $n = (Ot.metrics.left - Xt) * Ot.scale - tn + _n[0], Zn = (-Ot.metrics.top - Xt) * Ot.scale + _n[1], Er = $n + ht.w / Vn * Ot.scale / di, rn = Zn + ht.h / Vn * Ot.scale / di, Ln = new q($n, Zn), vn = new q(Er, Zn), Wn = new q($n, rn), xn = new q(Er, rn);
            if (Yi) {
              const Bi = new q(-tn, tn - Zc), ar = -Math.PI / 2, dr = Wr / 2 - tn, Ts = new q(5 - Zc - dr, -(Ot.imageName ? dr : 0)), wr = new q(...Cr);
              Ln._rotateAround(ar, Bi)._add(Ts)._add(wr), vn._rotateAround(ar, Bi)._add(Ts)._add(wr), Wn._rotateAround(ar, Bi)._add(Ts)._add(wr), xn._rotateAround(ar, Bi)._add(Ts)._add(wr);
            }
            if (St) {
              const Bi = Math.sin(St), ar = Math.cos(St), dr = [ar, -Bi, Bi, ar];
              Ln._matMult(dr), vn._matMult(dr), Wn._matMult(dr), xn._matMult(dr);
            }
            const Js = new q(0, 0), cs = new q(0, 0);
            Gt.push({ tl: Ln, tr: vn, bl: Wn, br: xn, tex: ht, writingMode: Pe.writingMode, glyphOffset: Pa, sectionIndex: Ot.sectionIndex, isSDF: $t, pixelOffsetTL: Js, pixelOffsetBR: cs, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return Gt;
        }(0, r, S, h, d, y, a, i.allowVerticalPlacement), me = i.textSizeData;
        let be = null;
        me.kind === "source" ? (be = [wo * h.layout.get("text-size").evaluate(y, {})], be[0] > vl && Ie(`${i.layerIds[0]}: Value for "text-size" is >= ${Gc}. Reduce your "text-size".`)) : me.kind === "composite" && (be = [wo * Y.compositeTextSizes[0].evaluate(y, {}, ee), wo * Y.compositeTextSizes[1].evaluate(y, {}, ee)], (be[0] > vl || be[1] > vl) && Ie(`${i.layerIds[0]}: Value for "text-size" is >= ${Gc}. Reduce your "text-size".`)), i.addSymbols(i.text, re, be, S, d, y, M, e, k.lineStartIndex, k.lineLength, $, ee);
        for (const Re of F) O[Re] = i.text.placedSymbolArray.length - 1;
        return 4 * re.length;
      }
      function yp(i) {
        for (const e in i) return i[e];
        return null;
      }
      function Vm(i, e, r, a) {
        const h = i.compareText;
        if (e in h) {
          const d = h[e];
          for (let y = d.length - 1; y >= 0; y--) if (a.dist(d[y]) < r) return !0;
        } else h[e] = [];
        return h[e].push(a), !1;
      }
      const _p = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class wu {
        static from(e) {
          if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [r, a] = new Uint8Array(e, 0, 2);
          if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const h = a >> 4;
          if (h !== 1) throw new Error(`Got v${h} data when expected v1.`);
          const d = _p[15 & a];
          if (!d) throw new Error("Unrecognized array type.");
          const [y] = new Uint16Array(e, 2, 1), [S] = new Uint32Array(e, 4, 1);
          return new wu(S, y, d, e);
        }
        constructor(e, r = 64, a = Float64Array, h) {
          if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
          this.numItems = +e, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = a, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
          const d = _p.indexOf(this.ArrayType), y = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, S = e * this.IndexArrayType.BYTES_PER_ELEMENT, k = (8 - S % 8) % 8;
          if (d < 0) throw new Error(`Unexpected typed array class: ${a}.`);
          h && h instanceof ArrayBuffer ? (this.data = h, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + S + k, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + y + S + k), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + S + k, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + d]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = e);
        }
        add(e, r) {
          const a = this._pos >> 1;
          return this.ids[a] = a, this.coords[this._pos++] = e, this.coords[this._pos++] = r, a;
        }
        finish() {
          const e = this._pos >> 1;
          if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
          return Su(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(e, r, a, h) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: d, coords: y, nodeSize: S } = this, k = [0, d.length - 1, 0], M = [];
          for (; k.length; ) {
            const F = k.pop() || 0, O = k.pop() || 0, $ = k.pop() || 0;
            if (O - $ <= S) {
              for (let me = $; me <= O; me++) {
                const be = y[2 * me], Re = y[2 * me + 1];
                be >= e && be <= a && Re >= r && Re <= h && M.push(d[me]);
              }
              continue;
            }
            const Y = $ + O >> 1, ee = y[2 * Y], re = y[2 * Y + 1];
            ee >= e && ee <= a && re >= r && re <= h && M.push(d[Y]), (F === 0 ? e <= ee : r <= re) && (k.push($), k.push(Y - 1), k.push(1 - F)), (F === 0 ? a >= ee : h >= re) && (k.push(Y + 1), k.push(O), k.push(1 - F));
          }
          return M;
        }
        within(e, r, a) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: h, coords: d, nodeSize: y } = this, S = [0, h.length - 1, 0], k = [], M = a * a;
          for (; S.length; ) {
            const F = S.pop() || 0, O = S.pop() || 0, $ = S.pop() || 0;
            if (O - $ <= y) {
              for (let me = $; me <= O; me++) xp(d[2 * me], d[2 * me + 1], e, r) <= M && k.push(h[me]);
              continue;
            }
            const Y = $ + O >> 1, ee = d[2 * Y], re = d[2 * Y + 1];
            xp(ee, re, e, r) <= M && k.push(h[Y]), (F === 0 ? e - a <= ee : r - a <= re) && (S.push($), S.push(Y - 1), S.push(1 - F)), (F === 0 ? e + a >= ee : r + a >= re) && (S.push(Y + 1), S.push(O), S.push(1 - F));
          }
          return k;
        }
      }
      function Su(i, e, r, a, h, d) {
        if (h - a <= r) return;
        const y = a + h >> 1;
        vp(i, e, y, a, h, d), Su(i, e, r, a, y - 1, 1 - d), Su(i, e, r, y + 1, h, 1 - d);
      }
      function vp(i, e, r, a, h, d) {
        for (; h > a; ) {
          if (h - a > 600) {
            const M = h - a + 1, F = r - a + 1, O = Math.log(M), $ = 0.5 * Math.exp(2 * O / 3), Y = 0.5 * Math.sqrt(O * $ * (M - $) / M) * (F - M / 2 < 0 ? -1 : 1);
            vp(i, e, r, Math.max(a, Math.floor(r - F * $ / M + Y)), Math.min(h, Math.floor(r + (M - F) * $ / M + Y)), d);
          }
          const y = e[2 * r + d];
          let S = a, k = h;
          for (Xc(i, e, a, r), e[2 * h + d] > y && Xc(i, e, a, h); S < k; ) {
            for (Xc(i, e, S, k), S++, k--; e[2 * S + d] < y; ) S++;
            for (; e[2 * k + d] > y; ) k--;
          }
          e[2 * a + d] === y ? Xc(i, e, a, k) : (k++, Xc(i, e, k, h)), k <= r && (a = k + 1), r <= k && (h = k - 1);
        }
      }
      function Xc(i, e, r, a) {
        Au(i, r, a), Au(e, 2 * r, 2 * a), Au(e, 2 * r + 1, 2 * a + 1);
      }
      function Au(i, e, r) {
        const a = i[e];
        i[e] = i[r], i[r] = a;
      }
      function xp(i, e, r, a) {
        const h = i - r, d = e - a;
        return h * h + d * d;
      }
      var Pu;
      v.be = void 0, (Pu = v.be || (v.be = {})).create = "create", Pu.load = "load", Pu.fullLoad = "fullLoad";
      let Ch = null, Yc = [];
      const Iu = 1e3 / 60, Tu = "loadTime", ku = "fullLoadTime", $m = { mark(i) {
        performance.mark(i);
      }, frame(i) {
        const e = i;
        Ch != null && Yc.push(e - Ch), Ch = e;
      }, clearMetrics() {
        Ch = null, Yc = [], performance.clearMeasures(Tu), performance.clearMeasures(ku);
        for (const i in v.be) performance.clearMarks(v.be[i]);
      }, getPerformanceMetrics() {
        performance.measure(Tu, v.be.create, v.be.load), performance.measure(ku, v.be.create, v.be.fullLoad);
        const i = performance.getEntriesByName(Tu)[0].duration, e = performance.getEntriesByName(ku)[0].duration, r = Yc.length, a = 1 / (Yc.reduce((d, y) => d + y, 0) / r / 1e3), h = Yc.filter((d) => d > Iu).reduce((d, y) => d + (y - Iu) / Iu, 0);
        return { loadTime: i, fullLoadTime: e, fps: a, percentDroppedFrames: h / (r + h) * 100, totalFrames: r };
      } };
      v.$ = vr, v.A = uc, v.B = function(i) {
        if (Qe == null) {
          const e = i.navigator ? i.navigator.userAgent : null;
          Qe = !!i.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
        }
        return Qe;
      }, v.C = class {
        constructor(i, e) {
          this.target = i, this.mapId = e, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new zm(() => this.process()), this.subscription = function(r, a, h, d) {
            return r.addEventListener(a, h, !1), { unsubscribe: () => {
              r.removeEventListener(a, h, !1);
            } };
          }(this.target, "message", (r) => this.receive(r)), this.globalScope = et(self) ? i : window;
        }
        registerMessageHandler(i, e) {
          this.messageHandlers[i] = e;
        }
        sendAsync(i, e) {
          return new Promise((r, a) => {
            const h = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[h] = { resolve: r, reject: a }, e && e.signal.addEventListener("abort", () => {
              delete this.resolveRejects[h];
              const S = { id: h, type: "<cancel>", origin: location.origin, targetMapId: i.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(S);
            }, { once: !0 });
            const d = [], y = Object.assign(Object.assign({}, i), { id: h, sourceMapId: this.mapId, origin: location.origin, data: on(i.data, d) });
            this.target.postMessage(y, { transfer: d });
          });
        }
        receive(i) {
          const e = i.data, r = e.id;
          if (!(e.origin !== "file://" && location.origin !== "file://" && e.origin !== location.origin || e.targetMapId && this.mapId !== e.targetMapId)) {
            if (e.type === "<cancel>") {
              delete this.tasks[r];
              const a = this.abortControllers[r];
              return delete this.abortControllers[r], void (a && a.abort());
            }
            if (et(self) || e.mustQueue) return this.tasks[r] = e, this.taskQueue.push(r), void this.invoker.trigger();
            this.processTask(r, e);
          }
        }
        process() {
          if (this.taskQueue.length === 0) return;
          const i = this.taskQueue.shift(), e = this.tasks[i];
          delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), e && this.processTask(i, e);
        }
        processTask(i, e) {
          return o(this, void 0, void 0, function* () {
            if (e.type === "<response>") {
              const h = this.resolveRejects[i];
              return delete this.resolveRejects[i], h ? void (e.error ? h.reject(jr(e.error)) : h.resolve(jr(e.data))) : void 0;
            }
            if (!this.messageHandlers[e.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${e.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const r = jr(e.data), a = new AbortController();
            this.abortControllers[i] = a;
            try {
              const h = yield this.messageHandlers[e.type](e.sourceMapId, r, a);
              this.completeTask(i, null, h);
            } catch (h) {
              this.completeTask(i, h);
            }
          });
        }
        completeTask(i, e, r) {
          const a = [];
          delete this.abortControllers[i];
          const h = { id: i, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e ? on(e) : null, data: on(r, a) };
          this.target.postMessage(h, { transfer: a });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, v.D = Vt, v.E = st, v.F = function() {
        var i = new uc(16);
        return uc != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
      }, v.G = Be, v.H = function(i, e, r) {
        var a, h, d, y, S, k, M, F, O, $, Y, ee, re = r[0], me = r[1], be = r[2];
        return e === i ? (i[12] = e[0] * re + e[4] * me + e[8] * be + e[12], i[13] = e[1] * re + e[5] * me + e[9] * be + e[13], i[14] = e[2] * re + e[6] * me + e[10] * be + e[14], i[15] = e[3] * re + e[7] * me + e[11] * be + e[15]) : (h = e[1], d = e[2], y = e[3], S = e[4], k = e[5], M = e[6], F = e[7], O = e[8], $ = e[9], Y = e[10], ee = e[11], i[0] = a = e[0], i[1] = h, i[2] = d, i[3] = y, i[4] = S, i[5] = k, i[6] = M, i[7] = F, i[8] = O, i[9] = $, i[10] = Y, i[11] = ee, i[12] = a * re + S * me + O * be + e[12], i[13] = h * re + k * me + $ * be + e[13], i[14] = d * re + M * me + Y * be + e[14], i[15] = y * re + F * me + ee * be + e[15]), i;
      }, v.I = cu, v.J = function(i, e, r) {
        var a = r[0], h = r[1], d = r[2];
        return i[0] = e[0] * a, i[1] = e[1] * a, i[2] = e[2] * a, i[3] = e[3] * a, i[4] = e[4] * h, i[5] = e[5] * h, i[6] = e[6] * h, i[7] = e[7] * h, i[8] = e[8] * d, i[9] = e[9] * d, i[10] = e[10] * d, i[11] = e[11] * d, i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
      }, v.K = ed, v.L = function(i, e) {
        const r = {};
        for (let a = 0; a < e.length; a++) {
          const h = e[a];
          h in i && (r[h] = i[h]);
        }
        return r;
      }, v.M = xl, v.N = Xd, v.O = Yd, v.P = q, v.Q = Ys, v.R = Xs, v.S = se, v.T = wa, v.U = ve, v.V = ct, v.W = xr, v.X = p, v.Y = Ph, v.Z = class extends E {
      }, v._ = o, v.a = we, v.a$ = function(i, e) {
        return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
      }, v.a0 = vu, v.a1 = pt, v.a2 = (i) => {
        const e = window.document.createElement("video");
        return e.muted = !0, new Promise((r) => {
          e.onloadstart = () => {
            r(e);
          };
          for (const a of i) {
            const h = window.document.createElement("source");
            bt(a) || (e.crossOrigin = "Anonymous"), h.src = a, e.appendChild(h);
          }
        });
      }, v.a3 = function() {
        return Le++;
      }, v.a4 = Mt, v.a5 = yc, v.a6 = Zi, v.a7 = Go, v.a8 = ji, v.a9 = ip, v.aA = function(i) {
        if (i.type === "custom") return new Dm(i);
        switch (i.type) {
          case "background":
            return new Cm(i);
          case "circle":
            return new yf(i);
          case "fill":
            return new zf(i);
          case "fill-extrusion":
            return new Xf(i);
          case "heatmap":
            return new vf(i);
          case "hillshade":
            return new bf(i);
          case "line":
            return new rm(i);
          case "raster":
            return new Mm(i);
          case "symbol":
            return new Ah(i);
        }
      }, v.aB = ae, v.aC = function(i, e) {
        if (!i) return [{ command: "setStyle", args: [e] }];
        let r = [];
        try {
          if (!ut(i.version, e.version)) return [{ command: "setStyle", args: [e] }];
          ut(i.center, e.center) || r.push({ command: "setCenter", args: [e.center] }), ut(i.zoom, e.zoom) || r.push({ command: "setZoom", args: [e.zoom] }), ut(i.bearing, e.bearing) || r.push({ command: "setBearing", args: [e.bearing] }), ut(i.pitch, e.pitch) || r.push({ command: "setPitch", args: [e.pitch] }), ut(i.sprite, e.sprite) || r.push({ command: "setSprite", args: [e.sprite] }), ut(i.glyphs, e.glyphs) || r.push({ command: "setGlyphs", args: [e.glyphs] }), ut(i.transition, e.transition) || r.push({ command: "setTransition", args: [e.transition] }), ut(i.light, e.light) || r.push({ command: "setLight", args: [e.light] }), ut(i.terrain, e.terrain) || r.push({ command: "setTerrain", args: [e.terrain] }), ut(i.sky, e.sky) || r.push({ command: "setSky", args: [e.sky] }), ut(i.projection, e.projection) || r.push({ command: "setProjection", args: [e.projection] });
          const a = {}, h = [];
          (function(y, S, k, M) {
            let F;
            for (F in S = S || {}, y = y || {}) Object.prototype.hasOwnProperty.call(y, F) && (Object.prototype.hasOwnProperty.call(S, F) || Ct(F, k, M));
            for (F in S) Object.prototype.hasOwnProperty.call(S, F) && (Object.prototype.hasOwnProperty.call(y, F) ? ut(y[F], S[F]) || (y[F].type === "geojson" && S[F].type === "geojson" && pi(y, S, F) ? _t(k, { command: "setGeoJSONSourceData", args: [F, S[F].data] }) : ei(F, S, k, M)) : Lt(F, S, k));
          })(i.sources, e.sources, h, a);
          const d = [];
          i.layers && i.layers.forEach((y) => {
            "source" in y && a[y.source] ? r.push({ command: "removeLayer", args: [y.id] }) : d.push(y);
          }), r = r.concat(h), function(y, S, k) {
            S = S || [];
            const M = (y = y || []).map(wi), F = S.map(wi), O = y.reduce(Ci, {}), $ = S.reduce(Ci, {}), Y = M.slice(), ee = /* @__PURE__ */ Object.create(null);
            let re, me, be, Re, Pe;
            for (let ze = 0, Xe = 0; ze < M.length; ze++) re = M[ze], Object.prototype.hasOwnProperty.call($, re) ? Xe++ : (_t(k, { command: "removeLayer", args: [re] }), Y.splice(Y.indexOf(re, Xe), 1));
            for (let ze = 0, Xe = 0; ze < F.length; ze++) re = F[F.length - 1 - ze], Y[Y.length - 1 - ze] !== re && (Object.prototype.hasOwnProperty.call(O, re) ? (_t(k, { command: "removeLayer", args: [re] }), Y.splice(Y.lastIndexOf(re, Y.length - Xe), 1)) : Xe++, Re = Y[Y.length - ze], _t(k, { command: "addLayer", args: [$[re], Re] }), Y.splice(Y.length - ze, 0, re), ee[re] = !0);
            for (let ze = 0; ze < F.length; ze++) if (re = F[ze], me = O[re], be = $[re], !ee[re] && !ut(me, be)) if (ut(me.source, be.source) && ut(me["source-layer"], be["source-layer"]) && ut(me.type, be.type)) {
              for (Pe in fi(me.layout, be.layout, k, re, null, "setLayoutProperty"), fi(me.paint, be.paint, k, re, null, "setPaintProperty"), ut(me.filter, be.filter) || _t(k, { command: "setFilter", args: [re, be.filter] }), ut(me.minzoom, be.minzoom) && ut(me.maxzoom, be.maxzoom) || _t(k, { command: "setLayerZoomRange", args: [re, be.minzoom, be.maxzoom] }), me) Object.prototype.hasOwnProperty.call(me, Pe) && Pe !== "layout" && Pe !== "paint" && Pe !== "filter" && Pe !== "metadata" && Pe !== "minzoom" && Pe !== "maxzoom" && (Pe.indexOf("paint.") === 0 ? fi(me[Pe], be[Pe], k, re, Pe.slice(6), "setPaintProperty") : ut(me[Pe], be[Pe]) || _t(k, { command: "setLayerProperty", args: [re, Pe, be[Pe]] }));
              for (Pe in be) Object.prototype.hasOwnProperty.call(be, Pe) && !Object.prototype.hasOwnProperty.call(me, Pe) && Pe !== "layout" && Pe !== "paint" && Pe !== "filter" && Pe !== "metadata" && Pe !== "minzoom" && Pe !== "maxzoom" && (Pe.indexOf("paint.") === 0 ? fi(me[Pe], be[Pe], k, re, Pe.slice(6), "setPaintProperty") : ut(me[Pe], be[Pe]) || _t(k, { command: "setLayerProperty", args: [re, Pe, be[Pe]] }));
            } else _t(k, { command: "removeLayer", args: [re] }), Re = Y[Y.lastIndexOf(re) + 1], _t(k, { command: "addLayer", args: [be, Re] });
          }(d, e.layers, r);
        } catch (a) {
          console.warn("Unable to compute style diff:", a), r = [{ command: "setStyle", args: [e] }];
        }
        return r;
      }, v.aD = function(i) {
        const e = [], r = i.id;
        return r === void 0 && e.push({ message: `layers.${r}: missing required property "id"` }), i.render === void 0 && e.push({ message: `layers.${r}: missing required method "render"` }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && e.push({ message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"` }), e;
      }, v.aE = function i(e, r) {
        if (Array.isArray(e)) {
          if (!Array.isArray(r) || e.length !== r.length) return !1;
          for (let a = 0; a < e.length; a++) if (!i(e[a], r[a])) return !1;
          return !0;
        }
        if (typeof e == "object" && e !== null && r !== null) {
          if (typeof r != "object" || Object.keys(e).length !== Object.keys(r).length) return !1;
          for (const a in e) if (!i(e[a], r[a])) return !1;
          return !0;
        }
        return e === r;
      }, v.aF = dt, v.aG = at, v.aH = class extends qn {
        constructor(i, e) {
          super(i, e), this.current = 0;
        }
        set(i) {
          this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i));
        }
      }, v.aI = lc, v.aJ = class extends qn {
        constructor(i, e) {
          super(i, e), this.current = lh;
        }
        set(i) {
          if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
          for (let e = 1; e < 16; e++) if (i[e] !== this.current[e]) {
            this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
            break;
          }
        }
      }, v.aK = ah, v.aL = class extends qn {
        constructor(i, e) {
          super(i, e), this.current = [0, 0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]));
        }
      }, v.aM = class extends qn {
        constructor(i, e) {
          super(i, e), this.current = [0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]));
        }
      }, v.aN = oh, v.aO = function(i, e, r, a, h, d, y) {
        var S = 1 / (e - r), k = 1 / (a - h), M = 1 / (d - y);
        return i[0] = -2 * S, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * k, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * M, i[11] = 0, i[12] = (e + r) * S, i[13] = (h + a) * k, i[14] = (y + d) * M, i[15] = 1, i;
      }, v.aP = Ri, v.aQ = gf, v.aR = class extends ne {
      }, v.aS = om, v.aT = class extends De {
      }, v.aU = function(i) {
        return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
      }, v.aV = sd, v.aW = ur, v.aX = class extends ft {
      }, v.aY = zr, v.aZ = function(i, e) {
        return i[0] === e[0] && i[1] === e[1] && i[2] === e[2] && i[3] === e[3] && i[4] === e[4] && i[5] === e[5] && i[6] === e[6] && i[7] === e[7] && i[8] === e[8] && i[9] === e[9] && i[10] === e[10] && i[11] === e[11] && i[12] === e[12] && i[13] === e[13] && i[14] === e[14] && i[15] === e[15];
      }, v.a_ = function(i, e) {
        var r = i[0], a = i[1], h = i[2], d = i[3], y = i[4], S = i[5], k = i[6], M = i[7], F = i[8], O = i[9], $ = i[10], Y = i[11], ee = i[12], re = i[13], me = i[14], be = i[15], Re = e[0], Pe = e[1], ze = e[2], Xe = e[3], mt = e[4], At = e[5], Kt = e[6], Et = e[7], St = e[8], Gt = e[9], qt = e[10], Ot = e[11], ht = e[12], Xt = e[13], $t = e[14], di = e[15];
        return Math.abs(r - Re) <= Un * Math.max(1, Math.abs(r), Math.abs(Re)) && Math.abs(a - Pe) <= Un * Math.max(1, Math.abs(a), Math.abs(Pe)) && Math.abs(h - ze) <= Un * Math.max(1, Math.abs(h), Math.abs(ze)) && Math.abs(d - Xe) <= Un * Math.max(1, Math.abs(d), Math.abs(Xe)) && Math.abs(y - mt) <= Un * Math.max(1, Math.abs(y), Math.abs(mt)) && Math.abs(S - At) <= Un * Math.max(1, Math.abs(S), Math.abs(At)) && Math.abs(k - Kt) <= Un * Math.max(1, Math.abs(k), Math.abs(Kt)) && Math.abs(M - Et) <= Un * Math.max(1, Math.abs(M), Math.abs(Et)) && Math.abs(F - St) <= Un * Math.max(1, Math.abs(F), Math.abs(St)) && Math.abs(O - Gt) <= Un * Math.max(1, Math.abs(O), Math.abs(Gt)) && Math.abs($ - qt) <= Un * Math.max(1, Math.abs($), Math.abs(qt)) && Math.abs(Y - Ot) <= Un * Math.max(1, Math.abs(Y), Math.abs(Ot)) && Math.abs(ee - ht) <= Un * Math.max(1, Math.abs(ee), Math.abs(ht)) && Math.abs(re - Xt) <= Un * Math.max(1, Math.abs(re), Math.abs(Xt)) && Math.abs(me - $t) <= Un * Math.max(1, Math.abs(me), Math.abs($t)) && Math.abs(be - di) <= Un * Math.max(1, Math.abs(be), Math.abs(di));
      }, v.aa = function(i) {
        const e = {};
        if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (r, a, h, d) => {
          const y = h || d;
          return e[a] = !y || y.toLowerCase(), "";
        }), e["max-age"]) {
          const r = parseInt(e["max-age"], 10);
          isNaN(r) ? delete e["max-age"] : e["max-age"] = r;
        }
        return e;
      }, v.ab = function(i, e) {
        const r = [];
        for (const a in i) a in e || r.push(a);
        return r;
      }, v.ac = Ke, v.ad = function(i, e, r) {
        var a = Math.sin(r), h = Math.cos(r), d = e[0], y = e[1], S = e[2], k = e[3], M = e[4], F = e[5], O = e[6], $ = e[7];
        return e !== i && (i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[0] = d * h + M * a, i[1] = y * h + F * a, i[2] = S * h + O * a, i[3] = k * h + $ * a, i[4] = M * h - d * a, i[5] = F * h - y * a, i[6] = O * h - S * a, i[7] = $ * h - k * a, i;
      }, v.ae = function(i) {
        var e = new uc(16);
        return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], e;
      }, v.af = fh, v.ag = function(i, e) {
        let r = 0, a = 0;
        if (i.kind === "constant") a = i.layoutSize;
        else if (i.kind !== "source") {
          const { interpolationType: h, minZoom: d, maxZoom: y } = i, S = h ? Ke(ri.interpolationFactor(h, e, d, y), 0, 1) : 0;
          i.kind === "camera" ? a = Rr.number(i.minSize, i.maxSize, S) : r = S;
        }
        return { uSizeT: r, uSize: a };
      }, v.ai = function(i, { uSize: e, uSizeT: r }, { lowerSize: a, upperSize: h }) {
        return i.kind === "source" ? a / wo : i.kind === "composite" ? Rr.number(a / wo, h / wo, r) : e;
      }, v.aj = pu, v.ak = function(i, e, r, a) {
        const h = e.y - i.y, d = e.x - i.x, y = a.y - r.y, S = a.x - r.x, k = y * d - S * h;
        if (k === 0) return null;
        const M = (S * (i.y - r.y) - y * (i.x - r.x)) / k;
        return new q(i.x + M * d, i.y + M * h);
      }, v.al = ap, v.am = ch, v.an = Gh, v.ao = function(i) {
        let e = 1 / 0, r = 1 / 0, a = -1 / 0, h = -1 / 0;
        for (const d of i) e = Math.min(e, d.x), r = Math.min(r, d.y), a = Math.max(a, d.x), h = Math.max(h, d.y);
        return [e, r, a, h];
      }, v.ap = Wr, v.ar = du, v.as = function(i, e) {
        var r = e[0], a = e[1], h = e[2], d = e[3], y = e[4], S = e[5], k = e[6], M = e[7], F = e[8], O = e[9], $ = e[10], Y = e[11], ee = e[12], re = e[13], me = e[14], be = e[15], Re = r * S - a * y, Pe = r * k - h * y, ze = r * M - d * y, Xe = a * k - h * S, mt = a * M - d * S, At = h * M - d * k, Kt = F * re - O * ee, Et = F * me - $ * ee, St = F * be - Y * ee, Gt = O * me - $ * re, qt = O * be - Y * re, Ot = $ * be - Y * me, ht = Re * Ot - Pe * qt + ze * Gt + Xe * St - mt * Et + At * Kt;
        return ht ? (i[0] = (S * Ot - k * qt + M * Gt) * (ht = 1 / ht), i[1] = (h * qt - a * Ot - d * Gt) * ht, i[2] = (re * At - me * mt + be * Xe) * ht, i[3] = ($ * mt - O * At - Y * Xe) * ht, i[4] = (k * St - y * Ot - M * Et) * ht, i[5] = (r * Ot - h * St + d * Et) * ht, i[6] = (me * ze - ee * At - be * Pe) * ht, i[7] = (F * At - $ * ze + Y * Pe) * ht, i[8] = (y * qt - S * St + M * Kt) * ht, i[9] = (a * St - r * qt - d * Kt) * ht, i[10] = (ee * mt - re * ze + be * Re) * ht, i[11] = (O * ze - F * mt - Y * Re) * ht, i[12] = (S * Et - y * Gt - k * Kt) * ht, i[13] = (r * Gt - a * Et + h * Kt) * ht, i[14] = (re * Pe - ee * Xe - me * Re) * ht, i[15] = (F * Xe - O * Pe + $ * Re) * ht, i) : null;
      }, v.at = bu, v.au = uu, v.av = wu, v.aw = function() {
        const i = {}, e = te.$version;
        for (const r in te.$root) {
          const a = te.$root[r];
          if (a.required) {
            let h = null;
            h = r === "version" ? e : a.type === "array" ? [] : {}, h != null && (i[r] = h);
          }
        }
        return i;
      }, v.ax = ac, v.ay = We, v.az = function(i) {
        i = i.slice();
        const e = /* @__PURE__ */ Object.create(null);
        for (let r = 0; r < i.length; r++) e[i[r].id] = i[r];
        for (let r = 0; r < i.length; r++) "ref" in i[r] && (i[r] = Ht(i[r], e[i[r].ref]));
        return i;
      }, v.b = rt, v.b0 = function(i, e, r) {
        return i[0] = e[0] * r[0], i[1] = e[1] * r[1], i[2] = e[2] * r[2], i[3] = e[3] * r[3], i;
      }, v.b1 = function(i, e) {
        return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] * e[3];
      }, v.b2 = gt, v.b3 = Qd, v.b4 = Jd, v.b5 = function(i, e, r, a, h) {
        var d, y = 1 / Math.tan(e / 2);
        return i[0] = y / r, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = y, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, h != null && h !== 1 / 0 ? (i[10] = (h + a) * (d = 1 / (a - h)), i[14] = 2 * h * a * d) : (i[10] = -1, i[14] = -2 * a), i;
      }, v.b6 = function(i, e, r) {
        var a = Math.sin(r), h = Math.cos(r), d = e[4], y = e[5], S = e[6], k = e[7], M = e[8], F = e[9], O = e[10], $ = e[11];
        return e !== i && (i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[4] = d * h + M * a, i[5] = y * h + F * a, i[6] = S * h + O * a, i[7] = k * h + $ * a, i[8] = M * h - d * a, i[9] = F * h - y * a, i[10] = O * h - S * a, i[11] = $ * h - k * a, i;
      }, v.b7 = Fe, v.b8 = it, v.b9 = function(i) {
        return i * Math.PI / 180;
      }, v.bA = Rn, v.bB = ba, v.ba = function(i, e) {
        return i[0] = e[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = e[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = e[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }, v.bb = class extends C {
      }, v.bc = yu, v.bd = $m, v.bf = Ve, v.bg = function(i, e) {
        we.REGISTERED_PROTOCOLS[i] = e;
      }, v.bh = function(i) {
        delete we.REGISTERED_PROTOCOLS[i];
      }, v.bi = function(i, e) {
        const r = {};
        for (let h = 0; h < i.length; h++) {
          const d = e && e[i[h].id] || rc(i[h]);
          e && (e[i[h].id] = d);
          let y = r[d];
          y || (y = r[d] = []), y.push(i[h]);
        }
        const a = [];
        for (const h in r) a.push(r[h]);
        return a;
      }, v.bj = Rt, v.bk = tp, v.bl = rp, v.bm = zd, v.bn = function(i) {
        i.bucket.createArrays(), i.bucket.tilePixelRatio = xr / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
        const e = i.bucket.layers[0], r = e.layout, a = e._unevaluatedLayout._values, h = { layoutIconSize: a["icon-size"].possiblyEvaluate(new ji(i.bucket.zoom + 1), i.canonical), layoutTextSize: a["text-size"].possiblyEvaluate(new ji(i.bucket.zoom + 1), i.canonical), textMaxSize: a["text-size"].possiblyEvaluate(new ji(18)) };
        if (i.bucket.textSizeData.kind === "composite") {
          const { minZoom: M, maxZoom: F } = i.bucket.textSizeData;
          h.compositeTextSizes = [a["text-size"].possiblyEvaluate(new ji(M), i.canonical), a["text-size"].possiblyEvaluate(new ji(F), i.canonical)];
        }
        if (i.bucket.iconSizeData.kind === "composite") {
          const { minZoom: M, maxZoom: F } = i.bucket.iconSizeData;
          h.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new ji(M), i.canonical), a["icon-size"].possiblyEvaluate(new ji(F), i.canonical)];
        }
        const d = r.get("text-line-height") * Wr, y = r.get("text-rotation-alignment") !== "viewport" && r.get("symbol-placement") !== "point", S = r.get("text-keep-upright"), k = r.get("text-size");
        for (const M of i.bucket.features) {
          const F = r.get("text-font").evaluate(M, {}, i.canonical).join(","), O = k.evaluate(M, {}, i.canonical), $ = h.layoutTextSize.evaluate(M, {}, i.canonical), Y = h.layoutIconSize.evaluate(M, {}, i.canonical), ee = { horizontal: {}, vertical: void 0 }, re = M.text;
          let me, be = [0, 0];
          if (re) {
            const ze = re.toString(), Xe = r.get("text-letter-spacing").evaluate(M, {}, i.canonical) * Wr, mt = On(ze) ? Xe : 0, At = r.get("text-anchor").evaluate(M, {}, i.canonical), Kt = mp(e, M, i.canonical);
            if (!Kt) {
              const qt = r.get("text-radial-offset").evaluate(M, {}, i.canonical);
              be = qt ? fp(At, [qt * Wr, xu]) : r.get("text-offset").evaluate(M, {}, i.canonical).map((Ot) => Ot * Wr);
            }
            let Et = y ? "center" : r.get("text-justify").evaluate(M, {}, i.canonical);
            const St = r.get("symbol-placement") === "point" ? r.get("text-max-width").evaluate(M, {}, i.canonical) * Wr : 1 / 0, Gt = () => {
              i.bucket.allowVerticalPlacement && bs(ze) && (ee.vertical = bh(re, i.glyphMap, i.glyphPositions, i.imagePositions, F, St, d, At, "left", mt, be, v.ah.vertical, !0, $, O));
            };
            if (!y && Kt) {
              const qt = /* @__PURE__ */ new Set();
              if (Et === "auto") for (let ht = 0; ht < Kt.values.length; ht += 2) qt.add(bu(Kt.values[ht]));
              else qt.add(Et);
              let Ot = !1;
              for (const ht of qt) if (!ee.horizontal[ht]) if (Ot) ee.horizontal[ht] = ee.horizontal[0];
              else {
                const Xt = bh(re, i.glyphMap, i.glyphPositions, i.imagePositions, F, St, d, "center", ht, mt, be, v.ah.horizontal, !1, $, O);
                Xt && (ee.horizontal[ht] = Xt, Ot = Xt.positionedLines.length === 1);
              }
              Gt();
            } else {
              Et === "auto" && (Et = bu(At));
              const qt = bh(re, i.glyphMap, i.glyphPositions, i.imagePositions, F, St, d, At, Et, mt, be, v.ah.horizontal, !1, $, O);
              qt && (ee.horizontal[Et] = qt), Gt(), bs(ze) && y && S && (ee.vertical = bh(re, i.glyphMap, i.glyphPositions, i.imagePositions, F, St, d, At, Et, mt, be, v.ah.vertical, !1, $, O));
            }
          }
          let Re = !1;
          if (M.icon && M.icon.name) {
            const ze = i.imageMap[M.icon.name];
            ze && (me = Pm(i.imagePositions[M.icon.name], r.get("icon-offset").evaluate(M, {}, i.canonical), r.get("icon-anchor").evaluate(M, {}, i.canonical)), Re = !!ze.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Re : i.bucket.sdfIcons !== Re && Ie("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (ze.pixelRatio !== i.bucket.pixelRatio || r.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0));
          }
          const Pe = yp(ee.horizontal) || ee.vertical;
          i.bucket.iconsInText = !!Pe && Pe.iconsInText, (Pe || me) && Um(i.bucket, M, ee, me, i.imageMap, h, $, Y, be, Re, i.canonical);
        }
        i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers();
      }, v.bo = su, v.bp = iu, v.bq = nu, v.br = yl, v.bs = ou, v.bt = class {
        constructor(i) {
          this._marks = { start: [i.url, "start"].join("#"), end: [i.url, "end"].join("#"), measure: i.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let i = performance.getEntriesByName(this._marks.measure);
          return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i;
        }
      }, v.bu = function(i, e, r, a, h) {
        return o(this, void 0, void 0, function* () {
          if (ve()) try {
            return yield ct(i, e, r, a, h);
          } catch {
          }
          return function(d, y, S, k, M) {
            const F = d.width, O = d.height;
            nt && wt || (nt = new OffscreenCanvas(F, O), wt = nt.getContext("2d", { willReadFrequently: !0 })), nt.width = F, nt.height = O, wt.drawImage(d, 0, 0, F, O);
            const $ = wt.getImageData(y, S, k, M);
            return wt.clearRect(0, 0, F, O), $.data;
          }(i, e, r, a, h);
        });
      }, v.bv = ep, v.bw = D, v.bx = j, v.by = Pd, v.bz = function(i) {
        return i.message === K;
      }, v.c = ge, v.d = (i) => o(void 0, void 0, void 0, function* () {
        if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
        const e = new Blob([new Uint8Array(i)], { type: "image/png" });
        try {
          return createImageBitmap(e);
        } catch (r) {
          throw new Error(`Could not load image because of ${r.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), v.e = $e, v.f = (i) => new Promise((e, r) => {
        const a = new Image();
        a.onload = () => {
          e(a), URL.revokeObjectURL(a.src), a.onload = null, window.requestAnimationFrame(() => {
            a.src = Ze;
          });
        }, a.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const h = new Blob([new Uint8Array(i)], { type: "image/png" });
        a.src = i.byteLength ? URL.createObjectURL(h) : Ze;
      }), v.g = Ee, v.h = (i, e) => Ye($e(i, { type: "json" }), e), v.i = et, v.j = Ut, v.k = zt, v.l = (i, e) => Ye($e(i, { type: "arrayBuffer" }), e), v.m = Ye, v.n = function(i) {
        return new ou(i).readFields(_m, []);
      }, v.o = Bc, v.p = Dd, v.q = c, v.r = Cc, v.s = bt, v.t = Rl, v.u = Pt, v.v = te, v.w = Ie, v.x = Us, v.y = function([i, e, r]) {
        return e += 90, e *= Math.PI / 180, r *= Math.PI / 180, { x: i * Math.cos(e) * Math.sin(r), y: i * Math.sin(e) * Math.sin(r), z: i * Math.cos(r) };
      }, v.z = Rr;
    }), I("worker", ["./shared"], function(v) {
      class o {
        constructor(Z) {
          this.keyCache = {}, Z && this.replace(Z);
        }
        replace(Z) {
          this._layerConfigs = {}, this._layers = {}, this.update(Z, []);
        }
        update(Z, W) {
          for (const fe of Z) {
            this._layerConfigs[fe.id] = fe;
            const Ae = this._layers[fe.id] = v.aA(fe);
            Ae._featureFilter = v.a6(Ae.filter), this.keyCache[fe.id] && delete this.keyCache[fe.id];
          }
          for (const fe of W) delete this.keyCache[fe], delete this._layerConfigs[fe], delete this._layers[fe];
          this.familiesBySource = {};
          const J = v.bi(Object.values(this._layerConfigs), this.keyCache);
          for (const fe of J) {
            const Ae = fe.map((Je) => this._layers[Je.id]), Ce = Ae[0];
            if (Ce.visibility === "none") continue;
            const Me = Ce.source || "";
            let pe = this.familiesBySource[Me];
            pe || (pe = this.familiesBySource[Me] = {});
            const Oe = Ce.sourceLayer || "_geojsonTileLayer";
            let ot = pe[Oe];
            ot || (ot = pe[Oe] = []), ot.push(Ae);
          }
        }
      }
      class D {
        constructor(Z) {
          const W = {}, J = [];
          for (const Me in Z) {
            const pe = Z[Me], Oe = W[Me] = {};
            for (const ot in pe) {
              const Je = pe[+ot];
              if (!Je || Je.bitmap.width === 0 || Je.bitmap.height === 0) continue;
              const Ge = { x: 0, y: 0, w: Je.bitmap.width + 2, h: Je.bitmap.height + 2 };
              J.push(Ge), Oe[ot] = { rect: Ge, metrics: Je.metrics };
            }
          }
          const { w: fe, h: Ae } = v.p(J), Ce = new v.o({ width: fe || 1, height: Ae || 1 });
          for (const Me in Z) {
            const pe = Z[Me];
            for (const Oe in pe) {
              const ot = pe[+Oe];
              if (!ot || ot.bitmap.width === 0 || ot.bitmap.height === 0) continue;
              const Je = W[Me][Oe].rect;
              v.o.copy(ot.bitmap, Ce, { x: 0, y: 0 }, { x: Je.x + 1, y: Je.y + 1 }, ot.bitmap);
            }
          }
          this.image = Ce, this.positions = W;
        }
      }
      v.bj("GlyphAtlas", D);
      class j {
        constructor(Z) {
          this.tileID = new v.Q(Z.tileID.overscaledZ, Z.tileID.wrap, Z.tileID.canonical.z, Z.tileID.canonical.x, Z.tileID.canonical.y), this.uid = Z.uid, this.zoom = Z.zoom, this.pixelRatio = Z.pixelRatio, this.tileSize = Z.tileSize, this.source = Z.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = Z.showCollisionBoxes, this.collectResourceTiming = !!Z.collectResourceTiming, this.returnDependencies = !!Z.returnDependencies, this.promoteId = Z.promoteId, this.inFlightDependencies = [];
        }
        parse(Z, W, J, fe) {
          return v._(this, void 0, void 0, function* () {
            this.status = "parsing", this.data = Z, this.collisionBoxArray = new v.a4();
            const Ae = new v.bk(Object.keys(Z.layers).sort()), Ce = new v.bl(this.tileID, this.promoteId);
            Ce.bucketLayerIDs = [];
            const Me = {}, pe = { featureIndex: Ce, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: J }, Oe = W.familiesBySource[this.source];
            for (const ai in Oe) {
              const Fi = Z.layers[ai];
              if (!Fi) continue;
              Fi.version === 1 && v.w(`Vector tile source "${this.source}" layer "${ai}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const er = Ae.encode(ai), Mr = [];
              for (let Nr = 0; Nr < Fi.length; Nr++) {
                const cr = Fi.feature(Nr), Jn = Ce.getId(cr, ai);
                Mr.push({ feature: cr, id: Jn, index: Nr, sourceLayerIndex: er });
              }
              for (const Nr of Oe[ai]) {
                const cr = Nr[0];
                cr.source !== this.source && v.w(`layer.source = ${cr.source} does not equal this.source = ${this.source}`), cr.minzoom && this.zoom < Math.floor(cr.minzoom) || cr.maxzoom && this.zoom >= cr.maxzoom || cr.visibility !== "none" && (V(Nr, this.zoom, J), (Me[cr.id] = cr.createBucket({ index: Ce.bucketLayerIDs.length, layers: Nr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: er, sourceID: this.source })).populate(Mr, pe, this.tileID.canonical), Ce.bucketLayerIDs.push(Nr.map((Jn) => Jn.id)));
              }
            }
            const ot = v.aF(pe.glyphDependencies, (ai) => Object.keys(ai).map(Number));
            this.inFlightDependencies.forEach((ai) => ai == null ? void 0 : ai.abort()), this.inFlightDependencies = [];
            let Je = Promise.resolve({});
            if (Object.keys(ot).length) {
              const ai = new AbortController();
              this.inFlightDependencies.push(ai), Je = fe.sendAsync({ type: "GG", data: { stacks: ot, source: this.source, tileID: this.tileID, type: "glyphs" } }, ai);
            }
            const Ge = Object.keys(pe.iconDependencies);
            let It = Promise.resolve({});
            if (Ge.length) {
              const ai = new AbortController();
              this.inFlightDependencies.push(ai), It = fe.sendAsync({ type: "GI", data: { icons: Ge, source: this.source, tileID: this.tileID, type: "icons" } }, ai);
            }
            const Nt = Object.keys(pe.patternDependencies);
            let gi = Promise.resolve({});
            if (Nt.length) {
              const ai = new AbortController();
              this.inFlightDependencies.push(ai), gi = fe.sendAsync({ type: "GI", data: { icons: Nt, source: this.source, tileID: this.tileID, type: "patterns" } }, ai);
            }
            const [ti, mi, Ii] = yield Promise.all([Je, It, gi]), Ei = new D(ti), Ui = new v.bm(mi, Ii);
            for (const ai in Me) {
              const Fi = Me[ai];
              Fi instanceof v.a5 ? (V(Fi.layers, this.zoom, J), v.bn({ bucket: Fi, glyphMap: ti, glyphPositions: Ei.positions, imageMap: mi, imagePositions: Ui.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : Fi.hasPattern && (Fi instanceof v.bo || Fi instanceof v.bp || Fi instanceof v.bq) && (V(Fi.layers, this.zoom, J), Fi.addFeatures(pe, this.tileID.canonical, Ui.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(Me).filter((ai) => !ai.isEmpty()), featureIndex: Ce, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Ei.image, imageAtlas: Ui, glyphMap: this.returnDependencies ? ti : null, iconMap: this.returnDependencies ? mi : null, glyphPositions: this.returnDependencies ? Ei.positions : null };
          });
        }
      }
      function V(de, Z, W) {
        const J = new v.a8(Z);
        for (const fe of de) fe.recalculate(J, W);
      }
      class q {
        constructor(Z, W, J) {
          this.actor = Z, this.layerIndex = W, this.availableImages = J, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(Z, W) {
          return v._(this, void 0, void 0, function* () {
            const J = yield v.l(Z.request, W);
            try {
              return { vectorTile: new v.br.VectorTile(new v.bs(J.data)), rawData: J.data, cacheControl: J.cacheControl, expires: J.expires };
            } catch (fe) {
              const Ae = new Uint8Array(J.data);
              let Ce = `Unable to parse the tile at ${Z.request.url}, `;
              throw Ce += Ae[0] === 31 && Ae[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${fe.message}`, new Error(Ce);
            }
          });
        }
        loadTile(Z) {
          return v._(this, void 0, void 0, function* () {
            const W = Z.uid, J = !!(Z && Z.request && Z.request.collectResourceTiming) && new v.bt(Z.request), fe = new j(Z);
            this.loading[W] = fe;
            const Ae = new AbortController();
            fe.abort = Ae;
            try {
              const Ce = yield this.loadVectorTile(Z, Ae);
              if (delete this.loading[W], !Ce) return null;
              const Me = Ce.rawData, pe = {};
              Ce.expires && (pe.expires = Ce.expires), Ce.cacheControl && (pe.cacheControl = Ce.cacheControl);
              const Oe = {};
              if (J) {
                const Je = J.finish();
                Je && (Oe.resourceTiming = JSON.parse(JSON.stringify(Je)));
              }
              fe.vectorTile = Ce.vectorTile;
              const ot = fe.parse(Ce.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[W] = fe, this.fetching[W] = { rawTileData: Me, cacheControl: pe, resourceTiming: Oe };
              try {
                const Je = yield ot;
                return v.e({ rawTileData: Me.slice(0) }, Je, pe, Oe);
              } finally {
                delete this.fetching[W];
              }
            } catch (Ce) {
              throw delete this.loading[W], fe.status = "done", this.loaded[W] = fe, Ce;
            }
          });
        }
        reloadTile(Z) {
          return v._(this, void 0, void 0, function* () {
            const W = Z.uid;
            if (!this.loaded || !this.loaded[W]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const J = this.loaded[W];
            if (J.showCollisionBoxes = Z.showCollisionBoxes, J.status === "parsing") {
              const fe = yield J.parse(J.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let Ae;
              if (this.fetching[W]) {
                const { rawTileData: Ce, cacheControl: Me, resourceTiming: pe } = this.fetching[W];
                delete this.fetching[W], Ae = v.e({ rawTileData: Ce.slice(0) }, fe, Me, pe);
              } else Ae = fe;
              return Ae;
            }
            if (J.status === "done" && J.vectorTile) return J.parse(J.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile(Z) {
          return v._(this, void 0, void 0, function* () {
            const W = this.loading, J = Z.uid;
            W && W[J] && W[J].abort && (W[J].abort.abort(), delete W[J]);
          });
        }
        removeTile(Z) {
          return v._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[Z.uid] && delete this.loaded[Z.uid];
          });
        }
      }
      class U {
        constructor() {
          this.loaded = {};
        }
        loadTile(Z) {
          return v._(this, void 0, void 0, function* () {
            const { uid: W, encoding: J, rawImageData: fe, redFactor: Ae, greenFactor: Ce, blueFactor: Me, baseShift: pe } = Z, Oe = fe.width + 2, ot = fe.height + 2, Je = v.b(fe) ? new v.R({ width: Oe, height: ot }, yield v.bu(fe, -1, -1, Oe, ot)) : fe, Ge = new v.bv(W, Je, J, Ae, Ce, Me, pe);
            return this.loaded = this.loaded || {}, this.loaded[W] = Ge, Ge;
          });
        }
        removeTile(Z) {
          const W = this.loaded, J = Z.uid;
          W && W[J] && delete W[J];
        }
      }
      function B(de, Z) {
        if (de.length !== 0) {
          ye(de[0], Z);
          for (var W = 1; W < de.length; W++) ye(de[W], !Z);
        }
      }
      function ye(de, Z) {
        for (var W = 0, J = 0, fe = 0, Ae = de.length, Ce = Ae - 1; fe < Ae; Ce = fe++) {
          var Me = (de[fe][0] - de[Ce][0]) * (de[Ce][1] + de[fe][1]), pe = W + Me;
          J += Math.abs(W) >= Math.abs(Me) ? W - pe + Me : Me - pe + W, W = pe;
        }
        W + J >= 0 != !!Z && de.reverse();
      }
      var oe = v.bw(function de(Z, W) {
        var J, fe = Z && Z.type;
        if (fe === "FeatureCollection") for (J = 0; J < Z.features.length; J++) de(Z.features[J], W);
        else if (fe === "GeometryCollection") for (J = 0; J < Z.geometries.length; J++) de(Z.geometries[J], W);
        else if (fe === "Feature") de(Z.geometry, W);
        else if (fe === "Polygon") B(Z.coordinates, W);
        else if (fe === "MultiPolygon") for (J = 0; J < Z.coordinates.length; J++) B(Z.coordinates[J], W);
        return Z;
      });
      const xe = v.br.VectorTileFeature.prototype.toGeoJSON;
      var se = { exports: {} }, ve = v.bx, Fe = v.br.VectorTileFeature, it = Ke;
      function Ke(de, Z) {
        this.options = Z || {}, this.features = de, this.length = de.length;
      }
      function gt(de, Z) {
        this.id = typeof de.id == "number" ? de.id : void 0, this.type = de.type, this.rawGeometry = de.type === 1 ? [de.geometry] : de.geometry, this.properties = de.tags, this.extent = Z || 4096;
      }
      Ke.prototype.feature = function(de) {
        return new gt(this.features[de], this.options.extent);
      }, gt.prototype.loadGeometry = function() {
        var de = this.rawGeometry;
        this.geometry = [];
        for (var Z = 0; Z < de.length; Z++) {
          for (var W = de[Z], J = [], fe = 0; fe < W.length; fe++) J.push(new ve(W[fe][0], W[fe][1]));
          this.geometry.push(J);
        }
        return this.geometry;
      }, gt.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var de = this.geometry, Z = 1 / 0, W = -1 / 0, J = 1 / 0, fe = -1 / 0, Ae = 0; Ae < de.length; Ae++) for (var Ce = de[Ae], Me = 0; Me < Ce.length; Me++) {
          var pe = Ce[Me];
          Z = Math.min(Z, pe.x), W = Math.max(W, pe.x), J = Math.min(J, pe.y), fe = Math.max(fe, pe.y);
        }
        return [Z, J, W, fe];
      }, gt.prototype.toGeoJSON = Fe.prototype.toGeoJSON;
      var $e = v.by, Le = it;
      function dt(de) {
        var Z = new $e();
        return function(W, J) {
          for (var fe in W.layers) J.writeMessage(3, at, W.layers[fe]);
        }(de, Z), Z.finish();
      }
      function at(de, Z) {
        var W;
        Z.writeVarintField(15, de.version || 1), Z.writeStringField(1, de.name || ""), Z.writeVarintField(5, de.extent || 4096);
        var J = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (W = 0; W < de.length; W++) J.feature = de.feature(W), Z.writeMessage(2, ae, J);
        var fe = J.keys;
        for (W = 0; W < fe.length; W++) Z.writeStringField(3, fe[W]);
        var Ae = J.values;
        for (W = 0; W < Ae.length; W++) Z.writeMessage(4, Qe, Ae[W]);
      }
      function ae(de, Z) {
        var W = de.feature;
        W.id !== void 0 && Z.writeVarintField(1, W.id), Z.writeMessage(2, he, de), Z.writeVarintField(3, W.type), Z.writeMessage(4, et, W);
      }
      function he(de, Z) {
        var W = de.feature, J = de.keys, fe = de.values, Ae = de.keycache, Ce = de.valuecache;
        for (var Me in W.properties) {
          var pe = W.properties[Me], Oe = Ae[Me];
          if (pe !== null) {
            Oe === void 0 && (J.push(Me), Ae[Me] = Oe = J.length - 1), Z.writeVarint(Oe);
            var ot = typeof pe;
            ot !== "string" && ot !== "boolean" && ot !== "number" && (pe = JSON.stringify(pe));
            var Je = ot + ":" + pe, Ge = Ce[Je];
            Ge === void 0 && (fe.push(pe), Ce[Je] = Ge = fe.length - 1), Z.writeVarint(Ge);
          }
        }
      }
      function Ie(de, Z) {
        return (Z << 3) + (7 & de);
      }
      function Se(de) {
        return de << 1 ^ de >> 31;
      }
      function et(de, Z) {
        for (var W = de.loadGeometry(), J = de.type, fe = 0, Ae = 0, Ce = W.length, Me = 0; Me < Ce; Me++) {
          var pe = W[Me], Oe = 1;
          J === 1 && (Oe = pe.length), Z.writeVarint(Ie(1, Oe));
          for (var ot = J === 3 ? pe.length - 1 : pe.length, Je = 0; Je < ot; Je++) {
            Je === 1 && J !== 1 && Z.writeVarint(Ie(2, ot - 1));
            var Ge = pe[Je].x - fe, It = pe[Je].y - Ae;
            Z.writeVarint(Se(Ge)), Z.writeVarint(Se(It)), fe += Ge, Ae += It;
          }
          J === 3 && Z.writeVarint(Ie(7, 1));
        }
      }
      function Qe(de, Z) {
        var W = typeof de;
        W === "string" ? Z.writeStringField(1, de) : W === "boolean" ? Z.writeBooleanField(7, de) : W === "number" && (de % 1 != 0 ? Z.writeDoubleField(3, de) : de < 0 ? Z.writeSVarintField(6, de) : Z.writeVarintField(5, de));
      }
      se.exports = dt, se.exports.fromVectorTileJs = dt, se.exports.fromGeojsonVt = function(de, Z) {
        Z = Z || {};
        var W = {};
        for (var J in de) W[J] = new Le(de[J].features, Z), W[J].name = J, W[J].version = Z.version, W[J].extent = Z.extent;
        return dt({ layers: W });
      }, se.exports.GeoJSONWrapper = Le;
      var rt = v.bw(se.exports);
      const Ze = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (de) => de }, ct = Math.fround || (nt = new Float32Array(1), (de) => (nt[0] = +de, nt[0]));
      var nt;
      const wt = 3, K = 5, ge = 6;
      class we {
        constructor(Z) {
          this.options = Object.assign(Object.create(Ze), Z), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(Z) {
          const { log: W, minZoom: J, maxZoom: fe } = this.options;
          W && console.time("total time");
          const Ae = `prepare ${Z.length} points`;
          W && console.time(Ae), this.points = Z;
          const Ce = [];
          for (let pe = 0; pe < Z.length; pe++) {
            const Oe = Z[pe];
            if (!Oe.geometry) continue;
            const [ot, Je] = Oe.geometry.coordinates, Ge = ct(Ve(ot)), It = ct(We(Je));
            Ce.push(Ge, It, 1 / 0, pe, -1, 1), this.options.reduce && Ce.push(0);
          }
          let Me = this.trees[fe + 1] = this._createTree(Ce);
          W && console.timeEnd(Ae);
          for (let pe = fe; pe >= J; pe--) {
            const Oe = +Date.now();
            Me = this.trees[pe] = this._createTree(this._cluster(Me, pe)), W && console.log("z%d: %d clusters in %dms", pe, Me.numItems, +Date.now() - Oe);
          }
          return W && console.timeEnd("total time"), this;
        }
        getClusters(Z, W) {
          let J = ((Z[0] + 180) % 360 + 360) % 360 - 180;
          const fe = Math.max(-90, Math.min(90, Z[1]));
          let Ae = Z[2] === 180 ? 180 : ((Z[2] + 180) % 360 + 360) % 360 - 180;
          const Ce = Math.max(-90, Math.min(90, Z[3]));
          if (Z[2] - Z[0] >= 360) J = -180, Ae = 180;
          else if (J > Ae) {
            const Je = this.getClusters([J, fe, 180, Ce], W), Ge = this.getClusters([-180, fe, Ae, Ce], W);
            return Je.concat(Ge);
          }
          const Me = this.trees[this._limitZoom(W)], pe = Me.range(Ve(J), We(Ce), Ve(Ae), We(fe)), Oe = Me.data, ot = [];
          for (const Je of pe) {
            const Ge = this.stride * Je;
            ot.push(Oe[Ge + K] > 1 ? Ee(Oe, Ge, this.clusterProps) : this.points[Oe[Ge + wt]]);
          }
          return ot;
        }
        getChildren(Z) {
          const W = this._getOriginId(Z), J = this._getOriginZoom(Z), fe = "No cluster with the specified id.", Ae = this.trees[J];
          if (!Ae) throw new Error(fe);
          const Ce = Ae.data;
          if (W * this.stride >= Ce.length) throw new Error(fe);
          const Me = this.options.radius / (this.options.extent * Math.pow(2, J - 1)), pe = Ae.within(Ce[W * this.stride], Ce[W * this.stride + 1], Me), Oe = [];
          for (const ot of pe) {
            const Je = ot * this.stride;
            Ce[Je + 4] === Z && Oe.push(Ce[Je + K] > 1 ? Ee(Ce, Je, this.clusterProps) : this.points[Ce[Je + wt]]);
          }
          if (Oe.length === 0) throw new Error(fe);
          return Oe;
        }
        getLeaves(Z, W, J) {
          const fe = [];
          return this._appendLeaves(fe, Z, W = W || 10, J = J || 0, 0), fe;
        }
        getTile(Z, W, J) {
          const fe = this.trees[this._limitZoom(Z)], Ae = Math.pow(2, Z), { extent: Ce, radius: Me } = this.options, pe = Me / Ce, Oe = (J - pe) / Ae, ot = (J + 1 + pe) / Ae, Je = { features: [] };
          return this._addTileFeatures(fe.range((W - pe) / Ae, Oe, (W + 1 + pe) / Ae, ot), fe.data, W, J, Ae, Je), W === 0 && this._addTileFeatures(fe.range(1 - pe / Ae, Oe, 1, ot), fe.data, Ae, J, Ae, Je), W === Ae - 1 && this._addTileFeatures(fe.range(0, Oe, pe / Ae, ot), fe.data, -1, J, Ae, Je), Je.features.length ? Je : null;
        }
        getClusterExpansionZoom(Z) {
          let W = this._getOriginZoom(Z) - 1;
          for (; W <= this.options.maxZoom; ) {
            const J = this.getChildren(Z);
            if (W++, J.length !== 1) break;
            Z = J[0].properties.cluster_id;
          }
          return W;
        }
        _appendLeaves(Z, W, J, fe, Ae) {
          const Ce = this.getChildren(W);
          for (const Me of Ce) {
            const pe = Me.properties;
            if (pe && pe.cluster ? Ae + pe.point_count <= fe ? Ae += pe.point_count : Ae = this._appendLeaves(Z, pe.cluster_id, J, fe, Ae) : Ae < fe ? Ae++ : Z.push(Me), Z.length === J) break;
          }
          return Ae;
        }
        _createTree(Z) {
          const W = new v.av(Z.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let J = 0; J < Z.length; J += this.stride) W.add(Z[J], Z[J + 1]);
          return W.finish(), W.data = Z, W;
        }
        _addTileFeatures(Z, W, J, fe, Ae, Ce) {
          for (const Me of Z) {
            const pe = Me * this.stride, Oe = W[pe + K] > 1;
            let ot, Je, Ge;
            if (Oe) ot = Be(W, pe, this.clusterProps), Je = W[pe], Ge = W[pe + 1];
            else {
              const gi = this.points[W[pe + wt]];
              ot = gi.properties;
              const [ti, mi] = gi.geometry.coordinates;
              Je = Ve(ti), Ge = We(mi);
            }
            const It = { type: 1, geometry: [[Math.round(this.options.extent * (Je * Ae - J)), Math.round(this.options.extent * (Ge * Ae - fe))]], tags: ot };
            let Nt;
            Nt = Oe || this.options.generateId ? W[pe + wt] : this.points[W[pe + wt]].id, Nt !== void 0 && (It.id = Nt), Ce.features.push(It);
          }
        }
        _limitZoom(Z) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+Z), this.options.maxZoom + 1));
        }
        _cluster(Z, W) {
          const { radius: J, extent: fe, reduce: Ae, minPoints: Ce } = this.options, Me = J / (fe * Math.pow(2, W)), pe = Z.data, Oe = [], ot = this.stride;
          for (let Je = 0; Je < pe.length; Je += ot) {
            if (pe[Je + 2] <= W) continue;
            pe[Je + 2] = W;
            const Ge = pe[Je], It = pe[Je + 1], Nt = Z.within(pe[Je], pe[Je + 1], Me), gi = pe[Je + K];
            let ti = gi;
            for (const mi of Nt) {
              const Ii = mi * ot;
              pe[Ii + 2] > W && (ti += pe[Ii + K]);
            }
            if (ti > gi && ti >= Ce) {
              let mi, Ii = Ge * gi, Ei = It * gi, Ui = -1;
              const ai = ((Je / ot | 0) << 5) + (W + 1) + this.points.length;
              for (const Fi of Nt) {
                const er = Fi * ot;
                if (pe[er + 2] <= W) continue;
                pe[er + 2] = W;
                const Mr = pe[er + K];
                Ii += pe[er] * Mr, Ei += pe[er + 1] * Mr, pe[er + 4] = ai, Ae && (mi || (mi = this._map(pe, Je, !0), Ui = this.clusterProps.length, this.clusterProps.push(mi)), Ae(mi, this._map(pe, er)));
              }
              pe[Je + 4] = ai, Oe.push(Ii / ti, Ei / ti, 1 / 0, ai, -1, ti), Ae && Oe.push(Ui);
            } else {
              for (let mi = 0; mi < ot; mi++) Oe.push(pe[Je + mi]);
              if (ti > 1) for (const mi of Nt) {
                const Ii = mi * ot;
                if (!(pe[Ii + 2] <= W)) {
                  pe[Ii + 2] = W;
                  for (let Ei = 0; Ei < ot; Ei++) Oe.push(pe[Ii + Ei]);
                }
              }
            }
          }
          return Oe;
        }
        _getOriginId(Z) {
          return Z - this.points.length >> 5;
        }
        _getOriginZoom(Z) {
          return (Z - this.points.length) % 32;
        }
        _map(Z, W, J) {
          if (Z[W + K] > 1) {
            const Ce = this.clusterProps[Z[W + ge]];
            return J ? Object.assign({}, Ce) : Ce;
          }
          const fe = this.points[Z[W + wt]].properties, Ae = this.options.map(fe);
          return J && Ae === fe ? Object.assign({}, Ae) : Ae;
        }
      }
      function Ee(de, Z, W) {
        return { type: "Feature", id: de[Z + wt], properties: Be(de, Z, W), geometry: { type: "Point", coordinates: [(J = de[Z], 360 * (J - 0.5)), Ye(de[Z + 1])] } };
        var J;
      }
      function Be(de, Z, W) {
        const J = de[Z + K], fe = J >= 1e4 ? `${Math.round(J / 1e3)}k` : J >= 1e3 ? Math.round(J / 100) / 10 + "k" : J, Ae = de[Z + ge], Ce = Ae === -1 ? {} : Object.assign({}, W[Ae]);
        return Object.assign(Ce, { cluster: !0, cluster_id: de[Z + wt], point_count: J, point_count_abbreviated: fe });
      }
      function Ve(de) {
        return de / 360 + 0.5;
      }
      function We(de) {
        const Z = Math.sin(de * Math.PI / 180), W = 0.5 - 0.25 * Math.log((1 + Z) / (1 - Z)) / Math.PI;
        return W < 0 ? 0 : W > 1 ? 1 : W;
      }
      function Ye(de) {
        const Z = (180 - 360 * de) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(Z)) / Math.PI - 90;
      }
      function bt(de, Z, W, J) {
        for (var fe, Ae = J, Ce = W - Z >> 1, Me = W - Z, pe = de[Z], Oe = de[Z + 1], ot = de[W], Je = de[W + 1], Ge = Z + 3; Ge < W; Ge += 3) {
          var It = xt(de[Ge], de[Ge + 1], pe, Oe, ot, Je);
          if (It > Ae) fe = Ge, Ae = It;
          else if (It === Ae) {
            var Nt = Math.abs(Ge - Ce);
            Nt < Me && (fe = Ge, Me = Nt);
          }
        }
        Ae > J && (fe - Z > 3 && bt(de, Z, fe, J), de[fe + 2] = Ae, W - fe > 3 && bt(de, fe, W, J));
      }
      function xt(de, Z, W, J, fe, Ae) {
        var Ce = fe - W, Me = Ae - J;
        if (Ce !== 0 || Me !== 0) {
          var pe = ((de - W) * Ce + (Z - J) * Me) / (Ce * Ce + Me * Me);
          pe > 1 ? (W = fe, J = Ae) : pe > 0 && (W += Ce * pe, J += Me * pe);
        }
        return (Ce = de - W) * Ce + (Me = Z - J) * Me;
      }
      function kt(de, Z, W, J) {
        var fe = { id: de === void 0 ? null : de, type: Z, geometry: W, tags: J, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(Ae) {
          var Ce = Ae.geometry, Me = Ae.type;
          if (Me === "Point" || Me === "MultiPoint" || Me === "LineString") zt(Ae, Ce);
          else if (Me === "Polygon" || Me === "MultiLineString") for (var pe = 0; pe < Ce.length; pe++) zt(Ae, Ce[pe]);
          else if (Me === "MultiPolygon") for (pe = 0; pe < Ce.length; pe++) for (var Oe = 0; Oe < Ce[pe].length; Oe++) zt(Ae, Ce[pe][Oe]);
        }(fe), fe;
      }
      function zt(de, Z) {
        for (var W = 0; W < Z.length; W += 3) de.minX = Math.min(de.minX, Z[W]), de.minY = Math.min(de.minY, Z[W + 1]), de.maxX = Math.max(de.maxX, Z[W]), de.maxY = Math.max(de.maxY, Z[W + 1]);
      }
      function Ut(de, Z, W, J) {
        if (Z.geometry) {
          var fe = Z.geometry.coordinates, Ae = Z.geometry.type, Ce = Math.pow(W.tolerance / ((1 << W.maxZoom) * W.extent), 2), Me = [], pe = Z.id;
          if (W.promoteId ? pe = Z.properties[W.promoteId] : W.generateId && (pe = J || 0), Ae === "Point") st(fe, Me);
          else if (Ae === "MultiPoint") for (var Oe = 0; Oe < fe.length; Oe++) st(fe[Oe], Me);
          else if (Ae === "LineString") te(fe, Me, Ce, !1);
          else if (Ae === "MultiLineString") {
            if (W.lineMetrics) {
              for (Oe = 0; Oe < fe.length; Oe++) te(fe[Oe], Me = [], Ce, !1), de.push(kt(pe, "LineString", Me, Z.properties));
              return;
            }
            hi(fe, Me, Ce, !1);
          } else if (Ae === "Polygon") hi(fe, Me, Ce, !0);
          else {
            if (Ae !== "MultiPolygon") {
              if (Ae === "GeometryCollection") {
                for (Oe = 0; Oe < Z.geometry.geometries.length; Oe++) Ut(de, { id: pe, geometry: Z.geometry.geometries[Oe], properties: Z.properties }, W, J);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (Oe = 0; Oe < fe.length; Oe++) {
              var ot = [];
              hi(fe[Oe], ot, Ce, !0), Me.push(ot);
            }
          }
          de.push(kt(pe, Ae, Me, Z.properties));
        }
      }
      function st(de, Z) {
        Z.push(Ht(de[0])), Z.push(ut(de[1])), Z.push(0);
      }
      function te(de, Z, W, J) {
        for (var fe, Ae, Ce = 0, Me = 0; Me < de.length; Me++) {
          var pe = Ht(de[Me][0]), Oe = ut(de[Me][1]);
          Z.push(pe), Z.push(Oe), Z.push(0), Me > 0 && (Ce += J ? (fe * Oe - pe * Ae) / 2 : Math.sqrt(Math.pow(pe - fe, 2) + Math.pow(Oe - Ae, 2))), fe = pe, Ae = Oe;
        }
        var ot = Z.length - 3;
        Z[2] = 1, bt(Z, 0, ot, W), Z[ot + 2] = 1, Z.size = Math.abs(Ce), Z.start = 0, Z.end = Z.size;
      }
      function hi(de, Z, W, J) {
        for (var fe = 0; fe < de.length; fe++) {
          var Ae = [];
          te(de[fe], Ae, W, J), Z.push(Ae);
        }
      }
      function Ht(de) {
        return de / 360 + 0.5;
      }
      function ut(de) {
        var Z = Math.sin(de * Math.PI / 180), W = 0.5 - 0.25 * Math.log((1 + Z) / (1 - Z)) / Math.PI;
        return W < 0 ? 0 : W > 1 ? 1 : W;
      }
      function _t(de, Z, W, J, fe, Ae, Ce, Me) {
        if (J /= Z, Ae >= (W /= Z) && Ce < J) return de;
        if (Ce < W || Ae >= J) return null;
        for (var pe = [], Oe = 0; Oe < de.length; Oe++) {
          var ot = de[Oe], Je = ot.geometry, Ge = ot.type, It = fe === 0 ? ot.minX : ot.minY, Nt = fe === 0 ? ot.maxX : ot.maxY;
          if (It >= W && Nt < J) pe.push(ot);
          else if (!(Nt < W || It >= J)) {
            var gi = [];
            if (Ge === "Point" || Ge === "MultiPoint") Lt(Je, gi, W, J, fe);
            else if (Ge === "LineString") Ct(Je, gi, W, J, fe, !1, Me.lineMetrics);
            else if (Ge === "MultiLineString") pi(Je, gi, W, J, fe, !1);
            else if (Ge === "Polygon") pi(Je, gi, W, J, fe, !0);
            else if (Ge === "MultiPolygon") for (var ti = 0; ti < Je.length; ti++) {
              var mi = [];
              pi(Je[ti], mi, W, J, fe, !0), mi.length && gi.push(mi);
            }
            if (gi.length) {
              if (Me.lineMetrics && Ge === "LineString") {
                for (ti = 0; ti < gi.length; ti++) pe.push(kt(ot.id, Ge, gi[ti], ot.tags));
                continue;
              }
              Ge !== "LineString" && Ge !== "MultiLineString" || (gi.length === 1 ? (Ge = "LineString", gi = gi[0]) : Ge = "MultiLineString"), Ge !== "Point" && Ge !== "MultiPoint" || (Ge = gi.length === 3 ? "Point" : "MultiPoint"), pe.push(kt(ot.id, Ge, gi, ot.tags));
            }
          }
        }
        return pe.length ? pe : null;
      }
      function Lt(de, Z, W, J, fe) {
        for (var Ae = 0; Ae < de.length; Ae += 3) {
          var Ce = de[Ae + fe];
          Ce >= W && Ce <= J && (Z.push(de[Ae]), Z.push(de[Ae + 1]), Z.push(de[Ae + 2]));
        }
      }
      function Ct(de, Z, W, J, fe, Ae, Ce) {
        for (var Me, pe, Oe = ei(de), ot = fe === 0 ? wi : Ci, Je = de.start, Ge = 0; Ge < de.length - 3; Ge += 3) {
          var It = de[Ge], Nt = de[Ge + 1], gi = de[Ge + 2], ti = de[Ge + 3], mi = de[Ge + 4], Ii = fe === 0 ? It : Nt, Ei = fe === 0 ? ti : mi, Ui = !1;
          Ce && (Me = Math.sqrt(Math.pow(It - ti, 2) + Math.pow(Nt - mi, 2))), Ii < W ? Ei > W && (pe = ot(Oe, It, Nt, ti, mi, W), Ce && (Oe.start = Je + Me * pe)) : Ii > J ? Ei < J && (pe = ot(Oe, It, Nt, ti, mi, J), Ce && (Oe.start = Je + Me * pe)) : fi(Oe, It, Nt, gi), Ei < W && Ii >= W && (pe = ot(Oe, It, Nt, ti, mi, W), Ui = !0), Ei > J && Ii <= J && (pe = ot(Oe, It, Nt, ti, mi, J), Ui = !0), !Ae && Ui && (Ce && (Oe.end = Je + Me * pe), Z.push(Oe), Oe = ei(de)), Ce && (Je += Me);
        }
        var ai = de.length - 3;
        It = de[ai], Nt = de[ai + 1], gi = de[ai + 2], (Ii = fe === 0 ? It : Nt) >= W && Ii <= J && fi(Oe, It, Nt, gi), ai = Oe.length - 3, Ae && ai >= 3 && (Oe[ai] !== Oe[0] || Oe[ai + 1] !== Oe[1]) && fi(Oe, Oe[0], Oe[1], Oe[2]), Oe.length && Z.push(Oe);
      }
      function ei(de) {
        var Z = [];
        return Z.size = de.size, Z.start = de.start, Z.end = de.end, Z;
      }
      function pi(de, Z, W, J, fe, Ae) {
        for (var Ce = 0; Ce < de.length; Ce++) Ct(de[Ce], Z, W, J, fe, Ae, !1);
      }
      function fi(de, Z, W, J) {
        de.push(Z), de.push(W), de.push(J);
      }
      function wi(de, Z, W, J, fe, Ae) {
        var Ce = (Ae - Z) / (J - Z);
        return de.push(Ae), de.push(W + (fe - W) * Ce), de.push(1), Ce;
      }
      function Ci(de, Z, W, J, fe, Ae) {
        var Ce = (Ae - W) / (fe - W);
        return de.push(Z + (J - Z) * Ce), de.push(Ae), de.push(1), Ce;
      }
      function pt(de, Z) {
        for (var W = [], J = 0; J < de.length; J++) {
          var fe, Ae = de[J], Ce = Ae.type;
          if (Ce === "Point" || Ce === "MultiPoint" || Ce === "LineString") fe = Jt(Ae.geometry, Z);
          else if (Ce === "MultiLineString" || Ce === "Polygon") {
            fe = [];
            for (var Me = 0; Me < Ae.geometry.length; Me++) fe.push(Jt(Ae.geometry[Me], Z));
          } else if (Ce === "MultiPolygon") for (fe = [], Me = 0; Me < Ae.geometry.length; Me++) {
            for (var pe = [], Oe = 0; Oe < Ae.geometry[Me].length; Oe++) pe.push(Jt(Ae.geometry[Me][Oe], Z));
            fe.push(pe);
          }
          W.push(kt(Ae.id, Ce, fe, Ae.tags));
        }
        return W;
      }
      function Jt(de, Z) {
        var W = [];
        W.size = de.size, de.start !== void 0 && (W.start = de.start, W.end = de.end);
        for (var J = 0; J < de.length; J += 3) W.push(de[J] + Z, de[J + 1], de[J + 2]);
        return W;
      }
      function ui(de, Z) {
        if (de.transformed) return de;
        var W, J, fe, Ae = 1 << de.z, Ce = de.x, Me = de.y;
        for (W = 0; W < de.features.length; W++) {
          var pe = de.features[W], Oe = pe.geometry, ot = pe.type;
          if (pe.geometry = [], ot === 1) for (J = 0; J < Oe.length; J += 2) pe.geometry.push(Dt(Oe[J], Oe[J + 1], Z, Ae, Ce, Me));
          else for (J = 0; J < Oe.length; J++) {
            var Je = [];
            for (fe = 0; fe < Oe[J].length; fe += 2) Je.push(Dt(Oe[J][fe], Oe[J][fe + 1], Z, Ae, Ce, Me));
            pe.geometry.push(Je);
          }
        }
        return de.transformed = !0, de;
      }
      function Dt(de, Z, W, J, fe, Ae) {
        return [Math.round(W * (de * J - fe)), Math.round(W * (Z * J - Ae))];
      }
      function gr(de, Z, W, J, fe) {
        for (var Ae = Z === fe.maxZoom ? 0 : fe.tolerance / ((1 << Z) * fe.extent), Ce = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: W, y: J, z: Z, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, Me = 0; Me < de.length; Me++) {
          Ce.numFeatures++, lt(Ce, de[Me], Ae, fe);
          var pe = de[Me].minX, Oe = de[Me].minY, ot = de[Me].maxX, Je = de[Me].maxY;
          pe < Ce.minX && (Ce.minX = pe), Oe < Ce.minY && (Ce.minY = Oe), ot > Ce.maxX && (Ce.maxX = ot), Je > Ce.maxY && (Ce.maxY = Je);
        }
        return Ce;
      }
      function lt(de, Z, W, J) {
        var fe = Z.geometry, Ae = Z.type, Ce = [];
        if (Ae === "Point" || Ae === "MultiPoint") for (var Me = 0; Me < fe.length; Me += 3) Ce.push(fe[Me]), Ce.push(fe[Me + 1]), de.numPoints++, de.numSimplified++;
        else if (Ae === "LineString") li(Ce, fe, de, W, !1, !1);
        else if (Ae === "MultiLineString" || Ae === "Polygon") for (Me = 0; Me < fe.length; Me++) li(Ce, fe[Me], de, W, Ae === "Polygon", Me === 0);
        else if (Ae === "MultiPolygon") for (var pe = 0; pe < fe.length; pe++) {
          var Oe = fe[pe];
          for (Me = 0; Me < Oe.length; Me++) li(Ce, Oe[Me], de, W, !0, Me === 0);
        }
        if (Ce.length) {
          var ot = Z.tags || null;
          if (Ae === "LineString" && J.lineMetrics) {
            for (var Je in ot = {}, Z.tags) ot[Je] = Z.tags[Je];
            ot.mapbox_clip_start = fe.start / fe.size, ot.mapbox_clip_end = fe.end / fe.size;
          }
          var Ge = { geometry: Ce, type: Ae === "Polygon" || Ae === "MultiPolygon" ? 3 : Ae === "LineString" || Ae === "MultiLineString" ? 2 : 1, tags: ot };
          Z.id !== null && (Ge.id = Z.id), de.features.push(Ge);
        }
      }
      function li(de, Z, W, J, fe, Ae) {
        var Ce = J * J;
        if (J > 0 && Z.size < (fe ? Ce : J)) W.numPoints += Z.length / 3;
        else {
          for (var Me = [], pe = 0; pe < Z.length; pe += 3) (J === 0 || Z[pe + 2] > Ce) && (W.numSimplified++, Me.push(Z[pe]), Me.push(Z[pe + 1])), W.numPoints++;
          fe && function(Oe, ot) {
            for (var Je = 0, Ge = 0, It = Oe.length, Nt = It - 2; Ge < It; Nt = Ge, Ge += 2) Je += (Oe[Ge] - Oe[Nt]) * (Oe[Ge + 1] + Oe[Nt + 1]);
            if (Je > 0 === ot) for (Ge = 0, It = Oe.length; Ge < It / 2; Ge += 2) {
              var gi = Oe[Ge], ti = Oe[Ge + 1];
              Oe[Ge] = Oe[It - 2 - Ge], Oe[Ge + 1] = Oe[It - 1 - Ge], Oe[It - 2 - Ge] = gi, Oe[It - 1 - Ge] = ti;
            }
          }(Me, Ae), de.push(Me);
        }
      }
      function Bt(de, Z) {
        var W = (Z = this.options = function(fe, Ae) {
          for (var Ce in Ae) fe[Ce] = Ae[Ce];
          return fe;
        }(Object.create(this.options), Z)).debug;
        if (W && console.time("preprocess data"), Z.maxZoom < 0 || Z.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
        if (Z.promoteId && Z.generateId) throw new Error("promoteId and generateId cannot be used together.");
        var J = function(fe, Ae) {
          var Ce = [];
          if (fe.type === "FeatureCollection") for (var Me = 0; Me < fe.features.length; Me++) Ut(Ce, fe.features[Me], Ae, Me);
          else Ut(Ce, fe.type === "Feature" ? fe : { geometry: fe }, Ae);
          return Ce;
        }(de, Z);
        this.tiles = {}, this.tileCoords = [], W && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", Z.indexMaxZoom, Z.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), J = function(fe, Ae) {
          var Ce = Ae.buffer / Ae.extent, Me = fe, pe = _t(fe, 1, -1 - Ce, Ce, 0, -1, 2, Ae), Oe = _t(fe, 1, 1 - Ce, 2 + Ce, 0, -1, 2, Ae);
          return (pe || Oe) && (Me = _t(fe, 1, -Ce, 1 + Ce, 0, -1, 2, Ae) || [], pe && (Me = pt(pe, 1).concat(Me)), Oe && (Me = Me.concat(pt(Oe, -1)))), Me;
        }(J, Z), J.length && this.splitTile(J, 0, 0, 0), W && (J.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function ki(de, Z, W) {
        return 32 * ((1 << de) * W + Z) + de;
      }
      function lr(de, Z) {
        return Z ? de.properties[Z] : de.id;
      }
      function Ft(de, Z) {
        if (de == null) return !0;
        if (de.type === "Feature") return lr(de, Z) != null;
        if (de.type === "FeatureCollection") {
          const W = /* @__PURE__ */ new Set();
          for (const J of de.features) {
            const fe = lr(J, Z);
            if (fe == null || W.has(fe)) return !1;
            W.add(fe);
          }
          return !0;
        }
        return !1;
      }
      function nn(de, Z) {
        const W = /* @__PURE__ */ new Map();
        if (de != null) if (de.type === "Feature") W.set(lr(de, Z), de);
        else for (const J of de.features) W.set(lr(J, Z), J);
        return W;
      }
      Bt.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, Bt.prototype.splitTile = function(de, Z, W, J, fe, Ae, Ce) {
        for (var Me = [de, Z, W, J], pe = this.options, Oe = pe.debug; Me.length; ) {
          J = Me.pop(), W = Me.pop(), Z = Me.pop(), de = Me.pop();
          var ot = 1 << Z, Je = ki(Z, W, J), Ge = this.tiles[Je];
          if (!Ge && (Oe > 1 && console.time("creation"), Ge = this.tiles[Je] = gr(de, Z, W, J, pe), this.tileCoords.push({ z: Z, x: W, y: J }), Oe)) {
            Oe > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", Z, W, J, Ge.numFeatures, Ge.numPoints, Ge.numSimplified), console.timeEnd("creation"));
            var It = "z" + Z;
            this.stats[It] = (this.stats[It] || 0) + 1, this.total++;
          }
          if (Ge.source = de, fe) {
            if (Z === pe.maxZoom || Z === fe) continue;
            var Nt = 1 << fe - Z;
            if (W !== Math.floor(Ae / Nt) || J !== Math.floor(Ce / Nt)) continue;
          } else if (Z === pe.indexMaxZoom || Ge.numPoints <= pe.indexMaxPoints) continue;
          if (Ge.source = null, de.length !== 0) {
            Oe > 1 && console.time("clipping");
            var gi, ti, mi, Ii, Ei, Ui, ai = 0.5 * pe.buffer / pe.extent, Fi = 0.5 - ai, er = 0.5 + ai, Mr = 1 + ai;
            gi = ti = mi = Ii = null, Ei = _t(de, ot, W - ai, W + er, 0, Ge.minX, Ge.maxX, pe), Ui = _t(de, ot, W + Fi, W + Mr, 0, Ge.minX, Ge.maxX, pe), de = null, Ei && (gi = _t(Ei, ot, J - ai, J + er, 1, Ge.minY, Ge.maxY, pe), ti = _t(Ei, ot, J + Fi, J + Mr, 1, Ge.minY, Ge.maxY, pe), Ei = null), Ui && (mi = _t(Ui, ot, J - ai, J + er, 1, Ge.minY, Ge.maxY, pe), Ii = _t(Ui, ot, J + Fi, J + Mr, 1, Ge.minY, Ge.maxY, pe), Ui = null), Oe > 1 && console.timeEnd("clipping"), Me.push(gi || [], Z + 1, 2 * W, 2 * J), Me.push(ti || [], Z + 1, 2 * W, 2 * J + 1), Me.push(mi || [], Z + 1, 2 * W + 1, 2 * J), Me.push(Ii || [], Z + 1, 2 * W + 1, 2 * J + 1);
          }
        }
      }, Bt.prototype.getTile = function(de, Z, W) {
        var J = this.options, fe = J.extent, Ae = J.debug;
        if (de < 0 || de > 24) return null;
        var Ce = 1 << de, Me = ki(de, Z = (Z % Ce + Ce) % Ce, W);
        if (this.tiles[Me]) return ui(this.tiles[Me], fe);
        Ae > 1 && console.log("drilling down to z%d-%d-%d", de, Z, W);
        for (var pe, Oe = de, ot = Z, Je = W; !pe && Oe > 0; ) Oe--, ot = Math.floor(ot / 2), Je = Math.floor(Je / 2), pe = this.tiles[ki(Oe, ot, Je)];
        return pe && pe.source ? (Ae > 1 && console.log("found parent tile z%d-%d-%d", Oe, ot, Je), Ae > 1 && console.time("drilling down"), this.splitTile(pe.source, Oe, ot, Je, de, Z, W), Ae > 1 && console.timeEnd("drilling down"), this.tiles[Me] ? ui(this.tiles[Me], fe) : null) : null;
      };
      class Oi extends q {
        constructor() {
          super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
        }
        loadVectorTile(Z, W) {
          return v._(this, void 0, void 0, function* () {
            const J = Z.tileID.canonical;
            if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
            const fe = this._geoJSONIndex.getTile(J.z, J.x, J.y);
            if (!fe) return null;
            const Ae = new class {
              constructor(Me) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = v.W, this.length = Me.length, this._features = Me;
              }
              feature(Me) {
                return new class {
                  constructor(pe) {
                    this._feature = pe, this.extent = v.W, this.type = pe.type, this.properties = pe.tags, "id" in pe && !isNaN(pe.id) && (this.id = parseInt(pe.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const pe = [];
                      for (const Oe of this._feature.geometry) pe.push([new v.P(Oe[0], Oe[1])]);
                      return pe;
                    }
                    {
                      const pe = [];
                      for (const Oe of this._feature.geometry) {
                        const ot = [];
                        for (const Je of Oe) ot.push(new v.P(Je[0], Je[1]));
                        pe.push(ot);
                      }
                      return pe;
                    }
                  }
                  toGeoJSON(pe, Oe, ot) {
                    return xe.call(this, pe, Oe, ot);
                  }
                }(this._features[Me]);
              }
            }(fe.features);
            let Ce = rt(Ae);
            return Ce.byteOffset === 0 && Ce.byteLength === Ce.buffer.byteLength || (Ce = new Uint8Array(Ce)), { vectorTile: Ae, rawData: Ce.buffer };
          });
        }
        loadData(Z) {
          return v._(this, void 0, void 0, function* () {
            var W;
            (W = this._pendingRequest) === null || W === void 0 || W.abort();
            const J = !!(Z && Z.request && Z.request.collectResourceTiming) && new v.bt(Z.request);
            this._pendingRequest = new AbortController();
            try {
              this._pendingData = this.loadAndProcessGeoJSON(Z, this._pendingRequest), this._geoJSONIndex = Z.cluster ? new we(function({ superclusterOptions: Ae, clusterProperties: Ce }) {
                if (!Ce || !Ae) return Ae;
                const Me = {}, pe = {}, Oe = { accumulated: null, zoom: 0 }, ot = { properties: null }, Je = Object.keys(Ce);
                for (const Ge of Je) {
                  const [It, Nt] = Ce[Ge], gi = v.bA(Nt), ti = v.bA(typeof It == "string" ? [It, ["accumulated"], ["get", Ge]] : It);
                  Me[Ge] = gi.value, pe[Ge] = ti.value;
                }
                return Ae.map = (Ge) => {
                  ot.properties = Ge;
                  const It = {};
                  for (const Nt of Je) It[Nt] = Me[Nt].evaluate(Oe, ot);
                  return It;
                }, Ae.reduce = (Ge, It) => {
                  ot.properties = It;
                  for (const Nt of Je) Oe.accumulated = Ge[Nt], Ge[Nt] = pe[Nt].evaluate(Oe, ot);
                }, Ae;
              }(Z)).load((yield this._pendingData).features) : new Bt(yield this._pendingData, Z.geojsonVtOptions), this.loaded = {};
              const fe = {};
              if (J) {
                const Ae = J.finish();
                Ae && (fe.resourceTiming = {}, fe.resourceTiming[Z.source] = JSON.parse(JSON.stringify(Ae)));
              }
              return fe;
            } catch (fe) {
              if (delete this._pendingRequest, v.bz(fe)) return { abandoned: !0 };
              throw fe;
            }
          });
        }
        getData() {
          return v._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile(Z) {
          const W = this.loaded;
          return W && W[Z.uid] ? super.reloadTile(Z) : this.loadTile(Z);
        }
        loadAndProcessGeoJSON(Z, W) {
          return v._(this, void 0, void 0, function* () {
            let J = yield this.loadGeoJSON(Z, W);
            if (delete this._pendingRequest, typeof J != "object") throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
            if (oe(J, !0), Z.filter) {
              const fe = v.bA(Z.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
              if (fe.result === "error") throw new Error(fe.value.map((Ce) => `${Ce.key}: ${Ce.message}`).join(", "));
              J = { type: "FeatureCollection", features: J.features.filter((Ce) => fe.value.evaluate({ zoom: 0 }, Ce)) };
            }
            return J;
          });
        }
        loadGeoJSON(Z, W) {
          return v._(this, void 0, void 0, function* () {
            const { promoteId: J } = Z;
            if (Z.request) {
              const fe = yield v.h(Z.request, W);
              return this._dataUpdateable = Ft(fe.data, J) ? nn(fe.data, J) : void 0, fe.data;
            }
            if (typeof Z.data == "string") try {
              const fe = JSON.parse(Z.data);
              return this._dataUpdateable = Ft(fe, J) ? nn(fe, J) : void 0, fe;
            } catch {
              throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
            }
            if (!Z.dataDiff) throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${Z.source}`);
            return function(fe, Ae, Ce) {
              var Me, pe, Oe, ot;
              if (Ae.removeAll && fe.clear(), Ae.remove) for (const Je of Ae.remove) fe.delete(Je);
              if (Ae.add) for (const Je of Ae.add) {
                const Ge = lr(Je, Ce);
                Ge != null && fe.set(Ge, Je);
              }
              if (Ae.update) for (const Je of Ae.update) {
                let Ge = fe.get(Je.id);
                if (Ge == null) continue;
                const It = !Je.removeAllProperties && (((Me = Je.removeProperties) === null || Me === void 0 ? void 0 : Me.length) > 0 || ((pe = Je.addOrUpdateProperties) === null || pe === void 0 ? void 0 : pe.length) > 0);
                if ((Je.newGeometry || Je.removeAllProperties || It) && (Ge = Object.assign({}, Ge), fe.set(Je.id, Ge), It && (Ge.properties = Object.assign({}, Ge.properties))), Je.newGeometry && (Ge.geometry = Je.newGeometry), Je.removeAllProperties) Ge.properties = {};
                else if (((Oe = Je.removeProperties) === null || Oe === void 0 ? void 0 : Oe.length) > 0) for (const Nt of Je.removeProperties) Object.prototype.hasOwnProperty.call(Ge.properties, Nt) && delete Ge.properties[Nt];
                if (((ot = Je.addOrUpdateProperties) === null || ot === void 0 ? void 0 : ot.length) > 0) for (const { key: Nt, value: gi } of Je.addOrUpdateProperties) Ge.properties[Nt] = gi;
              }
            }(this._dataUpdateable, Z.dataDiff, J), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(Z) {
          return v._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(Z) {
          return this._geoJSONIndex.getClusterExpansionZoom(Z.clusterId);
        }
        getClusterChildren(Z) {
          return this._geoJSONIndex.getChildren(Z.clusterId);
        }
        getClusterLeaves(Z) {
          return this._geoJSONIndex.getLeaves(Z.clusterId, Z.limit, Z.offset);
        }
      }
      class $i {
        constructor(Z) {
          this.self = Z, this.actor = new v.C(Z), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (W, J) => {
            if (this.externalWorkerSourceTypes[W]) throw new Error(`Worker source with name "${W}" already registered.`);
            this.externalWorkerSourceTypes[W] = J;
          }, this.self.addProtocol = v.bg, this.self.removeProtocol = v.bh, this.self.registerRTLTextPlugin = (W) => {
            if (v.bB.isParsed()) throw new Error("RTL text plugin already registered.");
            v.bB.setMethods(W);
          }, this.actor.registerMessageHandler("LDT", (W, J) => this._getDEMWorkerSource(W, J.source).loadTile(J)), this.actor.registerMessageHandler("RDT", (W, J) => v._(this, void 0, void 0, function* () {
            this._getDEMWorkerSource(W, J.source).removeTile(J);
          })), this.actor.registerMessageHandler("GCEZ", (W, J) => v._(this, void 0, void 0, function* () {
            return this._getWorkerSource(W, J.type, J.source).getClusterExpansionZoom(J);
          })), this.actor.registerMessageHandler("GCC", (W, J) => v._(this, void 0, void 0, function* () {
            return this._getWorkerSource(W, J.type, J.source).getClusterChildren(J);
          })), this.actor.registerMessageHandler("GCL", (W, J) => v._(this, void 0, void 0, function* () {
            return this._getWorkerSource(W, J.type, J.source).getClusterLeaves(J);
          })), this.actor.registerMessageHandler("LD", (W, J) => this._getWorkerSource(W, J.type, J.source).loadData(J)), this.actor.registerMessageHandler("GD", (W, J) => this._getWorkerSource(W, J.type, J.source).getData()), this.actor.registerMessageHandler("LT", (W, J) => this._getWorkerSource(W, J.type, J.source).loadTile(J)), this.actor.registerMessageHandler("RT", (W, J) => this._getWorkerSource(W, J.type, J.source).reloadTile(J)), this.actor.registerMessageHandler("AT", (W, J) => this._getWorkerSource(W, J.type, J.source).abortTile(J)), this.actor.registerMessageHandler("RMT", (W, J) => this._getWorkerSource(W, J.type, J.source).removeTile(J)), this.actor.registerMessageHandler("RS", (W, J) => v._(this, void 0, void 0, function* () {
            if (!this.workerSources[W] || !this.workerSources[W][J.type] || !this.workerSources[W][J.type][J.source]) return;
            const fe = this.workerSources[W][J.type][J.source];
            delete this.workerSources[W][J.type][J.source], fe.removeSource !== void 0 && fe.removeSource(J);
          })), this.actor.registerMessageHandler("RM", (W) => v._(this, void 0, void 0, function* () {
            delete this.layerIndexes[W], delete this.availableImages[W], delete this.workerSources[W], delete this.demWorkerSources[W];
          })), this.actor.registerMessageHandler("SR", (W, J) => v._(this, void 0, void 0, function* () {
            this.referrer = J;
          })), this.actor.registerMessageHandler("SRPS", (W, J) => this._syncRTLPluginState(W, J)), this.actor.registerMessageHandler("IS", (W, J) => v._(this, void 0, void 0, function* () {
            this.self.importScripts(J);
          })), this.actor.registerMessageHandler("SI", (W, J) => this._setImages(W, J)), this.actor.registerMessageHandler("UL", (W, J) => v._(this, void 0, void 0, function* () {
            this._getLayerIndex(W).update(J.layers, J.removedIds);
          })), this.actor.registerMessageHandler("SL", (W, J) => v._(this, void 0, void 0, function* () {
            this._getLayerIndex(W).replace(J);
          }));
        }
        _setImages(Z, W) {
          return v._(this, void 0, void 0, function* () {
            this.availableImages[Z] = W;
            for (const J in this.workerSources[Z]) {
              const fe = this.workerSources[Z][J];
              for (const Ae in fe) fe[Ae].availableImages = W;
            }
          });
        }
        _syncRTLPluginState(Z, W) {
          return v._(this, void 0, void 0, function* () {
            if (v.bB.isParsed()) return v.bB.getState();
            if (W.pluginStatus !== "loading") return v.bB.setState(W), W;
            const J = W.pluginURL;
            if (this.self.importScripts(J), v.bB.isParsed()) {
              const fe = { pluginStatus: "loaded", pluginURL: J };
              return v.bB.setState(fe), fe;
            }
            throw v.bB.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${J}`);
          });
        }
        _getAvailableImages(Z) {
          let W = this.availableImages[Z];
          return W || (W = []), W;
        }
        _getLayerIndex(Z) {
          let W = this.layerIndexes[Z];
          return W || (W = this.layerIndexes[Z] = new o()), W;
        }
        _getWorkerSource(Z, W, J) {
          if (this.workerSources[Z] || (this.workerSources[Z] = {}), this.workerSources[Z][W] || (this.workerSources[Z][W] = {}), !this.workerSources[Z][W][J]) {
            const fe = { sendAsync: (Ae, Ce) => (Ae.targetMapId = Z, this.actor.sendAsync(Ae, Ce)) };
            switch (W) {
              case "vector":
                this.workerSources[Z][W][J] = new q(fe, this._getLayerIndex(Z), this._getAvailableImages(Z));
                break;
              case "geojson":
                this.workerSources[Z][W][J] = new Oi(fe, this._getLayerIndex(Z), this._getAvailableImages(Z));
                break;
              default:
                this.workerSources[Z][W][J] = new this.externalWorkerSourceTypes[W](fe, this._getLayerIndex(Z), this._getAvailableImages(Z));
            }
          }
          return this.workerSources[Z][W][J];
        }
        _getDEMWorkerSource(Z, W) {
          return this.demWorkerSources[Z] || (this.demWorkerSources[Z] = {}), this.demWorkerSources[Z][W] || (this.demWorkerSources[Z][W] = new U()), this.demWorkerSources[Z][W];
        }
      }
      return v.i(self) && (self.worker = new $i(self)), $i;
    }), I("index", ["exports", "./shared"], function(v, o) {
      var D = "4.4.0";
      let j, V;
      const q = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (f) => new Promise((t, n) => {
        const c = requestAnimationFrame(t);
        f.signal.addEventListener("abort", () => {
          cancelAnimationFrame(c), n(o.c());
        });
      }), getImageData(f, t = 0) {
        return this.getImageCanvasContext(f).getImageData(-t, -t, f.width + 2 * t, f.height + 2 * t);
      }, getImageCanvasContext(f) {
        const t = window.document.createElement("canvas"), n = t.getContext("2d", { willReadFrequently: !0 });
        if (!n) throw new Error("failed to create canvas 2d context");
        return t.width = f.width, t.height = f.height, n.drawImage(f, 0, 0, f.width, f.height), n;
      }, resolveURL: (f) => (j || (j = document.createElement("a")), j.href = f, j.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (V == null && (V = matchMedia("(prefers-reduced-motion: reduce)")), V.matches);
      } };
      class U {
        static testProp(t) {
          if (!U.docStyle) return t[0];
          for (let n = 0; n < t.length; n++) if (t[n] in U.docStyle) return t[n];
          return t[0];
        }
        static create(t, n, c) {
          const u = window.document.createElement(t);
          return n !== void 0 && (u.className = n), c && c.appendChild(u), u;
        }
        static createNS(t, n) {
          return window.document.createElementNS(t, n);
        }
        static disableDrag() {
          U.docStyle && U.selectProp && (U.userSelect = U.docStyle[U.selectProp], U.docStyle[U.selectProp] = "none");
        }
        static enableDrag() {
          U.docStyle && U.selectProp && (U.docStyle[U.selectProp] = U.userSelect);
        }
        static setTransform(t, n) {
          t.style[U.transformProp] = n;
        }
        static addEventListener(t, n, c, u = {}) {
          t.addEventListener(n, c, "passive" in u ? u : u.capture);
        }
        static removeEventListener(t, n, c, u = {}) {
          t.removeEventListener(n, c, "passive" in u ? u : u.capture);
        }
        static suppressClickInternal(t) {
          t.preventDefault(), t.stopPropagation(), window.removeEventListener("click", U.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", U.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", U.suppressClickInternal, !0);
          }, 0);
        }
        static getScale(t) {
          const n = t.getBoundingClientRect();
          return { x: n.width / t.offsetWidth || 1, y: n.height / t.offsetHeight || 1, boundingClientRect: n };
        }
        static getPoint(t, n, c) {
          const u = n.boundingClientRect;
          return new o.P((c.clientX - u.left) / n.x - t.clientLeft, (c.clientY - u.top) / n.y - t.clientTop);
        }
        static mousePos(t, n) {
          const c = U.getScale(t);
          return U.getPoint(t, c, n);
        }
        static touchPos(t, n) {
          const c = [], u = U.getScale(t);
          for (let m = 0; m < n.length; m++) c.push(U.getPoint(t, u, n[m]));
          return c;
        }
        static mouseButton(t) {
          return t.button;
        }
        static remove(t) {
          t.parentNode && t.parentNode.removeChild(t);
        }
      }
      U.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, U.selectProp = U.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), U.transformProp = U.testProp(["transform", "WebkitTransform"]);
      const B = { supported: !1, testSupport: function(f) {
        !xe && oe && (se ? ve(f) : ye = f);
      } };
      let ye, oe, xe = !1, se = !1;
      function ve(f) {
        const t = f.createTexture();
        f.bindTexture(f.TEXTURE_2D, t);
        try {
          if (f.texImage2D(f.TEXTURE_2D, 0, f.RGBA, f.RGBA, f.UNSIGNED_BYTE, oe), f.isContextLost()) return;
          B.supported = !0;
        } catch {
        }
        f.deleteTexture(t), xe = !0;
      }
      var Fe;
      typeof document < "u" && (oe = document.createElement("img"), oe.onload = () => {
        ye && ve(ye), ye = null, se = !0;
      }, oe.onerror = () => {
        xe = !0, ye = null;
      }, oe.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(f) {
        let t, n, c, u;
        f.resetRequestQueue = () => {
          t = [], n = 0, c = 0, u = {};
        }, f.addThrottleControl = (l) => {
          const p = c++;
          return u[p] = l, p;
        }, f.removeThrottleControl = (l) => {
          delete u[l], T();
        }, f.getImage = (l, p, b = !0) => new Promise((P, C) => {
          B.supported && (l.headers || (l.headers = {}), l.headers.accept = "image/webp,*/*"), o.e(l, { type: "image" }), t.push({ abortController: p, requestParameters: l, supportImageRefresh: b, state: "queued", onError: (E) => {
            C(E);
          }, onSuccess: (E) => {
            P(E);
          } }), T();
        });
        const m = (l) => o._(this, void 0, void 0, function* () {
          l.state = "running";
          const { requestParameters: p, supportImageRefresh: b, onError: P, onSuccess: C, abortController: E } = l, z = b === !1 && !o.i(self) && !o.g(p.url) && (!p.headers || Object.keys(p.headers).reduce((G, ie) => G && ie === "accept", !0));
          n++;
          const N = z ? s(p, E) : o.m(p, E);
          try {
            const G = yield N;
            delete l.abortController, l.state = "completed", G.data instanceof HTMLImageElement || o.b(G.data) ? C(G) : G.data && C({ data: yield (R = G.data, typeof createImageBitmap == "function" ? o.d(R) : o.f(R)), cacheControl: G.cacheControl, expires: G.expires });
          } catch (G) {
            delete l.abortController, P(G);
          } finally {
            n--, T();
          }
          var R;
        }), T = () => {
          const l = (() => {
            for (const p of Object.keys(u)) if (u[p]()) return !0;
            return !1;
          })() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let p = n; p < l && t.length > 0; p++) {
            const b = t.shift();
            b.abortController.signal.aborted ? p-- : m(b);
          }
        }, s = (l, p) => new Promise((b, P) => {
          const C = new Image(), E = l.url, z = l.credentials;
          z && z === "include" ? C.crossOrigin = "use-credentials" : (z && z === "same-origin" || !o.s(E)) && (C.crossOrigin = "anonymous"), p.signal.addEventListener("abort", () => {
            C.src = "", P(o.c());
          }), C.fetchPriority = "high", C.onload = () => {
            C.onerror = C.onload = null, b({ data: C });
          }, C.onerror = () => {
            C.onerror = C.onload = null, p.signal.aborted || P(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, C.src = E;
        });
      }(Fe || (Fe = {})), Fe.resetRequestQueue();
      class it {
        constructor(t) {
          this._transformRequestFn = t;
        }
        transformRequest(t, n) {
          return this._transformRequestFn && this._transformRequestFn(t, n) || { url: t };
        }
        setTransformRequest(t) {
          this._transformRequestFn = t;
        }
      }
      function Ke(f) {
        var t = new o.A(3);
        return t[0] = f[0], t[1] = f[1], t[2] = f[2], t;
      }
      var gt, $e = function(f, t, n) {
        return f[0] = t[0] - n[0], f[1] = t[1] - n[1], f[2] = t[2] - n[2], f;
      };
      gt = new o.A(3), o.A != Float32Array && (gt[0] = 0, gt[1] = 0, gt[2] = 0);
      var Le = function(f) {
        var t = f[0], n = f[1];
        return t * t + n * n;
      };
      function dt(f) {
        const t = [];
        if (typeof f == "string") t.push({ id: "default", url: f });
        else if (f && f.length > 0) {
          const n = [];
          for (const { id: c, url: u } of f) {
            const m = `${c}${u}`;
            n.indexOf(m) === -1 && (n.push(m), t.push({ id: c, url: u }));
          }
        }
        return t;
      }
      function at(f, t, n) {
        const c = f.split("?");
        return c[0] += `${t}${n}`, c.join("?");
      }
      (function() {
        var f = new o.A(2);
        o.A != Float32Array && (f[0] = 0, f[1] = 0);
      })();
      class ae {
        constructor(t, n, c, u) {
          this.context = t, this.format = c, this.texture = t.gl.createTexture(), this.update(n, u);
        }
        update(t, n, c) {
          const { width: u, height: m } = t, T = !(this.size && this.size[0] === u && this.size[1] === m || c), { context: s } = this, { gl: l } = s;
          if (this.useMipmap = !!(n && n.useMipmap), l.bindTexture(l.TEXTURE_2D, this.texture), s.pixelStoreUnpackFlipY.set(!1), s.pixelStoreUnpack.set(1), s.pixelStoreUnpackPremultiplyAlpha.set(this.format === l.RGBA && (!n || n.premultiply !== !1)), T) this.size = [u, m], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || o.b(t) ? l.texImage2D(l.TEXTURE_2D, 0, this.format, this.format, l.UNSIGNED_BYTE, t) : l.texImage2D(l.TEXTURE_2D, 0, this.format, u, m, 0, this.format, l.UNSIGNED_BYTE, t.data);
          else {
            const { x: p, y: b } = c || { x: 0, y: 0 };
            t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || o.b(t) ? l.texSubImage2D(l.TEXTURE_2D, 0, p, b, l.RGBA, l.UNSIGNED_BYTE, t) : l.texSubImage2D(l.TEXTURE_2D, 0, p, b, u, m, l.RGBA, l.UNSIGNED_BYTE, t.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && l.generateMipmap(l.TEXTURE_2D);
        }
        bind(t, n, c) {
          const { context: u } = this, { gl: m } = u;
          m.bindTexture(m.TEXTURE_2D, this.texture), c !== m.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (c = m.LINEAR), t !== this.filter && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, t), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, c || t), this.filter = t), n !== this.wrap && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, n), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, n), this.wrap = n);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: t } = this.context;
          t.deleteTexture(this.texture), this.texture = null;
        }
      }
      function he(f) {
        const { userImage: t } = f;
        return !!(t && t.render && t.render()) && (f.data.replace(new Uint8Array(t.data.buffer)), !0);
      }
      class Ie extends o.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.R({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(t) {
          if (this.loaded !== t && (this.loaded = t, t)) {
            for (const { ids: n, promiseResolve: c } of this.requestors) c(this._getImagesForIds(n));
            this.requestors = [];
          }
        }
        getImage(t) {
          const n = this.images[t];
          if (n && !n.data && n.spriteData) {
            const c = n.spriteData;
            n.data = new o.R({ width: c.width, height: c.height }, c.context.getImageData(c.x, c.y, c.width, c.height).data), n.spriteData = null;
          }
          return n;
        }
        addImage(t, n) {
          if (this.images[t]) throw new Error(`Image id ${t} already exist, use updateImage instead`);
          this._validate(t, n) && (this.images[t] = n);
        }
        _validate(t, n) {
          let c = !0;
          const u = n.data || n.spriteData;
          return this._validateStretch(n.stretchX, u && u.width) || (this.fire(new o.j(new Error(`Image "${t}" has invalid "stretchX" value`))), c = !1), this._validateStretch(n.stretchY, u && u.height) || (this.fire(new o.j(new Error(`Image "${t}" has invalid "stretchY" value`))), c = !1), this._validateContent(n.content, n) || (this.fire(new o.j(new Error(`Image "${t}" has invalid "content" value`))), c = !1), c;
        }
        _validateStretch(t, n) {
          if (!t) return !0;
          let c = 0;
          for (const u of t) {
            if (u[0] < c || u[1] < u[0] || n < u[1]) return !1;
            c = u[1];
          }
          return !0;
        }
        _validateContent(t, n) {
          if (!t) return !0;
          if (t.length !== 4) return !1;
          const c = n.spriteData, u = c && c.width || n.data.width, m = c && c.height || n.data.height;
          return !(t[0] < 0 || u < t[0] || t[1] < 0 || m < t[1] || t[2] < 0 || u < t[2] || t[3] < 0 || m < t[3] || t[2] < t[0] || t[3] < t[1]);
        }
        updateImage(t, n, c = !0) {
          const u = this.getImage(t);
          if (c && (u.data.width !== n.data.width || u.data.height !== n.data.height)) throw new Error(`size mismatch between old image (${u.data.width}x${u.data.height}) and new image (${n.data.width}x${n.data.height}).`);
          n.version = u.version + 1, this.images[t] = n, this.updatedImages[t] = !0;
        }
        removeImage(t) {
          const n = this.images[t];
          delete this.images[t], delete this.patterns[t], n.userImage && n.userImage.onRemove && n.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(t) {
          return new Promise((n, c) => {
            let u = !0;
            if (!this.isLoaded()) for (const m of t) this.images[m] || (u = !1);
            this.isLoaded() || u ? n(this._getImagesForIds(t)) : this.requestors.push({ ids: t, promiseResolve: n });
          });
        }
        _getImagesForIds(t) {
          const n = {};
          for (const c of t) {
            let u = this.getImage(c);
            u || (this.fire(new o.k("styleimagemissing", { id: c })), u = this.getImage(c)), u ? n[c] = { data: u.data.clone(), pixelRatio: u.pixelRatio, sdf: u.sdf, version: u.version, stretchX: u.stretchX, stretchY: u.stretchY, content: u.content, textFitWidth: u.textFitWidth, textFitHeight: u.textFitHeight, hasRenderCallback: !!(u.userImage && u.userImage.render) } : o.w(`Image "${c}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return n;
        }
        getPixelSize() {
          const { width: t, height: n } = this.atlasImage;
          return { width: t, height: n };
        }
        getPattern(t) {
          const n = this.patterns[t], c = this.getImage(t);
          if (!c) return null;
          if (n && n.position.version === c.version) return n.position;
          if (n) n.position.version = c.version;
          else {
            const u = { w: c.data.width + 2, h: c.data.height + 2, x: 0, y: 0 }, m = new o.I(u, c);
            this.patterns[t] = { bin: u, position: m };
          }
          return this._updatePatternAtlas(), this.patterns[t].position;
        }
        bind(t) {
          const n = t.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new ae(t, this.atlasImage, n.RGBA), this.atlasTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const t = [];
          for (const m in this.patterns) t.push(this.patterns[m].bin);
          const { w: n, h: c } = o.p(t), u = this.atlasImage;
          u.resize({ width: n || 1, height: c || 1 });
          for (const m in this.patterns) {
            const { bin: T } = this.patterns[m], s = T.x + 1, l = T.y + 1, p = this.getImage(m).data, b = p.width, P = p.height;
            o.R.copy(p, u, { x: 0, y: 0 }, { x: s, y: l }, { width: b, height: P }), o.R.copy(p, u, { x: 0, y: P - 1 }, { x: s, y: l - 1 }, { width: b, height: 1 }), o.R.copy(p, u, { x: 0, y: 0 }, { x: s, y: l + P }, { width: b, height: 1 }), o.R.copy(p, u, { x: b - 1, y: 0 }, { x: s - 1, y: l }, { width: 1, height: P }), o.R.copy(p, u, { x: 0, y: 0 }, { x: s + b, y: l }, { width: 1, height: P });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(t) {
          for (const n of t) {
            if (this.callbackDispatchedThisFrame[n]) continue;
            this.callbackDispatchedThisFrame[n] = !0;
            const c = this.getImage(n);
            c || o.w(`Image with ID: "${n}" was not found`), he(c) && this.updateImage(n, c);
          }
        }
      }
      const Se = 1e20;
      function et(f, t, n, c, u, m, T, s, l) {
        for (let p = t; p < t + c; p++) Qe(f, n * m + p, m, u, T, s, l);
        for (let p = n; p < n + u; p++) Qe(f, p * m + t, 1, c, T, s, l);
      }
      function Qe(f, t, n, c, u, m, T) {
        m[0] = 0, T[0] = -Se, T[1] = Se, u[0] = f[t];
        for (let s = 1, l = 0, p = 0; s < c; s++) {
          u[s] = f[t + s * n];
          const b = s * s;
          do {
            const P = m[l];
            p = (u[s] - u[P] + b - P * P) / (s - P) / 2;
          } while (p <= T[l] && --l > -1);
          l++, m[l] = s, T[l] = p, T[l + 1] = Se;
        }
        for (let s = 0, l = 0; s < c; s++) {
          for (; T[l + 1] < s; ) l++;
          const p = m[l], b = s - p;
          f[t + s * n] = u[p] + b * b;
        }
      }
      class rt {
        constructor(t, n) {
          this.requestManager = t, this.localIdeographFontFamily = n, this.entries = {};
        }
        setURL(t) {
          this.url = t;
        }
        getGlyphs(t) {
          return o._(this, void 0, void 0, function* () {
            const n = [];
            for (const m in t) for (const T of t[m]) n.push(this._getAndCacheGlyphsPromise(m, T));
            const c = yield Promise.all(n), u = {};
            for (const { stack: m, id: T, glyph: s } of c) u[m] || (u[m] = {}), u[m][T] = s && { id: s.id, bitmap: s.bitmap.clone(), metrics: s.metrics };
            return u;
          });
        }
        _getAndCacheGlyphsPromise(t, n) {
          return o._(this, void 0, void 0, function* () {
            let c = this.entries[t];
            c || (c = this.entries[t] = { glyphs: {}, requests: {}, ranges: {} });
            let u = c.glyphs[n];
            if (u !== void 0) return { stack: t, id: n, glyph: u };
            if (u = this._tinySDF(c, t, n), u) return c.glyphs[n] = u, { stack: t, id: n, glyph: u };
            const m = Math.floor(n / 256);
            if (256 * m > 65535) throw new Error("glyphs > 65535 not supported");
            if (c.ranges[m]) return { stack: t, id: n, glyph: u };
            if (!this.url) throw new Error("glyphsUrl is not set");
            if (!c.requests[m]) {
              const s = rt.loadGlyphRange(t, m, this.url, this.requestManager);
              c.requests[m] = s;
            }
            const T = yield c.requests[m];
            for (const s in T) this._doesCharSupportLocalGlyph(+s) || (c.glyphs[+s] = T[+s]);
            return c.ranges[m] = !0, { stack: t, id: n, glyph: T[n] || null };
          });
        }
        _doesCharSupportLocalGlyph(t) {
          return !!this.localIdeographFontFamily && (o.u["CJK Unified Ideographs"](t) || o.u["Hangul Syllables"](t) || o.u.Hiragana(t) || o.u.Katakana(t));
        }
        _tinySDF(t, n, c) {
          const u = this.localIdeographFontFamily;
          if (!u || !this._doesCharSupportLocalGlyph(c)) return;
          let m = t.tinySDF;
          if (!m) {
            let s = "400";
            /bold/i.test(n) ? s = "900" : /medium/i.test(n) ? s = "500" : /light/i.test(n) && (s = "200"), m = t.tinySDF = new rt.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: u, fontWeight: s });
          }
          const T = m.draw(String.fromCharCode(c));
          return { id: c, bitmap: new o.o({ width: T.width || 60, height: T.height || 60 }, T.data), metrics: { width: T.glyphWidth / 2 || 24, height: T.glyphHeight / 2 || 24, left: T.glyphLeft / 2 + 0.5 || 0, top: T.glyphTop / 2 - 27.5 || -8, advance: T.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
        }
      }
      rt.loadGlyphRange = function(f, t, n, c) {
        return o._(this, void 0, void 0, function* () {
          const u = 256 * t, m = u + 255, T = c.transformRequest(n.replace("{fontstack}", f).replace("{range}", `${u}-${m}`), "Glyphs"), s = yield o.l(T, new AbortController());
          if (!s || !s.data) throw new Error(`Could not load glyph range. range: ${t}, ${u}-${m}`);
          const l = {};
          for (const p of o.n(s.data)) l[p.id] = p;
          return l;
        });
      }, rt.TinySDF = class {
        constructor({ fontSize: f = 24, buffer: t = 3, radius: n = 8, cutoff: c = 0.25, fontFamily: u = "sans-serif", fontWeight: m = "normal", fontStyle: T = "normal" } = {}) {
          this.buffer = t, this.cutoff = c, this.radius = n;
          const s = this.size = f + 4 * t, l = this._createCanvas(s), p = this.ctx = l.getContext("2d", { willReadFrequently: !0 });
          p.font = `${T} ${m} ${f}px ${u}`, p.textBaseline = "alphabetic", p.textAlign = "left", p.fillStyle = "black", this.gridOuter = new Float64Array(s * s), this.gridInner = new Float64Array(s * s), this.f = new Float64Array(s), this.z = new Float64Array(s + 1), this.v = new Uint16Array(s);
        }
        _createCanvas(f) {
          const t = document.createElement("canvas");
          return t.width = t.height = f, t;
        }
        draw(f) {
          const { width: t, actualBoundingBoxAscent: n, actualBoundingBoxDescent: c, actualBoundingBoxLeft: u, actualBoundingBoxRight: m } = this.ctx.measureText(f), T = Math.ceil(n), s = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(m - u))), l = Math.min(this.size - this.buffer, T + Math.ceil(c)), p = s + 2 * this.buffer, b = l + 2 * this.buffer, P = Math.max(p * b, 0), C = new Uint8ClampedArray(P), E = { data: C, width: p, height: b, glyphWidth: s, glyphHeight: l, glyphTop: T, glyphLeft: 0, glyphAdvance: t };
          if (s === 0 || l === 0) return E;
          const { ctx: z, buffer: N, gridInner: R, gridOuter: G } = this;
          z.clearRect(N, N, s, l), z.fillText(f, N, N + T);
          const ie = z.getImageData(N, N, s, l);
          G.fill(Se, 0, P), R.fill(0, 0, P);
          for (let H = 0; H < l; H++) for (let Q = 0; Q < s; Q++) {
            const ue = ie.data[4 * (H * s + Q) + 3] / 255;
            if (ue === 0) continue;
            const ce = (H + N) * p + Q + N;
            if (ue === 1) G[ce] = 0, R[ce] = Se;
            else {
              const ne = 0.5 - ue;
              G[ce] = ne > 0 ? ne * ne : 0, R[ce] = ne < 0 ? ne * ne : 0;
            }
          }
          et(G, 0, 0, p, b, p, this.f, this.v, this.z), et(R, N, N, s, l, p, this.f, this.v, this.z);
          for (let H = 0; H < P; H++) {
            const Q = Math.sqrt(G[H]) - Math.sqrt(R[H]);
            C[H] = Math.round(255 - 255 * (Q / this.radius + this.cutoff));
          }
          return E;
        }
      };
      class Ze {
        constructor() {
          this.specification = o.v.light.position;
        }
        possiblyEvaluate(t, n) {
          return o.y(t.expression.evaluate(n));
        }
        interpolate(t, n, c) {
          return { x: o.z.number(t.x, n.x, c), y: o.z.number(t.y, n.y, c), z: o.z.number(t.z, n.z, c) };
        }
      }
      let ct;
      class nt extends o.E {
        constructor(t) {
          super(), ct = ct || new o.q({ anchor: new o.D(o.v.light.anchor), position: new Ze(), color: new o.D(o.v.light.color), intensity: new o.D(o.v.light.intensity) }), this._transitionable = new o.T(ct), this.setLight(t), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t, n = {}) {
          if (!this._validate(o.r, t, n)) for (const c in t) {
            const u = t[c];
            c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), u) : this._transitionable.setValue(c, u);
          }
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, n, c) {
          return (!c || c.validate !== !1) && o.t(this, t.call(o.x, { value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: o.v }));
        }
      }
      class wt {
        constructor(t, n) {
          this.width = t, this.height = n, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(t, n) {
          const c = t.join(",") + String(n);
          return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(t, n)), this.dashEntry[c];
        }
        getDashRanges(t, n, c) {
          const u = [];
          let m = t.length % 2 == 1 ? -t[t.length - 1] * c : 0, T = t[0] * c, s = !0;
          u.push({ left: m, right: T, isDash: s, zeroLength: t[0] === 0 });
          let l = t[0];
          for (let p = 1; p < t.length; p++) {
            s = !s;
            const b = t[p];
            m = l * c, l += b, T = l * c, u.push({ left: m, right: T, isDash: s, zeroLength: b === 0 });
          }
          return u;
        }
        addRoundDash(t, n, c) {
          const u = n / 2;
          for (let m = -c; m <= c; m++) {
            const T = this.width * (this.nextRow + c + m);
            let s = 0, l = t[s];
            for (let p = 0; p < this.width; p++) {
              p / l.right > 1 && (l = t[++s]);
              const b = Math.abs(p - l.left), P = Math.abs(p - l.right), C = Math.min(b, P);
              let E;
              const z = m / c * (u + 1);
              if (l.isDash) {
                const N = u - Math.abs(z);
                E = Math.sqrt(C * C + N * N);
              } else E = u - Math.sqrt(C * C + z * z);
              this.data[T + p] = Math.max(0, Math.min(255, E + 128));
            }
          }
        }
        addRegularDash(t) {
          for (let s = t.length - 1; s >= 0; --s) {
            const l = t[s], p = t[s + 1];
            l.zeroLength ? t.splice(s, 1) : p && p.isDash === l.isDash && (p.left = l.left, t.splice(s, 1));
          }
          const n = t[0], c = t[t.length - 1];
          n.isDash === c.isDash && (n.left = c.left - this.width, c.right = n.right + this.width);
          const u = this.width * this.nextRow;
          let m = 0, T = t[m];
          for (let s = 0; s < this.width; s++) {
            s / T.right > 1 && (T = t[++m]);
            const l = Math.abs(s - T.left), p = Math.abs(s - T.right), b = Math.min(l, p);
            this.data[u + s] = Math.max(0, Math.min(255, (T.isDash ? b : -b) + 128));
          }
        }
        addDash(t, n) {
          const c = n ? 7 : 0, u = 2 * c + 1;
          if (this.nextRow + u > this.height) return o.w("LineAtlas out of space"), null;
          let m = 0;
          for (let s = 0; s < t.length; s++) m += t[s];
          if (m !== 0) {
            const s = this.width / m, l = this.getDashRanges(t, this.width, s);
            n ? this.addRoundDash(l, s, c) : this.addRegularDash(l);
          }
          const T = { y: (this.nextRow + c + 0.5) / this.height, height: 2 * c / this.height, width: m };
          return this.nextRow += u, this.dirty = !0, T;
        }
        bind(t) {
          const n = t.gl;
          this.texture ? (n.bindTexture(n.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, this.width, this.height, n.ALPHA, n.UNSIGNED_BYTE, this.data))) : (this.texture = n.createTexture(), n.bindTexture(n.TEXTURE_2D, this.texture), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.REPEAT), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.REPEAT), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), n.texImage2D(n.TEXTURE_2D, 0, n.ALPHA, this.width, this.height, 0, n.ALPHA, n.UNSIGNED_BYTE, this.data));
        }
      }
      const K = "maplibre_preloaded_worker_pool";
      class ge {
        constructor() {
          this.active = {};
        }
        acquire(t) {
          if (!this.workers) for (this.workers = []; this.workers.length < ge.workerCount; ) this.workers.push(new Worker(o.a.WORKER_URL));
          return this.active[t] = !0, this.workers.slice();
        }
        release(t) {
          delete this.active[t], this.numActive() === 0 && (this.workers.forEach((n) => {
            n.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[K];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const we = Math.floor(q.hardwareConcurrency / 2);
      let Ee, Be;
      function Ve() {
        return Ee || (Ee = new ge()), Ee;
      }
      ge.workerCount = o.B(globalThis) ? Math.max(Math.min(we, 3), 1) : 1;
      class We {
        constructor(t, n) {
          this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = n;
          const c = this.workerPool.acquire(n);
          for (let u = 0; u < c.length; u++) {
            const m = new o.C(c[u], n);
            m.name = `Worker ${u}`, this.actors.push(m);
          }
          if (!this.actors.length) throw new Error("No actors found");
        }
        broadcast(t, n) {
          const c = [];
          for (const u of this.actors) c.push(u.sendAsync({ type: t, data: n }));
          return Promise.all(c);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(t = !0) {
          this.actors.forEach((n) => {
            n.remove();
          }), this.actors = [], t && this.workerPool.release(this.id);
        }
        registerMessageHandler(t, n) {
          for (const c of this.actors) c.registerMessageHandler(t, n);
        }
      }
      function Ye() {
        return Be || (Be = new We(Ve(), o.G), Be.registerMessageHandler("GR", (f, t, n) => o.m(t, n))), Be;
      }
      function bt(f, t) {
        const n = o.F();
        return o.H(n, n, [1, 1, 0]), o.J(n, n, [0.5 * f.width, 0.5 * f.height, 1]), o.K(n, n, f.calculatePosMatrix(t.toUnwrapped()));
      }
      function xt(f, t, n, c, u, m) {
        const T = function(P, C, E) {
          if (P) for (const z of P) {
            const N = C[z];
            if (N && N.source === E && N.type === "fill-extrusion") return !0;
          }
          else for (const z in C) {
            const N = C[z];
            if (N.source === E && N.type === "fill-extrusion") return !0;
          }
          return !1;
        }(u && u.layers, t, f.id), s = m.maxPitchScaleFactor(), l = f.tilesIn(c, s, T);
        l.sort(kt);
        const p = [];
        for (const P of l) p.push({ wrappedTileID: P.tileID.wrapped().key, queryResults: P.tile.queryRenderedFeatures(t, n, f._state, P.queryGeometry, P.cameraQueryGeometry, P.scale, u, m, s, bt(f.transform, P.tileID)) });
        const b = function(P) {
          const C = {}, E = {};
          for (const z of P) {
            const N = z.queryResults, R = z.wrappedTileID, G = E[R] = E[R] || {};
            for (const ie in N) {
              const H = N[ie], Q = G[ie] = G[ie] || {}, ue = C[ie] = C[ie] || [];
              for (const ce of H) Q[ce.featureIndex] || (Q[ce.featureIndex] = !0, ue.push(ce));
            }
          }
          return C;
        }(p);
        for (const P in b) b[P].forEach((C) => {
          const E = C.feature, z = f.getFeatureState(E.layer["source-layer"], E.id);
          E.source = E.layer.source, E.layer["source-layer"] && (E.sourceLayer = E.layer["source-layer"]), E.state = z;
        });
        return b;
      }
      function kt(f, t) {
        const n = f.tileID, c = t.tileID;
        return n.overscaledZ - c.overscaledZ || n.canonical.y - c.canonical.y || n.wrap - c.wrap || n.canonical.x - c.canonical.x;
      }
      function zt(f, t, n) {
        return o._(this, void 0, void 0, function* () {
          let c = f;
          if (f.url ? c = (yield o.h(t.transformRequest(f.url, "Source"), n)).data : yield q.frameAsync(n), !c) return null;
          const u = o.L(o.e(c, f), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in c && c.vector_layers && (u.vectorLayerIds = c.vector_layers.map((m) => m.id)), u;
        });
      }
      class Ut {
        constructor(t, n) {
          t && (n ? this.setSouthWest(t).setNorthEast(n) : Array.isArray(t) && (t.length === 4 ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1])));
        }
        setNorthEast(t) {
          return this._ne = t instanceof o.M ? new o.M(t.lng, t.lat) : o.M.convert(t), this;
        }
        setSouthWest(t) {
          return this._sw = t instanceof o.M ? new o.M(t.lng, t.lat) : o.M.convert(t), this;
        }
        extend(t) {
          const n = this._sw, c = this._ne;
          let u, m;
          if (t instanceof o.M) u = t, m = t;
          else {
            if (!(t instanceof Ut)) return Array.isArray(t) ? t.length === 4 || t.every(Array.isArray) ? this.extend(Ut.convert(t)) : this.extend(o.M.convert(t)) : t && ("lng" in t || "lon" in t) && "lat" in t ? this.extend(o.M.convert(t)) : this;
            if (u = t._sw, m = t._ne, !u || !m) return this;
          }
          return n || c ? (n.lng = Math.min(u.lng, n.lng), n.lat = Math.min(u.lat, n.lat), c.lng = Math.max(m.lng, c.lng), c.lat = Math.max(m.lat, c.lat)) : (this._sw = new o.M(u.lng, u.lat), this._ne = new o.M(m.lng, m.lat)), this;
        }
        getCenter() {
          return new o.M((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new o.M(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new o.M(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t) {
          const { lng: n, lat: c } = o.M.convert(t);
          let u = this._sw.lng <= n && n <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (u = this._sw.lng >= n && n >= this._ne.lng), this._sw.lat <= c && c <= this._ne.lat && u;
        }
        static convert(t) {
          return t instanceof Ut ? t : t && new Ut(t);
        }
        static fromLngLat(t, n = 0) {
          const c = 360 * n / 40075017, u = c / Math.cos(Math.PI / 180 * t.lat);
          return new Ut(new o.M(t.lng - u, t.lat - c), new o.M(t.lng + u, t.lat + c));
        }
      }
      class st {
        constructor(t, n, c) {
          this.bounds = Ut.convert(this.validateBounds(t)), this.minzoom = n || 0, this.maxzoom = c || 24;
        }
        validateBounds(t) {
          return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
        }
        contains(t) {
          const n = Math.pow(2, t.z), c = Math.floor(o.N(this.bounds.getWest()) * n), u = Math.floor(o.O(this.bounds.getNorth()) * n), m = Math.ceil(o.N(this.bounds.getEast()) * n), T = Math.ceil(o.O(this.bounds.getSouth()) * n);
          return t.x >= c && t.x < m && t.y >= u && t.y < T;
        }
      }
      class te extends o.E {
        constructor(t, n, c, u) {
          if (super(), this.id = t, this.dispatcher = c, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.e(this, o.L(n, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.e({ type: "vector" }, n), this._collectResourceTiming = n.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(u);
        }
        load() {
          return o._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new o.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const t = yield zt(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), t && (o.e(this, t), t.bounds && (this.tileBounds = new st(t.bounds, this.minzoom, this.maxzoom)), this.fire(new o.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new o.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (t) {
              this._tileJSONRequest = null, this.fire(new o.j(t));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        setSourceProperty(t) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), t(), this.load();
        }
        setTiles(t) {
          return this.setSourceProperty(() => {
            this._options.tiles = t;
          }), this;
        }
        setUrl(t) {
          return this.setSourceProperty(() => {
            this.url = t, this._options.url = t;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return o.e({}, this._options);
        }
        loadTile(t) {
          return o._(this, void 0, void 0, function* () {
            const n = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = { request: this.map._requestManager.transformRequest(n, "Tile"), uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            c.request.collectResourceTiming = this._collectResourceTiming;
            let u = "RT";
            if (t.actor && t.state !== "expired") {
              if (t.state === "loading") return new Promise((m, T) => {
                t.reloadPromise = { resolve: m, reject: T };
              });
            } else t.actor = this.dispatcher.getActor(), u = "LT";
            t.abortController = new AbortController();
            try {
              const m = yield t.actor.sendAsync({ type: u, data: c }, t.abortController);
              if (delete t.abortController, t.aborted) return;
              this._afterTileLoadWorkerResponse(t, m);
            } catch (m) {
              if (delete t.abortController, t.aborted) return;
              if (m && m.status !== 404) throw m;
              this._afterTileLoadWorkerResponse(t, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(t, n) {
          if (n && n.resourceTiming && (t.resourceTiming = n.resourceTiming), n && this.map._refreshExpiredTiles && t.setExpiryData(n), t.loadVectorData(n, this.map.painter), t.reloadPromise) {
            const c = t.reloadPromise;
            t.reloadPromise = null, this.loadTile(t).then(c.resolve).catch(c.reject);
          }
        }
        abortTile(t) {
          return o._(this, void 0, void 0, function* () {
            t.abortController && (t.abortController.abort(), delete t.abortController), t.actor && (yield t.actor.sendAsync({ type: "AT", data: { uid: t.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(t) {
          return o._(this, void 0, void 0, function* () {
            t.unloadVectorData(), t.actor && (yield t.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class hi extends o.E {
        constructor(t, n, c, u) {
          super(), this.id = t, this.dispatcher = c, this.setEventedParent(u), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.e({ type: "raster" }, n), o.e(this, o.L(n, ["url", "scheme", "tileSize"]));
        }
        load() {
          return o._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new o.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const t = yield zt(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, t && (o.e(this, t), t.bounds && (this.tileBounds = new st(t.bounds, this.minzoom, this.maxzoom)), this.fire(new o.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new o.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (t) {
              this._tileJSONRequest = null, this.fire(new o.j(t));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(t) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t(), this.load();
        }
        setTiles(t) {
          return this.setSourceProperty(() => {
            this._options.tiles = t;
          }), this;
        }
        setUrl(t) {
          return this.setSourceProperty(() => {
            this.url = t, this._options.url = t;
          }), this;
        }
        serialize() {
          return o.e({}, this._options);
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        loadTile(t) {
          return o._(this, void 0, void 0, function* () {
            const n = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            t.abortController = new AbortController();
            try {
              const c = yield Fe.getImage(this.map._requestManager.transformRequest(n, "Tile"), t.abortController, this.map._refreshExpiredTiles);
              if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
              if (c && c.data) {
                this.map._refreshExpiredTiles && c.cacheControl && c.expires && t.setExpiryData({ cacheControl: c.cacheControl, expires: c.expires });
                const u = this.map.painter.context, m = u.gl, T = c.data;
                t.texture = this.map.painter.getTileTexture(T.width), t.texture ? t.texture.update(T, { useMipmap: !0 }) : (t.texture = new ae(u, T, m.RGBA, { useMipmap: !0 }), t.texture.bind(m.LINEAR, m.CLAMP_TO_EDGE, m.LINEAR_MIPMAP_NEAREST), u.extTextureFilterAnisotropic && m.texParameterf(m.TEXTURE_2D, u.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u.extTextureFilterAnisotropicMax)), t.state = "loaded";
              }
            } catch (c) {
              if (delete t.abortController, t.aborted) t.state = "unloaded";
              else if (c) throw t.state = "errored", c;
            }
          });
        }
        abortTile(t) {
          return o._(this, void 0, void 0, function* () {
            t.abortController && (t.abortController.abort(), delete t.abortController);
          });
        }
        unloadTile(t) {
          return o._(this, void 0, void 0, function* () {
            t.texture && this.map.painter.saveTileTexture(t.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class Ht extends hi {
        constructor(t, n, c, u) {
          super(t, n, c, u), this.type = "raster-dem", this.maxzoom = 22, this._options = o.e({ type: "raster-dem" }, n), this.encoding = n.encoding || "mapbox", this.redFactor = n.redFactor, this.greenFactor = n.greenFactor, this.blueFactor = n.blueFactor, this.baseShift = n.baseShift;
        }
        loadTile(t) {
          return o._(this, void 0, void 0, function* () {
            const n = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = this.map._requestManager.transformRequest(n, "Tile");
            t.neighboringTiles = this._getNeighboringTiles(t.tileID), t.abortController = new AbortController();
            try {
              const u = yield Fe.getImage(c, t.abortController, this.map._refreshExpiredTiles);
              if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
              if (u && u.data) {
                const m = u.data;
                this.map._refreshExpiredTiles && u.cacheControl && u.expires && t.setExpiryData({ cacheControl: u.cacheControl, expires: u.expires });
                const T = o.b(m) && o.S() ? m : yield this.readImageNow(m), s = { type: this.type, uid: t.uid, source: this.id, rawImageData: T, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!t.actor || t.state === "expired") {
                  t.actor = this.dispatcher.getActor();
                  const l = yield t.actor.sendAsync({ type: "LDT", data: s });
                  t.dem = l, t.needsHillshadePrepare = !0, t.needsTerrainPrepare = !0, t.state = "loaded";
                }
              }
            } catch (u) {
              if (delete t.abortController, t.aborted) t.state = "unloaded";
              else if (u) throw t.state = "errored", u;
            }
          });
        }
        readImageNow(t) {
          return o._(this, void 0, void 0, function* () {
            if (typeof VideoFrame < "u" && o.U()) {
              const n = t.width + 2, c = t.height + 2;
              try {
                return new o.R({ width: n, height: c }, yield o.V(t, -1, -1, n, c));
              } catch {
              }
            }
            return q.getImageData(t, 1);
          });
        }
        _getNeighboringTiles(t) {
          const n = t.canonical, c = Math.pow(2, n.z), u = (n.x - 1 + c) % c, m = n.x === 0 ? t.wrap - 1 : t.wrap, T = (n.x + 1 + c) % c, s = n.x + 1 === c ? t.wrap + 1 : t.wrap, l = {};
          return l[new o.Q(t.overscaledZ, m, n.z, u, n.y).key] = { backfilled: !1 }, l[new o.Q(t.overscaledZ, s, n.z, T, n.y).key] = { backfilled: !1 }, n.y > 0 && (l[new o.Q(t.overscaledZ, m, n.z, u, n.y - 1).key] = { backfilled: !1 }, l[new o.Q(t.overscaledZ, t.wrap, n.z, n.x, n.y - 1).key] = { backfilled: !1 }, l[new o.Q(t.overscaledZ, s, n.z, T, n.y - 1).key] = { backfilled: !1 }), n.y + 1 < c && (l[new o.Q(t.overscaledZ, m, n.z, u, n.y + 1).key] = { backfilled: !1 }, l[new o.Q(t.overscaledZ, t.wrap, n.z, n.x, n.y + 1).key] = { backfilled: !1 }, l[new o.Q(t.overscaledZ, s, n.z, T, n.y + 1).key] = { backfilled: !1 }), l;
        }
        unloadTile(t) {
          return o._(this, void 0, void 0, function* () {
            t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && (yield t.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: t.uid, source: this.id } }));
          });
        }
      }
      class ut extends o.E {
        constructor(t, n, c, u) {
          super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = c.getActor(), this.setEventedParent(u), this._data = n.data, this._options = o.e({}, n), this._collectResourceTiming = n.collectResourceTiming, n.maxzoom !== void 0 && (this.maxzoom = n.maxzoom), n.type && (this.type = n.type), n.attribution && (this.attribution = n.attribution), this.promoteId = n.promoteId;
          const m = o.W / this.tileSize;
          this.workerOptions = o.e({ source: this.id, cluster: n.cluster || !1, geojsonVtOptions: { buffer: (n.buffer !== void 0 ? n.buffer : 128) * m, tolerance: (n.tolerance !== void 0 ? n.tolerance : 0.375) * m, extent: o.W, maxZoom: this.maxzoom, lineMetrics: n.lineMetrics || !1, generateId: n.generateId || !1 }, superclusterOptions: { maxZoom: n.clusterMaxZoom !== void 0 ? n.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, n.clusterMinPoints || 2), extent: o.W, radius: (n.clusterRadius || 50) * m, log: !1, generateId: n.generateId || !1 }, clusterProperties: n.clusterProperties, filter: n.filter }, n.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return o._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        setData(t) {
          return this._data = t, this._updateWorkerData(), this;
        }
        updateData(t) {
          return this._updateWorkerData(t), this;
        }
        getData() {
          return o._(this, void 0, void 0, function* () {
            const t = o.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: t });
          });
        }
        setClusterOptions(t) {
          return this.workerOptions.cluster = t.cluster, t && (t.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = t.clusterRadius), t.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = t.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(t) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: t, source: this.id } });
        }
        getClusterChildren(t) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: t, source: this.id } });
        }
        getClusterLeaves(t, n, c) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: t, limit: n, offset: c } });
        }
        _updateWorkerData(t) {
          return o._(this, void 0, void 0, function* () {
            const n = o.e({ type: this.type }, this.workerOptions);
            t ? n.dataDiff = t : typeof this._data == "string" ? (n.request = this.map._requestManager.transformRequest(q.resolveURL(this._data), "Source"), n.request.collectResourceTiming = this._collectResourceTiming) : n.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new o.k("dataloading", { dataType: "source" }));
            try {
              const c = yield this.actor.sendAsync({ type: "LD", data: n });
              if (this._pendingLoads--, this._removed || c.abandoned) return void this.fire(new o.k("dataabort", { dataType: "source" }));
              let u = null;
              c.resourceTiming && c.resourceTiming[this.id] && (u = c.resourceTiming[this.id].slice(0));
              const m = { dataType: "source" };
              this._collectResourceTiming && u && u.length > 0 && o.e(m, { resourceTiming: u }), this.fire(new o.k("data", Object.assign(Object.assign({}, m), { sourceDataType: "metadata" }))), this.fire(new o.k("data", Object.assign(Object.assign({}, m), { sourceDataType: "content" })));
            } catch (c) {
              if (this._pendingLoads--, this._removed) return void this.fire(new o.k("dataabort", { dataType: "source" }));
              this.fire(new o.j(c));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(t) {
          return o._(this, void 0, void 0, function* () {
            const n = t.actor ? "RT" : "LT";
            t.actor = this.actor;
            const c = { type: this.type, uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            t.abortController = new AbortController();
            const u = yield this.actor.sendAsync({ type: n, data: c }, t.abortController);
            delete t.abortController, t.unloadVectorData(), t.aborted || t.loadVectorData(u, this.map.painter, n === "RT");
          });
        }
        abortTile(t) {
          return o._(this, void 0, void 0, function* () {
            t.abortController && (t.abortController.abort(), delete t.abortController), t.aborted = !0;
          });
        }
        unloadTile(t) {
          return o._(this, void 0, void 0, function* () {
            t.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return o.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      var _t = o.X([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class Lt extends o.E {
        constructor(t, n, c, u) {
          super(), this.id = t, this.dispatcher = c, this.coordinates = n.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(u), this.options = n;
        }
        load(t) {
          return o._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new o.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
            try {
              const n = yield Fe.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = !0, n && n.data && (this.image = n.data, t && (this.coordinates = t), this._finishLoading());
            } catch (n) {
              this._request = null, this._loaded = !0, this.fire(new o.j(n));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t) {
          return t.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t.url, this.load(t.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new o.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(t) {
          this.coordinates = t;
          const n = t.map(o.Y.fromLngLat);
          this.tileID = function(u) {
            let m = 1 / 0, T = 1 / 0, s = -1 / 0, l = -1 / 0;
            for (const C of u) m = Math.min(m, C.x), T = Math.min(T, C.y), s = Math.max(s, C.x), l = Math.max(l, C.y);
            const p = Math.max(s - m, l - T), b = Math.max(0, Math.floor(-Math.log(p) / Math.LN2)), P = Math.pow(2, b);
            return new o.a0(b, Math.floor((m + s) / 2 * P), Math.floor((T + l) / 2 * P));
          }(n), this.minzoom = this.maxzoom = this.tileID.z;
          const c = n.map((u) => this.tileID.getTilePoint(u)._round());
          return this._boundsArray = new o.Z(), this._boundsArray.emplaceBack(c[0].x, c[0].y, 0, 0), this._boundsArray.emplaceBack(c[1].x, c[1].y, o.W, 0), this._boundsArray.emplaceBack(c[3].x, c[3].y, 0, o.W), this._boundsArray.emplaceBack(c[2].x, c[2].y, o.W, o.W), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new o.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          const t = this.map.painter.context, n = t.gl;
          this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, _t.members)), this.boundsSegments || (this.boundsSegments = o.$.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new ae(t, this.image, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
          let c = !1;
          for (const u in this.tiles) {
            const m = this.tiles[u];
            m.state !== "loaded" && (m.state = "loaded", m.texture = this.texture, c = !0);
          }
          c && this.fire(new o.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(t) {
          return o._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}) : t.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class Ct extends Lt {
        constructor(t, n, c, u) {
          super(t, n, c, u), this.roundZoom = !0, this.type = "video", this.options = n;
        }
        load() {
          return o._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const t = this.options;
            this.urls = [];
            for (const n of t.urls) this.urls.push(this.map._requestManager.transformRequest(n, "Source").url);
            try {
              const n = yield o.a2(this.urls);
              if (this._loaded = !0, !n) return;
              this.video = n, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (n) {
              this.fire(new o.j(n));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t) {
          if (this.video) {
            const n = this.video.seekable;
            t < n.start(0) || t > n.end(0) ? this.fire(new o.j(new o.a1(`sources.${this.id}`, null, `Playback for this video can be set only between the ${n.start(0)} and ${n.end(0)}-second mark.`))) : this.video.currentTime = t;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(t) {
          this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          const t = this.map.painter.context, n = t.gl;
          this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, _t.members)), this.boundsSegments || (this.boundsSegments = o.$.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, this.video)) : (this.texture = new ae(t, this.video, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
          let c = !1;
          for (const u in this.tiles) {
            const m = this.tiles[u];
            m.state !== "loaded" && (m.state = "loaded", m.texture = this.texture, c = !0);
          }
          c && this.fire(new o.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class ei extends Lt {
        constructor(t, n, c, u) {
          super(t, n, c, u), n.coordinates ? Array.isArray(n.coordinates) && n.coordinates.length === 4 && !n.coordinates.some((m) => !Array.isArray(m) || m.length !== 2 || m.some((T) => typeof T != "number")) || this.fire(new o.j(new o.a1(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.j(new o.a1(`sources.${t}`, null, 'missing required property "coordinates"'))), n.animate && typeof n.animate != "boolean" && this.fire(new o.j(new o.a1(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), n.canvas ? typeof n.canvas == "string" || n.canvas instanceof HTMLCanvasElement || this.fire(new o.j(new o.a1(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.j(new o.a1(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = n, this.animate = n.animate === void 0 || n.animate;
        }
        load() {
          return o._(this, void 0, void 0, function* () {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(t) {
          this.map = t, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let t = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          const n = this.map.painter.context, c = n.gl;
          this.boundsBuffer || (this.boundsBuffer = n.createVertexBuffer(this._boundsArray, _t.members)), this.boundsSegments || (this.boundsSegments = o.$.simpleSegment(0, 0, 4, 2)), this.texture ? (t || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new ae(n, this.canvas, c.RGBA, { premultiply: !0 });
          let u = !1;
          for (const m in this.tiles) {
            const T = this.tiles[m];
            T.state !== "loaded" && (T.state = "loaded", T.texture = this.texture, u = !0);
          }
          u && this.fire(new o.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const t of [this.canvas.width, this.canvas.height]) if (isNaN(t) || t <= 0) return !0;
          return !1;
        }
      }
      const pi = {}, fi = (f) => {
        switch (f) {
          case "geojson":
            return ut;
          case "image":
            return Lt;
          case "raster":
            return hi;
          case "raster-dem":
            return Ht;
          case "vector":
            return te;
          case "video":
            return Ct;
          case "canvas":
            return ei;
        }
        return pi[f];
      }, wi = "RTLPluginLoaded";
      class Ci extends o.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Ye();
        }
        _syncState(t) {
          return this.status = t, this.dispatcher.broadcast("SRPS", { pluginStatus: t, pluginURL: this.url }).catch((n) => {
            throw this.status = "error", n;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(t) {
          return o._(this, arguments, void 0, function* (n, c = !1) {
            if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            if (this.url = q.resolveURL(n), !this.url) throw new Error(`requested url ${n} is invalid`);
            if (this.status === "unavailable") {
              if (!c) return this._requestImport();
              this.status = "deferred", this._syncState(this.status);
            } else if (this.status === "requested") return this._requestImport();
          });
        }
        _requestImport() {
          return o._(this, void 0, void 0, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new o.k(wi));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let pt = null;
      function Jt() {
        return pt || (pt = new Ci()), pt;
      }
      class ui {
        constructor(t, n) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = t, this.uid = o.a3(), this.uses = 0, this.tileSize = n, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(t) {
          const n = t + this.timeAdded;
          n < this.fadeEndTime || (this.fadeEndTime = n);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(t) {
          this.demTexture && t.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(t, n, c) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) {
            t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function(u, m) {
              const T = {};
              if (!m) return T;
              for (const s of u) {
                const l = s.layerIds.map((p) => m.getLayer(p)).filter(Boolean);
                if (l.length !== 0) {
                  s.layers = l, s.stateDependentLayerIds && (s.stateDependentLayers = s.stateDependentLayerIds.map((p) => l.filter((b) => b.id === p)[0]));
                  for (const p of l) T[p.id] = s;
                }
              }
              return T;
            }(t.buckets, n.style), this.hasSymbolBuckets = !1;
            for (const u in this.buckets) {
              const m = this.buckets[u];
              if (m instanceof o.a5) {
                if (this.hasSymbolBuckets = !0, !c) break;
                m.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const u in this.buckets) {
              const m = this.buckets[u];
              if (m instanceof o.a5 && m.hasRTLText) {
                this.hasRTLText = !0, Jt().lazyLoad();
                break;
              }
            }
            this.queryPadding = 0;
            for (const u in this.buckets) {
              const m = this.buckets[u];
              this.queryPadding = Math.max(this.queryPadding, n.style.getLayer(u).queryRadius(m));
            }
            t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage);
          } else this.collisionBoxArray = new o.a4();
        }
        unloadVectorData() {
          for (const t in this.buckets) this.buckets[t].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(t) {
          return this.buckets[t.id];
        }
        upload(t) {
          for (const c in this.buckets) {
            const u = this.buckets[c];
            u.uploadPending() && u.upload(t);
          }
          const n = t.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new ae(t, this.imageAtlas.image, n.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new ae(t, this.glyphAtlasImage, n.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(t) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
        }
        queryRenderedFeatures(t, n, c, u, m, T, s, l, p, b) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: u, cameraQueryGeometry: m, scale: T, tileSize: this.tileSize, pixelPosMatrix: b, transform: l, params: s, queryPadding: this.queryPadding * p }, t, n, c) : {};
        }
        querySourceFeatures(t, n) {
          const c = this.latestFeatureIndex;
          if (!c || !c.rawTileData) return;
          const u = c.loadVTLayers(), m = n && n.sourceLayer ? n.sourceLayer : "", T = u._geojsonTileLayer || u[m];
          if (!T) return;
          const s = o.a6(n && n.filter), { z: l, x: p, y: b } = this.tileID.canonical, P = { z: l, x: p, y: b };
          for (let C = 0; C < T.length; C++) {
            const E = T.feature(C);
            if (s.needGeometry) {
              const R = o.a7(E, !0);
              if (!s.filter(new o.a8(this.tileID.overscaledZ), R, this.tileID.canonical)) continue;
            } else if (!s.filter(new o.a8(this.tileID.overscaledZ), E)) continue;
            const z = c.getId(E, m), N = new o.a9(E, l, p, b, z);
            N.tile = P, t.push(N);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t) {
          const n = this.expirationTime;
          if (t.cacheControl) {
            const c = o.aa(t.cacheControl);
            c["max-age"] && (this.expirationTime = Date.now() + 1e3 * c["max-age"]);
          } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
          if (this.expirationTime) {
            const c = Date.now();
            let u = !1;
            if (this.expirationTime > c) u = !1;
            else if (n) if (this.expirationTime < n) u = !0;
            else {
              const m = this.expirationTime - n;
              m ? this.expirationTime = c + Math.max(m, 3e4) : u = !0;
            }
            else u = !0;
            u ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t, n) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t).length === 0) return;
          const c = this.latestFeatureIndex.loadVTLayers();
          for (const u in this.buckets) {
            if (!n.style.hasLayer(u)) continue;
            const m = this.buckets[u], T = m.layers[0].sourceLayer || "_geojsonTileLayer", s = c[T], l = t[T];
            if (!s || !l || Object.keys(l).length === 0) continue;
            m.update(l, s, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const p = n && n.style && n.style.getLayer(u);
            p && (this.queryPadding = Math.max(this.queryPadding, p.queryRadius(m)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < q.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t) {
          this.symbolFadeHoldUntil = q.now() + t;
        }
        setDependencies(t, n) {
          const c = {};
          for (const u of n) c[u] = !0;
          this.dependencies[t] = c;
        }
        hasDependency(t, n) {
          for (const c of t) {
            const u = this.dependencies[c];
            if (u) {
              for (const m of n) if (u[m]) return !0;
            }
          }
          return !1;
        }
      }
      class Dt {
        constructor(t, n) {
          this.max = t, this.onRemove = n, this.reset();
        }
        reset() {
          for (const t in this.data) for (const n of this.data[t]) n.timeout && clearTimeout(n.timeout), this.onRemove(n.value);
          return this.data = {}, this.order = [], this;
        }
        add(t, n, c) {
          const u = t.wrapped().key;
          this.data[u] === void 0 && (this.data[u] = []);
          const m = { value: n, timeout: void 0 };
          if (c !== void 0 && (m.timeout = setTimeout(() => {
            this.remove(t, m);
          }, c)), this.data[u].push(m), this.order.push(u), this.order.length > this.max) {
            const T = this._getAndRemoveByKey(this.order[0]);
            T && this.onRemove(T);
          }
          return this;
        }
        has(t) {
          return t.wrapped().key in this.data;
        }
        getAndRemove(t) {
          return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
        }
        _getAndRemoveByKey(t) {
          const n = this.data[t].shift();
          return n.timeout && clearTimeout(n.timeout), this.data[t].length === 0 && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), n.value;
        }
        getByKey(t) {
          const n = this.data[t];
          return n ? n[0].value : null;
        }
        get(t) {
          return this.has(t) ? this.data[t.wrapped().key][0].value : null;
        }
        remove(t, n) {
          if (!this.has(t)) return this;
          const c = t.wrapped().key, u = n === void 0 ? 0 : this.data[c].indexOf(n), m = this.data[c][u];
          return this.data[c].splice(u, 1), m.timeout && clearTimeout(m.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(m.value), this.order.splice(this.order.indexOf(c), 1), this;
        }
        setMaxSize(t) {
          for (this.max = t; this.order.length > this.max; ) {
            const n = this._getAndRemoveByKey(this.order[0]);
            n && this.onRemove(n);
          }
          return this;
        }
        filter(t) {
          const n = [];
          for (const c in this.data) for (const u of this.data[c]) t(u.value) || n.push(u);
          for (const c of n) this.remove(c.value.tileID, c);
        }
      }
      class gr {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t, n, c) {
          const u = String(n);
          if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][u] = this.stateChanges[t][u] || {}, o.e(this.stateChanges[t][u], c), this.deletedStates[t] === null) {
            this.deletedStates[t] = {};
            for (const m in this.state[t]) m !== u && (this.deletedStates[t][m] = null);
          } else if (this.deletedStates[t] && this.deletedStates[t][u] === null) {
            this.deletedStates[t][u] = {};
            for (const m in this.state[t][u]) c[m] || (this.deletedStates[t][u][m] = null);
          } else for (const m in c) this.deletedStates[t] && this.deletedStates[t][u] && this.deletedStates[t][u][m] === null && delete this.deletedStates[t][u][m];
        }
        removeFeatureState(t, n, c) {
          if (this.deletedStates[t] === null) return;
          const u = String(n);
          if (this.deletedStates[t] = this.deletedStates[t] || {}, c && n !== void 0) this.deletedStates[t][u] !== null && (this.deletedStates[t][u] = this.deletedStates[t][u] || {}, this.deletedStates[t][u][c] = null);
          else if (n !== void 0) if (this.stateChanges[t] && this.stateChanges[t][u]) for (c in this.deletedStates[t][u] = {}, this.stateChanges[t][u]) this.deletedStates[t][u][c] = null;
          else this.deletedStates[t][u] = null;
          else this.deletedStates[t] = null;
        }
        getState(t, n) {
          const c = String(n), u = o.e({}, (this.state[t] || {})[c], (this.stateChanges[t] || {})[c]);
          if (this.deletedStates[t] === null) return {};
          if (this.deletedStates[t]) {
            const m = this.deletedStates[t][n];
            if (m === null) return {};
            for (const T in m) delete u[T];
          }
          return u;
        }
        initializeTileState(t, n) {
          t.setFeatureState(this.state, n);
        }
        coalesceChanges(t, n) {
          const c = {};
          for (const u in this.stateChanges) {
            this.state[u] = this.state[u] || {};
            const m = {};
            for (const T in this.stateChanges[u]) this.state[u][T] || (this.state[u][T] = {}), o.e(this.state[u][T], this.stateChanges[u][T]), m[T] = this.state[u][T];
            c[u] = m;
          }
          for (const u in this.deletedStates) {
            this.state[u] = this.state[u] || {};
            const m = {};
            if (this.deletedStates[u] === null) for (const T in this.state[u]) m[T] = {}, this.state[u][T] = {};
            else for (const T in this.deletedStates[u]) {
              if (this.deletedStates[u][T] === null) this.state[u][T] = {};
              else for (const s of Object.keys(this.deletedStates[u][T])) delete this.state[u][T][s];
              m[T] = this.state[u][T];
            }
            c[u] = c[u] || {}, o.e(c[u], m);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(c).length !== 0) for (const u in t) t[u].setFeatureState(c, n);
        }
      }
      class lt extends o.E {
        constructor(t, n, c) {
          super(), this.id = t, this.dispatcher = c, this.on("data", (u) => this._dataHandler(u)), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((u, m, T, s) => {
            const l = new (fi(m.type))(u, m, T, s);
            if (l.id !== u) throw new Error(`Expected Source id to be ${u} instead of ${l.id}`);
            return l;
          })(t, n, c, this), this._tiles = {}, this._cache = new Dt(0, (u) => this._unloadTile(u)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new gr(), this._didEmitContent = !1, this._updated = !1;
        }
        onAdd(t) {
          this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t ? t._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t);
        }
        onRemove(t) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
          if (!this._updated) return !1;
          for (const t in this._tiles) {
            const n = this._tiles[t];
            if (n.state !== "loaded" && n.state !== "errored") return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const t = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(t, n, c) {
          return o._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(t), this._tileLoaded(t, n, c);
            } catch (u) {
              t.state = "errored", u.status !== 404 ? this._source.fire(new o.j(u, { tile: t })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(t) {
          this._source.unloadTile && this._source.unloadTile(t);
        }
        _abortTile(t) {
          this._source.abortTile && this._source.abortTile(t), this._source.fire(new o.k("dataabort", { tile: t, coord: t.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const n in this._tiles) {
            const c = this._tiles[n];
            c.upload(t), c.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((t) => t.tileID).sort(li).map((t) => t.key);
        }
        getRenderableIds(t) {
          const n = [];
          for (const c in this._tiles) this._isIdRenderable(c, t) && n.push(this._tiles[c]);
          return t ? n.sort((c, u) => {
            const m = c.tileID, T = u.tileID, s = new o.P(m.canonical.x, m.canonical.y)._rotate(this.transform.angle), l = new o.P(T.canonical.x, T.canonical.y)._rotate(this.transform.angle);
            return m.overscaledZ - T.overscaledZ || l.y - s.y || l.x - s.x;
          }).map((c) => c.tileID.key) : n.map((c) => c.tileID).sort(li).map((c) => c.key);
        }
        hasRenderableParent(t) {
          const n = this.findLoadedParent(t, 0);
          return !!n && this._isIdRenderable(n.tileID.key);
        }
        _isIdRenderable(t, n) {
          return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (n || !this._tiles[t].holdingForFade());
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const t in this._tiles) this._tiles[t].state !== "errored" && this._reloadTile(t, "reloading");
          }
        }
        _reloadTile(t, n) {
          return o._(this, void 0, void 0, function* () {
            const c = this._tiles[t];
            c && (c.state !== "loading" && (c.state = n), yield this._loadTile(c, t, n));
          });
        }
        _tileLoaded(t, n, c) {
          t.timeAdded = q.now(), c === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(n, t), this.getSource().type === "raster-dem" && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), t.aborted || this._source.fire(new o.k("data", { dataType: "source", tile: t, coord: t.tileID }));
        }
        _backfillDEM(t) {
          const n = this.getRenderableIds();
          for (let u = 0; u < n.length; u++) {
            const m = n[u];
            if (t.neighboringTiles && t.neighboringTiles[m]) {
              const T = this.getTileByID(m);
              c(t, T), c(T, t);
            }
          }
          function c(u, m) {
            u.needsHillshadePrepare = !0, u.needsTerrainPrepare = !0;
            let T = m.tileID.canonical.x - u.tileID.canonical.x;
            const s = m.tileID.canonical.y - u.tileID.canonical.y, l = Math.pow(2, u.tileID.canonical.z), p = m.tileID.key;
            T === 0 && s === 0 || Math.abs(s) > 1 || (Math.abs(T) > 1 && (Math.abs(T + l) === 1 ? T += l : Math.abs(T - l) === 1 && (T -= l)), m.dem && u.dem && (u.dem.backfillBorder(m.dem, T, s), u.neighboringTiles && u.neighboringTiles[p] && (u.neighboringTiles[p].backfilled = !0)));
          }
        }
        getTile(t) {
          return this.getTileByID(t.key);
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        _retainLoadedChildren(t, n, c, u) {
          for (const m in this._tiles) {
            let T = this._tiles[m];
            if (u[m] || !T.hasData() || T.tileID.overscaledZ <= n || T.tileID.overscaledZ > c) continue;
            let s = T.tileID;
            for (; T && T.tileID.overscaledZ > n + 1; ) {
              const p = T.tileID.scaledTo(T.tileID.overscaledZ - 1);
              T = this._tiles[p.key], T && T.hasData() && (s = p);
            }
            let l = s;
            for (; l.overscaledZ > n; ) if (l = l.scaledTo(l.overscaledZ - 1), t[l.key]) {
              u[s.key] = s;
              break;
            }
          }
        }
        findLoadedParent(t, n) {
          if (t.key in this._loadedParentTiles) {
            const c = this._loadedParentTiles[t.key];
            return c && c.tileID.overscaledZ >= n ? c : null;
          }
          for (let c = t.overscaledZ - 1; c >= n; c--) {
            const u = t.scaledTo(c), m = this._getLoadedTile(u);
            if (m) return m;
          }
        }
        findLoadedSibling(t) {
          return this._getLoadedTile(t);
        }
        _getLoadedTile(t) {
          const n = this._tiles[t.key];
          return n && n.hasData() ? n : this._cache.getByKey(t.wrapped().key);
        }
        updateCacheSize(t) {
          const n = Math.ceil(t.width / this._source.tileSize) + 1, c = Math.ceil(t.height / this._source.tileSize) + 1, u = Math.floor(n * c * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), m = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, u) : u;
          this._cache.setMaxSize(m);
        }
        handleWrapJump(t) {
          const n = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
          if (this._prevLng = t, n) {
            const c = {};
            for (const u in this._tiles) {
              const m = this._tiles[u];
              m.tileID = m.tileID.unwrapTo(m.tileID.wrap + n), c[m.tileID.key] = m;
            }
            this._tiles = c;
            for (const u in this._timers) clearTimeout(this._timers[u]), delete this._timers[u];
            for (const u in this._tiles) this._setTileReloadTimer(u, this._tiles[u]);
          }
        }
        _updateCoveredAndRetainedTiles(t, n, c, u, m, T) {
          const s = {}, l = {}, p = Object.keys(t), b = q.now();
          for (const P of p) {
            const C = t[P], E = this._tiles[P];
            if (!E || E.fadeEndTime !== 0 && E.fadeEndTime <= b) continue;
            const z = this.findLoadedParent(C, n), N = this.findLoadedSibling(C), R = z || N || null;
            R && (this._addTile(R.tileID), s[R.tileID.key] = R.tileID), l[P] = C;
          }
          this._retainLoadedChildren(l, u, c, t);
          for (const P in s) t[P] || (this._coveredTiles[P] = !0, t[P] = s[P]);
          if (T) {
            const P = {}, C = {};
            for (const E of m) this._tiles[E.key].hasData() ? P[E.key] = E : C[E.key] = E;
            for (const E in C) {
              const z = C[E].children(this._source.maxzoom);
              this._tiles[z[0].key] && this._tiles[z[1].key] && this._tiles[z[2].key] && this._tiles[z[3].key] && (P[z[0].key] = t[z[0].key] = z[0], P[z[1].key] = t[z[1].key] = z[1], P[z[2].key] = t[z[2].key] = z[2], P[z[3].key] = t[z[3].key] = z[3], delete C[E]);
            }
            for (const E in C) {
              const z = C[E], N = this.findLoadedParent(z, this._source.minzoom), R = this.findLoadedSibling(z), G = N || R || null;
              if (G) {
                P[G.tileID.key] = t[G.tileID.key] = G.tileID;
                for (const ie in P) P[ie].isChildOf(G.tileID) && delete P[ie];
              }
            }
            for (const E in this._tiles) P[E] || (this._coveredTiles[E] = !0);
          }
        }
        update(t, n) {
          if (!this._sourceLoaded || this._paused) return;
          let c;
          this.transform = t, this.terrain = n, this.updateCacheSize(t), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? c = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((b) => new o.Q(b.canonical.z, b.wrap, b.canonical.z, b.canonical.x, b.canonical.y)) : (c = t.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: n }), this._source.hasTile && (c = c.filter((b) => this._source.hasTile(b)))) : c = [];
          const u = t.coveringZoomLevel(this._source), m = Math.max(u - lt.maxOverzooming, this._source.minzoom), T = Math.max(u + lt.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const b = {};
            for (const P of c) if (P.canonical.z > this._source.minzoom) {
              const C = P.scaledTo(P.canonical.z - 1);
              b[C.key] = C;
              const E = P.scaledTo(Math.max(this._source.minzoom, Math.min(P.canonical.z, 5)));
              b[E.key] = E;
            }
            c = c.concat(Object.values(b));
          }
          const s = c.length === 0 && !this._updated && this._didEmitContent;
          this._updated = !0, s && this.fire(new o.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const l = this._updateRetainedTiles(c, u);
          Bt(this._source.type) && this._updateCoveredAndRetainedTiles(l, m, T, u, c, n);
          for (const b in l) this._tiles[b].clearFadeHold();
          const p = o.ab(this._tiles, l);
          for (const b of p) {
            const P = this._tiles[b];
            P.hasSymbolBuckets && !P.holdingForFade() ? P.setHoldDuration(this.map._fadeDuration) : P.hasSymbolBuckets && !P.symbolFadeFinished() || this._removeTile(b);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(t);
        }
        _updateRetainedTiles(t, n) {
          var c;
          const u = {}, m = {}, T = Math.max(n - lt.maxOverzooming, this._source.minzoom), s = Math.max(n + lt.maxUnderzooming, this._source.minzoom), l = {};
          for (const p of t) {
            const b = this._addTile(p);
            u[p.key] = p, b.hasData() || n < this._source.maxzoom && (l[p.key] = p);
          }
          this._retainLoadedChildren(l, n, s, u);
          for (const p of t) {
            let b = this._tiles[p.key];
            if (b.hasData()) continue;
            if (n + 1 > this._source.maxzoom) {
              const C = p.children(this._source.maxzoom)[0], E = this.getTile(C);
              if (E && E.hasData()) {
                u[C.key] = C;
                continue;
              }
            } else {
              const C = p.children(this._source.maxzoom);
              if (u[C[0].key] && u[C[1].key] && u[C[2].key] && u[C[3].key]) continue;
            }
            let P = b.wasRequested();
            for (let C = p.overscaledZ - 1; C >= T; --C) {
              const E = p.scaledTo(C);
              if (m[E.key]) break;
              if (m[E.key] = !0, b = this.getTile(E), !b && P && (b = this._addTile(E)), b) {
                const z = b.hasData();
                if ((z || !(!((c = this.map) === null || c === void 0) && c.cancelPendingTileRequestsWhileZooming) || P) && (u[E.key] = E), P = b.wasRequested(), z) break;
              }
            }
          }
          return u;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t in this._tiles) {
            const n = [];
            let c, u = this._tiles[t].tileID;
            for (; u.overscaledZ > 0; ) {
              if (u.key in this._loadedParentTiles) {
                c = this._loadedParentTiles[u.key];
                break;
              }
              n.push(u.key);
              const m = u.scaledTo(u.overscaledZ - 1);
              if (c = this._getLoadedTile(m), c) break;
              u = m;
            }
            for (const m of n) this._loadedParentTiles[m] = c;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const t in this._tiles) {
            const n = this._tiles[t].tileID, c = this._getLoadedTile(n);
            this._loadedSiblingTiles[n.key] = c;
          }
        }
        _addTile(t) {
          let n = this._tiles[t.key];
          if (n) return n;
          n = this._cache.getAndRemove(t), n && (this._setTileReloadTimer(t.key, n), n.tileID = t, this._state.initializeTileState(n, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, n)));
          const c = n;
          return n || (n = new ui(t, this._source.tileSize * t.overscaleFactor()), this._loadTile(n, t.key, n.state)), n.uses++, this._tiles[t.key] = n, c || this._source.fire(new o.k("dataloading", { tile: n, coord: n.tileID, dataType: "source" })), n;
        }
        _setTileReloadTimer(t, n) {
          t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
          const c = n.getExpiryTimeout();
          c && (this._timers[t] = setTimeout(() => {
            this._reloadTile(t, "expired"), delete this._timers[t];
          }, c));
        }
        _removeTile(t) {
          const n = this._tiles[t];
          n && (n.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), n.uses > 0 || (n.hasData() && n.state !== "reloading" ? this._cache.add(n.tileID, n, n.getExpiryTimeout()) : (n.aborted = !0, this._abortTile(n), this._unloadTile(n))));
        }
        _dataHandler(t) {
          const n = t.sourceDataType;
          t.dataType === "source" && n === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && t.dataType === "source" && n === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const t in this._tiles) this._removeTile(t);
          this._cache.reset();
        }
        tilesIn(t, n, c) {
          const u = [], m = this.transform;
          if (!m) return u;
          const T = c ? m.getCameraQueryGeometry(t) : t, s = t.map((z) => m.pointCoordinate(z, this.terrain)), l = T.map((z) => m.pointCoordinate(z, this.terrain)), p = this.getIds();
          let b = 1 / 0, P = 1 / 0, C = -1 / 0, E = -1 / 0;
          for (const z of l) b = Math.min(b, z.x), P = Math.min(P, z.y), C = Math.max(C, z.x), E = Math.max(E, z.y);
          for (let z = 0; z < p.length; z++) {
            const N = this._tiles[p[z]];
            if (N.holdingForFade()) continue;
            const R = N.tileID, G = Math.pow(2, m.zoom - N.tileID.overscaledZ), ie = n * N.queryPadding * o.W / N.tileSize / G, H = [R.getTilePoint(new o.Y(b, P)), R.getTilePoint(new o.Y(C, E))];
            if (H[0].x - ie < o.W && H[0].y - ie < o.W && H[1].x + ie >= 0 && H[1].y + ie >= 0) {
              const Q = s.map((ce) => R.getTilePoint(ce)), ue = l.map((ce) => R.getTilePoint(ce));
              u.push({ tile: N, tileID: R, queryGeometry: Q, cameraQueryGeometry: ue, scale: G });
            }
          }
          return u;
        }
        getVisibleCoordinates(t) {
          const n = this.getRenderableIds(t).map((c) => this._tiles[c].tileID);
          for (const c of n) c.posMatrix = this.transform.calculatePosMatrix(c.toUnwrapped());
          return n;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (Bt(this._source.type)) {
            const t = q.now();
            for (const n in this._tiles) if (this._tiles[n].fadeEndTime >= t) return !0;
          }
          return !1;
        }
        setFeatureState(t, n, c) {
          this._state.updateState(t = t || "_geojsonTileLayer", n, c);
        }
        removeFeatureState(t, n, c) {
          this._state.removeFeatureState(t = t || "_geojsonTileLayer", n, c);
        }
        getFeatureState(t, n) {
          return this._state.getState(t = t || "_geojsonTileLayer", n);
        }
        setDependencies(t, n, c) {
          const u = this._tiles[t];
          u && u.setDependencies(n, c);
        }
        reloadTilesForDependencies(t, n) {
          for (const c in this._tiles) this._tiles[c].hasDependency(t, n) && this._reloadTile(c, "reloading");
          this._cache.filter((c) => !c.hasDependency(t, n));
        }
      }
      function li(f, t) {
        const n = Math.abs(2 * f.wrap) - +(f.wrap < 0), c = Math.abs(2 * t.wrap) - +(t.wrap < 0);
        return f.overscaledZ - t.overscaledZ || c - n || t.canonical.y - f.canonical.y || t.canonical.x - f.canonical.x;
      }
      function Bt(f) {
        return f === "raster" || f === "image" || f === "video";
      }
      lt.maxOverzooming = 10, lt.maxUnderzooming = 3;
      class ki {
        constructor(t, n) {
          this.reset(t, n);
        }
        reset(t, n) {
          this.points = t || [], this._distances = [0];
          for (let c = 1; c < this.points.length; c++) this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(n || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t) {
          if (this.points.length === 1) return this.points[0];
          t = o.ac(t, 0, 1);
          let n = 1, c = this._distances[n];
          const u = t * this.paddedLength + this.padding;
          for (; c < u && n < this._distances.length; ) c = this._distances[++n];
          const m = n - 1, T = this._distances[m], s = c - T, l = s > 0 ? (u - T) / s : 0;
          return this.points[m].mult(1 - l).add(this.points[n].mult(l));
        }
      }
      function lr(f, t) {
        let n = !0;
        return f === "always" || f !== "never" && t !== "never" || (n = !1), n;
      }
      class Ft {
        constructor(t, n, c) {
          const u = this.boxCells = [], m = this.circleCells = [];
          this.xCellCount = Math.ceil(t / c), this.yCellCount = Math.ceil(n / c);
          for (let T = 0; T < this.xCellCount * this.yCellCount; T++) u.push([]), m.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = n, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / n, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(t, n, c, u, m) {
          this._forEachCell(n, c, u, m, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(n), this.bboxes.push(c), this.bboxes.push(u), this.bboxes.push(m);
        }
        insertCircle(t, n, c, u) {
          this._forEachCell(n - u, c - u, n + u, c + u, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(n), this.circles.push(c), this.circles.push(u);
        }
        _insertBoxCell(t, n, c, u, m, T) {
          this.boxCells[m].push(T);
        }
        _insertCircleCell(t, n, c, u, m, T) {
          this.circleCells[m].push(T);
        }
        _query(t, n, c, u, m, T, s) {
          if (c < 0 || t > this.width || u < 0 || n > this.height) return [];
          const l = [];
          if (t <= 0 && n <= 0 && this.width <= c && this.height <= u) {
            if (m) return [{ key: null, x1: t, y1: n, x2: c, y2: u }];
            for (let p = 0; p < this.boxKeys.length; p++) l.push({ key: this.boxKeys[p], x1: this.bboxes[4 * p], y1: this.bboxes[4 * p + 1], x2: this.bboxes[4 * p + 2], y2: this.bboxes[4 * p + 3] });
            for (let p = 0; p < this.circleKeys.length; p++) {
              const b = this.circles[3 * p], P = this.circles[3 * p + 1], C = this.circles[3 * p + 2];
              l.push({ key: this.circleKeys[p], x1: b - C, y1: P - C, x2: b + C, y2: P + C });
            }
          } else this._forEachCell(t, n, c, u, this._queryCell, l, { hitTest: m, overlapMode: T, seenUids: { box: {}, circle: {} } }, s);
          return l;
        }
        query(t, n, c, u) {
          return this._query(t, n, c, u, !1, null);
        }
        hitTest(t, n, c, u, m, T) {
          return this._query(t, n, c, u, !0, m, T).length > 0;
        }
        hitTestCircle(t, n, c, u, m) {
          const T = t - c, s = t + c, l = n - c, p = n + c;
          if (s < 0 || T > this.width || p < 0 || l > this.height) return !1;
          const b = [];
          return this._forEachCell(T, l, s, p, this._queryCellCircle, b, { hitTest: !0, overlapMode: u, circle: { x: t, y: n, radius: c }, seenUids: { box: {}, circle: {} } }, m), b.length > 0;
        }
        _queryCell(t, n, c, u, m, T, s, l) {
          const { seenUids: p, hitTest: b, overlapMode: P } = s, C = this.boxCells[m];
          if (C !== null) {
            const z = this.bboxes;
            for (const N of C) if (!p.box[N]) {
              p.box[N] = !0;
              const R = 4 * N, G = this.boxKeys[N];
              if (t <= z[R + 2] && n <= z[R + 3] && c >= z[R + 0] && u >= z[R + 1] && (!l || l(G)) && (!b || !lr(P, G.overlapMode)) && (T.push({ key: G, x1: z[R], y1: z[R + 1], x2: z[R + 2], y2: z[R + 3] }), b)) return !0;
            }
          }
          const E = this.circleCells[m];
          if (E !== null) {
            const z = this.circles;
            for (const N of E) if (!p.circle[N]) {
              p.circle[N] = !0;
              const R = 3 * N, G = this.circleKeys[N];
              if (this._circleAndRectCollide(z[R], z[R + 1], z[R + 2], t, n, c, u) && (!l || l(G)) && (!b || !lr(P, G.overlapMode))) {
                const ie = z[R], H = z[R + 1], Q = z[R + 2];
                if (T.push({ key: G, x1: ie - Q, y1: H - Q, x2: ie + Q, y2: H + Q }), b) return !0;
              }
            }
          }
          return !1;
        }
        _queryCellCircle(t, n, c, u, m, T, s, l) {
          const { circle: p, seenUids: b, overlapMode: P } = s, C = this.boxCells[m];
          if (C !== null) {
            const z = this.bboxes;
            for (const N of C) if (!b.box[N]) {
              b.box[N] = !0;
              const R = 4 * N, G = this.boxKeys[N];
              if (this._circleAndRectCollide(p.x, p.y, p.radius, z[R + 0], z[R + 1], z[R + 2], z[R + 3]) && (!l || l(G)) && !lr(P, G.overlapMode)) return T.push(!0), !0;
            }
          }
          const E = this.circleCells[m];
          if (E !== null) {
            const z = this.circles;
            for (const N of E) if (!b.circle[N]) {
              b.circle[N] = !0;
              const R = 3 * N, G = this.circleKeys[N];
              if (this._circlesCollide(z[R], z[R + 1], z[R + 2], p.x, p.y, p.radius) && (!l || l(G)) && !lr(P, G.overlapMode)) return T.push(!0), !0;
            }
          }
        }
        _forEachCell(t, n, c, u, m, T, s, l) {
          const p = this._convertToXCellCoord(t), b = this._convertToYCellCoord(n), P = this._convertToXCellCoord(c), C = this._convertToYCellCoord(u);
          for (let E = p; E <= P; E++) for (let z = b; z <= C; z++) if (m.call(this, t, n, c, u, this.xCellCount * z + E, T, s, l)) return;
        }
        _convertToXCellCoord(t) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
        }
        _convertToYCellCoord(t) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
        }
        _circlesCollide(t, n, c, u, m, T) {
          const s = u - t, l = m - n, p = c + T;
          return p * p > s * s + l * l;
        }
        _circleAndRectCollide(t, n, c, u, m, T, s) {
          const l = (T - u) / 2, p = Math.abs(t - (u + l));
          if (p > l + c) return !1;
          const b = (s - m) / 2, P = Math.abs(n - (m + b));
          if (P > b + c) return !1;
          if (p <= l || P <= b) return !0;
          const C = p - l, E = P - b;
          return C * C + E * E <= c * c;
        }
      }
      function nn(f, t, n, c, u) {
        const m = o.F();
        return t ? (o.J(m, m, [1 / u, 1 / u, 1]), n || o.ad(m, m, c.angle)) : o.K(m, c.labelPlaneMatrix, f), m;
      }
      function Oi(f, t, n, c, u) {
        if (t) {
          const m = o.ae(f);
          return o.J(m, m, [u, u, 1]), n || o.ad(m, m, -c.angle), m;
        }
        return c.glCoordMatrix;
      }
      function $i(f, t, n) {
        let c;
        n ? (c = [f.x, f.y, n(f.x, f.y), 1], o.af(c, c, t)) : (c = [f.x, f.y, 0, 1], function(m, T, s) {
          const l = T[0], p = T[1];
          m[0] = s[0] * l + s[4] * p + s[12], m[1] = s[1] * l + s[5] * p + s[13], m[3] = s[3] * l + s[7] * p + s[15];
        }(c, c, t));
        const u = c[3];
        return { point: new o.P(c[0] / u, c[1] / u), signedDistanceFromCamera: u, isOccluded: !1 };
      }
      function de(f, t) {
        return 0.5 + f / t * 0.5;
      }
      function Z(f, t) {
        return f.x >= -t[0] && f.x <= t[0] && f.y >= -t[1] && f.y <= t[1];
      }
      function W(f, t, n, c, u, m, T, s, l, p, b, P, C, E, z) {
        const N = c ? f.textSizeData : f.iconSizeData, R = o.ag(N, n.transform.zoom), G = [256 / n.width * 2 + 1, 256 / n.height * 2 + 1], ie = c ? f.text.dynamicLayoutVertexArray : f.icon.dynamicLayoutVertexArray;
        ie.clear();
        const H = f.lineVertexArray, Q = c ? f.text.placedSymbolArray : f.icon.placedSymbolArray, ue = n.transform.width / n.transform.height;
        let ce = !1;
        for (let ne = 0; ne < Q.length; ne++) {
          const le = Q.get(ne);
          if (le.hidden || le.writingMode === o.ah.vertical && !ce) {
            It(le.numGlyphs, ie);
            continue;
          }
          ce = !1;
          const De = $i(new o.P(le.anchorX, le.anchorY), t, z);
          if (!Z(De.point, G)) {
            It(le.numGlyphs, ie);
            continue;
          }
          const Ne = de(n.transform.cameraToCenterDistance, De.signedDistanceFromCamera), Te = o.ai(N, R, le), qe = T ? Te / Ne : Te * Ne, He = { getElevation: z, labelPlaneMatrix: u, lineVertexArray: H, pitchWithMap: T, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: p, tileAnchorPoint: new o.P(le.anchorX, le.anchorY), unwrappedTileID: b, width: P, height: C, translation: E }, vt = Ae(He, le, qe, !1, s, t, m, f.glyphOffsetArray, ie, ue, l);
          ce = vt.useVertical, (vt.notEnoughRoom || ce || vt.needsFlipping && Ae(He, le, qe, !0, s, t, m, f.glyphOffsetArray, ie, ue, l).notEnoughRoom) && It(le.numGlyphs, ie);
        }
        c ? f.text.dynamicLayoutVertexBuffer.updateData(ie) : f.icon.dynamicLayoutVertexBuffer.updateData(ie);
      }
      function J(f, t, n, c, u, m, T, s) {
        const l = m.glyphStartIndex + m.numGlyphs, p = m.lineStartIndex, b = m.lineStartIndex + m.lineLength, P = t.getoffsetX(m.glyphStartIndex), C = t.getoffsetX(l - 1), E = Je(f * P, n, c, u, m.segment, p, b, s, T);
        if (!E) return null;
        const z = Je(f * C, n, c, u, m.segment, p, b, s, T);
        return z ? s.projectionCache.anyProjectionOccluded ? null : { first: E, last: z } : null;
      }
      function fe(f, t, n, c) {
        return f === o.ah.horizontal && Math.abs(n.y - t.y) > Math.abs(n.x - t.x) * c ? { useVertical: !0 } : (f === o.ah.vertical ? t.y < n.y : t.x > n.x) ? { needsFlipping: !0 } : null;
      }
      function Ae(f, t, n, c, u, m, T, s, l, p, b) {
        const P = n / 24, C = t.lineOffsetX * P, E = t.lineOffsetY * P;
        let z;
        if (t.numGlyphs > 1) {
          const N = t.glyphStartIndex + t.numGlyphs, R = t.lineStartIndex, G = t.lineStartIndex + t.lineLength, ie = J(P, s, C, E, c, t, b, f);
          if (!ie) return { notEnoughRoom: !0 };
          const H = $i(ie.first.point, T, f.getElevation).point, Q = $i(ie.last.point, T, f.getElevation).point;
          if (u && !c) {
            const ue = fe(t.writingMode, H, Q, p);
            if (ue) return ue;
          }
          z = [ie.first];
          for (let ue = t.glyphStartIndex + 1; ue < N - 1; ue++) z.push(Je(P * s.getoffsetX(ue), C, E, c, t.segment, R, G, f, b));
          z.push(ie.last);
        } else {
          if (u && !c) {
            const R = $i(f.tileAnchorPoint, m, f.getElevation).point, G = t.lineStartIndex + t.segment + 1, ie = new o.P(f.lineVertexArray.getx(G), f.lineVertexArray.gety(G)), H = $i(ie, m, f.getElevation), Q = H.signedDistanceFromCamera > 0 ? H.point : function(ce, ne, le, De, Ne, Te) {
              return Ce(ce, ne, le, 1, Ne, Te);
            }(f.tileAnchorPoint, ie, R, 0, m, f), ue = fe(t.writingMode, R, Q, p);
            if (ue) return ue;
          }
          const N = Je(P * s.getoffsetX(t.glyphStartIndex), C, E, c, t.segment, t.lineStartIndex, t.lineStartIndex + t.lineLength, f, b);
          if (!N || f.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
          z = [N];
        }
        for (const N of z) o.aj(l, N.point, N.angle);
        return {};
      }
      function Ce(f, t, n, c, u, m) {
        const T = f.add(f.sub(t)._unit()), s = u !== void 0 ? $i(T, u, m.getElevation).point : pe(T.x, T.y, m).point, l = n.sub(s);
        return n.add(l._mult(c / l.mag()));
      }
      function Me(f, t, n) {
        const c = t.projectionCache;
        if (c.projections[f]) return c.projections[f];
        const u = new o.P(t.lineVertexArray.getx(f), t.lineVertexArray.gety(f)), m = pe(u.x, u.y, t);
        if (m.signedDistanceFromCamera > 0) return c.projections[f] = m.point, c.anyProjectionOccluded = c.anyProjectionOccluded || m.isOccluded, m.point;
        const T = f - n.direction;
        return function(s, l, p, b, P) {
          return Ce(s, l, p, b, void 0, P);
        }(n.distanceFromAnchor === 0 ? t.tileAnchorPoint : new o.P(t.lineVertexArray.getx(T), t.lineVertexArray.gety(T)), u, n.previousVertex, n.absOffsetX - n.distanceFromAnchor + 1, t);
      }
      function pe(f, t, n) {
        const c = f + n.translation[0], u = t + n.translation[1];
        let m;
        return !n.pitchWithMap && n.projection.useSpecialProjectionForSymbols ? (m = n.projection.projectTileCoordinates(c, u, n.unwrappedTileID, n.getElevation), m.point.x = (0.5 * m.point.x + 0.5) * n.width, m.point.y = (0.5 * -m.point.y + 0.5) * n.height) : (m = $i(new o.P(c, u), n.labelPlaneMatrix, n.getElevation), m.isOccluded = !1), m;
      }
      function Oe(f, t, n) {
        return f._unit()._perp()._mult(t * n);
      }
      function ot(f, t, n, c, u, m, T, s, l) {
        if (s.projectionCache.offsets[f]) return s.projectionCache.offsets[f];
        const p = n.add(t);
        if (f + l.direction < c || f + l.direction >= u) return s.projectionCache.offsets[f] = p, p;
        const b = Me(f + l.direction, s, l), P = Oe(b.sub(n), T, l.direction), C = n.add(P), E = b.add(P);
        return s.projectionCache.offsets[f] = o.ak(m, p, C, E) || p, s.projectionCache.offsets[f];
      }
      function Je(f, t, n, c, u, m, T, s, l) {
        const p = c ? f - t : f + t;
        let b = p > 0 ? 1 : -1, P = 0;
        c && (b *= -1, P = Math.PI), b < 0 && (P += Math.PI);
        let C, E = b > 0 ? m + u : m + u + 1;
        s.projectionCache.cachedAnchorPoint ? C = s.projectionCache.cachedAnchorPoint : (C = pe(s.tileAnchorPoint.x, s.tileAnchorPoint.y, s).point, s.projectionCache.cachedAnchorPoint = C);
        let z, N, R = C, G = C, ie = 0, H = 0;
        const Q = Math.abs(p), ue = [];
        let ce;
        for (; ie + H <= Q; ) {
          if (E += b, E < m || E >= T) return null;
          ie += H, G = R, N = z;
          const De = { absOffsetX: Q, direction: b, distanceFromAnchor: ie, previousVertex: G };
          if (R = Me(E, s, De), n === 0) ue.push(G), ce = R.sub(G);
          else {
            let Ne;
            const Te = R.sub(G);
            Ne = Te.mag() === 0 ? Oe(Me(E + b, s, De).sub(R), n, b) : Oe(Te, n, b), N || (N = G.add(Ne)), z = ot(E, Ne, R, m, T, N, n, s, De), ue.push(N), ce = z.sub(N);
          }
          H = ce.mag();
        }
        const ne = ce._mult((Q - ie) / H)._add(N || G), le = P + Math.atan2(R.y - G.y, R.x - G.x);
        return ue.push(ne), { point: ne, angle: l ? le : 0, path: ue };
      }
      const Ge = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function It(f, t) {
        for (let n = 0; n < f; n++) {
          const c = t.length;
          t.resize(c + 4), t.float32.set(Ge, 3 * c);
        }
      }
      const Nt = 100;
      class gi {
        constructor(t, n, c = new Ft(t.width + 200, t.height + 200, 25), u = new Ft(t.width + 200, t.height + 200, 25)) {
          this.transform = t, this.mapProjection = n, this.grid = c, this.ignoredGrid = u, this.pitchFactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + Nt, this.screenBottomBoundary = t.height + Nt, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(t, n, c, u, m, T, s, l, p, b, P) {
          const C = t.anchorPointX + l[0], E = t.anchorPointY + l[1], z = this.projectAndGetPerspectiveRatio(u, C, E, m, b), N = this._projectCollisionBox(t, c, u, m, T, s, l, z, b, P), [R, G, ie, H] = N.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (T ? N.allPointsOccluded : this.mapProjection.isOccluded(C, E, m)) || z.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(R, G, ie, H) || n !== "always" && this.grid.hitTest(R, G, ie, H, n, p) ? { box: [R, G, ie, H], placeable: !1, offscreen: !1 } : { box: [R, G, ie, H], placeable: !0, offscreen: this.isOffscreen(R, G, ie, H) };
        }
        placeCollisionCircles(t, n, c, u, m, T, s, l, p, b, P, C, E, z, N, R) {
          const G = [], ie = new o.P(n.anchorX, n.anchorY), H = this.getPerspectiveRatio(T, ie.x, ie.y, s, R), Q = (P ? m / H : m * H) / o.ap, ue = { getElevation: R, labelPlaneMatrix: l, lineVertexArray: c, pitchWithMap: P, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: this.mapProjection, tileAnchorPoint: ie, unwrappedTileID: s, width: this.transform.width, height: this.transform.height, translation: N }, ce = J(Q, u, n.lineOffsetX * Q, n.lineOffsetY * Q, !1, n, !1, ue);
          let ne = !1, le = !1, De = !0;
          if (ce) {
            const Ne = 0.5 * E * H + z, Te = new o.P(-100, -100), qe = new o.P(this.screenRightBoundary, this.screenBottomBoundary), He = new ki(), vt = ce.first, Ue = ce.last;
            let ft = [];
            for (let Mt = vt.path.length - 1; Mt >= 1; Mt--) ft.push(vt.path[Mt]);
            for (let Mt = 1; Mt < Ue.path.length; Mt++) ft.push(Ue.path[Mt]);
            const Tt = 2.5 * Ne;
            if (p) {
              const Mt = this.projectPathToScreenSpace(ft, ue, p);
              ft = Mt.some((Wt) => Wt.signedDistanceFromCamera <= 0) ? [] : Mt.map((Wt) => Wt.point);
            }
            let ii = [];
            if (ft.length > 0) {
              const Mt = ft[0].clone(), Wt = ft[0].clone();
              for (let ci = 1; ci < ft.length; ci++) Mt.x = Math.min(Mt.x, ft[ci].x), Mt.y = Math.min(Mt.y, ft[ci].y), Wt.x = Math.max(Wt.x, ft[ci].x), Wt.y = Math.max(Wt.y, ft[ci].y);
              ii = Mt.x >= Te.x && Wt.x <= qe.x && Mt.y >= Te.y && Wt.y <= qe.y ? [ft] : Wt.x < Te.x || Mt.x > qe.x || Wt.y < Te.y || Mt.y > qe.y ? [] : o.al([ft], Te.x, Te.y, qe.x, qe.y);
            }
            for (const Mt of ii) {
              He.reset(Mt, 0.25 * Ne);
              let Wt = 0;
              Wt = He.length <= 0.5 * Ne ? 1 : Math.ceil(He.paddedLength / Tt) + 1;
              for (let ci = 0; ci < Wt; ci++) {
                const si = ci / Math.max(Wt - 1, 1), qi = He.lerp(si), Ti = qi.x + Nt, Ni = qi.y + Nt;
                G.push(Ti, Ni, Ne, 0);
                const Wi = Ti - Ne, bi = Ni - Ne, Gi = Ti + Ne, fr = Ni + Ne;
                if (De = De && this.isOffscreen(Wi, bi, Gi, fr), le = le || this.isInsideGrid(Wi, bi, Gi, fr), t !== "always" && this.grid.hitTestCircle(Ti, Ni, Ne, t, C) && (ne = !0, !b)) return { circles: [], offscreen: !1, collisionDetected: ne };
              }
            }
          }
          return { circles: !b && ne || !le || H < this.perspectiveRatioCutoff ? [] : G, offscreen: De, collisionDetected: ne };
        }
        projectPathToScreenSpace(t, n, c) {
          return t.map((u) => $i(u, c, n.getElevation));
        }
        queryRenderedSymbols(t) {
          if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          const n = [];
          let c = 1 / 0, u = 1 / 0, m = -1 / 0, T = -1 / 0;
          for (const b of t) {
            const P = new o.P(b.x + Nt, b.y + Nt);
            c = Math.min(c, P.x), u = Math.min(u, P.y), m = Math.max(m, P.x), T = Math.max(T, P.y), n.push(P);
          }
          const s = this.grid.query(c, u, m, T).concat(this.ignoredGrid.query(c, u, m, T)), l = {}, p = {};
          for (const b of s) {
            const P = b.key;
            if (l[P.bucketInstanceId] === void 0 && (l[P.bucketInstanceId] = {}), l[P.bucketInstanceId][P.featureIndex]) continue;
            const C = [new o.P(b.x1, b.y1), new o.P(b.x2, b.y1), new o.P(b.x2, b.y2), new o.P(b.x1, b.y2)];
            o.am(n, C) && (l[P.bucketInstanceId][P.featureIndex] = !0, p[P.bucketInstanceId] === void 0 && (p[P.bucketInstanceId] = []), p[P.bucketInstanceId].push(P.featureIndex));
          }
          return p;
        }
        insertCollisionBox(t, n, c, u, m, T) {
          (c ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: u, featureIndex: m, collisionGroupID: T, overlapMode: n }, t[0], t[1], t[2], t[3]);
        }
        insertCollisionCircles(t, n, c, u, m, T) {
          const s = c ? this.ignoredGrid : this.grid, l = { bucketInstanceId: u, featureIndex: m, collisionGroupID: T, overlapMode: n };
          for (let p = 0; p < t.length; p += 4) s.insertCircle(l, t[p], t[p + 1], t[p + 2]);
        }
        projectAndGetPerspectiveRatio(t, n, c, u, m) {
          const T = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(n, c, u, m) : $i(new o.P(n, c), t, m);
          return { point: new o.P((T.point.x + 1) / 2 * this.transform.width + Nt, (1 - T.point.y) / 2 * this.transform.height + Nt), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / T.signedDistanceFromCamera * 0.5, isOccluded: T.isOccluded, signedDistanceFromCamera: T.signedDistanceFromCamera };
        }
        getPerspectiveRatio(t, n, c, u, m) {
          const T = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(n, c, u, m) : $i(new o.P(n, c), t, m);
          return 0.5 + this.transform.cameraToCenterDistance / T.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(t, n, c, u) {
          return c < Nt || t >= this.screenRightBoundary || u < Nt || n > this.screenBottomBoundary;
        }
        isInsideGrid(t, n, c, u) {
          return c >= 0 && t < this.gridRightBoundary && u >= 0 && n < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t = o.an([]);
          return o.H(t, t, [-100, -100, 0]), t;
        }
        _projectCollisionBox(t, n, c, u, m, T, s, l, p, b) {
          const P = n * l.perspectiveRatio;
          let C = new o.P(1, 0), E = new o.P(0, 1);
          const z = new o.P(t.anchorPointX + s[0], t.anchorPointY + s[1]);
          if (T && !m) {
            const Ne = this.projectAndGetPerspectiveRatio(c, z.x + 1, z.y, u, p).point.sub(l.point).unit(), Te = Math.atan(Ne.y / Ne.x) + (Ne.x < 0 ? Math.PI : 0), qe = Math.sin(Te), He = Math.cos(Te);
            C = new o.P(He, qe), E = new o.P(-qe, He);
          } else if (!T && m) {
            const Ne = -this.transform.angle, Te = Math.sin(Ne), qe = Math.cos(Ne);
            C = new o.P(qe, Te), E = new o.P(-Te, qe);
          }
          let N = l.point, R = P;
          if (m) {
            N = z;
            const Ne = this.transform.zoom - Math.floor(this.transform.zoom);
            R = Math.pow(2, -Ne), R *= this.mapProjection.getPitchedTextCorrection(this.transform, z, u), b || (R *= o.ac(0.5 + l.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          b && (N = N.add(C.mult(b.x * R)).add(E.mult(b.y * R)));
          const G = t.x1 * R, ie = t.x2 * R, H = (G + ie) / 2, Q = t.y1 * R, ue = t.y2 * R, ce = (Q + ue) / 2, ne = [{ offsetX: G, offsetY: Q }, { offsetX: H, offsetY: Q }, { offsetX: ie, offsetY: Q }, { offsetX: ie, offsetY: ce }, { offsetX: ie, offsetY: ue }, { offsetX: H, offsetY: ue }, { offsetX: G, offsetY: ue }, { offsetX: G, offsetY: ce }];
          let le = [];
          for (const { offsetX: Ne, offsetY: Te } of ne) le.push(new o.P(N.x + C.x * Ne + E.x * Te, N.y + C.y * Ne + E.y * Te));
          let De = !1;
          if (m) {
            const Ne = le.map((Te) => this.projectAndGetPerspectiveRatio(c, Te.x, Te.y, u, p));
            De = Ne.some((Te) => !Te.isOccluded), le = Ne.map((Te) => Te.point);
          } else De = !0;
          return { box: o.ao(le), allPointsOccluded: !De };
        }
      }
      function ti(f, t, n) {
        return t * (o.W / (f.tileSize * Math.pow(2, n - f.tileID.overscaledZ)));
      }
      class mi {
        constructor(t, n, c, u) {
          this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? n : -n))) : u && c ? 1 : 0, this.placed = c;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Ii {
        constructor(t, n, c, u, m) {
          this.text = new mi(t ? t.text : null, n, c, m), this.icon = new mi(t ? t.icon : null, n, u, m);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Ei {
        constructor(t, n, c) {
          this.text = t, this.icon = n, this.skipFade = c;
        }
      }
      class Ui {
        constructor() {
          this.invProjMatrix = o.F(), this.viewportMatrix = o.F(), this.circles = [];
        }
      }
      class ai {
        constructor(t, n, c, u, m) {
          this.bucketInstanceId = t, this.featureIndex = n, this.sourceLayerIndex = c, this.bucketIndex = u, this.tileID = m;
        }
      }
      class Fi {
        constructor(t) {
          this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(t) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[t]) {
            const n = ++this.maxGroupID;
            this.collisionGroups[t] = { ID: n, predicate: (c) => c.collisionGroupID === n };
          }
          return this.collisionGroups[t];
        }
      }
      function er(f, t, n, c, u) {
        const { horizontalAlign: m, verticalAlign: T } = o.au(f);
        return new o.P(-(m - 0.5) * t + c[0] * u, -(T - 0.5) * n + c[1] * u);
      }
      class Mr {
        constructor(t, n, c, u, m, T) {
          this.transform = t.clone(), this.terrain = c, this.collisionIndex = new gi(this.transform, n), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = u, this.retainedQueryData = {}, this.collisionGroups = new Fi(m), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = T, T && (T.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(t) {
          const n = this.terrain;
          return n ? (c, u) => n.getElevation(t, c, u) : null;
        }
        getBucketParts(t, n, c, u) {
          const m = c.getBucket(n), T = c.latestFeatureIndex;
          if (!m || !T || n.id !== m.layerIds[0]) return;
          const s = c.collisionBoxArray, l = m.layers[0].layout, p = m.layers[0].paint, b = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), P = c.tileSize / o.W, C = c.tileID.toUnwrapped(), E = this.transform.calculatePosMatrix(C), z = l.get("text-pitch-alignment") === "map", N = l.get("text-rotation-alignment") === "map", R = ti(c, 1, this.transform.zoom), G = this.collisionIndex.mapProjection.translatePosition(this.transform, c, p.get("text-translate"), p.get("text-translate-anchor")), ie = this.collisionIndex.mapProjection.translatePosition(this.transform, c, p.get("icon-translate"), p.get("icon-translate-anchor")), H = nn(E, z, N, this.transform, R);
          let Q = null;
          if (z) {
            const ce = Oi(E, z, N, this.transform, R);
            Q = o.K([], this.transform.labelPlaneMatrix, ce);
          }
          this.retainedQueryData[m.bucketInstanceId] = new ai(m.bucketInstanceId, T, m.sourceLayerIndex, m.index, c.tileID);
          const ue = { bucket: m, layout: l, translationText: G, translationIcon: ie, posMatrix: E, unwrappedTileID: C, textLabelPlaneMatrix: H, labelToScreenMatrix: Q, scale: b, textPixelRatio: P, holdingForFade: c.holdingForFade(), collisionBoxArray: s, partiallyEvaluatedTextSize: o.ag(m.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(m.sourceID) };
          if (u) for (const ce of m.sortKeyRanges) {
            const { sortKey: ne, symbolInstanceStart: le, symbolInstanceEnd: De } = ce;
            t.push({ sortKey: ne, symbolInstanceStart: le, symbolInstanceEnd: De, parameters: ue });
          }
          else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: m.symbolInstances.length, parameters: ue });
        }
        attemptAnchorPlacement(t, n, c, u, m, T, s, l, p, b, P, C, E, z, N, R, G, ie, H) {
          const Q = o.aq[t.textAnchor], ue = [t.textOffset0, t.textOffset1], ce = er(Q, c, u, ue, m), ne = this.collisionIndex.placeCollisionBox(n, C, l, p, b, s, T, R, P.predicate, H, ce);
          if ((!ie || this.collisionIndex.placeCollisionBox(ie, C, l, p, b, s, T, G, P.predicate, H, ce).placeable) && ne.placeable) {
            let le;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[E.crossTileID] && this.prevPlacement.placements[E.crossTileID] && this.prevPlacement.placements[E.crossTileID].text && (le = this.prevPlacement.variableOffsets[E.crossTileID].anchor), E.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[E.crossTileID] = { textOffset: ue, width: c, height: u, anchor: Q, textBoxScale: m, prevAnchor: le }, this.markUsedJustification(z, Q, E, N), z.allowVerticalPlacement && (this.markUsedOrientation(z, N, E), this.placedOrientations[E.crossTileID] = N), { shift: ce, placedGlyphBoxes: ne };
          }
        }
        placeLayerBucketPart(t, n, c) {
          const { bucket: u, layout: m, translationText: T, translationIcon: s, posMatrix: l, unwrappedTileID: p, textLabelPlaneMatrix: b, labelToScreenMatrix: P, textPixelRatio: C, holdingForFade: E, collisionBoxArray: z, partiallyEvaluatedTextSize: N, collisionGroup: R } = t.parameters, G = m.get("text-optional"), ie = m.get("icon-optional"), H = o.ar(m, "text-overlap", "text-allow-overlap"), Q = H === "always", ue = o.ar(m, "icon-overlap", "icon-allow-overlap"), ce = ue === "always", ne = m.get("text-rotation-alignment") === "map", le = m.get("text-pitch-alignment") === "map", De = m.get("icon-text-fit") !== "none", Ne = m.get("symbol-z-order") === "viewport-y", Te = Q && (ce || !u.hasIconData() || ie), qe = ce && (Q || !u.hasTextData() || G);
          !u.collisionArrays && z && u.deserializeCollisionBoxes(z);
          const He = this._getTerrainElevationFunc(this.retainedQueryData[u.bucketInstanceId].tileID), vt = (Ue, ft, Tt) => {
            var ii, Mt;
            if (n[Ue.crossTileID]) return;
            if (E) return void (this.placements[Ue.crossTileID] = new Ei(!1, !1, !1));
            let Wt = !1, ci = !1, si = !0, qi = null, Ti = { box: null, placeable: !1, offscreen: null }, Ni = { box: null, placeable: !1, offscreen: null }, Wi = null, bi = null, Gi = null, fr = 0, ur = 0, Tr = 0;
            ft.textFeatureIndex ? fr = ft.textFeatureIndex : Ue.useRuntimeCollisionCircles && (fr = Ue.featureIndex), ft.verticalTextFeatureIndex && (ur = ft.verticalTextFeatureIndex);
            const kr = ft.textBox;
            if (kr) {
              const nr = (Li) => {
                let Ur = o.ah.horizontal;
                if (u.allowVerticalPlacement && !Li && this.prevPlacement) {
                  const zr = this.prevPlacement.placedOrientations[Ue.crossTileID];
                  zr && (this.placedOrientations[Ue.crossTileID] = zr, Ur = zr, this.markUsedOrientation(u, Ur, Ue));
                }
                return Ur;
              }, Zr = (Li, Ur) => {
                if (u.allowVerticalPlacement && Ue.numVerticalGlyphVertices > 0 && ft.verticalTextBox) {
                  for (const zr of u.writingModes) if (zr === o.ah.vertical ? (Ti = Ur(), Ni = Ti) : Ti = Li(), Ti && Ti.placeable) break;
                } else Ti = Li();
              }, Tn = Ue.textAnchorOffsetStartIndex, kn = Ue.textAnchorOffsetEndIndex;
              if (kn === Tn) {
                const Li = (Ur, zr) => {
                  const sr = this.collisionIndex.placeCollisionBox(Ur, H, C, l, p, le, ne, T, R.predicate, He);
                  return sr && sr.placeable && (this.markUsedOrientation(u, zr, Ue), this.placedOrientations[Ue.crossTileID] = zr), sr;
                };
                Zr(() => Li(kr, o.ah.horizontal), () => {
                  const Ur = ft.verticalTextBox;
                  return u.allowVerticalPlacement && Ue.numVerticalGlyphVertices > 0 && Ur ? Li(Ur, o.ah.vertical) : { box: null, offscreen: null };
                }), nr(Ti && Ti.placeable);
              } else {
                let Li = o.aq[(Mt = (ii = this.prevPlacement) === null || ii === void 0 ? void 0 : ii.variableOffsets[Ue.crossTileID]) === null || Mt === void 0 ? void 0 : Mt.anchor];
                const Ur = (sr, Zs, Oa) => {
                  const vr = sr.x2 - sr.x1, jn = sr.y2 - sr.y1, Ws = Ue.textBoxScale, Gs = De && ue === "never" ? Zs : null;
                  let Hs = null, Vo = H === "never" ? 1 : 2, dl = "never";
                  Li && Vo++;
                  for (let yo = 0; yo < Vo; yo++) {
                    for (let $o = Tn; $o < kn; $o++) {
                      const ja = u.textAnchorOffsets.get($o);
                      if (Li && ja.textAnchor !== Li) continue;
                      const As = this.attemptAnchorPlacement(ja, sr, vr, jn, Ws, ne, le, C, l, p, R, dl, Ue, u, Oa, T, s, Gs, He);
                      if (As && (Hs = As.placedGlyphBoxes, Hs && Hs.placeable)) return Wt = !0, qi = As.shift, Hs;
                    }
                    Li ? Li = null : dl = H;
                  }
                  return c && !Hs && (Hs = { box: this.collisionIndex.placeCollisionBox(kr, "always", C, l, p, le, ne, T, R.predicate, He, new o.P(0, 0)).box, offscreen: !1, placeable: !1 }), Hs;
                };
                Zr(() => Ur(kr, ft.iconBox, o.ah.horizontal), () => {
                  const sr = ft.verticalTextBox;
                  return u.allowVerticalPlacement && (!Ti || !Ti.placeable) && Ue.numVerticalGlyphVertices > 0 && sr ? Ur(sr, ft.verticalIconBox, o.ah.vertical) : { box: null, occluded: !0, offscreen: null };
                }), Ti && (Wt = Ti.placeable, si = Ti.offscreen);
                const zr = nr(Ti && Ti.placeable);
                if (!Wt && this.prevPlacement) {
                  const sr = this.prevPlacement.variableOffsets[Ue.crossTileID];
                  sr && (this.variableOffsets[Ue.crossTileID] = sr, this.markUsedJustification(u, sr.anchor, Ue, zr));
                }
              }
            }
            if (Wi = Ti, Wt = Wi && Wi.placeable, si = Wi && Wi.offscreen, Ue.useRuntimeCollisionCircles) {
              const nr = u.text.placedSymbolArray.get(Ue.centerJustifiedTextSymbolIndex), Zr = o.ai(u.textSizeData, N, nr), Tn = m.get("text-padding");
              bi = this.collisionIndex.placeCollisionCircles(H, nr, u.lineVertexArray, u.glyphOffsetArray, Zr, l, p, b, P, c, le, R.predicate, Ue.collisionCircleDiameter, Tn, T, He), bi.circles.length && bi.collisionDetected && !c && o.w("Collisions detected, but collision boxes are not shown"), Wt = Q || bi.circles.length > 0 && !bi.collisionDetected, si = si && bi.offscreen;
            }
            if (ft.iconFeatureIndex && (Tr = ft.iconFeatureIndex), ft.iconBox) {
              const nr = (Zr) => this.collisionIndex.placeCollisionBox(Zr, ue, C, l, p, le, ne, s, R.predicate, He, De && qi ? qi : void 0);
              Ni && Ni.placeable && ft.verticalIconBox ? (Gi = nr(ft.verticalIconBox), ci = Gi.placeable) : (Gi = nr(ft.iconBox), ci = Gi.placeable), si = si && Gi.offscreen;
            }
            const qr = G || Ue.numHorizontalGlyphVertices === 0 && Ue.numVerticalGlyphVertices === 0, In = ie || Ue.numIconVertices === 0;
            qr || In ? In ? qr || (ci = ci && Wt) : Wt = ci && Wt : ci = Wt = ci && Wt;
            const Lr = ci && Gi.placeable;
            if (Wt && Wi.placeable && this.collisionIndex.insertCollisionBox(Wi.box, H, m.get("text-ignore-placement"), u.bucketInstanceId, Ni && Ni.placeable && ur ? ur : fr, R.ID), Lr && this.collisionIndex.insertCollisionBox(Gi.box, ue, m.get("icon-ignore-placement"), u.bucketInstanceId, Tr, R.ID), bi && Wt && this.collisionIndex.insertCollisionCircles(bi.circles, H, m.get("text-ignore-placement"), u.bucketInstanceId, fr, R.ID), c && this.storeCollisionData(u.bucketInstanceId, Tt, ft, Wi, Gi, bi), Ue.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            if (u.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[Ue.crossTileID] = new Ei(Wt || Te, ci || qe, si || u.justReloaded), n[Ue.crossTileID] = !0;
          };
          if (Ne) {
            if (t.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
            const Ue = u.getSortedSymbolIndexes(this.transform.angle);
            for (let ft = Ue.length - 1; ft >= 0; --ft) {
              const Tt = Ue[ft];
              vt(u.symbolInstances.get(Tt), u.collisionArrays[Tt], Tt);
            }
          } else for (let Ue = t.symbolInstanceStart; Ue < t.symbolInstanceEnd; Ue++) vt(u.symbolInstances.get(Ue), u.collisionArrays[Ue], Ue);
          if (c && u.bucketInstanceId in this.collisionCircleArrays) {
            const Ue = this.collisionCircleArrays[u.bucketInstanceId];
            o.as(Ue.invProjMatrix, l), Ue.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          u.justReloaded = !1;
        }
        storeCollisionData(t, n, c, u, m, T) {
          if (c.textBox || c.iconBox) {
            let s, l;
            this.collisionBoxArrays.has(t) ? s = this.collisionBoxArrays.get(t) : (s = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(t, s)), s.has(n) ? l = s.get(n) : (l = { text: null, icon: null }, s.set(n, l)), c.textBox && (l.text = u.box), c.iconBox && (l.icon = m.box);
          }
          if (T) {
            let s = this.collisionCircleArrays[t];
            s === void 0 && (s = this.collisionCircleArrays[t] = new Ui());
            for (let l = 0; l < T.circles.length; l += 4) s.circles.push(T.circles[l + 0]), s.circles.push(T.circles[l + 1]), s.circles.push(T.circles[l + 2]), s.circles.push(T.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(t, n, c, u) {
          let m;
          m = u === o.ah.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[o.at(n)];
          const T = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex];
          for (const s of T) s >= 0 && (t.text.placedSymbolArray.get(s).crossTileID = m >= 0 && s !== m ? 0 : c.crossTileID);
        }
        markUsedOrientation(t, n, c) {
          const u = n === o.ah.horizontal || n === o.ah.horizontalOnly ? n : 0, m = n === o.ah.vertical ? n : 0, T = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex];
          for (const s of T) t.text.placedSymbolArray.get(s).placedOrientation = u;
          c.verticalPlacedTextSymbolIndex && (t.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = m);
        }
        commit(t) {
          this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const n = this.prevPlacement;
          let c = !1;
          this.prevZoomAdjustment = n ? n.zoomAdjustment(this.transform.zoom) : 0;
          const u = n ? n.symbolFadeChange(t) : 1, m = n ? n.opacities : {}, T = n ? n.variableOffsets : {}, s = n ? n.placedOrientations : {};
          for (const l in this.placements) {
            const p = this.placements[l], b = m[l];
            b ? (this.opacities[l] = new Ii(b, u, p.text, p.icon), c = c || p.text !== b.text.placed || p.icon !== b.icon.placed) : (this.opacities[l] = new Ii(null, u, p.text, p.icon, p.skipFade), c = c || p.text || p.icon);
          }
          for (const l in m) {
            const p = m[l];
            if (!this.opacities[l]) {
              const b = new Ii(p, u, !1, !1);
              b.isHidden() || (this.opacities[l] = b, c = c || p.text.placed || p.icon.placed);
            }
          }
          for (const l in T) this.variableOffsets[l] || !this.opacities[l] || this.opacities[l].isHidden() || (this.variableOffsets[l] = T[l]);
          for (const l in s) this.placedOrientations[l] || !this.opacities[l] || this.opacities[l].isHidden() || (this.placedOrientations[l] = s[l]);
          if (n && n.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
          c ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = n ? n.lastPlacementChangeTime : t);
        }
        updateLayerOpacities(t, n) {
          const c = {};
          for (const u of n) {
            const m = u.getBucket(t);
            m && u.latestFeatureIndex && t.id === m.layerIds[0] && this.updateBucketOpacities(m, u.tileID, c, u.collisionBoxArray);
          }
        }
        updateBucketOpacities(t, n, c, u) {
          t.hasTextData() && (t.text.opacityVertexArray.clear(), t.text.hasVisibleVertices = !1), t.hasIconData() && (t.icon.opacityVertexArray.clear(), t.icon.hasVisibleVertices = !1), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
          const m = t.layers[0], T = m.layout, s = new Ii(null, 0, !1, !1, !0), l = T.get("text-allow-overlap"), p = T.get("icon-allow-overlap"), b = m._unevaluatedLayout.hasValue("text-variable-anchor") || m._unevaluatedLayout.hasValue("text-variable-anchor-offset"), P = T.get("text-rotation-alignment") === "map", C = T.get("text-pitch-alignment") === "map", E = T.get("icon-text-fit") !== "none", z = new Ii(null, 0, l && (p || !t.hasIconData() || T.get("icon-optional")), p && (l || !t.hasTextData() || T.get("text-optional")), !0);
          !t.collisionArrays && u && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(u);
          const N = (G, ie, H) => {
            for (let Q = 0; Q < ie / 4; Q++) G.opacityVertexArray.emplaceBack(H);
            G.hasVisibleVertices = G.hasVisibleVertices || H !== Cs;
          }, R = this.collisionBoxArrays.get(t.bucketInstanceId);
          for (let G = 0; G < t.symbolInstances.length; G++) {
            const ie = t.symbolInstances.get(G), { numHorizontalGlyphVertices: H, numVerticalGlyphVertices: Q, crossTileID: ue } = ie;
            let ce = this.opacities[ue];
            c[ue] ? ce = s : ce || (ce = z, this.opacities[ue] = ce), c[ue] = !0;
            const ne = ie.numIconVertices > 0, le = this.placedOrientations[ie.crossTileID], De = le === o.ah.vertical, Ne = le === o.ah.horizontal || le === o.ah.horizontalOnly;
            if (H > 0 || Q > 0) {
              const qe = Jr(ce.text);
              N(t.text, H, De ? Cs : qe), N(t.text, Q, Ne ? Cs : qe);
              const He = ce.text.isHidden();
              [ie.rightJustifiedTextSymbolIndex, ie.centerJustifiedTextSymbolIndex, ie.leftJustifiedTextSymbolIndex].forEach((ft) => {
                ft >= 0 && (t.text.placedSymbolArray.get(ft).hidden = He || De ? 1 : 0);
              }), ie.verticalPlacedTextSymbolIndex >= 0 && (t.text.placedSymbolArray.get(ie.verticalPlacedTextSymbolIndex).hidden = He || Ne ? 1 : 0);
              const vt = this.variableOffsets[ie.crossTileID];
              vt && this.markUsedJustification(t, vt.anchor, ie, le);
              const Ue = this.placedOrientations[ie.crossTileID];
              Ue && (this.markUsedJustification(t, "left", ie, Ue), this.markUsedOrientation(t, Ue, ie));
            }
            if (ne) {
              const qe = Jr(ce.icon), He = !(E && ie.verticalPlacedIconSymbolIndex && De);
              ie.placedIconSymbolIndex >= 0 && (N(t.icon, ie.numIconVertices, He ? qe : Cs), t.icon.placedSymbolArray.get(ie.placedIconSymbolIndex).hidden = ce.icon.isHidden()), ie.verticalPlacedIconSymbolIndex >= 0 && (N(t.icon, ie.numVerticalIconVertices, He ? Cs : qe), t.icon.placedSymbolArray.get(ie.verticalPlacedIconSymbolIndex).hidden = ce.icon.isHidden());
            }
            const Te = R && R.has(G) ? R.get(G) : { text: null, icon: null };
            if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
              const qe = t.collisionArrays[G];
              if (qe) {
                let He = new o.P(0, 0);
                if (qe.textBox || qe.verticalTextBox) {
                  let vt = !0;
                  if (b) {
                    const Ue = this.variableOffsets[ue];
                    Ue ? (He = er(Ue.anchor, Ue.width, Ue.height, Ue.textOffset, Ue.textBoxScale), P && He._rotate(C ? this.transform.angle : -this.transform.angle)) : vt = !1;
                  }
                  if (qe.textBox || qe.verticalTextBox) {
                    let Ue;
                    qe.textBox && (Ue = De), qe.verticalTextBox && (Ue = Ne), Nr(t.textCollisionBox.collisionVertexArray, ce.text.placed, !vt || Ue, Te.text, He.x, He.y);
                  }
                }
                if (qe.iconBox || qe.verticalIconBox) {
                  const vt = !!(!Ne && qe.verticalIconBox);
                  let Ue;
                  qe.iconBox && (Ue = vt), qe.verticalIconBox && (Ue = !vt), Nr(t.iconCollisionBox.collisionVertexArray, ce.icon.placed, Ue, Te.icon, E ? He.x : 0, E ? He.y : 0);
                }
              }
            }
          }
          if (t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.text.opacityVertexArray.length !== t.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${t.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t.text.layoutVertexArray.length}) / 4`);
          if (t.icon.opacityVertexArray.length !== t.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${t.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t.icon.layoutVertexArray.length}) / 4`);
          if (t.bucketInstanceId in this.collisionCircleArrays) {
            const G = this.collisionCircleArrays[t.bucketInstanceId];
            t.placementInvProjMatrix = G.invProjMatrix, t.placementViewportMatrix = G.viewportMatrix, t.collisionCircleArray = G.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
          }
        }
        symbolFadeChange(t) {
          return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(t) {
          return Math.max(0, (this.transform.zoom - t) / 1.5);
        }
        hasTransitions(t) {
          return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(t, n) {
          const c = this.zoomAtLastRecencyCheck === n ? 1 - this.zoomAdjustment(n) : 1;
          return this.zoomAtLastRecencyCheck = n, this.commitTime + this.fadeDuration * c > t;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function Nr(f, t, n, c, u, m) {
        c && c.length !== 0 || (c = [0, 0, 0, 0]);
        const T = c[0] - Nt, s = c[1] - Nt, l = c[2] - Nt, p = c[3] - Nt;
        f.emplaceBack(t ? 1 : 0, n ? 1 : 0, u || 0, m || 0, T, s), f.emplaceBack(t ? 1 : 0, n ? 1 : 0, u || 0, m || 0, l, s), f.emplaceBack(t ? 1 : 0, n ? 1 : 0, u || 0, m || 0, l, p), f.emplaceBack(t ? 1 : 0, n ? 1 : 0, u || 0, m || 0, T, p);
      }
      const cr = Math.pow(2, 25), Jn = Math.pow(2, 24), Qo = Math.pow(2, 17), Ri = Math.pow(2, 16), Co = Math.pow(2, 9), ea = Math.pow(2, 8), Yr = Math.pow(2, 1);
      function Jr(f) {
        if (f.opacity === 0 && !f.placed) return 0;
        if (f.opacity === 1 && f.placed) return 4294967295;
        const t = f.placed ? 1 : 0, n = Math.floor(127 * f.opacity);
        return n * cr + t * Jn + n * Qo + t * Ri + n * Co + t * ea + n * Yr + t;
      }
      const Cs = 0;
      function Kr() {
        return { isOccluded: (f, t, n) => !1, getPitchedTextCorrection: (f, t, n) => 1, get useSpecialProjectionForSymbols() {
          return !1;
        }, projectTileCoordinates(f, t, n, c) {
          throw new Error("Not implemented.");
        }, translatePosition: (f, t, n, c) => function(u, m, T, s, l = !1) {
          if (!T[0] && !T[1]) return [0, 0];
          const p = l ? s === "map" ? u.angle : 0 : s === "viewport" ? -u.angle : 0;
          if (p) {
            const b = Math.sin(p), P = Math.cos(p);
            T = [T[0] * P - T[1] * b, T[0] * b + T[1] * P];
          }
          return [l ? T[0] : ti(m, T[0], u.zoom), l ? T[1] : ti(m, T[1], u.zoom)];
        }(f, t, n, c), getCircleRadiusCorrection: (f) => 1 };
      }
      class sn {
        constructor(t) {
          this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && !t.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(t, n, c, u, m) {
          const T = this._bucketParts;
          for (; this._currentTileIndex < t.length; ) if (n.getBucketParts(T, u, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, m()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, T.sort((s, l) => s.sortKey - l.sortKey)); this._currentPartIndex < T.length; ) if (n.placeLayerBucketPart(T[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, m()) return !0;
          return !1;
        }
      }
      class el {
        constructor(t, n, c, u, m, T, s, l) {
          this.placement = new Mr(t, Kr(), n, T, s, l), this._currentPlacementIndex = c.length - 1, this._forceFullPlacement = u, this._showCollisionBoxes = m, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t, n, c) {
          const u = q.now(), m = () => !this._forceFullPlacement && q.now() - u > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const T = n[t[this._currentPlacementIndex]], s = this.placement.collisionIndex.transform.zoom;
            if (T.type === "symbol" && (!T.minzoom || T.minzoom <= s) && (!T.maxzoom || T.maxzoom > s)) {
              if (this._inProgressLayer || (this._inProgressLayer = new sn(T)), this._inProgressLayer.continuePlacement(c[T.source], this.placement, this._showCollisionBoxes, T, m)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(t) {
          return this.placement.commit(t), this.placement;
        }
      }
      const cn = 512 / o.W / 2;
      class yr {
        constructor(t, n, c) {
          this.tileID = t, this.bucketInstanceId = c, this._symbolsByKey = {};
          const u = /* @__PURE__ */ new Map();
          for (let m = 0; m < n.length; m++) {
            const T = n.get(m), s = T.key, l = u.get(s);
            l ? l.push(T) : u.set(s, [T]);
          }
          for (const [m, T] of u) {
            const s = { positions: T.map((l) => ({ x: Math.floor(l.anchorX * cn), y: Math.floor(l.anchorY * cn) })), crossTileIDs: T.map((l) => l.crossTileID) };
            if (s.positions.length > 128) {
              const l = new o.av(s.positions.length, 16, Uint16Array);
              for (const { x: p, y: b } of s.positions) l.add(p, b);
              l.finish(), delete s.positions, s.index = l;
            }
            this._symbolsByKey[m] = s;
          }
        }
        getScaledCoordinates(t, n) {
          const { x: c, y: u, z: m } = this.tileID.canonical, { x: T, y: s, z: l } = n.canonical, p = cn / Math.pow(2, l - m), b = (s * o.W + t.anchorY) * p, P = u * o.W * cn;
          return { x: Math.floor((T * o.W + t.anchorX) * p - c * o.W * cn), y: Math.floor(b - P) };
        }
        findMatches(t, n, c) {
          const u = this.tileID.canonical.z < n.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - n.canonical.z);
          for (let m = 0; m < t.length; m++) {
            const T = t.get(m);
            if (T.crossTileID) continue;
            const s = this._symbolsByKey[T.key];
            if (!s) continue;
            const l = this.getScaledCoordinates(T, n);
            if (s.index) {
              const p = s.index.range(l.x - u, l.y - u, l.x + u, l.y + u).sort();
              for (const b of p) {
                const P = s.crossTileIDs[b];
                if (!c[P]) {
                  c[P] = !0, T.crossTileID = P;
                  break;
                }
              }
            } else if (s.positions) for (let p = 0; p < s.positions.length; p++) {
              const b = s.positions[p], P = s.crossTileIDs[p];
              if (Math.abs(b.x - l.x) <= u && Math.abs(b.y - l.y) <= u && !c[P]) {
                c[P] = !0, T.crossTileID = P;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: t }) => t);
        }
      }
      class tr {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class us {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(t) {
          const n = Math.round((t - this.lng) / 360);
          if (n !== 0) for (const c in this.indexes) {
            const u = this.indexes[c], m = {};
            for (const T in u) {
              const s = u[T];
              s.tileID = s.tileID.unwrapTo(s.tileID.wrap + n), m[s.tileID.key] = s;
            }
            this.indexes[c] = m;
          }
          this.lng = t;
        }
        addBucket(t, n, c) {
          if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
            if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === n.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
          }
          for (let m = 0; m < n.symbolInstances.length; m++) n.symbolInstances.get(m).crossTileID = 0;
          this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});
          const u = this.usedCrossTileIDs[t.overscaledZ];
          for (const m in this.indexes) {
            const T = this.indexes[m];
            if (Number(m) > t.overscaledZ) for (const s in T) {
              const l = T[s];
              l.tileID.isChildOf(t) && l.findMatches(n.symbolInstances, t, u);
            }
            else {
              const s = T[t.scaledTo(Number(m)).key];
              s && s.findMatches(n.symbolInstances, t, u);
            }
          }
          for (let m = 0; m < n.symbolInstances.length; m++) {
            const T = n.symbolInstances.get(m);
            T.crossTileID || (T.crossTileID = c.generate(), u[T.crossTileID] = !0);
          }
          return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new yr(t, n.symbolInstances, n.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(t, n) {
          for (const c of n.getCrossTileIDsLists()) for (const u of c) delete this.usedCrossTileIDs[t][u];
        }
        removeStaleBuckets(t) {
          let n = !1;
          for (const c in this.indexes) {
            const u = this.indexes[c];
            for (const m in u) t[u[m].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, u[m]), delete u[m], n = !0);
          }
          return n;
        }
      }
      class ir {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new tr(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(t, n, c) {
          let u = this.layerIndexes[t.id];
          u === void 0 && (u = this.layerIndexes[t.id] = new us());
          let m = !1;
          const T = {};
          u.handleWrapJump(c);
          for (const s of n) {
            const l = s.getBucket(t);
            l && t.id === l.layerIds[0] && (l.bucketInstanceId || (l.bucketInstanceId = ++this.maxBucketInstanceId), u.addBucket(s.tileID, l, this.crossTileIDs) && (m = !0), T[l.bucketInstanceId] = !0);
          }
          return u.removeStaleBuckets(T) && (m = !0), m;
        }
        pruneUnusedLayers(t) {
          const n = {};
          t.forEach((c) => {
            n[c] = !0;
          });
          for (const c in this.layerIndexes) n[c] || delete this.layerIndexes[c];
        }
      }
      const ds = (f, t) => o.t(f, t && t.filter((n) => n.identifier !== "source.canvas")), an = o.aw();
      class Ga extends o.E {
        constructor(t, n = {}) {
          super(), this._rtlPluginLoaded = () => {
            for (const c in this.sourceCaches) {
              const u = this.sourceCaches[c].getSource().type;
              u !== "vector" && u !== "geojson" || this.sourceCaches[c].reload();
            }
          }, this.map = t, this.dispatcher = new We(Ve(), t._getMapId()), this.dispatcher.registerMessageHandler("GG", (c, u) => this.getGlyphs(c, u)), this.dispatcher.registerMessageHandler("GI", (c, u) => this.getImages(c, u)), this.imageManager = new Ie(), this.imageManager.setEventedParent(this), this.glyphManager = new rt(t._requestManager, n.localIdeographFontFamily), this.lineAtlas = new wt(256, 512), this.crossTileSymbolIndex = new ir(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.ax(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", o.ay()), Jt().on(wi, this._rtlPluginLoaded), this.on("data", (c) => {
            if (c.dataType !== "source" || c.sourceDataType !== "metadata") return;
            const u = this.sourceCaches[c.sourceId];
            if (!u) return;
            const m = u.getSource();
            if (m && m.vectorLayerIds) for (const T in this._layers) {
              const s = this._layers[T];
              s.source === m.id && this._validateLayer(s);
            }
          });
        }
        loadURL(t, n = {}, c) {
          this.fire(new o.k("dataloading", { dataType: "style" })), n.validate = typeof n.validate != "boolean" || n.validate;
          const u = this.map._requestManager.transformRequest(t, "Style");
          this._loadStyleRequest = new AbortController(), o.h(u, this._loadStyleRequest).then((m) => {
            this._loadStyleRequest = null, this._load(m.data, n, c);
          }).catch((m) => {
            this._loadStyleRequest = null, m && this.fire(new o.j(m));
          });
        }
        loadJSON(t, n = {}, c) {
          this.fire(new o.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), q.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, n.validate = n.validate !== !1, this._load(t, n, c);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new o.k("dataloading", { dataType: "style" })), this._load(an, { validate: !1 });
        }
        _load(t, n, c) {
          var u;
          const m = n.transformStyle ? n.transformStyle(c, t) : t;
          if (!n.validate || !ds(this, o.x(m))) {
            this._loaded = !0, this.stylesheet = m;
            for (const T in m.sources) this.addSource(T, m.sources[T], { validate: !1 });
            m.sprite ? this._loadSprite(m.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(m.glyphs), this._createLayers(), this.light = new nt(this.stylesheet.light), this.map.setTerrain((u = this.stylesheet.terrain) !== null && u !== void 0 ? u : null), this.fire(new o.k("data", { dataType: "style" })), this.fire(new o.k("style.load"));
          }
        }
        _createLayers() {
          const t = o.az(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", t), this._order = t.map((n) => n.id), this._layers = {}, this._serializedLayers = null;
          for (const n of t) {
            const c = o.aA(n);
            c.setEventedParent(this, { layer: { id: n.id } }), this._layers[n.id] = c;
          }
        }
        _loadSprite(t, n = !1, c = void 0) {
          let u;
          this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(m, T, s, l) {
            return o._(this, void 0, void 0, function* () {
              const p = dt(m), b = s > 1 ? "@2x" : "", P = {}, C = {};
              for (const { id: E, url: z } of p) {
                const N = T.transformRequest(at(z, b, ".json"), "SpriteJSON");
                P[E] = o.h(N, l);
                const R = T.transformRequest(at(z, b, ".png"), "SpriteImage");
                C[E] = Fe.getImage(R, l);
              }
              return yield Promise.all([...Object.values(P), ...Object.values(C)]), function(E, z) {
                return o._(this, void 0, void 0, function* () {
                  const N = {};
                  for (const R in E) {
                    N[R] = {};
                    const G = q.getImageCanvasContext((yield z[R]).data), ie = (yield E[R]).data;
                    for (const H in ie) {
                      const { width: Q, height: ue, x: ce, y: ne, sdf: le, pixelRatio: De, stretchX: Ne, stretchY: Te, content: qe, textFitWidth: He, textFitHeight: vt } = ie[H];
                      N[R][H] = { data: null, pixelRatio: De, sdf: le, stretchX: Ne, stretchY: Te, content: qe, textFitWidth: He, textFitHeight: vt, spriteData: { width: Q, height: ue, x: ce, y: ne, context: G } };
                    }
                  }
                  return N;
                });
              }(P, C);
            });
          }(t, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((m) => {
            if (this._spriteRequest = null, m) for (const T in m) {
              this._spritesImagesIds[T] = [];
              const s = this._spritesImagesIds[T] ? this._spritesImagesIds[T].filter((l) => !(l in m)) : [];
              for (const l of s) this.imageManager.removeImage(l), this._changedImages[l] = !0;
              for (const l in m[T]) {
                const p = T === "default" ? l : `${T}:${l}`;
                this._spritesImagesIds[T].push(p), p in this.imageManager.images ? this.imageManager.updateImage(p, m[T][l], !1) : this.imageManager.addImage(p, m[T][l]), n && (this._changedImages[p] = !0);
              }
            }
          }).catch((m) => {
            this._spriteRequest = null, u = m, this.fire(new o.j(u));
          }).finally(() => {
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), n && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" })), c && c(u);
          });
        }
        _unloadSprite() {
          for (const t of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t), this._changedImages[t] = !0;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" }));
        }
        _validateLayer(t) {
          const n = this.sourceCaches[t.source];
          if (!n) return;
          const c = t.sourceLayer;
          if (!c) return;
          const u = n.getSource();
          (u.type === "geojson" || u.vectorLayerIds && u.vectorLayerIds.indexOf(c) === -1) && this.fire(new o.j(new Error(`Source layer "${c}" does not exist on source "${u.id}" as specified by style layer "${t.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
          for (const t in this.sourceCaches) if (!this.sourceCaches[t].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(t) {
          const n = this._serializedAllLayers();
          if (!t || t.length === 0) return Object.values(n);
          const c = [];
          for (const u of t) n[u] && c.push(n[u]);
          return c;
        }
        _serializedAllLayers() {
          let t = this._serializedLayers;
          if (t) return t;
          t = this._serializedLayers = {};
          const n = Object.keys(this._layers);
          for (const c of n) {
            const u = this._layers[c];
            u.type !== "custom" && (t[c] = u.serialize());
          }
          return t;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition()) return !0;
          for (const t in this.sourceCaches) if (this.sourceCaches[t].hasTransition()) return !0;
          for (const t in this._layers) if (this._layers[t].hasTransition()) return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading.");
        }
        update(t) {
          if (!this._loaded) return;
          const n = this._changed;
          if (n) {
            const u = Object.keys(this._updatedLayers), m = Object.keys(this._removedLayers);
            (u.length || m.length) && this._updateWorkerLayers(u, m);
            for (const T in this._updatedSources) {
              const s = this._updatedSources[T];
              if (s === "reload") this._reloadSource(T);
              else {
                if (s !== "clear") throw new Error(`Invalid action ${s}`);
                this._clearSource(T);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const T in this._updatedPaintProps) this._layers[T].updateTransitions(t);
            this.light.updateTransitions(t), this._resetUpdates();
          }
          const c = {};
          for (const u in this.sourceCaches) {
            const m = this.sourceCaches[u];
            c[u] = m.used, m.used = !1;
          }
          for (const u of this._order) {
            const m = this._layers[u];
            m.recalculate(t, this._availableImages), !m.isHidden(t.zoom) && m.source && (this.sourceCaches[m.source].used = !0);
          }
          for (const u in c) {
            const m = this.sourceCaches[u];
            !!c[u] != !!m.used && m.fire(new o.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: u }));
          }
          this.light.recalculate(t), this.z = t.zoom, n && this.fire(new o.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const t = Object.keys(this._changedImages);
          if (t.length) {
            for (const n in this.sourceCaches) this.sourceCaches[n].reloadTilesForDependencies(["icons", "patterns"], t);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const t in this.sourceCaches) this.sourceCaches[t].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(t, n) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t), removedIds: n });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
        }
        setState(t, n = {}) {
          var c;
          this._checkLoaded();
          const u = this.serialize();
          if (t = n.transformStyle ? n.transformStyle(u, t) : t, ((c = n.validate) === null || c === void 0 || c) && ds(this, o.x(t))) return !1;
          (t = o.aB(t)).layers = o.az(t.layers);
          const m = o.aC(u, t), T = this._getOperationsToPerform(m);
          if (T.unimplemented.length > 0) throw new Error(`Unimplemented: ${T.unimplemented.join(", ")}.`);
          if (T.operations.length === 0) return !1;
          for (const s of T.operations) s();
          return this.stylesheet = t, this._serializedLayers = null, !0;
        }
        _getOperationsToPerform(t) {
          const n = [], c = [];
          for (const u of t) switch (u.command) {
            case "setCenter":
            case "setZoom":
            case "setBearing":
            case "setPitch":
              continue;
            case "addLayer":
              n.push(() => this.addLayer.apply(this, u.args));
              break;
            case "removeLayer":
              n.push(() => this.removeLayer.apply(this, u.args));
              break;
            case "setPaintProperty":
              n.push(() => this.setPaintProperty.apply(this, u.args));
              break;
            case "setLayoutProperty":
              n.push(() => this.setLayoutProperty.apply(this, u.args));
              break;
            case "setFilter":
              n.push(() => this.setFilter.apply(this, u.args));
              break;
            case "addSource":
              n.push(() => this.addSource.apply(this, u.args));
              break;
            case "removeSource":
              n.push(() => this.removeSource.apply(this, u.args));
              break;
            case "setLayerZoomRange":
              n.push(() => this.setLayerZoomRange.apply(this, u.args));
              break;
            case "setLight":
              n.push(() => this.setLight.apply(this, u.args));
              break;
            case "setGeoJSONSourceData":
              n.push(() => this.setGeoJSONSourceData.apply(this, u.args));
              break;
            case "setGlyphs":
              n.push(() => this.setGlyphs.apply(this, u.args));
              break;
            case "setSprite":
              n.push(() => this.setSprite.apply(this, u.args));
              break;
            case "setTerrain":
              n.push(() => this.map.setTerrain.apply(this, u.args));
              break;
            case "setTransition":
              n.push(() => {
              });
              break;
            default:
              c.push(u.command);
          }
          return { operations: n, unimplemented: c };
        }
        addImage(t, n) {
          if (this.getImage(t)) return this.fire(new o.j(new Error(`An image named "${t}" already exists.`)));
          this.imageManager.addImage(t, n), this._afterImageUpdated(t);
        }
        updateImage(t, n) {
          this.imageManager.updateImage(t, n);
        }
        getImage(t) {
          return this.imageManager.getImage(t);
        }
        removeImage(t) {
          if (!this.getImage(t)) return this.fire(new o.j(new Error(`An image named "${t}" does not exist.`)));
          this.imageManager.removeImage(t), this._afterImageUpdated(t);
        }
        _afterImageUpdated(t) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(t, n, c = {}) {
          if (this._checkLoaded(), this.sourceCaches[t] !== void 0) throw new Error(`Source "${t}" already exists.`);
          if (!n.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(n).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(n.type) >= 0 && this._validate(o.x.source, `sources.${t}`, n, null, c)) return;
          this.map && this.map._collectResourceTiming && (n.collectResourceTiming = !0);
          const u = this.sourceCaches[t] = new lt(t, n, this.dispatcher);
          u.style = this, u.setEventedParent(this, () => ({ isSourceLoaded: u.loaded(), source: u.serialize(), sourceId: t })), u.onAdd(this.map), this._changed = !0;
        }
        removeSource(t) {
          if (this._checkLoaded(), this.sourceCaches[t] === void 0) throw new Error("There is no source with this ID");
          for (const c in this._layers) if (this._layers[c].source === t) return this.fire(new o.j(new Error(`Source "${t}" cannot be removed while layer "${c}" is using it.`)));
          const n = this.sourceCaches[t];
          delete this.sourceCaches[t], delete this._updatedSources[t], n.fire(new o.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: t })), n.setEventedParent(null), n.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(t, n) {
          if (this._checkLoaded(), this.sourceCaches[t] === void 0) throw new Error(`There is no source with this ID=${t}`);
          const c = this.sourceCaches[t].getSource();
          if (c.type !== "geojson") throw new Error(`geojsonSource.type is ${c.type}, which is !== 'geojson`);
          c.setData(n), this._changed = !0;
        }
        getSource(t) {
          return this.sourceCaches[t] && this.sourceCaches[t].getSource();
        }
        addLayer(t, n, c = {}) {
          this._checkLoaded();
          const u = t.id;
          if (this.getLayer(u)) return void this.fire(new o.j(new Error(`Layer "${u}" already exists on this map.`)));
          let m;
          if (t.type === "custom") {
            if (ds(this, o.aD(t))) return;
            m = o.aA(t);
          } else {
            if ("source" in t && typeof t.source == "object" && (this.addSource(u, t.source), t = o.aB(t), t = o.e(t, { source: u })), this._validate(o.x.layer, `layers.${u}`, t, { arrayIndex: -1 }, c)) return;
            m = o.aA(t), this._validateLayer(m), m.setEventedParent(this, { layer: { id: u } });
          }
          const T = n ? this._order.indexOf(n) : this._order.length;
          if (n && T === -1) this.fire(new o.j(new Error(`Cannot add layer "${u}" before non-existing layer "${n}".`)));
          else {
            if (this._order.splice(T, 0, u), this._layerOrderChanged = !0, this._layers[u] = m, this._removedLayers[u] && m.source && m.type !== "custom") {
              const s = this._removedLayers[u];
              delete this._removedLayers[u], s.type !== m.type ? this._updatedSources[m.source] = "clear" : (this._updatedSources[m.source] = "reload", this.sourceCaches[m.source].pause());
            }
            this._updateLayer(m), m.onAdd && m.onAdd(this.map);
          }
        }
        moveLayer(t, n) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new o.j(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));
          if (t === n) return;
          const c = this._order.indexOf(t);
          this._order.splice(c, 1);
          const u = n ? this._order.indexOf(n) : this._order.length;
          n && u === -1 ? this.fire(new o.j(new Error(`Cannot move layer "${t}" before non-existing layer "${n}".`))) : (this._order.splice(u, 0, t), this._layerOrderChanged = !0);
        }
        removeLayer(t) {
          this._checkLoaded();
          const n = this._layers[t];
          if (!n) return void this.fire(new o.j(new Error(`Cannot remove non-existing layer "${t}".`)));
          n.setEventedParent(null);
          const c = this._order.indexOf(t);
          this._order.splice(c, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = n, delete this._layers[t], this._serializedLayers && delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], n.onRemove && n.onRemove(this.map);
        }
        getLayer(t) {
          return this._layers[t];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(t) {
          return t in this._layers;
        }
        setLayerZoomRange(t, n, c) {
          this._checkLoaded();
          const u = this.getLayer(t);
          u ? u.minzoom === n && u.maxzoom === c || (n != null && (u.minzoom = n), c != null && (u.maxzoom = c), this._updateLayer(u)) : this.fire(new o.j(new Error(`Cannot set the zoom range of non-existing layer "${t}".`)));
        }
        setFilter(t, n, c = {}) {
          this._checkLoaded();
          const u = this.getLayer(t);
          if (u) {
            if (!o.aE(u.filter, n)) return n == null ? (u.filter = void 0, void this._updateLayer(u)) : void (this._validate(o.x.filter, `layers.${u.id}.filter`, n, null, c) || (u.filter = o.aB(n), this._updateLayer(u)));
          } else this.fire(new o.j(new Error(`Cannot filter non-existing layer "${t}".`)));
        }
        getFilter(t) {
          return o.aB(this.getLayer(t).filter);
        }
        setLayoutProperty(t, n, c, u = {}) {
          this._checkLoaded();
          const m = this.getLayer(t);
          m ? o.aE(m.getLayoutProperty(n), c) || (m.setLayoutProperty(n, c, u), this._updateLayer(m)) : this.fire(new o.j(new Error(`Cannot style non-existing layer "${t}".`)));
        }
        getLayoutProperty(t, n) {
          const c = this.getLayer(t);
          if (c) return c.getLayoutProperty(n);
          this.fire(new o.j(new Error(`Cannot get style of non-existing layer "${t}".`)));
        }
        setPaintProperty(t, n, c, u = {}) {
          this._checkLoaded();
          const m = this.getLayer(t);
          m ? o.aE(m.getPaintProperty(n), c) || (m.setPaintProperty(n, c, u) && this._updateLayer(m), this._changed = !0, this._updatedPaintProps[t] = !0, this._serializedLayers = null) : this.fire(new o.j(new Error(`Cannot style non-existing layer "${t}".`)));
        }
        getPaintProperty(t, n) {
          return this.getLayer(t).getPaintProperty(n);
        }
        setFeatureState(t, n) {
          this._checkLoaded();
          const c = t.source, u = t.sourceLayer, m = this.sourceCaches[c];
          if (m === void 0) return void this.fire(new o.j(new Error(`The source '${c}' does not exist in the map's style.`)));
          const T = m.getSource().type;
          T === "geojson" && u ? this.fire(new o.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : T !== "vector" || u ? (t.id === void 0 && this.fire(new o.j(new Error("The feature id parameter must be provided."))), m.setFeatureState(u, t.id, n)) : this.fire(new o.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(t, n) {
          this._checkLoaded();
          const c = t.source, u = this.sourceCaches[c];
          if (u === void 0) return void this.fire(new o.j(new Error(`The source '${c}' does not exist in the map's style.`)));
          const m = u.getSource().type, T = m === "vector" ? t.sourceLayer : void 0;
          m !== "vector" || T ? n && typeof t.id != "string" && typeof t.id != "number" ? this.fire(new o.j(new Error("A feature id is required to remove its specific state property."))) : u.removeFeatureState(T, t.id, n) : this.fire(new o.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(t) {
          this._checkLoaded();
          const n = t.source, c = t.sourceLayer, u = this.sourceCaches[n];
          if (u !== void 0) return u.getSource().type !== "vector" || c ? (t.id === void 0 && this.fire(new o.j(new Error("The feature id parameter must be provided."))), u.getFeatureState(c, t.id)) : void this.fire(new o.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new o.j(new Error(`The source '${n}' does not exist in the map's style.`)));
        }
        getTransition() {
          return o.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          const t = o.aF(this.sourceCaches, (m) => m.serialize()), n = this._serializeByIds(this._order), c = this.map.getTerrain() || void 0, u = this.stylesheet;
          return o.aG({ version: u.version, name: u.name, metadata: u.metadata, light: u.light, center: u.center, zoom: u.zoom, bearing: u.bearing, pitch: u.pitch, sprite: u.sprite, glyphs: u.glyphs, transition: u.transition, sources: t, layers: n, terrain: c }, (m) => m !== void 0);
        }
        _updateLayer(t) {
          this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && this.sourceCaches[t.source].getSource().type !== "raster" && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._serializedLayers = null, this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(t) {
          const n = (T) => this._layers[T].type === "fill-extrusion", c = {}, u = [];
          for (let T = this._order.length - 1; T >= 0; T--) {
            const s = this._order[T];
            if (n(s)) {
              c[s] = T;
              for (const l of t) {
                const p = l[s];
                if (p) for (const b of p) u.push(b);
              }
            }
          }
          u.sort((T, s) => s.intersectionZ - T.intersectionZ);
          const m = [];
          for (let T = this._order.length - 1; T >= 0; T--) {
            const s = this._order[T];
            if (n(s)) for (let l = u.length - 1; l >= 0; l--) {
              const p = u[l].feature;
              if (c[p.layer.id] < T) break;
              m.push(p), u.pop();
            }
            else for (const l of t) {
              const p = l[s];
              if (p) for (const b of p) m.push(b.feature);
            }
          }
          return m;
        }
        queryRenderedFeatures(t, n, c) {
          n && n.filter && this._validate(o.x.filter, "queryRenderedFeatures.filter", n.filter, null, n);
          const u = {};
          if (n && n.layers) {
            if (!Array.isArray(n.layers)) return this.fire(new o.j(new Error("parameters.layers must be an Array."))), [];
            for (const s of n.layers) {
              const l = this._layers[s];
              if (!l) return this.fire(new o.j(new Error(`The layer '${s}' does not exist in the map's style and cannot be queried for features.`))), [];
              u[l.source] = !0;
            }
          }
          const m = [];
          n.availableImages = this._availableImages;
          const T = this._serializedAllLayers();
          for (const s in this.sourceCaches) n.layers && !u[s] || m.push(xt(this.sourceCaches[s], this._layers, T, t, n, c));
          return this.placement && m.push(function(s, l, p, b, P, C, E) {
            const z = {}, N = C.queryRenderedSymbols(b), R = [];
            for (const G of Object.keys(N).map(Number)) R.push(E[G]);
            R.sort(kt);
            for (const G of R) {
              const ie = G.featureIndex.lookupSymbolFeatures(N[G.bucketInstanceId], l, G.bucketIndex, G.sourceLayerIndex, P.filter, P.layers, P.availableImages, s);
              for (const H in ie) {
                const Q = z[H] = z[H] || [], ue = ie[H];
                ue.sort((ce, ne) => {
                  const le = G.featureSortOrder;
                  if (le) {
                    const De = le.indexOf(ce.featureIndex);
                    return le.indexOf(ne.featureIndex) - De;
                  }
                  return ne.featureIndex - ce.featureIndex;
                });
                for (const ce of ue) Q.push(ce);
              }
            }
            for (const G in z) z[G].forEach((ie) => {
              const H = ie.feature, Q = p[s[G].source].getFeatureState(H.layer["source-layer"], H.id);
              H.source = H.layer.source, H.layer["source-layer"] && (H.sourceLayer = H.layer["source-layer"]), H.state = Q;
            });
            return z;
          }(this._layers, T, this.sourceCaches, t, n, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(m);
        }
        querySourceFeatures(t, n) {
          n && n.filter && this._validate(o.x.filter, "querySourceFeatures.filter", n.filter, null, n);
          const c = this.sourceCaches[t];
          return c ? function(u, m) {
            const T = u.getRenderableIds().map((p) => u.getTileByID(p)), s = [], l = {};
            for (let p = 0; p < T.length; p++) {
              const b = T[p], P = b.tileID.canonical.key;
              l[P] || (l[P] = !0, b.querySourceFeatures(s, m));
            }
            return s;
          }(c, n) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(t, n = {}) {
          this._checkLoaded();
          const c = this.light.getLight();
          let u = !1;
          for (const T in t) if (!o.aE(t[T], c[T])) {
            u = !0;
            break;
          }
          if (!u) return;
          const m = { now: q.now(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(t, n), this.light.updateTransitions(m);
        }
        _validate(t, n, c, u, m = {}) {
          return (!m || m.validate !== !1) && ds(this, t.call(o.x, o.e({ key: n, style: this.serialize(), value: c, styleSpec: o.v }, u)));
        }
        _remove(t = !0) {
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Jt().off(wi, this._rtlPluginLoaded);
          for (const n in this._layers) this._layers[n].setEventedParent(null);
          for (const n in this.sourceCaches) {
            const c = this.sourceCaches[n];
            c.setEventedParent(null), c.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), t && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t);
        }
        _clearSource(t) {
          this.sourceCaches[t].clearTiles();
        }
        _reloadSource(t) {
          this.sourceCaches[t].resume(), this.sourceCaches[t].reload();
        }
        _updateSources(t) {
          for (const n in this.sourceCaches) this.sourceCaches[n].update(t, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const t in this.sourceCaches) this._reloadSource(t);
        }
        _updatePlacement(t, n, c, u, m = !1) {
          let T = !1, s = !1;
          const l = {};
          for (const p of this._order) {
            const b = this._layers[p];
            if (b.type !== "symbol") continue;
            if (!l[b.source]) {
              const C = this.sourceCaches[b.source];
              l[b.source] = C.getRenderableIds(!0).map((E) => C.getTileByID(E)).sort((E, z) => z.tileID.overscaledZ - E.tileID.overscaledZ || (E.tileID.isLessThan(z.tileID) ? -1 : 1));
            }
            const P = this.crossTileSymbolIndex.addLayer(b, l[b.source], t.center.lng);
            T = T || P;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((m = m || this._layerOrderChanged || c === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(q.now(), t.zoom)) && (this.pauseablePlacement = new el(t, this.map.terrain, this._order, m, n, c, u, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(q.now()), s = !0), T && this.pauseablePlacement.placement.setStale()), s || T) for (const p of this._order) {
            const b = this._layers[p];
            b.type === "symbol" && this.placement.updateLayerOpacities(b, l[b.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(q.now());
        }
        _releaseSymbolFadeTiles() {
          for (const t in this.sourceCaches) this.sourceCaches[t].releaseSymbolFadeTiles();
        }
        getImages(t, n) {
          return o._(this, void 0, void 0, function* () {
            const c = yield this.imageManager.getImages(n.icons);
            this._updateTilesForChangedImages();
            const u = this.sourceCaches[n.source];
            return u && u.setDependencies(n.tileID.key, n.type, n.icons), c;
          });
        }
        getGlyphs(t, n) {
          return o._(this, void 0, void 0, function* () {
            const c = yield this.glyphManager.getGlyphs(n.stacks), u = this.sourceCaches[n.source];
            return u && u.setDependencies(n.tileID.key, n.type, [""]), c;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(t, n = {}) {
          this._checkLoaded(), t && this._validate(o.x.glyphs, "glyphs", t, null, n) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = t, this.glyphManager.entries = {}, this.glyphManager.setURL(t));
        }
        addSprite(t, n, c = {}, u) {
          this._checkLoaded();
          const m = [{ id: t, url: n }], T = [...dt(this.stylesheet.sprite), ...m];
          this._validate(o.x.sprite, "sprite", T, null, c) || (this.stylesheet.sprite = T, this._loadSprite(m, !0, u));
        }
        removeSprite(t) {
          this._checkLoaded();
          const n = dt(this.stylesheet.sprite);
          if (n.find((c) => c.id === t)) {
            if (this._spritesImagesIds[t]) for (const c of this._spritesImagesIds[t]) this.imageManager.removeImage(c), this._changedImages[c] = !0;
            n.splice(n.findIndex((c) => c.id === t), 1), this.stylesheet.sprite = n.length > 0 ? n : void 0, delete this._spritesImagesIds[t], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" }));
          } else this.fire(new o.j(new Error(`Sprite "${t}" doesn't exists on this map.`)));
        }
        getSprite() {
          return dt(this.stylesheet.sprite);
        }
        setSprite(t, n = {}, c) {
          this._checkLoaded(), t && this._validate(o.x.sprite, "sprite", t, null, n) || (this.stylesheet.sprite = t, t ? this._loadSprite(t, !0, c) : (this._unloadSprite(), c && c(null)));
        }
      }
      var Ar = o.X([{ name: "a_pos", type: "Int16", components: 2 }]), ta = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
      const Dr = { prelude: Mi(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: Mi(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: Mi(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Mi(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Mi("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Mi(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`), heatmapTexture: Mi(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Mi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Mi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Mi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: Mi(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: Mi(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: Mi(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: Mi(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Mi(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Mi(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Mi(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Mi(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: Mi(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Mi(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Mi(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Mi(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Mi(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Mi(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Mi(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Mi(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Mi("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", ta), terrainDepth: Mi("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", ta), terrainCoords: Mi("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", ta) };
      function Mi(f, t) {
        const n = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, c = t.match(/attribute ([\w]+) ([\w]+)/g), u = f.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), m = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), T = m ? m.concat(u) : u, s = {};
        return { fragmentSource: f = f.replace(n, (l, p, b, P, C) => (s[C] = !0, p === "define" ? `
#ifndef HAS_UNIFORM_u_${C}
varying ${b} ${P} ${C};
#else
uniform ${b} ${P} u_${C};
#endif
` : `
#ifdef HAS_UNIFORM_u_${C}
    ${b} ${P} ${C} = u_${C};
#endif
`)), vertexSource: t = t.replace(n, (l, p, b, P, C) => {
          const E = P === "float" ? "vec2" : "vec4", z = C.match(/color/) ? "color" : E;
          return s[C] ? p === "define" ? `
#ifndef HAS_UNIFORM_u_${C}
uniform lowp float u_${C}_t;
attribute ${b} ${E} a_${C};
varying ${b} ${P} ${C};
#else
uniform ${b} ${P} u_${C};
#endif
` : z === "vec4" ? `
#ifndef HAS_UNIFORM_u_${C}
    ${C} = a_${C};
#else
    ${b} ${P} ${C} = u_${C};
#endif
` : `
#ifndef HAS_UNIFORM_u_${C}
    ${C} = unpack_mix_${z}(a_${C}, u_${C}_t);
#else
    ${b} ${P} ${C} = u_${C};
#endif
` : p === "define" ? `
#ifndef HAS_UNIFORM_u_${C}
uniform lowp float u_${C}_t;
attribute ${b} ${E} a_${C};
#else
uniform ${b} ${P} u_${C};
#endif
` : z === "vec4" ? `
#ifndef HAS_UNIFORM_u_${C}
    ${b} ${P} ${C} = a_${C};
#else
    ${b} ${P} ${C} = u_${C};
#endif
` : `
#ifndef HAS_UNIFORM_u_${C}
    ${b} ${P} ${C} = unpack_mix_${z}(a_${C}, u_${C}_t);
#else
    ${b} ${P} ${C} = u_${C};
#endif
`;
        }), staticAttributes: c, staticUniforms: T };
      }
      class Ta {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(t, n, c, u, m, T, s, l, p) {
          this.context = t;
          let b = this.boundPaintVertexBuffers.length !== u.length;
          for (let P = 0; !b && P < u.length; P++) this.boundPaintVertexBuffers[P] !== u[P] && (b = !0);
          !this.vao || this.boundProgram !== n || this.boundLayoutVertexBuffer !== c || b || this.boundIndexBuffer !== m || this.boundVertexOffset !== T || this.boundDynamicVertexBuffer !== s || this.boundDynamicVertexBuffer2 !== l || this.boundDynamicVertexBuffer3 !== p ? this.freshBind(n, c, u, m, T, s, l, p) : (t.bindVertexArray.set(this.vao), s && s.bind(), m && m.dynamicDraw && m.bind(), l && l.bind(), p && p.bind());
        }
        freshBind(t, n, c, u, m, T, s, l) {
          const p = t.numAttributes, b = this.context, P = b.gl;
          this.vao && this.destroy(), this.vao = b.createVertexArray(), b.bindVertexArray.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = n, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = u, this.boundVertexOffset = m, this.boundDynamicVertexBuffer = T, this.boundDynamicVertexBuffer2 = s, this.boundDynamicVertexBuffer3 = l, n.enableAttributes(P, t);
          for (const C of c) C.enableAttributes(P, t);
          T && T.enableAttributes(P, t), s && s.enableAttributes(P, t), l && l.enableAttributes(P, t), n.bind(), n.setVertexAttribPointers(P, t, m);
          for (const C of c) C.bind(), C.setVertexAttribPointers(P, t, m);
          T && (T.bind(), T.setVertexAttribPointers(P, t, m)), u && u.bind(), s && (s.bind(), s.setVertexAttribPointers(P, t, m)), l && (l.bind(), l.setVertexAttribPointers(P, t, m)), b.currentNumAttributes = p;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      function ia(f) {
        const t = [];
        for (let n = 0; n < f.length; n++) {
          if (f[n] === null) continue;
          const c = f[n].split(" ");
          t.push(c.pop());
        }
        return t;
      }
      class Ha {
        constructor(t, n, c, u, m, T) {
          const s = t.gl;
          this.program = s.createProgram();
          const l = ia(n.staticAttributes), p = c ? c.getBinderAttributes() : [], b = l.concat(p), P = Dr.prelude.staticUniforms ? ia(Dr.prelude.staticUniforms) : [], C = n.staticUniforms ? ia(n.staticUniforms) : [], E = c ? c.getBinderUniforms() : [], z = P.concat(C).concat(E), N = [];
          for (const ce of z) N.indexOf(ce) < 0 && N.push(ce);
          const R = c ? c.defines() : [];
          m && R.push("#define OVERDRAW_INSPECTOR;"), T && R.push("#define TERRAIN3D;");
          const G = R.concat(Dr.prelude.fragmentSource, n.fragmentSource).join(`
`), ie = R.concat(Dr.prelude.vertexSource, n.vertexSource).join(`
`), H = s.createShader(s.FRAGMENT_SHADER);
          if (s.isContextLost()) return void (this.failedToCreate = !0);
          if (s.shaderSource(H, G), s.compileShader(H), !s.getShaderParameter(H, s.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${s.getShaderInfoLog(H)}`);
          s.attachShader(this.program, H);
          const Q = s.createShader(s.VERTEX_SHADER);
          if (s.isContextLost()) return void (this.failedToCreate = !0);
          if (s.shaderSource(Q, ie), s.compileShader(Q), !s.getShaderParameter(Q, s.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${s.getShaderInfoLog(Q)}`);
          s.attachShader(this.program, Q), this.attributes = {};
          const ue = {};
          this.numAttributes = b.length;
          for (let ce = 0; ce < this.numAttributes; ce++) b[ce] && (s.bindAttribLocation(this.program, ce, b[ce]), this.attributes[b[ce]] = ce);
          if (s.linkProgram(this.program), !s.getProgramParameter(this.program, s.LINK_STATUS)) throw new Error(`Program failed to link: ${s.getProgramInfoLog(this.program)}`);
          s.deleteShader(Q), s.deleteShader(H);
          for (let ce = 0; ce < N.length; ce++) {
            const ne = N[ce];
            if (ne && !ue[ne]) {
              const le = s.getUniformLocation(this.program, ne);
              le && (ue[ne] = le);
            }
          }
          this.fixedUniforms = u(t, ue), this.terrainUniforms = ((ce, ne) => ({ u_depth: new o.aH(ce, ne.u_depth), u_terrain: new o.aH(ce, ne.u_terrain), u_terrain_dim: new o.aI(ce, ne.u_terrain_dim), u_terrain_matrix: new o.aJ(ce, ne.u_terrain_matrix), u_terrain_unpack: new o.aK(ce, ne.u_terrain_unpack), u_terrain_exaggeration: new o.aI(ce, ne.u_terrain_exaggeration) }))(t, ue), this.binderUniforms = c ? c.getUniforms(t, ue) : [];
        }
        draw(t, n, c, u, m, T, s, l, p, b, P, C, E, z, N, R, G, ie) {
          const H = t.gl;
          if (this.failedToCreate) return;
          if (t.program.set(this.program), t.setDepthMode(c), t.setStencilMode(u), t.setColorMode(m), t.setCullFace(T), l) {
            t.activeTexture.set(H.TEXTURE2), H.bindTexture(H.TEXTURE_2D, l.depthTexture), t.activeTexture.set(H.TEXTURE3), H.bindTexture(H.TEXTURE_2D, l.texture);
            for (const ue in this.terrainUniforms) this.terrainUniforms[ue].set(l[ue]);
          }
          for (const ue in this.fixedUniforms) this.fixedUniforms[ue].set(s[ue]);
          N && N.setUniforms(t, this.binderUniforms, E, { zoom: z });
          let Q = 0;
          switch (n) {
            case H.LINES:
              Q = 2;
              break;
            case H.TRIANGLES:
              Q = 3;
              break;
            case H.LINE_STRIP:
              Q = 1;
          }
          for (const ue of C.get()) {
            const ce = ue.vaos || (ue.vaos = {});
            (ce[p] || (ce[p] = new Ta())).bind(t, this, b, N ? N.getPaintVertexBuffers() : [], P, ue.vertexOffset, R, G, ie), H.drawElements(n, ue.primitiveLength * Q, H.UNSIGNED_SHORT, ue.primitiveOffset * Q * 2);
          }
        }
      }
      function Xa(f, t, n) {
        const c = 1 / ti(n, 1, t.transform.tileZoom), u = Math.pow(2, n.tileID.overscaledZ), m = n.tileSize * Math.pow(2, t.transform.tileZoom) / u, T = m * (n.tileID.canonical.x + n.tileID.wrap * u), s = m * n.tileID.canonical.y;
        return { u_image: 0, u_texsize: n.imageAtlasTexture.size, u_scale: [c, f.fromScale, f.toScale], u_fade: f.t, u_pixel_coord_upper: [T >> 16, s >> 16], u_pixel_coord_lower: [65535 & T, 65535 & s] };
      }
      const ra = (f, t, n, c) => {
        const u = t.style.light, m = u.properties.get("position"), T = [m.x, m.y, m.z], s = function() {
          var p = new o.A(9);
          return o.A != Float32Array && (p[1] = 0, p[2] = 0, p[3] = 0, p[5] = 0, p[6] = 0, p[7] = 0), p[0] = 1, p[4] = 1, p[8] = 1, p;
        }();
        u.properties.get("anchor") === "viewport" && function(p, b) {
          var P = Math.sin(b), C = Math.cos(b);
          p[0] = C, p[1] = P, p[2] = 0, p[3] = -P, p[4] = C, p[5] = 0, p[6] = 0, p[7] = 0, p[8] = 1;
        }(s, -t.transform.angle), function(p, b, P) {
          var C = b[0], E = b[1], z = b[2];
          p[0] = C * P[0] + E * P[3] + z * P[6], p[1] = C * P[1] + E * P[4] + z * P[7], p[2] = C * P[2] + E * P[5] + z * P[8];
        }(T, T, s);
        const l = u.properties.get("color");
        return { u_matrix: f, u_lightpos: T, u_lightintensity: u.properties.get("intensity"), u_lightcolor: [l.r, l.g, l.b], u_vertical_gradient: +n, u_opacity: c };
      }, Eo = (f, t, n, c, u, m, T) => o.e(ra(f, t, n, c), Xa(m, t, T), { u_height_factor: -Math.pow(2, u.overscaledZ) / T.tileSize / 8 }), na = (f) => ({ u_matrix: f }), ka = (f, t, n, c) => o.e(na(f), Xa(n, t, c)), Ya = (f, t) => ({ u_matrix: f, u_world: t }), La = (f, t, n, c, u) => o.e(ka(f, t, n, c), { u_world: u }), Es = (f, t, n, c) => {
        const u = f.transform;
        let m, T;
        if (c.paint.get("circle-pitch-alignment") === "map") {
          const s = ti(n, 1, u.zoom);
          m = !0, T = [s, s];
        } else m = !1, T = u.pixelsToGLUnits;
        return { u_camera_to_center_distance: u.cameraToCenterDistance, u_scale_with_map: +(c.paint.get("circle-pitch-scale") === "map"), u_matrix: f.translatePosMatrix(t.posMatrix, n, c.paint.get("circle-translate"), c.paint.get("circle-translate-anchor")), u_pitch_with_map: +m, u_device_pixel_ratio: f.pixelRatio, u_extrude_scale: T };
      }, Ja = (f, t, n) => ({ u_matrix: f, u_inv_matrix: t, u_camera_to_center_distance: n.cameraToCenterDistance, u_viewport_size: [n.width, n.height] }), sa = (f, t, n = 1) => ({ u_matrix: f, u_color: t, u_overlay: 0, u_overlay_scale: n }), Mo = (f) => ({ u_matrix: f }), _r = (f, t, n, c) => ({ u_matrix: f, u_extrude_scale: ti(t, 1, n), u_intensity: c });
      function Ka(f, t) {
        const n = Math.pow(2, t.canonical.z), c = t.canonical.y;
        return [new o.Y(0, c / n).toLngLat().lat, new o.Y(0, (c + 1) / n).toLngLat().lat];
      }
      const Rr = (f, t, n, c) => {
        const u = f.transform;
        return { u_matrix: eo(f, t, n, c), u_ratio: 1 / ti(t, 1, u.zoom), u_device_pixel_ratio: f.pixelRatio, u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]] };
      }, ri = (f, t, n, c, u) => o.e(Rr(f, t, n, u), { u_image: 0, u_image_height: c }), Do = (f, t, n, c, u) => {
        const m = f.transform, T = En(t, m);
        return { u_matrix: eo(f, t, n, u), u_texsize: t.imageAtlasTexture.size, u_ratio: 1 / ti(t, 1, m.zoom), u_device_pixel_ratio: f.pixelRatio, u_image: 0, u_scale: [T, c.fromScale, c.toScale], u_fade: c.t, u_units_to_pixels: [1 / m.pixelsToGLUnits[0], 1 / m.pixelsToGLUnits[1]] };
      }, Qa = (f, t, n, c, u, m) => {
        const T = f.lineAtlas, s = En(t, f.transform), l = n.layout.get("line-cap") === "round", p = T.getDash(c.from, l), b = T.getDash(c.to, l), P = p.width * u.fromScale, C = b.width * u.toScale;
        return o.e(Rr(f, t, n, m), { u_patternscale_a: [s / P, -p.height / 2], u_patternscale_b: [s / C, -b.height / 2], u_sdfgamma: T.width / (256 * Math.min(P, C) * f.pixelRatio) / 2, u_image: 0, u_tex_y_a: p.y, u_tex_y_b: b.y, u_mix: u.t });
      };
      function En(f, t) {
        return 1 / ti(f, 1, t.tileZoom);
      }
      function eo(f, t, n, c) {
        return f.translatePosMatrix(c ? c.posMatrix : t.tileID.posMatrix, t, n.paint.get("line-translate"), n.paint.get("line-translate-anchor"));
      }
      const Ms = (f, t, n, c, u) => {
        return { u_matrix: f, u_tl_parent: t, u_scale_parent: n, u_buffer_scale: 1, u_fade_t: c.mix, u_opacity: c.opacity * u.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: u.paint.get("raster-brightness-min"), u_brightness_high: u.paint.get("raster-brightness-max"), u_saturation_factor: (T = u.paint.get("raster-saturation"), T > 0 ? 1 - 1 / (1.001 - T) : -T), u_contrast_factor: (m = u.paint.get("raster-contrast"), m > 0 ? 1 / (1 - m) : 1 + m), u_spin_weights: to(u.paint.get("raster-hue-rotate")) };
        var m, T;
      };
      function to(f) {
        f *= Math.PI / 180;
        const t = Math.sin(f), n = Math.cos(f);
        return [(2 * n + 1) / 3, (-Math.sqrt(3) * t - n + 1) / 3, (Math.sqrt(3) * t - n + 1) / 3];
      }
      const io = (f, t, n, c, u, m, T, s, l, p, b, P, C, E) => {
        const z = T.transform;
        return { u_is_size_zoom_constant: +(f === "constant" || f === "source"), u_is_size_feature_constant: +(f === "constant" || f === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: z.cameraToCenterDistance, u_pitch: z.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +n, u_aspect_ratio: z.width / z.height, u_fade_change: T.options.fadeDuration ? T.symbolFadeChange : 1, u_matrix: s, u_label_plane_matrix: l, u_coord_matrix: p, u_is_text: +P, u_pitch_with_map: +c, u_is_along_line: u, u_is_variable_anchor: m, u_texsize: C, u_texture: 0, u_translation: b, u_pitched_scale: E };
      }, tl = (f, t, n, c, u, m, T, s, l, p, b, P, C, E, z) => {
        const N = T.transform;
        return o.e(io(f, t, n, c, u, m, T, s, l, p, b, P, C, z), { u_gamma_scale: c ? Math.cos(N._pitch) * N.cameraToCenterDistance : 1, u_device_pixel_ratio: T.pixelRatio, u_is_halo: +E });
      }, kl = (f, t, n, c, u, m, T, s, l, p, b, P, C, E) => o.e(tl(f, t, n, c, u, m, T, s, l, p, b, !0, P, !0, E), { u_texsize_icon: C, u_texture_icon: 1 }), Ll = (f, t, n) => ({ u_matrix: f, u_opacity: t, u_color: n }), zo = (f, t, n, c, u, m) => o.e(function(T, s, l, p) {
        const b = l.imageManager.getPattern(T.from.toString()), P = l.imageManager.getPattern(T.to.toString()), { width: C, height: E } = l.imageManager.getPixelSize(), z = Math.pow(2, p.tileID.overscaledZ), N = p.tileSize * Math.pow(2, l.transform.tileZoom) / z, R = N * (p.tileID.canonical.x + p.tileID.wrap * z), G = N * p.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: b.tl, u_pattern_br_a: b.br, u_pattern_tl_b: P.tl, u_pattern_br_b: P.br, u_texsize: [C, E], u_mix: s.t, u_pattern_size_a: b.displaySize, u_pattern_size_b: P.displaySize, u_scale_a: s.fromScale, u_scale_b: s.toScale, u_tile_units_to_pixels: 1 / ti(p, 1, l.transform.tileZoom), u_pixel_coord_upper: [R >> 16, G >> 16], u_pixel_coord_lower: [65535 & R, 65535 & G] };
      }(c, m, n, u), { u_matrix: f, u_opacity: t }), ps = { fillExtrusion: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_lightpos: new o.aL(f, t.u_lightpos), u_lightintensity: new o.aI(f, t.u_lightintensity), u_lightcolor: new o.aL(f, t.u_lightcolor), u_vertical_gradient: new o.aI(f, t.u_vertical_gradient), u_opacity: new o.aI(f, t.u_opacity) }), fillExtrusionPattern: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_lightpos: new o.aL(f, t.u_lightpos), u_lightintensity: new o.aI(f, t.u_lightintensity), u_lightcolor: new o.aL(f, t.u_lightcolor), u_vertical_gradient: new o.aI(f, t.u_vertical_gradient), u_height_factor: new o.aI(f, t.u_height_factor), u_image: new o.aH(f, t.u_image), u_texsize: new o.aM(f, t.u_texsize), u_pixel_coord_upper: new o.aM(f, t.u_pixel_coord_upper), u_pixel_coord_lower: new o.aM(f, t.u_pixel_coord_lower), u_scale: new o.aL(f, t.u_scale), u_fade: new o.aI(f, t.u_fade), u_opacity: new o.aI(f, t.u_opacity) }), fill: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix) }), fillPattern: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_image: new o.aH(f, t.u_image), u_texsize: new o.aM(f, t.u_texsize), u_pixel_coord_upper: new o.aM(f, t.u_pixel_coord_upper), u_pixel_coord_lower: new o.aM(f, t.u_pixel_coord_lower), u_scale: new o.aL(f, t.u_scale), u_fade: new o.aI(f, t.u_fade) }), fillOutline: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_world: new o.aM(f, t.u_world) }), fillOutlinePattern: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_world: new o.aM(f, t.u_world), u_image: new o.aH(f, t.u_image), u_texsize: new o.aM(f, t.u_texsize), u_pixel_coord_upper: new o.aM(f, t.u_pixel_coord_upper), u_pixel_coord_lower: new o.aM(f, t.u_pixel_coord_lower), u_scale: new o.aL(f, t.u_scale), u_fade: new o.aI(f, t.u_fade) }), circle: (f, t) => ({ u_camera_to_center_distance: new o.aI(f, t.u_camera_to_center_distance), u_scale_with_map: new o.aH(f, t.u_scale_with_map), u_pitch_with_map: new o.aH(f, t.u_pitch_with_map), u_extrude_scale: new o.aM(f, t.u_extrude_scale), u_device_pixel_ratio: new o.aI(f, t.u_device_pixel_ratio), u_matrix: new o.aJ(f, t.u_matrix) }), collisionBox: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_pixel_extrude_scale: new o.aM(f, t.u_pixel_extrude_scale) }), collisionCircle: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_inv_matrix: new o.aJ(f, t.u_inv_matrix), u_camera_to_center_distance: new o.aI(f, t.u_camera_to_center_distance), u_viewport_size: new o.aM(f, t.u_viewport_size) }), debug: (f, t) => ({ u_color: new o.aN(f, t.u_color), u_matrix: new o.aJ(f, t.u_matrix), u_overlay: new o.aH(f, t.u_overlay), u_overlay_scale: new o.aI(f, t.u_overlay_scale) }), clippingMask: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix) }), heatmap: (f, t) => ({ u_extrude_scale: new o.aI(f, t.u_extrude_scale), u_intensity: new o.aI(f, t.u_intensity), u_matrix: new o.aJ(f, t.u_matrix) }), heatmapTexture: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_world: new o.aM(f, t.u_world), u_image: new o.aH(f, t.u_image), u_color_ramp: new o.aH(f, t.u_color_ramp), u_opacity: new o.aI(f, t.u_opacity) }), hillshade: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_image: new o.aH(f, t.u_image), u_latrange: new o.aM(f, t.u_latrange), u_light: new o.aM(f, t.u_light), u_shadow: new o.aN(f, t.u_shadow), u_highlight: new o.aN(f, t.u_highlight), u_accent: new o.aN(f, t.u_accent) }), hillshadePrepare: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_image: new o.aH(f, t.u_image), u_dimension: new o.aM(f, t.u_dimension), u_zoom: new o.aI(f, t.u_zoom), u_unpack: new o.aK(f, t.u_unpack) }), line: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_ratio: new o.aI(f, t.u_ratio), u_device_pixel_ratio: new o.aI(f, t.u_device_pixel_ratio), u_units_to_pixels: new o.aM(f, t.u_units_to_pixels) }), lineGradient: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_ratio: new o.aI(f, t.u_ratio), u_device_pixel_ratio: new o.aI(f, t.u_device_pixel_ratio), u_units_to_pixels: new o.aM(f, t.u_units_to_pixels), u_image: new o.aH(f, t.u_image), u_image_height: new o.aI(f, t.u_image_height) }), linePattern: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_texsize: new o.aM(f, t.u_texsize), u_ratio: new o.aI(f, t.u_ratio), u_device_pixel_ratio: new o.aI(f, t.u_device_pixel_ratio), u_image: new o.aH(f, t.u_image), u_units_to_pixels: new o.aM(f, t.u_units_to_pixels), u_scale: new o.aL(f, t.u_scale), u_fade: new o.aI(f, t.u_fade) }), lineSDF: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_ratio: new o.aI(f, t.u_ratio), u_device_pixel_ratio: new o.aI(f, t.u_device_pixel_ratio), u_units_to_pixels: new o.aM(f, t.u_units_to_pixels), u_patternscale_a: new o.aM(f, t.u_patternscale_a), u_patternscale_b: new o.aM(f, t.u_patternscale_b), u_sdfgamma: new o.aI(f, t.u_sdfgamma), u_image: new o.aH(f, t.u_image), u_tex_y_a: new o.aI(f, t.u_tex_y_a), u_tex_y_b: new o.aI(f, t.u_tex_y_b), u_mix: new o.aI(f, t.u_mix) }), raster: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_tl_parent: new o.aM(f, t.u_tl_parent), u_scale_parent: new o.aI(f, t.u_scale_parent), u_buffer_scale: new o.aI(f, t.u_buffer_scale), u_fade_t: new o.aI(f, t.u_fade_t), u_opacity: new o.aI(f, t.u_opacity), u_image0: new o.aH(f, t.u_image0), u_image1: new o.aH(f, t.u_image1), u_brightness_low: new o.aI(f, t.u_brightness_low), u_brightness_high: new o.aI(f, t.u_brightness_high), u_saturation_factor: new o.aI(f, t.u_saturation_factor), u_contrast_factor: new o.aI(f, t.u_contrast_factor), u_spin_weights: new o.aL(f, t.u_spin_weights) }), symbolIcon: (f, t) => ({ u_is_size_zoom_constant: new o.aH(f, t.u_is_size_zoom_constant), u_is_size_feature_constant: new o.aH(f, t.u_is_size_feature_constant), u_size_t: new o.aI(f, t.u_size_t), u_size: new o.aI(f, t.u_size), u_camera_to_center_distance: new o.aI(f, t.u_camera_to_center_distance), u_pitch: new o.aI(f, t.u_pitch), u_rotate_symbol: new o.aH(f, t.u_rotate_symbol), u_aspect_ratio: new o.aI(f, t.u_aspect_ratio), u_fade_change: new o.aI(f, t.u_fade_change), u_matrix: new o.aJ(f, t.u_matrix), u_label_plane_matrix: new o.aJ(f, t.u_label_plane_matrix), u_coord_matrix: new o.aJ(f, t.u_coord_matrix), u_is_text: new o.aH(f, t.u_is_text), u_pitch_with_map: new o.aH(f, t.u_pitch_with_map), u_is_along_line: new o.aH(f, t.u_is_along_line), u_is_variable_anchor: new o.aH(f, t.u_is_variable_anchor), u_texsize: new o.aM(f, t.u_texsize), u_texture: new o.aH(f, t.u_texture), u_translation: new o.aM(f, t.u_translation), u_pitched_scale: new o.aI(f, t.u_pitched_scale) }), symbolSDF: (f, t) => ({ u_is_size_zoom_constant: new o.aH(f, t.u_is_size_zoom_constant), u_is_size_feature_constant: new o.aH(f, t.u_is_size_feature_constant), u_size_t: new o.aI(f, t.u_size_t), u_size: new o.aI(f, t.u_size), u_camera_to_center_distance: new o.aI(f, t.u_camera_to_center_distance), u_pitch: new o.aI(f, t.u_pitch), u_rotate_symbol: new o.aH(f, t.u_rotate_symbol), u_aspect_ratio: new o.aI(f, t.u_aspect_ratio), u_fade_change: new o.aI(f, t.u_fade_change), u_matrix: new o.aJ(f, t.u_matrix), u_label_plane_matrix: new o.aJ(f, t.u_label_plane_matrix), u_coord_matrix: new o.aJ(f, t.u_coord_matrix), u_is_text: new o.aH(f, t.u_is_text), u_pitch_with_map: new o.aH(f, t.u_pitch_with_map), u_is_along_line: new o.aH(f, t.u_is_along_line), u_is_variable_anchor: new o.aH(f, t.u_is_variable_anchor), u_texsize: new o.aM(f, t.u_texsize), u_texture: new o.aH(f, t.u_texture), u_gamma_scale: new o.aI(f, t.u_gamma_scale), u_device_pixel_ratio: new o.aI(f, t.u_device_pixel_ratio), u_is_halo: new o.aH(f, t.u_is_halo), u_translation: new o.aM(f, t.u_translation), u_pitched_scale: new o.aI(f, t.u_pitched_scale) }), symbolTextAndIcon: (f, t) => ({ u_is_size_zoom_constant: new o.aH(f, t.u_is_size_zoom_constant), u_is_size_feature_constant: new o.aH(f, t.u_is_size_feature_constant), u_size_t: new o.aI(f, t.u_size_t), u_size: new o.aI(f, t.u_size), u_camera_to_center_distance: new o.aI(f, t.u_camera_to_center_distance), u_pitch: new o.aI(f, t.u_pitch), u_rotate_symbol: new o.aH(f, t.u_rotate_symbol), u_aspect_ratio: new o.aI(f, t.u_aspect_ratio), u_fade_change: new o.aI(f, t.u_fade_change), u_matrix: new o.aJ(f, t.u_matrix), u_label_plane_matrix: new o.aJ(f, t.u_label_plane_matrix), u_coord_matrix: new o.aJ(f, t.u_coord_matrix), u_is_text: new o.aH(f, t.u_is_text), u_pitch_with_map: new o.aH(f, t.u_pitch_with_map), u_is_along_line: new o.aH(f, t.u_is_along_line), u_is_variable_anchor: new o.aH(f, t.u_is_variable_anchor), u_texsize: new o.aM(f, t.u_texsize), u_texsize_icon: new o.aM(f, t.u_texsize_icon), u_texture: new o.aH(f, t.u_texture), u_texture_icon: new o.aH(f, t.u_texture_icon), u_gamma_scale: new o.aI(f, t.u_gamma_scale), u_device_pixel_ratio: new o.aI(f, t.u_device_pixel_ratio), u_is_halo: new o.aH(f, t.u_is_halo), u_translation: new o.aM(f, t.u_translation), u_pitched_scale: new o.aI(f, t.u_pitched_scale) }), background: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_opacity: new o.aI(f, t.u_opacity), u_color: new o.aN(f, t.u_color) }), backgroundPattern: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_opacity: new o.aI(f, t.u_opacity), u_image: new o.aH(f, t.u_image), u_pattern_tl_a: new o.aM(f, t.u_pattern_tl_a), u_pattern_br_a: new o.aM(f, t.u_pattern_br_a), u_pattern_tl_b: new o.aM(f, t.u_pattern_tl_b), u_pattern_br_b: new o.aM(f, t.u_pattern_br_b), u_texsize: new o.aM(f, t.u_texsize), u_mix: new o.aI(f, t.u_mix), u_pattern_size_a: new o.aM(f, t.u_pattern_size_a), u_pattern_size_b: new o.aM(f, t.u_pattern_size_b), u_scale_a: new o.aI(f, t.u_scale_a), u_scale_b: new o.aI(f, t.u_scale_b), u_pixel_coord_upper: new o.aM(f, t.u_pixel_coord_upper), u_pixel_coord_lower: new o.aM(f, t.u_pixel_coord_lower), u_tile_units_to_pixels: new o.aI(f, t.u_tile_units_to_pixels) }), terrain: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_texture: new o.aH(f, t.u_texture), u_ele_delta: new o.aI(f, t.u_ele_delta) }), terrainDepth: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_ele_delta: new o.aI(f, t.u_ele_delta) }), terrainCoords: (f, t) => ({ u_matrix: new o.aJ(f, t.u_matrix), u_texture: new o.aH(f, t.u_texture), u_terrain_coords_id: new o.aI(f, t.u_terrain_coords_id), u_ele_delta: new o.aI(f, t.u_ele_delta) }) };
      class fs {
        constructor(t, n, c) {
          this.context = t;
          const u = t.gl;
          this.buffer = u.createBuffer(), this.dynamicDraw = !!c, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), u.bufferData(u.ELEMENT_ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? u.DYNAMIC_DRAW : u.STATIC_DRAW), this.dynamicDraw || delete n.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t) {
          const n = this.context.gl;
          if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), n.bufferSubData(n.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const ro = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class Ds {
        constructor(t, n, c, u) {
          this.length = n.length, this.attributes = c, this.itemSize = n.bytesPerElement, this.dynamicDraw = u, this.context = t;
          const m = t.gl;
          this.buffer = m.createBuffer(), t.bindVertexBuffer.set(this.buffer), m.bufferData(m.ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? m.DYNAMIC_DRAW : m.STATIC_DRAW), this.dynamicDraw || delete n.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(t) {
          if (t.length !== this.length) throw new Error(`Length of new data is ${t.length}, which doesn't match current length of ${this.length}`);
          const n = this.context.gl;
          this.bind(), n.bufferSubData(n.ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        enableAttributes(t, n) {
          for (let c = 0; c < this.attributes.length; c++) {
            const u = n.attributes[this.attributes[c].name];
            u !== void 0 && t.enableVertexAttribArray(u);
          }
        }
        setVertexAttribPointers(t, n, c) {
          for (let u = 0; u < this.attributes.length; u++) {
            const m = this.attributes[u], T = n.attributes[m.name];
            T !== void 0 && t.vertexAttribPointer(T, m.components, t[ro[m.type]], !1, this.itemSize, m.offset + this.itemSize * (c || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const zs = /* @__PURE__ */ new WeakMap();
      function Br(f) {
        var t;
        if (zs.has(f)) return zs.get(f);
        {
          const n = (t = f.getParameter(f.VERSION)) === null || t === void 0 ? void 0 : t.startsWith("WebGL 2.0");
          return zs.set(f, n), n;
        }
      }
      class zi {
        constructor(t) {
          this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(t) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class no extends zi {
        getDefault() {
          return o.aP.transparent;
        }
        set(t) {
          const n = this.current;
          (t.r !== n.r || t.g !== n.g || t.b !== n.b || t.a !== n.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
        }
      }
      class aa extends zi {
        getDefault() {
          return 1;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);
        }
      }
      class oa extends zi {
        getDefault() {
          return 0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);
        }
      }
      class Fs extends zi {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(t) {
          const n = this.current;
          (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || t[3] !== n[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class Kn extends zi {
        getDefault() {
          return !0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);
        }
      }
      class Cl extends zi {
        getDefault() {
          return 255;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);
        }
      }
      class wn extends zi {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(t) {
          const n = this.current;
          (t.func !== n.func || t.ref !== n.ref || t.mask !== n.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);
        }
      }
      class Qn extends zi {
        getDefault() {
          const t = this.gl;
          return [t.KEEP, t.KEEP, t.KEEP];
        }
        set(t) {
          const n = this.current;
          (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);
        }
      }
      class so extends zi {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          t ? n.enable(n.STENCIL_TEST) : n.disable(n.STENCIL_TEST), this.current = t, this.dirty = !1;
        }
      }
      class Ca extends zi {
        getDefault() {
          return [0, 1];
        }
        set(t) {
          const n = this.current;
          (t[0] !== n[0] || t[1] !== n[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);
        }
      }
      class il extends zi {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          t ? n.enable(n.DEPTH_TEST) : n.disable(n.DEPTH_TEST), this.current = t, this.dirty = !1;
        }
      }
      class la extends zi {
        getDefault() {
          return this.gl.LESS;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);
        }
      }
      class rl extends zi {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          t ? n.enable(n.BLEND) : n.disable(n.BLEND), this.current = t, this.dirty = !1;
        }
      }
      class ao extends zi {
        getDefault() {
          const t = this.gl;
          return [t.ONE, t.ZERO];
        }
        set(t) {
          const n = this.current;
          (t[0] !== n[0] || t[1] !== n[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1);
        }
      }
      class oo extends zi {
        getDefault() {
          return o.aP.transparent;
        }
        set(t) {
          const n = this.current;
          (t.r !== n.r || t.g !== n.g || t.b !== n.b || t.a !== n.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
        }
      }
      class Fo extends zi {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1);
        }
      }
      class Mn extends zi {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          t ? n.enable(n.CULL_FACE) : n.disable(n.CULL_FACE), this.current = t, this.dirty = !1;
        }
      }
      class lo extends zi {
        getDefault() {
          return this.gl.BACK;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);
        }
      }
      class No extends zi {
        getDefault() {
          return this.gl.CCW;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);
        }
      }
      class nl extends zi {
        getDefault() {
          return null;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1);
        }
      }
      class sl extends zi {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);
        }
      }
      class ms extends zi {
        getDefault() {
          const t = this.gl;
          return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
        }
        set(t) {
          const n = this.current;
          (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || t[3] !== n[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class Ea extends zi {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          n.bindFramebuffer(n.FRAMEBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class ca extends zi {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          n.bindRenderbuffer(n.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class ha extends zi {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          n.bindTexture(n.TEXTURE_2D, t), this.current = t, this.dirty = !1;
        }
      }
      class Ro extends zi {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          n.bindBuffer(n.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class L extends zi {
        getDefault() {
          return null;
        }
        set(t) {
          const n = this.gl;
          n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class X extends zi {
        getDefault() {
          return null;
        }
        set(t) {
          var n;
          if (t === this.current && !this.dirty) return;
          const c = this.gl;
          Br(c) ? c.bindVertexArray(t) : (n = c.getExtension("OES_vertex_array_object")) === null || n === void 0 || n.bindVertexArrayOES(t), this.current = t, this.dirty = !1;
        }
      }
      class _e extends zi {
        getDefault() {
          return 4;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          n.pixelStorei(n.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;
        }
      }
      class ke extends zi {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;
        }
      }
      class je extends zi {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const n = this.gl;
          n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;
        }
      }
      class tt extends zi {
        constructor(t, n) {
          super(t), this.context = t, this.parent = n;
        }
        getDefault() {
          return null;
        }
      }
      class yt extends tt {
        setDirty() {
          this.dirty = !0;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const n = this.gl;
          n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
        }
      }
      class jt extends tt {
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const n = this.gl;
          n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class oi extends tt {
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const n = this.gl;
          n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class yi {
        constructor(t, n, c, u, m) {
          this.context = t, this.width = n, this.height = c;
          const T = t.gl, s = this.framebuffer = T.createFramebuffer();
          if (this.colorAttachment = new yt(t, s), u) this.depthAttachment = m ? new oi(t, s) : new jt(t, s);
          else if (m) throw new Error("Stencil cannot be set without depth");
          if (T.checkFramebufferStatus(T.FRAMEBUFFER) !== T.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const t = this.context.gl, n = this.colorAttachment.get();
          if (n && t.deleteTexture(n), this.depthAttachment) {
            const c = this.depthAttachment.get();
            c && t.deleteRenderbuffer(c);
          }
          t.deleteFramebuffer(this.framebuffer);
        }
      }
      class Yt {
        constructor(t, n, c) {
          this.blendFunction = t, this.blendColor = n, this.mask = c;
        }
      }
      Yt.Replace = [1, 0], Yt.disabled = new Yt(Yt.Replace, o.aP.transparent, [!1, !1, !1, !1]), Yt.unblended = new Yt(Yt.Replace, o.aP.transparent, [!0, !0, !0, !0]), Yt.alphaBlended = new Yt([1, 771], o.aP.transparent, [!0, !0, !0, !0]);
      class Di {
        constructor(t) {
          var n, c;
          if (this.gl = t, this.clearColor = new no(this), this.clearDepth = new aa(this), this.clearStencil = new oa(this), this.colorMask = new Fs(this), this.depthMask = new Kn(this), this.stencilMask = new Cl(this), this.stencilFunc = new wn(this), this.stencilOp = new Qn(this), this.stencilTest = new so(this), this.depthRange = new Ca(this), this.depthTest = new il(this), this.depthFunc = new la(this), this.blend = new rl(this), this.blendFunc = new ao(this), this.blendColor = new oo(this), this.blendEquation = new Fo(this), this.cullFace = new Mn(this), this.cullFaceSide = new lo(this), this.frontFace = new No(this), this.program = new nl(this), this.activeTexture = new sl(this), this.viewport = new ms(this), this.bindFramebuffer = new Ea(this), this.bindRenderbuffer = new ca(this), this.bindTexture = new ha(this), this.bindVertexBuffer = new Ro(this), this.bindElementBuffer = new L(this), this.bindVertexArray = new X(this), this.pixelStoreUnpack = new _e(this), this.pixelStoreUnpackPremultiplyAlpha = new ke(this), this.pixelStoreUnpackFlipY = new je(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), Br(t)) {
            this.HALF_FLOAT = t.HALF_FLOAT;
            const u = t.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (n = t.RGBA16F) !== null && n !== void 0 ? n : u == null ? void 0 : u.RGBA16F_EXT, this.RGB16F = (c = t.RGB16F) !== null && c !== void 0 ? c : u == null ? void 0 : u.RGB16F_EXT, t.getExtension("EXT_color_buffer_float");
          } else {
            t.getExtension("EXT_color_buffer_half_float"), t.getExtension("OES_texture_half_float_linear");
            const u = t.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = u == null ? void 0 : u.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(t, n) {
          return new fs(this, t, n);
        }
        createVertexBuffer(t, n, c) {
          return new Ds(this, t, n, c);
        }
        createRenderbuffer(t, n, c) {
          const u = this.gl, m = u.createRenderbuffer();
          return this.bindRenderbuffer.set(m), u.renderbufferStorage(u.RENDERBUFFER, t, n, c), this.bindRenderbuffer.set(null), m;
        }
        createFramebuffer(t, n, c, u) {
          return new yi(this, t, n, c, u);
        }
        clear({ color: t, depth: n, stencil: c }) {
          const u = this.gl;
          let m = 0;
          t && (m |= u.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set([!0, !0, !0, !0])), n !== void 0 && (m |= u.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(n), this.depthMask.set(!0)), c !== void 0 && (m |= u.STENCIL_BUFFER_BIT, this.clearStencil.set(c), this.stencilMask.set(255)), u.clear(m);
        }
        setCullFace(t) {
          t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
        }
        setDepthMode(t) {
          t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);
        }
        setStencilMode(t) {
          t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(t) {
          o.aE(t.blendFunction, Yt.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask);
        }
        createVertexArray() {
          var t;
          return Br(this.gl) ? this.gl.createVertexArray() : (t = this.gl.getExtension("OES_vertex_array_object")) === null || t === void 0 ? void 0 : t.createVertexArrayOES();
        }
        deleteVertexArray(t) {
          var n;
          return Br(this.gl) ? this.gl.deleteVertexArray(t) : (n = this.gl.getExtension("OES_vertex_array_object")) === null || n === void 0 ? void 0 : n.deleteVertexArrayOES(t);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      class Zt {
        constructor(t, n, c) {
          this.func = t, this.mask = n, this.range = c;
        }
      }
      Zt.ReadOnly = !1, Zt.ReadWrite = !0, Zt.disabled = new Zt(519, Zt.ReadOnly, [0, 1]);
      const rr = 7680;
      class Si {
        constructor(t, n, c, u, m, T) {
          this.test = t, this.ref = n, this.mask = c, this.fail = u, this.depthFail = m, this.pass = T;
        }
      }
      Si.disabled = new Si({ func: 519, mask: 0 }, 0, 0, rr, rr, rr);
      class Ai {
        constructor(t, n, c) {
          this.enable = t, this.mode = n, this.frontFace = c;
        }
      }
      let br;
      function Dn(f, t, n, c, u) {
        const m = f.context, T = m.gl, s = f.useProgram("collisionBox"), l = [];
        let p = 0, b = 0;
        for (let G = 0; G < c.length; G++) {
          const ie = c[G], H = t.getTile(ie).getBucket(n);
          if (!H) continue;
          const Q = u ? H.textCollisionBox : H.iconCollisionBox, ue = H.collisionCircleArray;
          if (ue.length > 0) {
            const ce = o.F();
            o.aQ(ce, H.placementInvProjMatrix, f.transform.glCoordMatrix), o.aQ(ce, ce, H.placementViewportMatrix), l.push({ circleArray: ue, circleOffset: b, transform: ie.posMatrix, invTransform: ce, coord: ie }), p += ue.length / 4, b = p;
          }
          Q && s.draw(m, T.LINES, Zt.disabled, Si.disabled, f.colorModeForRenderPass(), Ai.disabled, { u_matrix: ie.posMatrix, u_pixel_extrude_scale: [1 / (P = f.transform).width, 1 / P.height] }, f.style.map.terrain && f.style.map.terrain.getTerrainData(ie), n.id, Q.layoutVertexBuffer, Q.indexBuffer, Q.segments, null, f.transform.zoom, null, null, Q.collisionVertexBuffer);
        }
        var P;
        if (!u || !l.length) return;
        const C = f.useProgram("collisionCircle"), E = new o.aR();
        E.resize(4 * p), E._trim();
        let z = 0;
        for (const G of l) for (let ie = 0; ie < G.circleArray.length / 4; ie++) {
          const H = 4 * ie, Q = G.circleArray[H + 0], ue = G.circleArray[H + 1], ce = G.circleArray[H + 2], ne = G.circleArray[H + 3];
          E.emplace(z++, Q, ue, ce, ne, 0), E.emplace(z++, Q, ue, ce, ne, 1), E.emplace(z++, Q, ue, ce, ne, 2), E.emplace(z++, Q, ue, ce, ne, 3);
        }
        (!br || br.length < 2 * p) && (br = function(G) {
          const ie = 2 * G, H = new o.aT();
          H.resize(ie), H._trim();
          for (let Q = 0; Q < ie; Q++) {
            const ue = 6 * Q;
            H.uint16[ue + 0] = 4 * Q + 0, H.uint16[ue + 1] = 4 * Q + 1, H.uint16[ue + 2] = 4 * Q + 2, H.uint16[ue + 3] = 4 * Q + 2, H.uint16[ue + 4] = 4 * Q + 3, H.uint16[ue + 5] = 4 * Q + 0;
          }
          return H;
        }(p));
        const N = m.createIndexBuffer(br, !0), R = m.createVertexBuffer(E, o.aS.members, !0);
        for (const G of l) {
          const ie = Ja(G.transform, G.invTransform, f.transform);
          C.draw(m, T.TRIANGLES, Zt.disabled, Si.disabled, f.colorModeForRenderPass(), Ai.disabled, ie, f.style.map.terrain && f.style.map.terrain.getTerrainData(G.coord), n.id, R, N, o.$.simpleSegment(0, 2 * G.circleOffset, G.circleArray.length, G.circleArray.length / 2), null, f.transform.zoom, null, null, null);
        }
        R.destroy(), N.destroy();
      }
      Ai.disabled = new Ai(!1, 1029, 2305), Ai.backCCW = new Ai(!0, 1029, 2305);
      const hn = o.an(new Float32Array(16));
      function Ns(f, t, n, c, u, m) {
        const { horizontalAlign: T, verticalAlign: s } = o.au(f);
        return new o.P((-(T - 0.5) * t / u + c[0]) * m, (-(s - 0.5) * n / u + c[1]) * m);
      }
      function Bo(f, t, n, c, u, m) {
        const T = t.tileAnchorPoint.add(new o.P(t.translation[0], t.translation[1]));
        if (t.pitchWithMap) {
          let s = c.mult(m);
          return n || (s = s.rotate(-u)), $i(T.add(s), t.labelPlaneMatrix, t.getElevation).point;
        }
        if (n) {
          const s = pe(t.tileAnchorPoint.x + 1, t.tileAnchorPoint.y, t).point.sub(f), l = Math.atan(s.y / s.x) + (s.x < 0 ? Math.PI : 0);
          return f.add(c.rotate(l));
        }
        return f.add(c);
      }
      function ua(f, t, n, c, u, m, T, s, l, p, b, P, C, E) {
        const z = f.text.placedSymbolArray, N = f.text.dynamicLayoutVertexArray, R = f.icon.dynamicLayoutVertexArray, G = {};
        N.clear();
        for (let ie = 0; ie < z.length; ie++) {
          const H = z.get(ie), Q = H.hidden || !H.crossTileID || f.allowVerticalPlacement && !H.placedOrientation ? null : c[H.crossTileID];
          if (Q) {
            const ue = new o.P(H.anchorX, H.anchorY), ce = { getElevation: E, width: u.width, height: u.height, labelPlaneMatrix: m, lineVertexArray: null, pitchWithMap: n, projection: b, projectionCache: null, tileAnchorPoint: ue, translation: P, unwrappedTileID: C }, ne = n ? $i(ue, T, E) : pe(ue.x, ue.y, ce), le = de(u.cameraToCenterDistance, ne.signedDistanceFromCamera);
            let De = o.ai(f.textSizeData, l, H) * le / o.ap;
            n && (De *= f.tilePixelRatio / s);
            const { width: Ne, height: Te, anchor: qe, textOffset: He, textBoxScale: vt } = Q, Ue = Ns(qe, Ne, Te, He, vt, De), ft = b.getPitchedTextCorrection(u, ue.add(new o.P(P[0], P[1])), C), Tt = Bo(ne.point, ce, t, Ue, u.angle, ft), ii = f.allowVerticalPlacement && H.placedOrientation === o.ah.vertical ? Math.PI / 2 : 0;
            for (let Mt = 0; Mt < H.numGlyphs; Mt++) o.aj(N, Tt, ii);
            p && H.associatedIconIndex >= 0 && (G[H.associatedIconIndex] = { shiftedAnchor: Tt, angle: ii });
          } else It(H.numGlyphs, N);
        }
        if (p) {
          R.clear();
          const ie = f.icon.placedSymbolArray;
          for (let H = 0; H < ie.length; H++) {
            const Q = ie.get(H);
            if (Q.hidden) It(Q.numGlyphs, R);
            else {
              const ue = G[H];
              if (ue) for (let ce = 0; ce < Q.numGlyphs; ce++) o.aj(R, ue.shiftedAnchor, ue.angle);
              else It(Q.numGlyphs, R);
            }
          }
          f.icon.dynamicLayoutVertexBuffer.updateData(R);
        }
        f.text.dynamicLayoutVertexBuffer.updateData(N);
      }
      function da(f, t, n) {
        return n.iconsInText && t ? "symbolTextAndIcon" : f ? "symbolSDF" : "symbolIcon";
      }
      function gs(f, t, n, c, u, m, T, s, l, p, b, P) {
        const C = f.context, E = C.gl, z = f.transform, N = Kr(), R = s === "map", G = l === "map", ie = s !== "viewport" && n.layout.get("symbol-placement") !== "point", H = R && !G && !ie, Q = !G && ie, ue = !n.layout.get("symbol-sort-key").isConstant();
        let ce = !1;
        const ne = f.depthModeForSublayer(0, Zt.ReadOnly), le = n._unevaluatedLayout.hasValue("text-variable-anchor") || n._unevaluatedLayout.hasValue("text-variable-anchor-offset"), De = [], Ne = N.getCircleRadiusCorrection(z);
        for (const Te of c) {
          const qe = t.getTile(Te), He = qe.getBucket(n);
          if (!He) continue;
          const vt = u ? He.text : He.icon;
          if (!vt || !vt.segments.get().length || !vt.hasVisibleVertices) continue;
          const Ue = vt.programConfigurations.get(n.id), ft = u || He.sdfIcons, Tt = u ? He.textSizeData : He.iconSizeData, ii = G || z.pitch !== 0, Mt = f.useProgram(da(ft, u, He), Ue), Wt = o.ag(Tt, z.zoom), ci = f.style.map.terrain && f.style.map.terrain.getTerrainData(Te);
          let si, qi, Ti, Ni, Wi = [0, 0], bi = null;
          if (u) qi = qe.glyphAtlasTexture, Ti = E.LINEAR, si = qe.glyphAtlasTexture.size, He.iconsInText && (Wi = qe.imageAtlasTexture.size, bi = qe.imageAtlasTexture, Ni = ii || f.options.rotating || f.options.zooming || Tt.kind === "composite" || Tt.kind === "camera" ? E.LINEAR : E.NEAREST);
          else {
            const sr = n.layout.get("icon-size").constantOr(0) !== 1 || He.iconsNeedLinear;
            qi = qe.imageAtlasTexture, Ti = ft || f.options.rotating || f.options.zooming || sr || ii ? E.LINEAR : E.NEAREST, si = qe.imageAtlasTexture.size;
          }
          const Gi = ti(qe, 1, f.transform.zoom), fr = Q ? Te.posMatrix : hn, ur = nn(fr, G, R, f.transform, Gi), Tr = Oi(fr, G, R, f.transform, Gi), kr = Oi(Te.posMatrix, G, R, f.transform, Gi), qr = N.translatePosition(f.transform, qe, m, T), In = le && He.hasTextData(), Lr = n.layout.get("icon-text-fit") !== "none" && In && He.hasIconData();
          if (ie) {
            const sr = f.style.map.terrain ? (Oa, vr) => f.style.map.terrain.getElevation(Te, Oa, vr) : null, Zs = n.layout.get("text-rotation-alignment") === "map";
            W(He, Te.posMatrix, f, u, ur, kr, G, p, Zs, N, Te.toUnwrapped(), z.width, z.height, qr, sr);
          }
          const nr = Te.posMatrix, Zr = u && le || Lr, Tn = ie || Zr ? hn : ur, kn = Tr, Li = ft && n.paint.get(u ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let Ur;
          Ur = ft ? He.iconsInText ? kl(Tt.kind, Wt, H, G, ie, Zr, f, nr, Tn, kn, qr, si, Wi, Ne) : tl(Tt.kind, Wt, H, G, ie, Zr, f, nr, Tn, kn, qr, u, si, !0, Ne) : io(Tt.kind, Wt, H, G, ie, Zr, f, nr, Tn, kn, qr, u, si, Ne);
          const zr = { program: Mt, buffers: vt, uniformValues: Ur, atlasTexture: qi, atlasTextureIcon: bi, atlasInterpolation: Ti, atlasInterpolationIcon: Ni, isSDF: ft, hasHalo: Li };
          if (ue && He.canOverlap) {
            ce = !0;
            const sr = vt.segments.get();
            for (const Zs of sr) De.push({ segments: new o.$([Zs]), sortKey: Zs.sortKey, state: zr, terrainData: ci });
          } else De.push({ segments: vt.segments, sortKey: 0, state: zr, terrainData: ci });
        }
        ce && De.sort((Te, qe) => Te.sortKey - qe.sortKey);
        for (const Te of De) {
          const qe = Te.state;
          if (C.activeTexture.set(E.TEXTURE0), qe.atlasTexture.bind(qe.atlasInterpolation, E.CLAMP_TO_EDGE), qe.atlasTextureIcon && (C.activeTexture.set(E.TEXTURE1), qe.atlasTextureIcon && qe.atlasTextureIcon.bind(qe.atlasInterpolationIcon, E.CLAMP_TO_EDGE)), qe.isSDF) {
            const He = qe.uniformValues;
            qe.hasHalo && (He.u_is_halo = 1, pa(qe.buffers, Te.segments, n, f, qe.program, ne, b, P, He, Te.terrainData)), He.u_is_halo = 0;
          }
          pa(qe.buffers, Te.segments, n, f, qe.program, ne, b, P, qe.uniformValues, Te.terrainData);
        }
      }
      function pa(f, t, n, c, u, m, T, s, l, p) {
        const b = c.context;
        u.draw(b, b.gl.TRIANGLES, m, T, s, Ai.disabled, l, p, n.id, f.layoutVertexBuffer, f.indexBuffer, t, n.paint, c.transform.zoom, f.programConfigurations.get(n.id), f.dynamicLayoutVertexBuffer, f.opacityVertexBuffer);
      }
      function zn(f, t, n, c, u) {
        if (!n || !c || !c.imageAtlas) return;
        const m = c.imageAtlas.patternPositions;
        let T = m[n.to.toString()], s = m[n.from.toString()];
        if (!T && s && (T = s), !s && T && (s = T), !T || !s) {
          const l = u.getPaintProperty(t);
          T = m[l], s = m[l];
        }
        T && s && f.setConstantPatternPositions(T, s);
      }
      function Fn(f, t, n, c, u, m, T) {
        const s = f.context.gl, l = "fill-pattern", p = n.paint.get(l), b = p && p.constantOr(1), P = n.getCrossfadeParameters();
        let C, E, z, N, R;
        T ? (E = b && !n.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", C = s.LINES) : (E = b ? "fillPattern" : "fill", C = s.TRIANGLES);
        const G = p.constantOr(null);
        for (const ie of c) {
          const H = t.getTile(ie);
          if (b && !H.patternsLoaded()) continue;
          const Q = H.getBucket(n);
          if (!Q) continue;
          const ue = Q.programConfigurations.get(n.id), ce = f.useProgram(E, ue), ne = f.style.map.terrain && f.style.map.terrain.getTerrainData(ie);
          b && (f.context.activeTexture.set(s.TEXTURE0), H.imageAtlasTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), ue.updatePaintBuffers(P)), zn(ue, l, G, H, n);
          const le = ne ? ie : null, De = f.translatePosMatrix(le ? le.posMatrix : ie.posMatrix, H, n.paint.get("fill-translate"), n.paint.get("fill-translate-anchor"));
          if (T) {
            N = Q.indexBuffer2, R = Q.segments2;
            const Ne = [s.drawingBufferWidth, s.drawingBufferHeight];
            z = E === "fillOutlinePattern" && b ? La(De, f, P, H, Ne) : Ya(De, Ne);
          } else N = Q.indexBuffer, R = Q.segments, z = b ? ka(De, f, P, H) : na(De);
          ce.draw(f.context, C, u, f.stencilModeForClipping(ie), m, Ai.disabled, z, ne, n.id, Q.layoutVertexBuffer, N, R, n.paint, f.transform.zoom, ue);
        }
      }
      function Hi(f, t, n, c, u, m, T) {
        const s = f.context, l = s.gl, p = "fill-extrusion-pattern", b = n.paint.get(p), P = b.constantOr(1), C = n.getCrossfadeParameters(), E = n.paint.get("fill-extrusion-opacity"), z = b.constantOr(null);
        for (const N of c) {
          const R = t.getTile(N), G = R.getBucket(n);
          if (!G) continue;
          const ie = f.style.map.terrain && f.style.map.terrain.getTerrainData(N), H = G.programConfigurations.get(n.id), Q = f.useProgram(P ? "fillExtrusionPattern" : "fillExtrusion", H);
          P && (f.context.activeTexture.set(l.TEXTURE0), R.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), H.updatePaintBuffers(C)), zn(H, p, z, R, n);
          const ue = f.translatePosMatrix(N.posMatrix, R, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")), ce = n.paint.get("fill-extrusion-vertical-gradient"), ne = P ? Eo(ue, f, ce, E, N, C, R) : ra(ue, f, ce, E);
          Q.draw(s, s.gl.TRIANGLES, u, m, T, Ai.backCCW, ne, ie, n.id, G.layoutVertexBuffer, G.indexBuffer, G.segments, n.paint, f.transform.zoom, H, f.style.map.terrain && G.centroidVertexBuffer);
        }
      }
      function Ma(f, t, n, c, u, m, T) {
        const s = f.context, l = s.gl, p = n.fbo;
        if (!p) return;
        const b = f.useProgram("hillshade"), P = f.style.map.terrain && f.style.map.terrain.getTerrainData(t);
        s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, p.colorAttachment.get()), b.draw(s, l.TRIANGLES, u, m, T, Ai.disabled, ((C, E, z, N) => {
          const R = z.paint.get("hillshade-shadow-color"), G = z.paint.get("hillshade-highlight-color"), ie = z.paint.get("hillshade-accent-color");
          let H = z.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          z.paint.get("hillshade-illumination-anchor") === "viewport" && (H -= C.transform.angle);
          const Q = !C.options.moving;
          return { u_matrix: N ? N.posMatrix : C.transform.calculatePosMatrix(E.tileID.toUnwrapped(), Q), u_image: 0, u_latrange: Ka(0, E.tileID), u_light: [z.paint.get("hillshade-exaggeration"), H], u_shadow: R, u_highlight: G, u_accent: ie };
        })(f, n, c, P ? t : null), P, c.id, f.rasterBoundsBuffer, f.quadTriangleIndexBuffer, f.rasterBoundsSegments);
      }
      function Da(f, t, n, c, u, m) {
        const T = f.context, s = T.gl, l = t.dem;
        if (l && l.data) {
          const p = l.dim, b = l.stride, P = l.getPixels();
          if (T.activeTexture.set(s.TEXTURE1), T.pixelStoreUnpackPremultiplyAlpha.set(!1), t.demTexture = t.demTexture || f.getTileTexture(b), t.demTexture) {
            const E = t.demTexture;
            E.update(P, { premultiply: !1 }), E.bind(s.NEAREST, s.CLAMP_TO_EDGE);
          } else t.demTexture = new ae(T, P, s.RGBA, { premultiply: !1 }), t.demTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE);
          T.activeTexture.set(s.TEXTURE0);
          let C = t.fbo;
          if (!C) {
            const E = new ae(T, { width: p, height: p, data: null }, s.RGBA);
            E.bind(s.LINEAR, s.CLAMP_TO_EDGE), C = t.fbo = T.createFramebuffer(p, p, !0, !1), C.colorAttachment.set(E.texture);
          }
          T.bindFramebuffer.set(C.framebuffer), T.viewport.set([0, 0, p, p]), f.useProgram("hillshadePrepare").draw(T, s.TRIANGLES, c, u, m, Ai.disabled, ((E, z) => {
            const N = z.stride, R = o.F();
            return o.aO(R, 0, o.W, -o.W, 0, 0, 1), o.H(R, R, [0, -o.W, 0]), { u_matrix: R, u_image: 1, u_dimension: [N, N], u_zoom: E.overscaledZ, u_unpack: z.getUnpackVector() };
          })(t.tileID, l), null, n.id, f.rasterBoundsBuffer, f.quadTriangleIndexBuffer, f.rasterBoundsSegments), t.needsHillshadePrepare = !1;
        }
      }
      function fa(f, t, n, c, u, m) {
        const T = c.paint.get("raster-fade-duration");
        if (!m && T > 0) {
          const s = q.now(), l = (s - f.timeAdded) / T, p = t ? (s - t.timeAdded) / T : -1, b = n.getSource(), P = u.coveringZoomLevel({ tileSize: b.tileSize, roundZoom: b.roundZoom }), C = !t || Math.abs(t.tileID.overscaledZ - P) > Math.abs(f.tileID.overscaledZ - P), E = C && f.refreshedUponExpiration ? 1 : o.ac(C ? l : 1 - p, 0, 1);
          return f.refreshedUponExpiration && l >= 1 && (f.refreshedUponExpiration = !1), t ? { opacity: 1, mix: 1 - E } : { opacity: E, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const es = new o.aP(1, 0, 0, 1), $r = new o.aP(0, 1, 0, 1), co = new o.aP(0, 0, 1, 1), Rs = new o.aP(1, 0, 1, 1), za = new o.aP(0, 1, 1, 1);
      function Sn(f, t, n, c) {
        is(f, 0, t + n / 2, f.transform.width, n, c);
      }
      function ts(f, t, n, c) {
        is(f, t - n / 2, 0, n, f.transform.height, c);
      }
      function is(f, t, n, c, u, m) {
        const T = f.context, s = T.gl;
        s.enable(s.SCISSOR_TEST), s.scissor(t * f.pixelRatio, n * f.pixelRatio, c * f.pixelRatio, u * f.pixelRatio), T.clear({ color: m }), s.disable(s.SCISSOR_TEST);
      }
      function al(f, t, n) {
        const c = f.context, u = c.gl, m = n.posMatrix, T = f.useProgram("debug"), s = Zt.disabled, l = Si.disabled, p = f.colorModeForRenderPass(), b = "$debug", P = f.style.map.terrain && f.style.map.terrain.getTerrainData(n);
        c.activeTexture.set(u.TEXTURE0);
        const C = t.getTileByID(n.key).latestRawTileData, E = Math.floor((C && C.byteLength || 0) / 1024), z = t.getTile(n).tileSize, N = 512 / Math.min(z, 512) * (n.overscaledZ / f.transform.zoom) * 0.5;
        let R = n.canonical.toString();
        n.overscaledZ !== n.canonical.z && (R += ` => ${n.overscaledZ}`), function(G, ie) {
          G.initDebugOverlayCanvas();
          const H = G.debugOverlayCanvas, Q = G.context.gl, ue = G.debugOverlayCanvas.getContext("2d");
          ue.clearRect(0, 0, H.width, H.height), ue.shadowColor = "white", ue.shadowBlur = 2, ue.lineWidth = 1.5, ue.strokeStyle = "white", ue.textBaseline = "top", ue.font = "bold 36px Open Sans, sans-serif", ue.fillText(ie, 5, 5), ue.strokeText(ie, 5, 5), G.debugOverlayTexture.update(H), G.debugOverlayTexture.bind(Q.LINEAR, Q.CLAMP_TO_EDGE);
        }(f, `${R} ${E}kB`), T.draw(c, u.TRIANGLES, s, l, Yt.alphaBlended, Ai.disabled, sa(m, o.aP.transparent, N), null, b, f.debugBuffer, f.quadTriangleIndexBuffer, f.debugSegments), T.draw(c, u.LINE_STRIP, s, l, p, Ai.disabled, sa(m, o.aP.red), P, b, f.debugBuffer, f.tileBorderIndexBuffer, f.debugSegments);
      }
      function rs(f, t, n) {
        const c = f.context, u = c.gl, m = f.colorModeForRenderPass(), T = new Zt(u.LEQUAL, Zt.ReadWrite, f.depthRangeFor3D), s = f.useProgram("terrain"), l = t.getTerrainMesh();
        c.bindFramebuffer.set(null), c.viewport.set([0, 0, f.width, f.height]);
        for (const p of n) {
          const b = f.renderToTexture.getTexture(p), P = t.getTerrainData(p.tileID);
          c.activeTexture.set(u.TEXTURE0), u.bindTexture(u.TEXTURE_2D, b.texture);
          const C = { u_matrix: f.transform.calculatePosMatrix(p.tileID.toUnwrapped()), u_texture: 0, u_ele_delta: t.getMeshFrameDelta(f.transform.zoom) };
          s.draw(c, u.TRIANGLES, T, Si.disabled, m, Ai.backCCW, C, P, "terrain", l.vertexBuffer, l.indexBuffer, l.segments);
        }
      }
      class _i {
        constructor(t, n) {
          this.context = new Di(t), this.transform = n, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: o.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = lt.maxUnderzooming + lt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ir();
        }
        resize(t, n, c) {
          if (this.width = Math.floor(t * c), this.height = Math.floor(n * c), this.pixelRatio = c, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const u of this.style._order) this.style._layers[u].resize();
        }
        setup() {
          const t = this.context, n = new o.aW();
          n.emplaceBack(0, 0), n.emplaceBack(o.W, 0), n.emplaceBack(0, o.W), n.emplaceBack(o.W, o.W), this.tileExtentBuffer = t.createVertexBuffer(n, Ar.members), this.tileExtentSegments = o.$.simpleSegment(0, 0, 4, 2);
          const c = new o.aW();
          c.emplaceBack(0, 0), c.emplaceBack(o.W, 0), c.emplaceBack(0, o.W), c.emplaceBack(o.W, o.W), this.debugBuffer = t.createVertexBuffer(c, Ar.members), this.debugSegments = o.$.simpleSegment(0, 0, 4, 5);
          const u = new o.Z();
          u.emplaceBack(0, 0, 0, 0), u.emplaceBack(o.W, 0, o.W, 0), u.emplaceBack(0, o.W, 0, o.W), u.emplaceBack(o.W, o.W, o.W, o.W), this.rasterBoundsBuffer = t.createVertexBuffer(u, _t.members), this.rasterBoundsSegments = o.$.simpleSegment(0, 0, 4, 2);
          const m = new o.aW();
          m.emplaceBack(0, 0), m.emplaceBack(1, 0), m.emplaceBack(0, 1), m.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(m, Ar.members), this.viewportSegments = o.$.simpleSegment(0, 0, 4, 2);
          const T = new o.aX();
          T.emplaceBack(0), T.emplaceBack(1), T.emplaceBack(3), T.emplaceBack(2), T.emplaceBack(0), this.tileBorderIndexBuffer = t.createIndexBuffer(T);
          const s = new o.aY();
          s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(s);
          const l = this.context.gl;
          this.stencilClearMode = new Si({ func: l.ALWAYS, mask: 0 }, 0, 255, l.ZERO, l.ZERO, l.ZERO);
        }
        clearStencil() {
          const t = this.context, n = t.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const c = o.F();
          o.aO(c, 0, this.width, this.height, 0, 0, 1), o.J(c, c, [n.drawingBufferWidth, n.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(t, n.TRIANGLES, Zt.disabled, this.stencilClearMode, Yt.disabled, Ai.disabled, Mo(c), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(t, n) {
          if (this.currentStencilSource === t.source || !t.isTileClipped() || !n || !n.length) return;
          this.currentStencilSource = t.source;
          const c = this.context, u = c.gl;
          this.nextStencilID + n.length > 256 && this.clearStencil(), c.setColorMode(Yt.disabled), c.setDepthMode(Zt.disabled);
          const m = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const T of n) {
            const s = this._tileClippingMaskIDs[T.key] = this.nextStencilID++, l = this.style.map.terrain && this.style.map.terrain.getTerrainData(T);
            m.draw(c, u.TRIANGLES, Zt.disabled, new Si({ func: u.ALWAYS, mask: 0 }, s, 255, u.KEEP, u.KEEP, u.REPLACE), Yt.disabled, Ai.disabled, Mo(T.posMatrix), l, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t = this.nextStencilID++, n = this.context.gl;
          return new Si({ func: n.NOTEQUAL, mask: 255 }, t, 255, n.KEEP, n.KEEP, n.REPLACE);
        }
        stencilModeForClipping(t) {
          const n = this.context.gl;
          return new Si({ func: n.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, n.KEEP, n.KEEP, n.REPLACE);
        }
        stencilConfigForOverlap(t) {
          const n = this.context.gl, c = t.sort((T, s) => s.overscaledZ - T.overscaledZ), u = c[c.length - 1].overscaledZ, m = c[0].overscaledZ - u + 1;
          if (m > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + m > 256 && this.clearStencil();
            const T = {};
            for (let s = 0; s < m; s++) T[s + u] = new Si({ func: n.GEQUAL, mask: 255 }, s + this.nextStencilID, 255, n.KEEP, n.KEEP, n.REPLACE);
            return this.nextStencilID += m, [T, c];
          }
          return [{ [u]: Si.disabled }, c];
        }
        colorModeForRenderPass() {
          const t = this.context.gl;
          return this._showOverdrawInspector ? new Yt([t.CONSTANT_COLOR, t.ONE], new o.aP(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Yt.unblended : Yt.alphaBlended;
        }
        depthModeForSublayer(t, n, c) {
          if (!this.opaquePassEnabledForLayer()) return Zt.disabled;
          const u = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
          return new Zt(c || this.context.gl.LEQUAL, n, [u, u]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t, n) {
          this.style = t, this.options = n, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(q.now()), this.imageManager.beginFrame();
          const c = this.style._order, u = this.style.sourceCaches, m = {}, T = {}, s = {};
          for (const l in u) {
            const p = u[l];
            p.used && p.prepare(this.context), m[l] = p.getVisibleCoordinates(), T[l] = m[l].slice().reverse(), s[l] = p.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let l = 0; l < c.length; l++) if (this.style._layers[c[l]].is3D()) {
            this.opaquePassCutoff = l;
            break;
          }
          this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const l of c) {
            const p = this.style._layers[l];
            if (!p.hasOffscreenPass() || p.isHidden(this.transform.zoom)) continue;
            const b = T[p.source];
            (p.type === "custom" || b.length) && this.renderLayer(this, u[p.source], p, b);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: n.showOverdrawInspector ? o.aP.black : o.aP.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = n.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = c.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const l = this.style._layers[c[this.currentLayer]], p = u[l.source], b = m[l.source];
            this._renderTileClippingMasks(l, b), this.renderLayer(this, p, l, b);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < c.length; this.currentLayer++) {
            const l = this.style._layers[c[this.currentLayer]], p = u[l.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(l)) continue;
            const b = (l.type === "symbol" ? s : T)[l.source];
            this._renderTileClippingMasks(l, m[l.source]), this.renderLayer(this, p, l, b);
          }
          if (this.options.showTileBoundaries) {
            const l = function(p, b) {
              let P = null;
              const C = Object.values(p._layers).flatMap((R) => R.source && !R.isHidden(b) ? [p.sourceCaches[R.source]] : []), E = C.filter((R) => R.getSource().type === "vector"), z = C.filter((R) => R.getSource().type !== "vector"), N = (R) => {
                (!P || P.getSource().maxzoom < R.getSource().maxzoom) && (P = R);
              };
              return E.forEach((R) => N(R)), P || z.forEach((R) => N(R)), P;
            }(this.style, this.transform.zoom);
            l && function(p, b, P) {
              for (let C = 0; C < P.length; C++) al(p, b, P[C]);
            }(this, l, l.getVisibleCoordinates());
          }
          this.options.showPadding && function(l) {
            const p = l.transform.padding;
            Sn(l, l.transform.height - (p.top || 0), 3, es), Sn(l, p.bottom || 0, 3, $r), ts(l, p.left || 0, 3, co), ts(l, l.transform.width - (p.right || 0), 3, Rs);
            const b = l.transform.centerPoint;
            (function(P, C, E, z) {
              is(P, C - 1, E - 10, 2, 20, z), is(P, C - 10, E - 1, 20, 2, z);
            })(l, b.x, l.transform.height - b.y, za);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(t) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          const n = this.terrainFacilitator.matrix, c = this.transform.modelViewProjectionMatrix;
          let u = this.terrainFacilitator.dirty;
          u || (u = t ? !o.aZ(n, c) : !o.a_(n, c)), u || (u = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), u && (o.a$(n, c), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(m, T) {
            const s = m.context, l = s.gl, p = Yt.unblended, b = new Zt(l.LEQUAL, Zt.ReadWrite, [0, 1]), P = T.getTerrainMesh(), C = T.sourceCache.getRenderableTiles(), E = m.useProgram("terrainDepth");
            s.bindFramebuffer.set(T.getFramebuffer("depth").framebuffer), s.viewport.set([0, 0, m.width / devicePixelRatio, m.height / devicePixelRatio]), s.clear({ color: o.aP.transparent, depth: 1 });
            for (const z of C) {
              const N = T.getTerrainData(z.tileID), R = { u_matrix: m.transform.calculatePosMatrix(z.tileID.toUnwrapped()), u_ele_delta: T.getMeshFrameDelta(m.transform.zoom) };
              E.draw(s, l.TRIANGLES, b, Si.disabled, p, Ai.backCCW, R, N, "terrain", P.vertexBuffer, P.indexBuffer, P.segments);
            }
            s.bindFramebuffer.set(null), s.viewport.set([0, 0, m.width, m.height]);
          }(this, this.style.map.terrain), function(m, T) {
            const s = m.context, l = s.gl, p = Yt.unblended, b = new Zt(l.LEQUAL, Zt.ReadWrite, [0, 1]), P = T.getTerrainMesh(), C = T.getCoordsTexture(), E = T.sourceCache.getRenderableTiles(), z = m.useProgram("terrainCoords");
            s.bindFramebuffer.set(T.getFramebuffer("coords").framebuffer), s.viewport.set([0, 0, m.width / devicePixelRatio, m.height / devicePixelRatio]), s.clear({ color: o.aP.transparent, depth: 1 }), T.coordsIndex = [];
            for (const N of E) {
              const R = T.getTerrainData(N.tileID);
              s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, C.texture);
              const G = { u_matrix: m.transform.calculatePosMatrix(N.tileID.toUnwrapped()), u_terrain_coords_id: (255 - T.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: T.getMeshFrameDelta(m.transform.zoom) };
              z.draw(s, l.TRIANGLES, b, Si.disabled, p, Ai.backCCW, G, R, "terrain", P.vertexBuffer, P.indexBuffer, P.segments), T.coordsIndex.push(N.tileID.key);
            }
            s.bindFramebuffer.set(null), s.viewport.set([0, 0, m.width, m.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(t, n, c, u) {
          if (!c.isHidden(this.transform.zoom) && (c.type === "background" || c.type === "custom" || (u || []).length)) switch (this.id = c.id, c.type) {
            case "symbol":
              (function(m, T, s, l, p) {
                if (m.renderPass !== "translucent") return;
                const b = Si.disabled, P = m.colorModeForRenderPass();
                (s._unevaluatedLayout.hasValue("text-variable-anchor") || s._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(C, E, z, N, R, G, ie, H, Q) {
                  const ue = E.transform, ce = Kr(), ne = R === "map", le = G === "map";
                  for (const De of C) {
                    const Ne = N.getTile(De), Te = Ne.getBucket(z);
                    if (!Te || !Te.text || !Te.text.segments.get().length) continue;
                    const qe = o.ag(Te.textSizeData, ue.zoom), He = ti(Ne, 1, E.transform.zoom), vt = nn(De.posMatrix, le, ne, E.transform, He), Ue = z.layout.get("icon-text-fit") !== "none" && Te.hasIconData();
                    if (qe) {
                      const ft = Math.pow(2, ue.zoom - Ne.tileID.overscaledZ), Tt = E.style.map.terrain ? (Mt, Wt) => E.style.map.terrain.getElevation(De, Mt, Wt) : null, ii = ce.translatePosition(ue, Ne, ie, H);
                      ua(Te, ne, le, Q, ue, vt, De.posMatrix, ft, qe, Ue, ce, ii, De.toUnwrapped(), Tt);
                    }
                  }
                }(l, m, s, T, s.layout.get("text-rotation-alignment"), s.layout.get("text-pitch-alignment"), s.paint.get("text-translate"), s.paint.get("text-translate-anchor"), p), s.paint.get("icon-opacity").constantOr(1) !== 0 && gs(m, T, s, l, !1, s.paint.get("icon-translate"), s.paint.get("icon-translate-anchor"), s.layout.get("icon-rotation-alignment"), s.layout.get("icon-pitch-alignment"), s.layout.get("icon-keep-upright"), b, P), s.paint.get("text-opacity").constantOr(1) !== 0 && gs(m, T, s, l, !0, s.paint.get("text-translate"), s.paint.get("text-translate-anchor"), s.layout.get("text-rotation-alignment"), s.layout.get("text-pitch-alignment"), s.layout.get("text-keep-upright"), b, P), T.map.showCollisionBoxes && (Dn(m, T, s, l, !0), Dn(m, T, s, l, !1));
              })(t, n, c, u, this.style.placement.variableOffsets);
              break;
            case "circle":
              (function(m, T, s, l) {
                if (m.renderPass !== "translucent") return;
                const p = s.paint.get("circle-opacity"), b = s.paint.get("circle-stroke-width"), P = s.paint.get("circle-stroke-opacity"), C = !s.layout.get("circle-sort-key").isConstant();
                if (p.constantOr(1) === 0 && (b.constantOr(1) === 0 || P.constantOr(1) === 0)) return;
                const E = m.context, z = E.gl, N = m.depthModeForSublayer(0, Zt.ReadOnly), R = Si.disabled, G = m.colorModeForRenderPass(), ie = [];
                for (let H = 0; H < l.length; H++) {
                  const Q = l[H], ue = T.getTile(Q), ce = ue.getBucket(s);
                  if (!ce) continue;
                  const ne = ce.programConfigurations.get(s.id), le = m.useProgram("circle", ne), De = ce.layoutVertexBuffer, Ne = ce.indexBuffer, Te = m.style.map.terrain && m.style.map.terrain.getTerrainData(Q), qe = { programConfiguration: ne, program: le, layoutVertexBuffer: De, indexBuffer: Ne, uniformValues: Es(m, Q, ue, s), terrainData: Te };
                  if (C) {
                    const He = ce.segments.get();
                    for (const vt of He) ie.push({ segments: new o.$([vt]), sortKey: vt.sortKey, state: qe });
                  } else ie.push({ segments: ce.segments, sortKey: 0, state: qe });
                }
                C && ie.sort((H, Q) => H.sortKey - Q.sortKey);
                for (const H of ie) {
                  const { programConfiguration: Q, program: ue, layoutVertexBuffer: ce, indexBuffer: ne, uniformValues: le, terrainData: De } = H.state;
                  ue.draw(E, z.TRIANGLES, N, R, G, Ai.disabled, le, De, s.id, ce, ne, H.segments, s.paint, m.transform.zoom, Q);
                }
              })(t, n, c, u);
              break;
            case "heatmap":
              (function(m, T, s, l) {
                if (s.paint.get("heatmap-opacity") !== 0) if (m.renderPass === "offscreen") {
                  const p = m.context, b = p.gl, P = Si.disabled, C = new Yt([b.ONE, b.ONE], o.aP.transparent, [!0, !0, !0, !0]);
                  (function(E, z, N) {
                    const R = E.gl;
                    E.activeTexture.set(R.TEXTURE1), E.viewport.set([0, 0, z.width / 4, z.height / 4]);
                    let G = N.heatmapFbo;
                    if (G) R.bindTexture(R.TEXTURE_2D, G.colorAttachment.get()), E.bindFramebuffer.set(G.framebuffer);
                    else {
                      const ie = R.createTexture();
                      R.bindTexture(R.TEXTURE_2D, ie), R.texParameteri(R.TEXTURE_2D, R.TEXTURE_WRAP_S, R.CLAMP_TO_EDGE), R.texParameteri(R.TEXTURE_2D, R.TEXTURE_WRAP_T, R.CLAMP_TO_EDGE), R.texParameteri(R.TEXTURE_2D, R.TEXTURE_MIN_FILTER, R.LINEAR), R.texParameteri(R.TEXTURE_2D, R.TEXTURE_MAG_FILTER, R.LINEAR), G = N.heatmapFbo = E.createFramebuffer(z.width / 4, z.height / 4, !1, !1), function(H, Q, ue, ce) {
                        var ne, le;
                        const De = H.gl, Ne = (ne = H.HALF_FLOAT) !== null && ne !== void 0 ? ne : De.UNSIGNED_BYTE, Te = (le = H.RGBA16F) !== null && le !== void 0 ? le : De.RGBA;
                        De.texImage2D(De.TEXTURE_2D, 0, Te, Q.width / 4, Q.height / 4, 0, De.RGBA, Ne, null), ce.colorAttachment.set(ue);
                      }(E, z, ie, G);
                    }
                  })(p, m, s), p.clear({ color: o.aP.transparent });
                  for (let E = 0; E < l.length; E++) {
                    const z = l[E];
                    if (T.hasRenderableParent(z)) continue;
                    const N = T.getTile(z), R = N.getBucket(s);
                    if (!R) continue;
                    const G = R.programConfigurations.get(s.id), ie = m.useProgram("heatmap", G), { zoom: H } = m.transform;
                    ie.draw(p, b.TRIANGLES, Zt.disabled, P, C, Ai.disabled, _r(z.posMatrix, N, H, s.paint.get("heatmap-intensity")), null, s.id, R.layoutVertexBuffer, R.indexBuffer, R.segments, s.paint, m.transform.zoom, G);
                  }
                  p.viewport.set([0, 0, m.width, m.height]);
                } else m.renderPass === "translucent" && (m.context.setColorMode(m.colorModeForRenderPass()), function(p, b) {
                  const P = p.context, C = P.gl, E = b.heatmapFbo;
                  if (!E) return;
                  P.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, E.colorAttachment.get()), P.activeTexture.set(C.TEXTURE1);
                  let z = b.colorRampTexture;
                  z || (z = b.colorRampTexture = new ae(P, b.colorRamp, C.RGBA)), z.bind(C.LINEAR, C.CLAMP_TO_EDGE), p.useProgram("heatmapTexture").draw(P, C.TRIANGLES, Zt.disabled, Si.disabled, p.colorModeForRenderPass(), Ai.disabled, ((N, R, G, ie) => {
                    const H = o.F();
                    o.aO(H, 0, N.width, N.height, 0, 0, 1);
                    const Q = N.context.gl;
                    return { u_matrix: H, u_world: [Q.drawingBufferWidth, Q.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: R.paint.get("heatmap-opacity") };
                  })(p, b), null, b.id, p.viewportBuffer, p.quadTriangleIndexBuffer, p.viewportSegments, b.paint, p.transform.zoom);
                }(m, s));
              })(t, n, c, u);
              break;
            case "line":
              (function(m, T, s, l) {
                if (m.renderPass !== "translucent") return;
                const p = s.paint.get("line-opacity"), b = s.paint.get("line-width");
                if (p.constantOr(1) === 0 || b.constantOr(1) === 0) return;
                const P = m.depthModeForSublayer(0, Zt.ReadOnly), C = m.colorModeForRenderPass(), E = s.paint.get("line-dasharray"), z = s.paint.get("line-pattern"), N = z.constantOr(1), R = s.paint.get("line-gradient"), G = s.getCrossfadeParameters(), ie = N ? "linePattern" : E ? "lineSDF" : R ? "lineGradient" : "line", H = m.context, Q = H.gl;
                let ue = !0;
                for (const ce of l) {
                  const ne = T.getTile(ce);
                  if (N && !ne.patternsLoaded()) continue;
                  const le = ne.getBucket(s);
                  if (!le) continue;
                  const De = le.programConfigurations.get(s.id), Ne = m.context.program.get(), Te = m.useProgram(ie, De), qe = ue || Te.program !== Ne, He = m.style.map.terrain && m.style.map.terrain.getTerrainData(ce), vt = z.constantOr(null);
                  if (vt && ne.imageAtlas) {
                    const Tt = ne.imageAtlas, ii = Tt.patternPositions[vt.to.toString()], Mt = Tt.patternPositions[vt.from.toString()];
                    ii && Mt && De.setConstantPatternPositions(ii, Mt);
                  }
                  const Ue = He ? ce : null, ft = N ? Do(m, ne, s, G, Ue) : E ? Qa(m, ne, s, E, G, Ue) : R ? ri(m, ne, s, le.lineClipsArray.length, Ue) : Rr(m, ne, s, Ue);
                  if (N) H.activeTexture.set(Q.TEXTURE0), ne.imageAtlasTexture.bind(Q.LINEAR, Q.CLAMP_TO_EDGE), De.updatePaintBuffers(G);
                  else if (E && (qe || m.lineAtlas.dirty)) H.activeTexture.set(Q.TEXTURE0), m.lineAtlas.bind(H);
                  else if (R) {
                    const Tt = le.gradients[s.id];
                    let ii = Tt.texture;
                    if (s.gradientVersion !== Tt.version) {
                      let Mt = 256;
                      if (s.stepInterpolant) {
                        const Wt = T.getSource().maxzoom, ci = ce.canonical.z === Wt ? Math.ceil(1 << m.transform.maxZoom - ce.canonical.z) : 1;
                        Mt = o.ac(o.aU(le.maxLineLength / o.W * 1024 * ci), 256, H.maxTextureSize);
                      }
                      Tt.gradient = o.aV({ expression: s.gradientExpression(), evaluationKey: "lineProgress", resolution: Mt, image: Tt.gradient || void 0, clips: le.lineClipsArray }), Tt.texture ? Tt.texture.update(Tt.gradient) : Tt.texture = new ae(H, Tt.gradient, Q.RGBA), Tt.version = s.gradientVersion, ii = Tt.texture;
                    }
                    H.activeTexture.set(Q.TEXTURE0), ii.bind(s.stepInterpolant ? Q.NEAREST : Q.LINEAR, Q.CLAMP_TO_EDGE);
                  }
                  Te.draw(H, Q.TRIANGLES, P, m.stencilModeForClipping(ce), C, Ai.disabled, ft, He, s.id, le.layoutVertexBuffer, le.indexBuffer, le.segments, s.paint, m.transform.zoom, De, le.layoutVertexBuffer2), ue = !1;
                }
              })(t, n, c, u);
              break;
            case "fill":
              (function(m, T, s, l) {
                const p = s.paint.get("fill-color"), b = s.paint.get("fill-opacity");
                if (b.constantOr(1) === 0) return;
                const P = m.colorModeForRenderPass(), C = s.paint.get("fill-pattern"), E = m.opaquePassEnabledForLayer() && !C.constantOr(1) && p.constantOr(o.aP.transparent).a === 1 && b.constantOr(0) === 1 ? "opaque" : "translucent";
                if (m.renderPass === E) {
                  const z = m.depthModeForSublayer(1, m.renderPass === "opaque" ? Zt.ReadWrite : Zt.ReadOnly);
                  Fn(m, T, s, l, z, P, !1);
                }
                if (m.renderPass === "translucent" && s.paint.get("fill-antialias")) {
                  const z = m.depthModeForSublayer(s.getPaintProperty("fill-outline-color") ? 2 : 0, Zt.ReadOnly);
                  Fn(m, T, s, l, z, P, !0);
                }
              })(t, n, c, u);
              break;
            case "fill-extrusion":
              (function(m, T, s, l) {
                const p = s.paint.get("fill-extrusion-opacity");
                if (p !== 0 && m.renderPass === "translucent") {
                  const b = new Zt(m.context.gl.LEQUAL, Zt.ReadWrite, m.depthRangeFor3D);
                  if (p !== 1 || s.paint.get("fill-extrusion-pattern").constantOr(1)) Hi(m, T, s, l, b, Si.disabled, Yt.disabled), Hi(m, T, s, l, b, m.stencilModeFor3D(), m.colorModeForRenderPass());
                  else {
                    const P = m.colorModeForRenderPass();
                    Hi(m, T, s, l, b, Si.disabled, P);
                  }
                }
              })(t, n, c, u);
              break;
            case "hillshade":
              (function(m, T, s, l) {
                if (m.renderPass !== "offscreen" && m.renderPass !== "translucent") return;
                const p = m.context, b = m.depthModeForSublayer(0, Zt.ReadOnly), P = m.colorModeForRenderPass(), [C, E] = m.renderPass === "translucent" ? m.stencilConfigForOverlap(l) : [{}, l];
                for (const z of E) {
                  const N = T.getTile(z);
                  N.needsHillshadePrepare !== void 0 && N.needsHillshadePrepare && m.renderPass === "offscreen" ? Da(m, N, s, b, Si.disabled, P) : m.renderPass === "translucent" && Ma(m, z, N, s, b, C[z.overscaledZ], P);
                }
                p.viewport.set([0, 0, m.width, m.height]);
              })(t, n, c, u);
              break;
            case "raster":
              (function(m, T, s, l) {
                if (m.renderPass !== "translucent" || s.paint.get("raster-opacity") === 0 || !l.length) return;
                const p = m.context, b = p.gl, P = T.getSource(), C = m.useProgram("raster"), E = m.colorModeForRenderPass(), [z, N] = P instanceof Lt ? [{}, l] : m.stencilConfigForOverlap(l), R = N[N.length - 1].overscaledZ, G = !m.options.moving;
                for (const ie of N) {
                  const H = m.depthModeForSublayer(ie.overscaledZ - R, s.paint.get("raster-opacity") === 1 ? Zt.ReadWrite : Zt.ReadOnly, b.LESS), Q = T.getTile(ie);
                  Q.registerFadeDuration(s.paint.get("raster-fade-duration"));
                  const ue = T.findLoadedParent(ie, 0), ce = T.findLoadedSibling(ie), ne = fa(Q, ue || ce || null, T, s, m.transform, m.style.map.terrain);
                  let le, De;
                  const Ne = s.paint.get("raster-resampling") === "nearest" ? b.NEAREST : b.LINEAR;
                  p.activeTexture.set(b.TEXTURE0), Q.texture.bind(Ne, b.CLAMP_TO_EDGE, b.LINEAR_MIPMAP_NEAREST), p.activeTexture.set(b.TEXTURE1), ue ? (ue.texture.bind(Ne, b.CLAMP_TO_EDGE, b.LINEAR_MIPMAP_NEAREST), le = Math.pow(2, ue.tileID.overscaledZ - Q.tileID.overscaledZ), De = [Q.tileID.canonical.x * le % 1, Q.tileID.canonical.y * le % 1]) : Q.texture.bind(Ne, b.CLAMP_TO_EDGE, b.LINEAR_MIPMAP_NEAREST);
                  const Te = m.style.map.terrain && m.style.map.terrain.getTerrainData(ie), qe = Te ? ie : null, He = qe ? qe.posMatrix : m.transform.calculatePosMatrix(ie.toUnwrapped(), G), vt = Ms(He, De || [0, 0], le || 1, ne, s);
                  P instanceof Lt ? C.draw(p, b.TRIANGLES, H, Si.disabled, E, Ai.disabled, vt, Te, s.id, P.boundsBuffer, m.quadTriangleIndexBuffer, P.boundsSegments) : C.draw(p, b.TRIANGLES, H, z[ie.overscaledZ], E, Ai.disabled, vt, Te, s.id, m.rasterBoundsBuffer, m.quadTriangleIndexBuffer, m.rasterBoundsSegments);
                }
              })(t, n, c, u);
              break;
            case "background":
              (function(m, T, s, l) {
                const p = s.paint.get("background-color"), b = s.paint.get("background-opacity");
                if (b === 0) return;
                const P = m.context, C = P.gl, E = m.transform, z = E.tileSize, N = s.paint.get("background-pattern");
                if (m.isPatternMissing(N)) return;
                const R = !N && p.a === 1 && b === 1 && m.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (m.renderPass !== R) return;
                const G = Si.disabled, ie = m.depthModeForSublayer(0, R === "opaque" ? Zt.ReadWrite : Zt.ReadOnly), H = m.colorModeForRenderPass(), Q = m.useProgram(N ? "backgroundPattern" : "background"), ue = l || E.coveringTiles({ tileSize: z, terrain: m.style.map.terrain });
                N && (P.activeTexture.set(C.TEXTURE0), m.imageManager.bind(m.context));
                const ce = s.getCrossfadeParameters();
                for (const ne of ue) {
                  const le = l ? ne.posMatrix : m.transform.calculatePosMatrix(ne.toUnwrapped()), De = N ? zo(le, b, m, N, { tileID: ne, tileSize: z }, ce) : Ll(le, b, p), Ne = m.style.map.terrain && m.style.map.terrain.getTerrainData(ne);
                  Q.draw(P, C.TRIANGLES, ie, G, H, Ai.disabled, De, Ne, s.id, m.tileExtentBuffer, m.quadTriangleIndexBuffer, m.tileExtentSegments);
                }
              })(t, 0, c, u);
              break;
            case "custom":
              (function(m, T, s) {
                const l = m.context, p = s.implementation;
                if (m.renderPass === "offscreen") {
                  const b = p.prerender;
                  b && (m.setCustomLayerDefaults(), l.setColorMode(m.colorModeForRenderPass()), b.call(p, l.gl, m.transform.customLayerMatrix()), l.setDirty(), m.setBaseState());
                } else if (m.renderPass === "translucent") {
                  m.setCustomLayerDefaults(), l.setColorMode(m.colorModeForRenderPass()), l.setStencilMode(Si.disabled);
                  const b = p.renderingMode === "3d" ? new Zt(m.context.gl.LEQUAL, Zt.ReadWrite, m.depthRangeFor3D) : m.depthModeForSublayer(0, Zt.ReadOnly);
                  l.setDepthMode(b), p.render(l.gl, m.transform.customLayerMatrix()), l.setDirty(), m.setBaseState(), l.bindFramebuffer.set(null);
                }
              })(t, 0, c);
          }
        }
        translatePosMatrix(t, n, c, u, m) {
          if (!c[0] && !c[1]) return t;
          const T = m ? u === "map" ? this.transform.angle : 0 : u === "viewport" ? -this.transform.angle : 0;
          if (T) {
            const p = Math.sin(T), b = Math.cos(T);
            c = [c[0] * b - c[1] * p, c[0] * p + c[1] * b];
          }
          const s = [m ? c[0] : ti(n, c[0], this.transform.zoom), m ? c[1] : ti(n, c[1], this.transform.zoom), 0], l = new Float32Array(16);
          return o.H(l, t, s), l;
        }
        saveTileTexture(t) {
          const n = this._tileTextures[t.size[0]];
          n ? n.push(t) : this._tileTextures[t.size[0]] = [t];
        }
        getTileTexture(t) {
          const n = this._tileTextures[t];
          return n && n.length > 0 ? n.pop() : null;
        }
        isPatternMissing(t) {
          if (!t) return !1;
          if (!t.from || !t.to) return !0;
          const n = this.imageManager.getPattern(t.from.toString()), c = this.imageManager.getPattern(t.to.toString());
          return !n || !c;
        }
        useProgram(t, n) {
          this.cache = this.cache || {};
          const c = t + (n ? n.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[c] || (this.cache[c] = new Ha(this.context, Dr[t], n, ps[t], this._showOverdrawInspector, this.style.map.terrain)), this.cache[c];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const t = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new ae(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: t, drawingBufferHeight: n } = this.context.gl;
          return this.width !== t || this.height !== n;
        }
      }
      class Qr {
        constructor(t, n) {
          this.points = t, this.planes = n;
        }
        static fromInvProjectionMatrix(t, n, c) {
          const u = Math.pow(2, c), m = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((s) => {
            const l = 1 / (s = o.af([], s, t))[3] / n * u;
            return o.b0(s, s, [l, l, 1 / s[3], l]);
          }), T = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((s) => {
            const l = function(C, E) {
              var z = E[0], N = E[1], R = E[2], G = z * z + N * N + R * R;
              return G > 0 && (G = 1 / Math.sqrt(G)), C[0] = E[0] * G, C[1] = E[1] * G, C[2] = E[2] * G, C;
            }([], function(C, E, z) {
              var N = E[0], R = E[1], G = E[2], ie = z[0], H = z[1], Q = z[2];
              return C[0] = R * Q - G * H, C[1] = G * ie - N * Q, C[2] = N * H - R * ie, C;
            }([], $e([], m[s[0]], m[s[1]]), $e([], m[s[2]], m[s[1]]))), p = -((b = l)[0] * (P = m[s[1]])[0] + b[1] * P[1] + b[2] * P[2]);
            var b, P;
            return l.concat(p);
          });
          return new Qr(m, T);
        }
      }
      class ns {
        constructor(t, n) {
          this.min = t, this.max = n, this.center = function(c, u, m) {
            return c[0] = 0.5 * u[0], c[1] = 0.5 * u[1], c[2] = 0.5 * u[2], c;
          }([], function(c, u, m) {
            return c[0] = u[0] + m[0], c[1] = u[1] + m[1], c[2] = u[2] + m[2], c;
          }([], this.min, this.max));
        }
        quadrant(t) {
          const n = [t % 2 == 0, t < 2], c = Ke(this.min), u = Ke(this.max);
          for (let m = 0; m < n.length; m++) c[m] = n[m] ? this.min[m] : this.center[m], u[m] = n[m] ? this.center[m] : this.max[m];
          return u[2] = this.max[2], new ns(c, u);
        }
        distanceX(t) {
          return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
        }
        distanceY(t) {
          return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
        }
        intersects(t) {
          const n = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let c = !0;
          for (let u = 0; u < t.planes.length; u++) {
            const m = t.planes[u];
            let T = 0;
            for (let s = 0; s < n.length; s++) o.b1(m, n[s]) >= 0 && T++;
            if (T === 0) return 0;
            T !== n.length && (c = !1);
          }
          if (c) return 2;
          for (let u = 0; u < 3; u++) {
            let m = Number.MAX_VALUE, T = -Number.MAX_VALUE;
            for (let s = 0; s < t.points.length; s++) {
              const l = t.points[s][u] - this.min[u];
              m = Math.min(m, l), T = Math.max(T, l);
            }
            if (T < 0 || m > this.max[u] - this.min[u]) return 0;
          }
          return 1;
        }
      }
      class un {
        constructor(t = 0, n = 0, c = 0, u = 0) {
          if (isNaN(t) || t < 0 || isNaN(n) || n < 0 || isNaN(c) || c < 0 || isNaN(u) || u < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = t, this.bottom = n, this.left = c, this.right = u;
        }
        interpolate(t, n, c) {
          return n.top != null && t.top != null && (this.top = o.z.number(t.top, n.top, c)), n.bottom != null && t.bottom != null && (this.bottom = o.z.number(t.bottom, n.bottom, c)), n.left != null && t.left != null && (this.left = o.z.number(t.left, n.left, c)), n.right != null && t.right != null && (this.right = o.z.number(t.right, n.right, c)), this;
        }
        getCenter(t, n) {
          const c = o.ac((this.left + t - this.right) / 2, 0, t), u = o.ac((this.top + n - this.bottom) / 2, 0, n);
          return new o.P(c, u);
        }
        equals(t) {
          return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
        }
        clone() {
          return new un(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const dn = 85.051129;
      class ma {
        constructor(t, n, c, u, m) {
          this.tileSize = 512, this._renderWorldCopies = m === void 0 || !!m, this._minZoom = t || 0, this._maxZoom = n || 22, this._minPitch = c ?? 0, this._maxPitch = u ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new o.M(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new un(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const t = new ma(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return t.apply(this), t;
        }
        apply(t) {
          this.tileSize = t.tileSize, this.latRange = t.latRange, this.width = t.width, this.height = t.height, this._center = t._center, this._elevation = t._elevation, this.minElevationForCurrentTile = t.minElevationForCurrentTile, this.zoom = t.zoom, this.angle = t.angle, this._fov = t._fov, this._pitch = t._pitch, this._unmodified = t._unmodified, this._edgeInsets = t._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(t) {
          this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(t) {
          this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(t) {
          this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(t) {
          this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(t) {
          t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new o.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(t) {
          const n = -o.b2(t, -180, 180) * Math.PI / 180;
          this.angle !== n && (this._unmodified = !1, this.angle = n, this._calcMatrices(), this.rotationMatrix = function() {
            var c = new o.A(4);
            return o.A != Float32Array && (c[1] = 0, c[2] = 0), c[0] = 1, c[3] = 1, c;
          }(), function(c, u, m) {
            var T = u[0], s = u[1], l = u[2], p = u[3], b = Math.sin(m), P = Math.cos(m);
            c[0] = T * P + l * b, c[1] = s * P + p * b, c[2] = T * -b + l * P, c[3] = s * -b + p * P;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t) {
          const n = o.ac(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== n && (this._unmodified = !1, this._pitch = n, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(t) {
          t = Math.max(0.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = t / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(t) {
          const n = Math.min(Math.max(t, this.minZoom), this.maxZoom);
          this._zoom !== n && (this._unmodified = !1, this._zoom = n, this.tileZoom = Math.max(0, Math.floor(n)), this.scale = this.zoomScale(n), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(t) {
          t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(t) {
          t !== this._elevation && (this._elevation = t, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(t) {
          this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(t) {
          return this._edgeInsets.equals(t);
        }
        interpolatePadding(t, n, c) {
          this._unmodified = !1, this._edgeInsets.interpolate(t, n, c), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(t) {
          const n = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
          return Math.max(0, n);
        }
        getVisibleUnwrappedCoordinates(t) {
          const n = [new o.b3(0, t)];
          if (this._renderWorldCopies) {
            const c = this.pointCoordinate(new o.P(0, 0)), u = this.pointCoordinate(new o.P(this.width, 0)), m = this.pointCoordinate(new o.P(this.width, this.height)), T = this.pointCoordinate(new o.P(0, this.height)), s = Math.floor(Math.min(c.x, u.x, m.x, T.x)), l = Math.floor(Math.max(c.x, u.x, m.x, T.x)), p = 1;
            for (let b = s - p; b <= l + p; b++) b !== 0 && n.push(new o.b3(b, t));
          }
          return n;
        }
        coveringTiles(t) {
          var n, c;
          let u = this.coveringZoomLevel(t);
          const m = u;
          if (t.minzoom !== void 0 && u < t.minzoom) return [];
          t.maxzoom !== void 0 && u > t.maxzoom && (u = t.maxzoom);
          const T = this.pointCoordinate(this.getCameraPoint()), s = o.Y.fromLngLat(this.center), l = Math.pow(2, u), p = [l * T.x, l * T.y, 0], b = [l * s.x, l * s.y, 0], P = Qr.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, u);
          let C = t.minzoom || 0;
          !t.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (C = u);
          const E = t.terrain ? 2 / Math.min(this.tileSize, t.tileSize) * this.tileSize : 3, z = (H) => ({ aabb: new ns([H * l, 0, 0], [(H + 1) * l, l, 0]), zoom: 0, x: 0, y: 0, wrap: H, fullyVisible: !1 }), N = [], R = [], G = u, ie = t.reparseOverscaled ? m : u;
          if (this._renderWorldCopies) for (let H = 1; H <= 3; H++) N.push(z(-H)), N.push(z(H));
          for (N.push(z(0)); N.length > 0; ) {
            const H = N.pop(), Q = H.x, ue = H.y;
            let ce = H.fullyVisible;
            if (!ce) {
              const Te = H.aabb.intersects(P);
              if (Te === 0) continue;
              ce = Te === 2;
            }
            const ne = t.terrain ? p : b, le = H.aabb.distanceX(ne), De = H.aabb.distanceY(ne), Ne = Math.max(Math.abs(le), Math.abs(De));
            if (H.zoom === G || Ne > E + (1 << G - H.zoom) - 2 && H.zoom >= C) {
              const Te = G - H.zoom, qe = p[0] - 0.5 - (Q << Te), He = p[1] - 0.5 - (ue << Te);
              R.push({ tileID: new o.Q(H.zoom === G ? ie : H.zoom, H.wrap, H.zoom, Q, ue), distanceSq: Le([b[0] - 0.5 - Q, b[1] - 0.5 - ue]), tileDistanceToCamera: Math.sqrt(qe * qe + He * He) });
            } else for (let Te = 0; Te < 4; Te++) {
              const qe = (Q << 1) + Te % 2, He = (ue << 1) + (Te >> 1), vt = H.zoom + 1;
              let Ue = H.aabb.quadrant(Te);
              if (t.terrain) {
                const ft = new o.Q(vt, H.wrap, vt, qe, He), Tt = t.terrain.getMinMaxElevation(ft), ii = (n = Tt.minElevation) !== null && n !== void 0 ? n : this.elevation, Mt = (c = Tt.maxElevation) !== null && c !== void 0 ? c : this.elevation;
                Ue = new ns([Ue.min[0], Ue.min[1], ii], [Ue.max[0], Ue.max[1], Mt]);
              }
              N.push({ aabb: Ue, zoom: vt, x: qe, y: He, wrap: H.wrap, fullyVisible: ce });
            }
          }
          return R.sort((H, Q) => H.distanceSq - Q.distanceSq).map((H) => H.tileID);
        }
        resize(t, n) {
          this.width = t, this.height = n, this.pixelsToGLUnits = [2 / t, -2 / n], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(t) {
          return Math.pow(2, t);
        }
        scaleZoom(t) {
          return Math.log(t) / Math.LN2;
        }
        project(t) {
          const n = o.ac(t.lat, -85.051129, dn);
          return new o.P(o.N(t.lng) * this.worldSize, o.O(n) * this.worldSize);
        }
        unproject(t) {
          return new o.Y(t.x / this.worldSize, t.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(t) {
          const n = this.elevation, c = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, u = this.pointLocation(this.centerPoint, t), m = t.getElevationForLngLatZoom(u, this.tileZoom);
          if (!(this.elevation - m)) return;
          const T = c + n - m, s = Math.cos(this._pitch) * this.cameraToCenterDistance / T / o.b4(1, u.lat), l = this.scaleZoom(s / this.tileSize);
          this._elevation = m, this._center = u, this.zoom = l;
        }
        setLocationAtPoint(t, n) {
          const c = this.pointCoordinate(n), u = this.pointCoordinate(this.centerPoint), m = this.locationCoordinate(t), T = new o.Y(m.x - (c.x - u.x), m.y - (c.y - u.y));
          this.center = this.coordinateLocation(T), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(t, n) {
          return n ? this.coordinatePoint(this.locationCoordinate(t), n.getElevationForLngLatZoom(t, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t));
        }
        pointLocation(t, n) {
          return this.coordinateLocation(this.pointCoordinate(t, n));
        }
        locationCoordinate(t) {
          return o.Y.fromLngLat(t);
        }
        coordinateLocation(t) {
          return t && t.toLngLat();
        }
        pointCoordinate(t, n) {
          if (n) {
            const C = n.pointCoordinate(t);
            if (C != null) return C;
          }
          const c = [t.x, t.y, 0, 1], u = [t.x, t.y, 1, 1];
          o.af(c, c, this.pixelMatrixInverse), o.af(u, u, this.pixelMatrixInverse);
          const m = c[3], T = u[3], s = c[1] / m, l = u[1] / T, p = c[2] / m, b = u[2] / T, P = p === b ? 0 : (0 - p) / (b - p);
          return new o.Y(o.z.number(c[0] / m, u[0] / T, P) / this.worldSize, o.z.number(s, l, P) / this.worldSize);
        }
        coordinatePoint(t, n = 0, c = this.pixelMatrix) {
          const u = [t.x * this.worldSize, t.y * this.worldSize, n, 1];
          return o.af(u, u, c), new o.P(u[0] / u[3], u[1] / u[3]);
        }
        getBounds() {
          const t = Math.max(0, this.height / 2 - this.getHorizon());
          return new Ut().extend(this.pointLocation(new o.P(0, t))).extend(this.pointLocation(new o.P(this.width, t))).extend(this.pointLocation(new o.P(this.width, this.height))).extend(this.pointLocation(new o.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new Ut([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(t) {
          t ? (this.lngRange = [t.getWest(), t.getEast()], this.latRange = [t.getSouth(), t.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, dn]);
        }
        calculatePosMatrix(t, n = !1) {
          const c = t.key, u = n ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (u[c]) return u[c];
          const m = t.canonical, T = this.worldSize / this.zoomScale(m.z), s = m.x + Math.pow(2, m.z) * t.wrap, l = o.an(new Float64Array(16));
          return o.H(l, l, [s * T, m.y * T, 0]), o.J(l, l, [T / o.W, T / o.W, 1]), o.K(l, n ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, l), u[c] = new Float32Array(l), u[c];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(t, n) {
          n = o.ac(+n, this.minZoom, this.maxZoom);
          const c = { center: new o.M(t.lng, t.lat), zoom: n };
          let u = this.lngRange;
          if (!this._renderWorldCopies && u === null) {
            const H = 179.9999999999;
            u = [-H, H];
          }
          const m = this.tileSize * this.zoomScale(c.zoom);
          let T = 0, s = m, l = 0, p = m, b = 0, P = 0;
          const { x: C, y: E } = this.size;
          if (this.latRange) {
            const H = this.latRange;
            T = o.O(H[1]) * m, s = o.O(H[0]) * m, s - T < E && (b = E / (s - T));
          }
          u && (l = o.b2(o.N(u[0]) * m, 0, m), p = o.b2(o.N(u[1]) * m, 0, m), p < l && (p += m), p - l < C && (P = C / (p - l)));
          const { x: z, y: N } = this.project.call({ worldSize: m }, t);
          let R, G;
          const ie = Math.max(P || 0, b || 0);
          if (ie) {
            const H = new o.P(P ? (p + l) / 2 : z, b ? (s + T) / 2 : N);
            return c.center = this.unproject.call({ worldSize: m }, H).wrap(), c.zoom += this.scaleZoom(ie), c;
          }
          if (this.latRange) {
            const H = E / 2;
            N - H < T && (G = T + H), N + H > s && (G = s - H);
          }
          if (u) {
            const H = (l + p) / 2;
            let Q = z;
            this._renderWorldCopies && (Q = o.b2(z, H - m / 2, H + m / 2));
            const ue = C / 2;
            Q - ue < l && (R = l + ue), Q + ue > p && (R = p - ue);
          }
          if (R !== void 0 || G !== void 0) {
            const H = new o.P(R ?? z, G ?? N);
            c.center = this.unproject.call({ worldSize: m }, H).wrap();
          }
          return c;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = !0;
          const t = this._unmodified, { center: n, zoom: c } = this.getConstrained(this.center, this.zoom);
          this.center = n, this.zoom = c, this._unmodified = t, this._constraining = !1;
        }
        _calcMatrices() {
          if (!this.height) return;
          const t = this.centerOffset, n = this.point.x, c = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = o.b4(1, this.center.lat) * this.worldSize;
          let u = o.an(new Float64Array(16));
          o.J(u, u, [this.width / 2, -this.height / 2, 1]), o.H(u, u, [1, -1, 0]), this.labelPlaneMatrix = u, u = o.an(new Float64Array(16)), o.J(u, u, [1, -1, 1]), o.H(u, u, [-1, -1, 0]), o.J(u, u, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = u;
          const m = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), T = Math.min(this.elevation, this.minElevationForCurrentTile), s = m - T * this._pixelPerMeter / Math.cos(this._pitch), l = T < 0 ? s : m, p = Math.PI / 2 + this._pitch, b = this._fov * (0.5 + t.y / this.height), P = Math.sin(b) * l / Math.sin(o.ac(Math.PI - p - b, 0.01, Math.PI - 0.01)), C = this.getHorizon(), E = 2 * Math.atan(C / this.cameraToCenterDistance) * (0.5 + t.y / (2 * C)), z = Math.sin(E) * l / Math.sin(o.ac(Math.PI - p - E, 0.01, Math.PI - 0.01)), N = Math.min(P, z), R = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * N + l), G = this.height / 50;
          u = new Float64Array(16), o.b5(u, this._fov, this.width / this.height, G, R), u[8] = 2 * -t.x / this.width, u[9] = 2 * t.y / this.height, o.J(u, u, [1, -1, 1]), o.H(u, u, [0, 0, -this.cameraToCenterDistance]), o.b6(u, u, this._pitch), o.ad(u, u, this.angle), o.H(u, u, [-n, -c, 0]), this.mercatorMatrix = o.J([], u, [this.worldSize, this.worldSize, this.worldSize]), o.J(u, u, [1, 1, this._pixelPerMeter]), this.pixelMatrix = o.K(new Float64Array(16), this.labelPlaneMatrix, u), o.H(u, u, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = u, this.invModelViewProjectionMatrix = o.as([], u), this.pixelMatrix3D = o.K(new Float64Array(16), this.labelPlaneMatrix, u);
          const ie = this.width % 2 / 2, H = this.height % 2 / 2, Q = Math.cos(this.angle), ue = Math.sin(this.angle), ce = n - Math.round(n) + Q * ie + ue * H, ne = c - Math.round(c) + Q * H + ue * ie, le = new Float64Array(u);
          if (o.H(le, le, [ce > 0.5 ? ce - 1 : ce, ne > 0.5 ? ne - 1 : ne, 0]), this.alignedModelViewProjectionMatrix = le, u = o.as(new Float64Array(16), this.pixelMatrix), !u) throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = u, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse) return 1;
          const t = this.pointCoordinate(new o.P(0, 0)), n = [t.x * this.worldSize, t.y * this.worldSize, 0, 1];
          return o.af(n, n, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new o.P(0, t));
        }
        getCameraQueryGeometry(t) {
          const n = this.getCameraPoint();
          if (t.length === 1) return [t[0], n];
          {
            let c = n.x, u = n.y, m = n.x, T = n.y;
            for (const s of t) c = Math.min(c, s.x), u = Math.min(u, s.y), m = Math.max(m, s.x), T = Math.max(T, s.y);
            return [new o.P(c, u), new o.P(m, u), new o.P(m, T), new o.P(c, T), new o.P(c, u)];
          }
        }
        lngLatToCameraDepth(t, n) {
          const c = this.locationCoordinate(t), u = [c.x * this.worldSize, c.y * this.worldSize, n, 1];
          return o.af(u, u, this.modelViewProjectionMatrix), u[2] / u[3];
        }
      }
      function Nn(f, t) {
        let n, c = !1, u = null, m = null;
        const T = () => {
          u = null, c && (f.apply(m, n), u = setTimeout(T, t), c = !1);
        };
        return (...s) => (c = !0, m = this, n = s, u || T(), u);
      }
      class ga {
        constructor(t) {
          this._getCurrentHash = () => {
            const n = window.location.hash.replace("#", "");
            if (this._hashName) {
              let c;
              return n.split("&").map((u) => u.split("=")).forEach((u) => {
                u[0] === this._hashName && (c = u);
              }), (c && c[1] || "").split("/");
            }
            return n.split("/");
          }, this._onHashChange = () => {
            const n = this._getCurrentHash();
            if (n.length >= 3 && !n.some((c) => isNaN(c))) {
              const c = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(n[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+n[2], +n[1]], zoom: +n[0], bearing: c, pitch: +(n[4] || 0) }), !0;
            }
            return !1;
          }, this._updateHashUnthrottled = () => {
            const n = window.location.href.replace(/(#.+)?$/, this.getHashString());
            try {
              window.history.replaceState(window.history.state, null, n);
            } catch {
            }
          }, this._updateHash = Nn(this._updateHashUnthrottled, 300), this._hashName = t && encodeURIComponent(t);
        }
        addTo(t) {
          return this._map = t, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
        }
        getHashString(t) {
          const n = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, u = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), m = Math.pow(10, u), T = Math.round(n.lng * m) / m, s = Math.round(n.lat * m) / m, l = this._map.getBearing(), p = this._map.getPitch();
          let b = "";
          if (b += t ? `/${T}/${s}/${c}` : `${c}/${s}/${T}`, (l || p) && (b += "/" + Math.round(10 * l) / 10), p && (b += `/${Math.round(p)}`), this._hashName) {
            const P = this._hashName;
            let C = !1;
            const E = window.location.hash.slice(1).split("&").map((z) => {
              const N = z.split("=")[0];
              return N === P ? (C = !0, `${N}=${b}`) : z;
            }).filter((z) => z);
            return C || E.push(`${P}=${b}`), `#${E.join("&")}`;
          }
          return `#${b}`;
        }
      }
      const ya = { linearity: 0.3, easing: o.b7(0, 0, 0.3, 1) }, ys = o.e({ deceleration: 2500, maxSpeed: 1400 }, ya), pn = o.e({ deceleration: 20, maxSpeed: 1400 }, ya), Rn = o.e({ deceleration: 1e3, maxSpeed: 360 }, ya), Bs = o.e({ deceleration: 1e3, maxSpeed: 90 }, ya);
      class _a {
        constructor(t) {
          this._map = t, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: q.now(), settings: t });
        }
        _drainInertiaBuffer() {
          const t = this._inertiaBuffer, n = q.now();
          for (; t.length > 0 && n - t[0].time > 160; ) t.shift();
        }
        _onMoveEnd(t) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const n = { zoom: 0, bearing: 0, pitch: 0, pan: new o.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: m } of this._inertiaBuffer) n.zoom += m.zoomDelta || 0, n.bearing += m.bearingDelta || 0, n.pitch += m.pitchDelta || 0, m.panDelta && n.pan._add(m.panDelta), m.around && (n.around = m.around), m.pinchAround && (n.pinchAround = m.pinchAround);
          const c = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, u = {};
          if (n.pan.mag()) {
            const m = fn(n.pan.mag(), c, o.e({}, ys, t || {}));
            u.offset = n.pan.mult(m.amount / n.pan.mag()), u.center = this._map.transform.center, ss(u, m);
          }
          if (n.zoom) {
            const m = fn(n.zoom, c, pn);
            u.zoom = this._map.transform.zoom + m.amount, ss(u, m);
          }
          if (n.bearing) {
            const m = fn(n.bearing, c, Rn);
            u.bearing = this._map.transform.bearing + o.ac(m.amount, -179, 179), ss(u, m);
          }
          if (n.pitch) {
            const m = fn(n.pitch, c, Bs);
            u.pitch = this._map.transform.pitch + m.amount, ss(u, m);
          }
          if (u.zoom || u.bearing) {
            const m = n.pinchAround === void 0 ? n.around : n.pinchAround;
            u.around = m ? this._map.unproject(m) : this._map.getCenter();
          }
          return this.clear(), o.e(u, { noMoveStart: !0 });
        }
      }
      function ss(f, t) {
        (!f.duration || f.duration < t.duration) && (f.duration = t.duration, f.easing = t.easing);
      }
      function fn(f, t, n) {
        const { maxSpeed: c, linearity: u, deceleration: m } = n, T = o.ac(f * u / (t / 1e3), -c, c), s = Math.abs(T) / (m * u);
        return { easing: n.easing, duration: 1e3 * s, amount: T * (s / 2) };
      }
      class Pr extends o.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, n, c, u = {}) {
          const m = U.mousePos(n.getCanvas(), c), T = n.unproject(m);
          super(t, o.e({ point: m, lngLat: T, originalEvent: c }, u)), this._defaultPrevented = !1, this.target = n;
        }
      }
      class Or extends o.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, n, c) {
          const u = t === "touchend" ? c.changedTouches : c.touches, m = U.touchPos(n.getCanvasContainer(), u), T = m.map((l) => n.unproject(l)), s = m.reduce((l, p, b, P) => l.add(p.div(P.length)), new o.P(0, 0));
          super(t, { points: m, point: s, lngLats: T, lngLat: n.unproject(s), originalEvent: c }), this._defaultPrevented = !1;
        }
      }
      class _s extends o.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, n, c) {
          super(t, { originalEvent: c }), this._defaultPrevented = !1;
        }
      }
      class Zi {
        constructor(t, n) {
          this._map = t, this._clickTolerance = n.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(t) {
          return this._firePreventable(new _s(t.type, this._map, t));
        }
        mousedown(t, n) {
          return this._mousedownPos = n, this._firePreventable(new Pr(t.type, this._map, t));
        }
        mouseup(t) {
          this._map.fire(new Pr(t.type, this._map, t));
        }
        click(t, n) {
          this._mousedownPos && this._mousedownPos.dist(n) >= this._clickTolerance || this._map.fire(new Pr(t.type, this._map, t));
        }
        dblclick(t) {
          return this._firePreventable(new Pr(t.type, this._map, t));
        }
        mouseover(t) {
          this._map.fire(new Pr(t.type, this._map, t));
        }
        mouseout(t) {
          this._map.fire(new Pr(t.type, this._map, t));
        }
        touchstart(t) {
          return this._firePreventable(new Or(t.type, this._map, t));
        }
        touchmove(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        touchend(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        touchcancel(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        _firePreventable(t) {
          if (this._map.fire(t), t.defaultPrevented) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Ji {
        constructor(t) {
          this._map = t;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(t) {
          this._map.fire(new Pr(t.type, this._map, t));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Pr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(t) {
          this._delayContextMenu ? this._contextMenuEvent = t : this._ignoreContextMenu || this._map.fire(new Pr(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Ki {
        constructor(t) {
          this._map = t;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(t) {
          return this.transform.pointLocation(o.P.convert(t), this._map.terrain);
        }
      }
      class pr {
        constructor(t, n) {
          this._map = t, this._tr = new Ki(t), this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = n.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(t, n) {
          this.isEnabled() && t.shiftKey && t.button === 0 && (U.disableDrag(), this._startPos = this._lastPos = n, this._active = !0);
        }
        mousemoveWindow(t, n) {
          if (!this._active) return;
          const c = n;
          if (this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance) return;
          const u = this._startPos;
          this._lastPos = c, this._box || (this._box = U.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t));
          const m = Math.min(u.x, c.x), T = Math.max(u.x, c.x), s = Math.min(u.y, c.y), l = Math.max(u.y, c.y);
          U.setTransform(this._box, `translate(${m}px,${s}px)`), this._box.style.width = T - m + "px", this._box.style.height = l - s + "px";
        }
        mouseupWindow(t, n) {
          if (!this._active || t.button !== 0) return;
          const c = this._startPos, u = n;
          if (this.reset(), U.suppressClick(), c.x !== u.x || c.y !== u.y) return this._map.fire(new o.k("boxzoomend", { originalEvent: t })), { cameraAnimation: (m) => m.fitScreenCoordinates(c, u, this._tr.bearing, { linear: !0 }) };
          this._fireEvent("boxzoomcancel", t);
        }
        keydown(t) {
          this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (U.remove(this._box), this._box = null), U.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t, n) {
          return this._map.fire(new o.k(t, { originalEvent: n }));
        }
      }
      function An(f, t) {
        if (f.length !== t.length) throw new Error(`The number of touches and points are not equal - touches ${f.length}, points ${t.length}`);
        const n = {};
        for (let c = 0; c < f.length; c++) n[f[c].identifier] = t[c];
        return n;
      }
      class Os {
        constructor(t) {
          this.reset(), this.numTouches = t.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(t, n, c) {
          (this.centroid || c.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = t.timeStamp), c.length === this.numTouches && (this.centroid = function(u) {
            const m = new o.P(0, 0);
            for (const T of u) m._add(T);
            return m.div(u.length);
          }(n), this.touches = An(c, n)));
        }
        touchmove(t, n, c) {
          if (this.aborted || !this.centroid) return;
          const u = An(c, n);
          for (const m in this.touches) {
            const T = u[m];
            (!T || T.dist(this.touches[m]) > 30) && (this.aborted = !0);
          }
        }
        touchend(t, n, c) {
          if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), c.length === 0) {
            const u = !this.aborted && this.centroid;
            if (this.reset(), u) return u;
          }
        }
      }
      class js {
        constructor(t) {
          this.singleTap = new Os(t), this.numTaps = t.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(t, n, c) {
          this.singleTap.touchstart(t, n, c);
        }
        touchmove(t, n, c) {
          this.singleTap.touchmove(t, n, c);
        }
        touchend(t, n, c) {
          const u = this.singleTap.touchend(t, n, c);
          if (u) {
            const m = t.timeStamp - this.lastTime < 500, T = !this.lastTap || this.lastTap.dist(u) < 30;
            if (m && T || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = u, this.count === this.numTaps) return this.reset(), u;
          }
        }
      }
      class Fa {
        constructor(t) {
          this._tr = new Ki(t), this._zoomIn = new js({ numTouches: 1, numTaps: 2 }), this._zoomOut = new js({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(t, n, c) {
          this._zoomIn.touchstart(t, n, c), this._zoomOut.touchstart(t, n, c);
        }
        touchmove(t, n, c) {
          this._zoomIn.touchmove(t, n, c), this._zoomOut.touchmove(t, n, c);
        }
        touchend(t, n, c) {
          const u = this._zoomIn.touchend(t, n, c), m = this._zoomOut.touchend(t, n, c), T = this._tr;
          return u ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (s) => s.easeTo({ duration: 300, zoom: T.zoom + 1, around: T.unproject(u) }, { originalEvent: t }) }) : m ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (s) => s.easeTo({ duration: 300, zoom: T.zoom - 1, around: T.unproject(m) }, { originalEvent: t }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class va {
        constructor(t) {
          this._enabled = !!t.enable, this._moveStateManager = t.moveStateManager, this._clickTolerance = t.clickTolerance || 1, this._moveFunction = t.move, this._activateOnStart = !!t.activateOnStart, t.assignEvents(this), this.reset();
        }
        reset(t) {
          this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(t);
        }
        _move(...t) {
          const n = this._moveFunction(...t);
          if (n.bearingDelta || n.pitchDelta || n.around || n.panDelta) return this._active = !0, n;
        }
        dragStart(t, n) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t) && (this._moveStateManager.startMove(t), this._lastPoint = n.length ? n[0] : n, this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(t, n) {
          if (!this.isEnabled()) return;
          const c = this._lastPoint;
          if (!c) return;
          if (t.preventDefault(), !this._moveStateManager.isValidMoveEvent(t)) return void this.reset(t);
          const u = n.length ? n[0] : n;
          return !this._moved && u.dist(c) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = u, this._move(c, u));
        }
        dragEnd(t) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t) && (this._moved && U.suppressClick(), this.reset(t));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const rc = { 0: 1, 2: 2 };
      class Oo {
        constructor(t) {
          this._correctEvent = t.checkCorrectEvent;
        }
        startMove(t) {
          const n = U.mouseButton(t);
          this._eventButton = n;
        }
        endMove(t) {
          delete this._eventButton;
        }
        isValidStartEvent(t) {
          return this._correctEvent(t);
        }
        isValidMoveEvent(t) {
          return !function(n, c) {
            const u = rc[c];
            return n.buttons === void 0 || (n.buttons & u) !== u;
          }(t, this._eventButton);
        }
        isValidEndEvent(t) {
          return U.mouseButton(t) === this._eventButton;
        }
      }
      class hr {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(t) {
          return t.targetTouches.length === 1;
        }
        _isSameTouchEvent(t) {
          return t.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(t) {
          this._firstTouch = t.targetTouches[0].identifier;
        }
        endMove(t) {
          delete this._firstTouch;
        }
        isValidStartEvent(t) {
          return this._isOneFingerTouch(t);
        }
        isValidMoveEvent(t) {
          return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
        }
        isValidEndEvent(t) {
          return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
        }
      }
      const vs = (f) => {
        f.mousedown = f.dragStart, f.mousemoveWindow = f.dragMove, f.mouseup = f.dragEnd, f.contextmenu = (t) => {
          t.preventDefault();
        };
      }, mn = ({ enable: f, clickTolerance: t, bearingDegreesPerPixelMoved: n = 0.8 }) => {
        const c = new Oo({ checkCorrectEvent: (u) => U.mouseButton(u) === 0 && u.ctrlKey || U.mouseButton(u) === 2 });
        return new va({ clickTolerance: t, move: (u, m) => ({ bearingDelta: (m.x - u.x) * n }), moveStateManager: c, enable: f, assignEvents: vs });
      }, ho = ({ enable: f, clickTolerance: t, pitchDegreesPerPixelMoved: n = -0.5 }) => {
        const c = new Oo({ checkCorrectEvent: (u) => U.mouseButton(u) === 0 && u.ctrlKey || U.mouseButton(u) === 2 });
        return new va({ clickTolerance: t, move: (u, m) => ({ pitchDelta: (m.y - u.y) * n }), moveStateManager: c, enable: f, assignEvents: vs });
      };
      class uo {
        constructor(t, n) {
          this._clickTolerance = t.clickTolerance || 1, this._map = n, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new o.P(0, 0);
        }
        minTouchs() {
          return this._map.cooperativeGestures.isEnabled() ? 2 : 1;
        }
        touchstart(t, n, c) {
          return this._calculateTransform(t, n, c);
        }
        touchmove(t, n, c) {
          if (this._active && !(c.length < this.minTouchs())) return t.preventDefault(), this._calculateTransform(t, n, c);
        }
        touchend(t, n, c) {
          this._calculateTransform(t, n, c), this._active && c.length < this.minTouchs() && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t, n, c) {
          c.length > 0 && (this._active = !0);
          const u = An(c, n), m = new o.P(0, 0), T = new o.P(0, 0);
          let s = 0;
          for (const p in u) {
            const b = u[p], P = this._touches[p];
            P && (m._add(b), T._add(b.sub(P)), s++, u[p] = b);
          }
          if (this._touches = u, s < this.minTouchs() || !T.mag()) return;
          const l = T.div(s);
          return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : { around: m.div(s), panDelta: l };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class en {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        touchstart(t, n, c) {
          this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([n[0], n[1]]));
        }
        touchmove(t, n, c) {
          if (!this._firstTwoTouches) return;
          t.preventDefault();
          const [u, m] = this._firstTwoTouches, T = Ir(c, n, u), s = Ir(c, n, m);
          if (!T || !s) return;
          const l = this._aroundCenter ? null : T.add(s).div(2);
          return this._move([T, s], l, t);
        }
        touchend(t, n, c) {
          if (!this._firstTwoTouches) return;
          const [u, m] = this._firstTwoTouches, T = Ir(c, n, u), s = Ir(c, n, m);
          T && s || (this._active && U.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(t) {
          this._enabled = !0, this._aroundCenter = !!t && t.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function Ir(f, t, n) {
        for (let c = 0; c < f.length; c++) if (f[c].identifier === n) return t[c];
      }
      function qs(f, t) {
        return Math.log(f / t) / Math.LN2;
      }
      class Na extends en {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(t) {
          this._startDistance = this._distance = t[0].dist(t[1]);
        }
        _move(t, n) {
          const c = this._distance;
          if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(qs(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: qs(this._distance, c), pinchAround: n };
        }
      }
      function ol(f, t) {
        return 180 * f.angleWith(t) / Math.PI;
      }
      class po extends en {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(t) {
          this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);
        }
        _move(t, n, c) {
          const u = this._vector;
          if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: ol(this._vector, u), pinchAround: n };
        }
        _isBelowThreshold(t) {
          this._minDiameter = Math.min(this._minDiameter, t.mag());
          const n = 25 / (Math.PI * this._minDiameter) * 360, c = ol(t, this._startVector);
          return Math.abs(c) < n;
        }
      }
      function Ra(f) {
        return Math.abs(f.y) > Math.abs(f.x);
      }
      class jo extends en {
        constructor(t) {
          super(), this._currentTouchCount = 0, this._map = t;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(t, n, c) {
          super.touchstart(t, n, c), this._currentTouchCount = c.length;
        }
        _start(t) {
          this._lastPoints = t, Ra(t[0].sub(t[1])) && (this._valid = !1);
        }
        _move(t, n, c) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
          const u = t[0].sub(this._lastPoints[0]), m = t[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(u, m, c.timeStamp), this._valid ? (this._lastPoints = t, this._active = !0, { pitchDelta: (u.y + m.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(t, n, c) {
          if (this._valid !== void 0) return this._valid;
          const u = t.mag() >= 2, m = n.mag() >= 2;
          if (!u && !m) return;
          if (!u || !m) return this._firstMove === void 0 && (this._firstMove = c), c - this._firstMove < 100 && void 0;
          const T = t.y > 0 == n.y > 0;
          return Ra(t) && Ra(n) && T;
        }
      }
      const El = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class xs {
        constructor(t) {
          this._tr = new Ki(t);
          const n = El;
          this._panStep = n.panStep, this._bearingStep = n.bearingStep, this._pitchStep = n.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(t) {
          if (t.altKey || t.ctrlKey || t.metaKey) return;
          let n = 0, c = 0, u = 0, m = 0, T = 0;
          switch (t.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              n = 1;
              break;
            case 189:
            case 109:
            case 173:
              n = -1;
              break;
            case 37:
              t.shiftKey ? c = -1 : (t.preventDefault(), m = -1);
              break;
            case 39:
              t.shiftKey ? c = 1 : (t.preventDefault(), m = 1);
              break;
            case 38:
              t.shiftKey ? u = 1 : (t.preventDefault(), T = -1);
              break;
            case 40:
              t.shiftKey ? u = -1 : (t.preventDefault(), T = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (c = 0, u = 0), { cameraAnimation: (s) => {
            const l = this._tr;
            s.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ll, zoom: n ? Math.round(l.zoom) + n * (t.shiftKey ? 2 : 1) : l.zoom, bearing: l.bearing + c * this._bearingStep, pitch: l.pitch + u * this._pitchStep, offset: [-m * this._panStep, -T * this._panStep], center: l.center }, { originalEvent: t });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function ll(f) {
        return f * (2 - f);
      }
      const fo = 4.000244140625;
      class qo {
        constructor(t, n) {
          this._onTimeout = (c) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(c);
          }, this._map = t, this._tr = new Ki(t), this._triggerRenderFrame = n, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(t) {
          this._defaultZoomRate = t;
        }
        setWheelZoomRate(t) {
          this._wheelZoomRate = t;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(t) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        wheel(t) {
          if (!this.isEnabled() || this._map.cooperativeGestures.isEnabled() && !t[this._map.cooperativeGestures._bypassKey]) return;
          let n = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
          const c = q.now(), u = c - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = c, n !== 0 && n % fo == 0 ? this._type = "wheel" : n !== 0 && Math.abs(n) < 4 ? this._type = "trackpad" : u > 400 ? (this._type = null, this._lastValue = n, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(u * n) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, n += this._lastValue)), t.shiftKey && n && (n /= 4), this._type && (this._lastWheelEvent = t, this._delta -= n, this._active || this._start(t)), t.preventDefault();
        }
        _start(t) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const n = U.mousePos(this._map.getCanvas(), t), c = this._tr;
          this._around = n.y > c.transform.height / 2 - c.transform.getHorizon() ? o.M.convert(this._aroundCenter ? c.center : c.unproject(n)) : o.M.convert(c.center), this._aroundPoint = c.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          const t = this._tr.transform;
          if (this._delta !== 0) {
            const s = this._type === "wheel" && Math.abs(this._delta) > fo ? this._wheelZoomRate : this._defaultZoomRate;
            let l = 2 / (1 + Math.exp(-Math.abs(this._delta * s)));
            this._delta < 0 && l !== 0 && (l = 1 / l);
            const p = typeof this._targetZoom == "number" ? t.zoomScale(this._targetZoom) : t.scale;
            this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(p * l))), this._type === "wheel" && (this._startZoom = t.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const n = typeof this._targetZoom == "number" ? this._targetZoom : t.zoom, c = this._startZoom, u = this._easing;
          let m, T = !1;
          if (this._type === "wheel" && c && u) {
            const s = Math.min((q.now() - this._lastWheelEventTime) / 200, 1), l = u(s);
            m = o.z.number(c, n, l), s < 1 ? this._frameId || (this._frameId = !0) : T = !0;
          } else m = n, T = !0;
          return this._active = !0, T && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !T, zoomDelta: m - t.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t) {
          let n = o.b8;
          if (this._prevEase) {
            const c = this._prevEase, u = (q.now() - c.start) / c.duration, m = c.easing(u + 0.01) - c.easing(u), T = 0.27 / Math.sqrt(m * m + 1e-4) * 0.01, s = Math.sqrt(0.0729 - T * T);
            n = o.b7(T, s, 0.25, 1);
          }
          return this._prevEase = { start: q.now(), duration: t, easing: n }, n;
        }
        reset() {
          this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class Ml {
        constructor(t, n) {
          this._clickZoom = t, this._tapZoom = n;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class nc {
        constructor(t) {
          this._tr = new Ki(t), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(t, n) {
          return t.preventDefault(), { cameraAnimation: (c) => {
            c.easeTo({ duration: 300, zoom: this._tr.zoom + (t.shiftKey ? -1 : 1), around: this._tr.unproject(n) }, { originalEvent: t });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Dl {
        constructor() {
          this._tap = new js({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(t, n, c) {
          if (!this._swipePoint) if (this._tapTime) {
            const u = n[0], m = t.timeStamp - this._tapTime < 500, T = this._tapPoint.dist(u) < 30;
            m && T ? c.length > 0 && (this._swipePoint = u, this._swipeTouch = c[0].identifier) : this.reset();
          } else this._tap.touchstart(t, n, c);
        }
        touchmove(t, n, c) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (c[0].identifier !== this._swipeTouch) return;
              const u = n[0], m = u.y - this._swipePoint.y;
              return this._swipePoint = u, t.preventDefault(), this._active = !0, { zoomDelta: m / 128 };
            }
          } else this._tap.touchmove(t, n, c);
        }
        touchend(t, n, c) {
          if (this._tapTime) this._swipePoint && c.length === 0 && this.reset();
          else {
            const u = this._tap.touchend(t, n, c);
            u && (this._tapTime = t.timeStamp, this._tapPoint = u);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class zl {
        constructor(t, n, c) {
          this._el = t, this._mousePan = n, this._touchPan = c;
        }
        enable(t) {
          this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class mo {
        constructor(t, n, c) {
          this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = n, this._mousePitch = c;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class Fl {
        constructor(t, n, c, u) {
          this._el = t, this._touchZoom = n, this._touchRotate = c, this._tapDragZoom = u, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(t) {
          this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class Bn {
        constructor(t, n) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = t, this._options = n, this._enabled = !1;
        }
        isActive() {
          return !1;
        }
        reset() {
        }
        _setupUI() {
          if (this._container) return;
          const t = this._map.getCanvasContainer();
          t.classList.add("maplibregl-cooperative-gestures"), this._container = U.create("div", "maplibregl-cooperative-gesture-screen", t);
          let n = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (n = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const c = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), u = document.createElement("div");
          u.className = "maplibregl-desktop-message", u.textContent = n, this._container.appendChild(u);
          const m = document.createElement("div");
          m.className = "maplibregl-mobile-message", m.textContent = c, this._container.appendChild(m), this._container.setAttribute("aria-hidden", "true");
        }
        _destoryUI() {
          this._container && (U.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this._destoryUI();
        }
        isEnabled() {
          return this._enabled;
        }
        touchmove(t) {
          this._onCooperativeGesture(t.touches.length === 1);
        }
        wheel(t) {
          this._map.scrollZoom.isEnabled() && this._onCooperativeGesture(!t[this._bypassKey]);
        }
        _onCooperativeGesture(t) {
          this._enabled && t && (this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const Pn = (f) => f.zoom || f.drag || f.pitch || f.rotate;
      class cl extends o.k {
      }
      function gn(f) {
        return f.panDelta && f.panDelta.mag() || f.zoomDelta || f.bearingDelta || f.pitchDelta;
      }
      class Us {
        constructor(t, n) {
          this.handleWindowEvent = (u) => {
            this.handleEvent(u, `${u.type}Window`);
          }, this.handleEvent = (u, m) => {
            if (u.type === "blur") return void this.stop(!0);
            this._updatingCamera = !0;
            const T = u.type === "renderFrame" ? void 0 : u, s = { needsRenderFrame: !1 }, l = {}, p = {}, b = u.touches, P = b ? this._getMapTouches(b) : void 0, C = P ? U.touchPos(this._map.getCanvas(), P) : U.mousePos(this._map.getCanvas(), u);
            for (const { handlerName: N, handler: R, allowed: G } of this._handlers) {
              if (!R.isEnabled()) continue;
              let ie;
              this._blockedByActive(p, G, N) ? R.reset() : R[m || u.type] && (ie = R[m || u.type](u, C, P), this.mergeHandlerResult(s, l, ie, N, T), ie && ie.needsRenderFrame && this._triggerRenderFrame()), (ie || R.isActive()) && (p[N] = R);
            }
            const E = {};
            for (const N in this._previousActiveHandlers) p[N] || (E[N] = T);
            this._previousActiveHandlers = p, (Object.keys(E).length || gn(s)) && (this._changes.push([s, l, E]), this._triggerRenderFrame()), (Object.keys(p).length || gn(s)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: z } = s;
            z && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], z(this._map));
          }, this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new _a(t), this._bearingSnap = n.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(n);
          const c = this._el;
          this._listeners = [[c, "touchstart", { passive: !0 }], [c, "touchmove", { passive: !1 }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: !1 }], [c, "keyup", void 0], [c, "wheel", { passive: !1 }], [c, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [u, m, T] of this._listeners) U.addEventListener(u, m, u === document ? this.handleWindowEvent : this.handleEvent, T);
        }
        destroy() {
          for (const [t, n, c] of this._listeners) U.removeEventListener(t, n, t === document ? this.handleWindowEvent : this.handleEvent, c);
        }
        _addDefaultHandlers(t) {
          const n = this._map, c = n.getCanvasContainer();
          this._add("mapEvent", new Zi(n, t));
          const u = n.boxZoom = new pr(n, t);
          this._add("boxZoom", u), t.interactive && t.boxZoom && u.enable();
          const m = n.cooperativeGestures = new Bn(n, t.cooperativeGestures);
          this._add("cooperativeGestures", m), t.cooperativeGestures && m.enable();
          const T = new Fa(n), s = new nc(n);
          n.doubleClickZoom = new Ml(s, T), this._add("tapZoom", T), this._add("clickZoom", s), t.interactive && t.doubleClickZoom && n.doubleClickZoom.enable();
          const l = new Dl();
          this._add("tapDragZoom", l);
          const p = n.touchPitch = new jo(n);
          this._add("touchPitch", p), t.interactive && t.touchPitch && n.touchPitch.enable(t.touchPitch);
          const b = mn(t), P = ho(t);
          n.dragRotate = new mo(t, b, P), this._add("mouseRotate", b, ["mousePitch"]), this._add("mousePitch", P, ["mouseRotate"]), t.interactive && t.dragRotate && n.dragRotate.enable();
          const C = (({ enable: ie, clickTolerance: H }) => {
            const Q = new Oo({ checkCorrectEvent: (ue) => U.mouseButton(ue) === 0 && !ue.ctrlKey });
            return new va({ clickTolerance: H, move: (ue, ce) => ({ around: ce, panDelta: ce.sub(ue) }), activateOnStart: !0, moveStateManager: Q, enable: ie, assignEvents: vs });
          })(t), E = new uo(t, n);
          n.dragPan = new zl(c, C, E), this._add("mousePan", C), this._add("touchPan", E, ["touchZoom", "touchRotate"]), t.interactive && t.dragPan && n.dragPan.enable(t.dragPan);
          const z = new po(), N = new Na();
          n.touchZoomRotate = new Fl(c, N, z, l), this._add("touchRotate", z, ["touchPan", "touchZoom"]), this._add("touchZoom", N, ["touchPan", "touchRotate"]), t.interactive && t.touchZoomRotate && n.touchZoomRotate.enable(t.touchZoomRotate);
          const R = n.scrollZoom = new qo(n, () => this._triggerRenderFrame());
          this._add("scrollZoom", R, ["mousePan"]), t.interactive && t.scrollZoom && n.scrollZoom.enable(t.scrollZoom);
          const G = n.keyboard = new xs(n);
          this._add("keyboard", G), t.interactive && t.keyboard && n.keyboard.enable(), this._add("blockableMapEvent", new Ji(n));
        }
        _add(t, n, c) {
          this._handlers.push({ handlerName: t, handler: n, allowed: c }), this._handlersById[t] = n;
        }
        stop(t) {
          if (!this._updatingCamera) {
            for (const { handler: n } of this._handlers) n.reset();
            this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: t } of this._handlers) if (t.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Pn(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(t, n, c) {
          for (const u in t) if (u !== c && (!n || n.indexOf(u) < 0)) return !0;
          return !1;
        }
        _getMapTouches(t) {
          const n = [];
          for (const c of t) this._el.contains(c.target) && n.push(c);
          return n;
        }
        mergeHandlerResult(t, n, c, u, m) {
          if (!c) return;
          o.e(t, c);
          const T = { handlerName: u, originalEvent: c.originalEvent || m };
          c.zoomDelta !== void 0 && (n.zoom = T), c.panDelta !== void 0 && (n.drag = T), c.pitchDelta !== void 0 && (n.pitch = T), c.bearingDelta !== void 0 && (n.rotate = T);
        }
        _applyChanges() {
          const t = {}, n = {}, c = {};
          for (const [u, m, T] of this._changes) u.panDelta && (t.panDelta = (t.panDelta || new o.P(0, 0))._add(u.panDelta)), u.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + u.zoomDelta), u.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + u.bearingDelta), u.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + u.pitchDelta), u.around !== void 0 && (t.around = u.around), u.pinchAround !== void 0 && (t.pinchAround = u.pinchAround), u.noInertia && (t.noInertia = u.noInertia), o.e(n, m), o.e(c, T);
          this._updateMapTransform(t, n, c), this._changes = [];
        }
        _updateMapTransform(t, n, c) {
          const u = this._map, m = u._getTransformForUpdate(), T = u.terrain;
          if (!(gn(t) || T && this._terrainMovement)) return this._fireEvents(n, c, !0);
          let { panDelta: s, zoomDelta: l, bearingDelta: p, pitchDelta: b, around: P, pinchAround: C } = t;
          C !== void 0 && (P = C), u._stop(!0), P = P || u.transform.centerPoint;
          const E = m.pointLocation(s ? P.sub(s) : P);
          p && (m.bearing += p), b && (m.pitch += b), l && (m.zoom += l), T ? this._terrainMovement || !n.drag && !n.zoom ? n.drag && this._terrainMovement ? m.center = m.pointLocation(m.centerPoint.sub(s)) : m.setLocationAtPoint(E, P) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, m.setLocationAtPoint(E, P)) : m.setLocationAtPoint(E, P), u._applyUpdatedTransform(m), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(n, c, !0);
        }
        _fireEvents(t, n, c) {
          const u = Pn(this._eventsInProgress), m = Pn(t), T = {};
          for (const P in t) {
            const { originalEvent: C } = t[P];
            this._eventsInProgress[P] || (T[`${P}start`] = C), this._eventsInProgress[P] = t[P];
          }
          !u && m && this._fireEvent("movestart", m.originalEvent);
          for (const P in T) this._fireEvent(P, T[P]);
          m && this._fireEvent("move", m.originalEvent);
          for (const P in t) {
            const { originalEvent: C } = t[P];
            this._fireEvent(P, C);
          }
          const s = {};
          let l;
          for (const P in this._eventsInProgress) {
            const { handlerName: C, originalEvent: E } = this._eventsInProgress[P];
            this._handlersById[C].isActive() || (delete this._eventsInProgress[P], l = n[C] || E, s[`${P}end`] = l);
          }
          for (const P in s) this._fireEvent(P, s[P]);
          const p = Pn(this._eventsInProgress), b = (u || m) && !p;
          if (b && this._terrainMovement && (this._map._elevationFreeze = !1, this._terrainMovement = !1, this._map.transform.recalculateZoom(this._map.terrain)), c && b) {
            this._updatingCamera = !0;
            const P = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), C = (E) => E !== 0 && -this._bearingSnap < E && E < this._bearingSnap;
            !P || !P.essential && q.prefersReducedMotion ? (this._map.fire(new o.k("moveend", { originalEvent: l })), C(this._map.getBearing()) && this._map.resetNorth()) : (C(P.bearing || this._map.getBearing()) && (P.bearing = 0), P.freezeElevation = !0, this._map.easeTo(P, { originalEvent: l })), this._updatingCamera = !1;
          }
        }
        _fireEvent(t, n) {
          this._map.fire(new o.k(t, n ? { originalEvent: n } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t) => {
            delete this._frameId, this.handleEvent(new cl("renderFrame", { timeStamp: t })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class Cc extends o.E {
        constructor(t, n) {
          super(), this._renderFrameCallback = () => {
            const c = Math.min((q.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(c)), c < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = n.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new o.M(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(t, n) {
          return this.jumpTo({ center: t }, n);
        }
        panBy(t, n, c) {
          return t = o.P.convert(t).mult(-1), this.panTo(this.transform.center, o.e({ offset: t }, n), c);
        }
        panTo(t, n, c) {
          return this.easeTo(o.e({ center: t }, n), c);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(t, n) {
          return this.jumpTo({ zoom: t }, n), this;
        }
        zoomTo(t, n, c) {
          return this.easeTo(o.e({ zoom: t }, n), c);
        }
        zoomIn(t, n) {
          return this.zoomTo(this.getZoom() + 1, t, n), this;
        }
        zoomOut(t, n) {
          return this.zoomTo(this.getZoom() - 1, t, n), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(t, n) {
          return this.jumpTo({ bearing: t }, n), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(t, n) {
          return this.jumpTo({ padding: t }, n), this;
        }
        rotateTo(t, n, c) {
          return this.easeTo(o.e({ bearing: t }, n), c);
        }
        resetNorth(t, n) {
          return this.rotateTo(0, o.e({ duration: 1e3 }, t), n), this;
        }
        resetNorthPitch(t, n) {
          return this.easeTo(o.e({ bearing: 0, pitch: 0, duration: 1e3 }, t), n), this;
        }
        snapToNorth(t, n) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, n) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(t, n) {
          return this.jumpTo({ pitch: t }, n), this;
        }
        cameraForBounds(t, n) {
          t = Ut.convert(t);
          const c = n && n.bearing || 0;
          return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), c, n);
        }
        _cameraForBoxAndBearing(t, n, c, u) {
          const m = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (u = o.e({ padding: m, offset: [0, 0], maxZoom: this.transform.maxZoom }, u)).padding == "number") {
            const Te = u.padding;
            u.padding = { top: Te, bottom: Te, right: Te, left: Te };
          }
          u.padding = o.e(m, u.padding);
          const T = this.transform, s = T.padding, l = new Ut(t, n), p = T.project(l.getNorthWest()), b = T.project(l.getNorthEast()), P = T.project(l.getSouthEast()), C = T.project(l.getSouthWest()), E = o.b9(-c), z = p.rotate(E), N = b.rotate(E), R = P.rotate(E), G = C.rotate(E), ie = new o.P(Math.max(z.x, N.x, G.x, R.x), Math.max(z.y, N.y, G.y, R.y)), H = new o.P(Math.min(z.x, N.x, G.x, R.x), Math.min(z.y, N.y, G.y, R.y)), Q = ie.sub(H), ue = (T.width - (s.left + s.right + u.padding.left + u.padding.right)) / Q.x, ce = (T.height - (s.top + s.bottom + u.padding.top + u.padding.bottom)) / Q.y;
          if (ce < 0 || ue < 0) return void o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const ne = Math.min(T.scaleZoom(T.scale * Math.min(ue, ce)), u.maxZoom), le = o.P.convert(u.offset), De = new o.P((u.padding.left - u.padding.right) / 2, (u.padding.top - u.padding.bottom) / 2).rotate(o.b9(c)), Ne = le.add(De).mult(T.scale / T.zoomScale(ne));
          return { center: T.unproject(p.add(P).div(2).sub(Ne)), zoom: ne, bearing: c };
        }
        fitBounds(t, n, c) {
          return this._fitInternal(this.cameraForBounds(t, n), n, c);
        }
        fitScreenCoordinates(t, n, c, u, m) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(o.P.convert(t)), this.transform.pointLocation(o.P.convert(n)), c, u), u, m);
        }
        _fitInternal(t, n, c) {
          return t ? (delete (n = o.e(t, n)).padding, n.linear ? this.easeTo(n, c) : this.flyTo(n, c)) : this;
        }
        jumpTo(t, n) {
          this.stop();
          const c = this._getTransformForUpdate();
          let u = !1, m = !1, T = !1;
          return "zoom" in t && c.zoom !== +t.zoom && (u = !0, c.zoom = +t.zoom), t.center !== void 0 && (c.center = o.M.convert(t.center)), "bearing" in t && c.bearing !== +t.bearing && (m = !0, c.bearing = +t.bearing), "pitch" in t && c.pitch !== +t.pitch && (T = !0, c.pitch = +t.pitch), t.padding == null || c.isPaddingEqual(t.padding) || (c.padding = t.padding), this._applyUpdatedTransform(c), this.fire(new o.k("movestart", n)).fire(new o.k("move", n)), u && this.fire(new o.k("zoomstart", n)).fire(new o.k("zoom", n)).fire(new o.k("zoomend", n)), m && this.fire(new o.k("rotatestart", n)).fire(new o.k("rotate", n)).fire(new o.k("rotateend", n)), T && this.fire(new o.k("pitchstart", n)).fire(new o.k("pitch", n)).fire(new o.k("pitchend", n)), this.fire(new o.k("moveend", n));
        }
        calculateCameraOptionsFromTo(t, n, c, u = 0) {
          const m = o.Y.fromLngLat(t, n), T = o.Y.fromLngLat(c, u), s = T.x - m.x, l = T.y - m.y, p = T.z - m.z, b = Math.hypot(s, l, p);
          if (b === 0) throw new Error("Can't calculate camera options with same From and To");
          const P = Math.hypot(s, l), C = this.transform.scaleZoom(this.transform.cameraToCenterDistance / b / this.transform.tileSize), E = 180 * Math.atan2(s, -l) / Math.PI;
          let z = 180 * Math.acos(P / b) / Math.PI;
          return z = p < 0 ? 90 - z : 90 + z, { center: T.toLngLat(), zoom: C, pitch: z, bearing: E };
        }
        easeTo(t, n) {
          var c;
          this._stop(!1, t.easeId), ((t = o.e({ offset: [0, 0], duration: 500, easing: o.b8 }, t)).animate === !1 || !t.essential && q.prefersReducedMotion) && (t.duration = 0);
          const u = this._getTransformForUpdate(), m = this.getZoom(), T = this.getBearing(), s = this.getPitch(), l = this.getPadding(), p = "bearing" in t ? this._normalizeBearing(t.bearing, T) : T, b = "pitch" in t ? +t.pitch : s, P = "padding" in t ? t.padding : u.padding, C = o.P.convert(t.offset);
          let E = u.centerPoint.add(C);
          const z = u.pointLocation(E), { center: N, zoom: R } = u.getConstrained(o.M.convert(t.center || z), (c = t.zoom) !== null && c !== void 0 ? c : m);
          this._normalizeCenter(N);
          const G = u.project(z), ie = u.project(N).sub(G), H = u.zoomScale(R - m);
          let Q, ue;
          t.around && (Q = o.M.convert(t.around), ue = u.locationPoint(Q));
          const ce = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || R !== m, this._rotating = this._rotating || T !== p, this._pitching = this._pitching || b !== s, this._padding = !u.isPaddingEqual(P), this._easeId = t.easeId, this._prepareEase(n, t.noMoveStart, ce), this.terrain && this._prepareElevation(N), this._ease((ne) => {
            if (this._zooming && (u.zoom = o.z.number(m, R, ne)), this._rotating && (u.bearing = o.z.number(T, p, ne)), this._pitching && (u.pitch = o.z.number(s, b, ne)), this._padding && (u.interpolatePadding(l, P, ne), E = u.centerPoint.add(C)), this.terrain && !t.freezeElevation && this._updateElevation(ne), Q) u.setLocationAtPoint(Q, ue);
            else {
              const le = u.zoomScale(u.zoom - m), De = R > m ? Math.min(2, H) : Math.max(0.5, H), Ne = Math.pow(De, 1 - ne), Te = u.unproject(G.add(ie.mult(ne * Ne)).mult(le));
              u.setLocationAtPoint(u.renderWorldCopies ? Te.wrap() : Te, E);
            }
            this._applyUpdatedTransform(u), this._fireMoveEvents(n);
          }, (ne) => {
            this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(n, ne);
          }, t), this;
        }
        _prepareEase(t, n, c = {}) {
          this._moving = !0, n || c.moving || this.fire(new o.k("movestart", t)), this._zooming && !c.zooming && this.fire(new o.k("zoomstart", t)), this._rotating && !c.rotating && this.fire(new o.k("rotatestart", t)), this._pitching && !c.pitching && this.fire(new o.k("pitchstart", t));
        }
        _prepareElevation(t) {
          this._elevationCenter = t, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t, this.transform.tileZoom), this._elevationFreeze = !0;
        }
        _updateElevation(t) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const n = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (t < 1 && n !== this._elevationTarget) {
            const c = this._elevationTarget - this._elevationStart;
            this._elevationStart += t * (c - (n - (c * t + this._elevationStart)) / (1 - t)), this._elevationTarget = n;
          }
          this.transform.elevation = o.z.number(this._elevationStart, this._elevationTarget, t);
        }
        _finalizeElevation() {
          this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _applyUpdatedTransform(t) {
          if (!this.transformCameraUpdate) return;
          const n = t.clone(), { center: c, zoom: u, pitch: m, bearing: T, elevation: s } = this.transformCameraUpdate(n);
          c && (n.center = c), u !== void 0 && (n.zoom = u), m !== void 0 && (n.pitch = m), T !== void 0 && (n.bearing = T), s !== void 0 && (n.elevation = s), this.transform.apply(n);
        }
        _fireMoveEvents(t) {
          this.fire(new o.k("move", t)), this._zooming && this.fire(new o.k("zoom", t)), this._rotating && this.fire(new o.k("rotate", t)), this._pitching && this.fire(new o.k("pitch", t));
        }
        _afterEase(t, n) {
          if (this._easeId && n && this._easeId === n) return;
          delete this._easeId;
          const c = this._zooming, u = this._rotating, m = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, c && this.fire(new o.k("zoomend", t)), u && this.fire(new o.k("rotateend", t)), m && this.fire(new o.k("pitchend", t)), this.fire(new o.k("moveend", t));
        }
        flyTo(t, n) {
          var c;
          if (!t.essential && q.prefersReducedMotion) {
            const ft = o.L(t, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(ft, n);
          }
          this.stop(), t = o.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.b8 }, t);
          const u = this._getTransformForUpdate(), m = this.getZoom(), T = this.getBearing(), s = this.getPitch(), l = this.getPadding(), p = "bearing" in t ? this._normalizeBearing(t.bearing, T) : T, b = "pitch" in t ? +t.pitch : s, P = "padding" in t ? t.padding : u.padding, C = o.P.convert(t.offset);
          let E = u.centerPoint.add(C);
          const z = u.pointLocation(E), { center: N, zoom: R } = u.getConstrained(o.M.convert(t.center || z), (c = t.zoom) !== null && c !== void 0 ? c : m);
          this._normalizeCenter(N);
          const G = u.zoomScale(R - m), ie = u.project(z), H = u.project(N).sub(ie);
          let Q = t.curve;
          const ue = Math.max(u.width, u.height), ce = ue / G, ne = H.mag();
          if ("minZoom" in t) {
            const ft = o.ac(Math.min(t.minZoom, m, R), u.minZoom, u.maxZoom), Tt = ue / u.zoomScale(ft - m);
            Q = Math.sqrt(Tt / ne * 2);
          }
          const le = Q * Q;
          function De(ft) {
            const Tt = (ce * ce - ue * ue + (ft ? -1 : 1) * le * le * ne * ne) / (2 * (ft ? ce : ue) * le * ne);
            return Math.log(Math.sqrt(Tt * Tt + 1) - Tt);
          }
          function Ne(ft) {
            return (Math.exp(ft) - Math.exp(-ft)) / 2;
          }
          function Te(ft) {
            return (Math.exp(ft) + Math.exp(-ft)) / 2;
          }
          const qe = De(!1);
          let He = function(ft) {
            return Te(qe) / Te(qe + Q * ft);
          }, vt = function(ft) {
            return ue * ((Te(qe) * (Ne(Tt = qe + Q * ft) / Te(Tt)) - Ne(qe)) / le) / ne;
            var Tt;
          }, Ue = (De(!0) - qe) / Q;
          if (Math.abs(ne) < 1e-6 || !isFinite(Ue)) {
            if (Math.abs(ue - ce) < 1e-6) return this.easeTo(t, n);
            const ft = ce < ue ? -1 : 1;
            Ue = Math.abs(Math.log(ce / ue)) / Q, vt = () => 0, He = (Tt) => Math.exp(ft * Q * Tt);
          }
          return t.duration = "duration" in t ? +t.duration : 1e3 * Ue / ("screenSpeed" in t ? +t.screenSpeed / Q : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = !0, this._rotating = T !== p, this._pitching = b !== s, this._padding = !u.isPaddingEqual(P), this._prepareEase(n, !1), this.terrain && this._prepareElevation(N), this._ease((ft) => {
            const Tt = ft * Ue, ii = 1 / He(Tt);
            u.zoom = ft === 1 ? R : m + u.scaleZoom(ii), this._rotating && (u.bearing = o.z.number(T, p, ft)), this._pitching && (u.pitch = o.z.number(s, b, ft)), this._padding && (u.interpolatePadding(l, P, ft), E = u.centerPoint.add(C)), this.terrain && !t.freezeElevation && this._updateElevation(ft);
            const Mt = ft === 1 ? N : u.unproject(ie.add(H.mult(vt(Tt))).mult(ii));
            u.setLocationAtPoint(u.renderWorldCopies ? Mt.wrap() : Mt, E), this._applyUpdatedTransform(u), this._fireMoveEvents(n);
          }, () => {
            this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(n);
          }, t), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(t, n) {
          var c;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const u = this._onEaseEnd;
            delete this._onEaseEnd, u.call(this, n);
          }
          return t || (c = this.handlers) === null || c === void 0 || c.stop(!1), this;
        }
        _ease(t, n, c) {
          c.animate === !1 || c.duration === 0 ? (t(1), n()) : (this._easeStart = q.now(), this._easeOptions = c, this._onEaseFrame = t, this._onEaseEnd = n, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(t, n) {
          t = o.b2(t, -180, 180);
          const c = Math.abs(t - n);
          return Math.abs(t - 360 - n) < c && (t -= 360), Math.abs(t + 360 - n) < c && (t += 360), t;
        }
        _normalizeCenter(t) {
          const n = this.transform;
          if (!n.renderWorldCopies || n.lngRange) return;
          const c = t.lng - n.center.lng;
          t.lng += c > 180 ? -360 : c < -180 ? 360 : 0;
        }
        queryTerrainElevation(t) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(o.M.convert(t), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const sc = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
      class Nl {
        constructor(t = sc) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (n) => {
            !n || n.sourceDataType !== "metadata" && n.sourceDataType !== "visibility" && n.dataType !== "style" && n.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = t;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(t) {
          return this._map = t, this._compact = this.options.compact, this._container = U.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = U.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = U.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          U.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(t, n) {
          const c = this._map._getUIString(`AttributionControl.${n}`);
          t.title = c, t.setAttribute("aria-label", c);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let t = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map((u) => typeof u != "string" ? "" : u)) : typeof this.options.customAttribution == "string" && t.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const u = this._map.style.stylesheet;
            this.styleOwner = u.owner, this.styleId = u.id;
          }
          const n = this._map.style.sourceCaches;
          for (const u in n) {
            const m = n[u];
            if (m.used || m.usedForTerrain) {
              const T = m.getSource();
              T.attribution && t.indexOf(T.attribution) < 0 && t.push(T.attribution);
            }
          }
          t = t.filter((u) => String(u).trim()), t.sort((u, m) => u.length - m.length), t = t.filter((u, m) => {
            for (let T = m + 1; T < t.length; T++) if (t[T].indexOf(u) >= 0) return !1;
            return !0;
          });
          const c = t.join(" | ");
          c !== this._attribHTML && (this._attribHTML = c, t.length ? (this._innerContainer.innerHTML = c, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class Rl {
        constructor(t = {}) {
          this._updateCompact = () => {
            const n = this._container.children;
            if (n.length) {
              const c = n[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && c.classList.add("maplibregl-compact") : c.classList.remove("maplibregl-compact");
            }
          }, this.options = t;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(t) {
          this._map = t, this._compact = this.options && this.options.compact, this._container = U.create("div", "maplibregl-ctrl");
          const n = U.create("a", "maplibregl-ctrl-logo");
          return n.target = "_blank", n.rel = "noopener nofollow", n.href = "https://maplibre.org/", n.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), n.setAttribute("rel", "noopener nofollow"), this._container.appendChild(n), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          U.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class Uo {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(t) {
          const n = ++this._id;
          return this._queue.push({ callback: t, id: n, cancelled: !1 }), n;
        }
        remove(t) {
          const n = this._currentlyRunning, c = n ? this._queue.concat(n) : this._queue;
          for (const u of c) if (u.id === t) return void (u.cancelled = !0);
        }
        run(t = 0) {
          if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
          const n = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const c of n) if (!c.cancelled && (c.callback(t), this._cleared)) break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      var xa = o.X([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class Rt extends o.E {
        constructor(t) {
          super(), this.sourceCache = t, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t.usedForTerrain = !0, t.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
        }
        update(t, n) {
          this.sourceCache.update(t, n), this._renderableTilesKeys = [];
          const c = {};
          for (const u of t.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: n })) c[u.key] = !0, this._renderableTilesKeys.push(u.key), this._tiles[u.key] || (u.posMatrix = new Float64Array(16), o.aO(u.posMatrix, 0, o.W, 0, o.W, 0, 1), this._tiles[u.key] = new ui(u, this.tileSize));
          for (const u in this._tiles) c[u] || delete this._tiles[u];
        }
        freeRtt(t) {
          for (const n in this._tiles) {
            const c = this._tiles[n];
            (!t || c.tileID.equals(t) || c.tileID.isChildOf(t) || t.isChildOf(c.tileID)) && (c.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((t) => this.getTileByID(t));
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        getTerrainCoords(t) {
          const n = {};
          for (const c of this._renderableTilesKeys) {
            const u = this._tiles[c].tileID;
            if (u.canonical.equals(t.canonical)) {
              const m = t.clone();
              m.posMatrix = new Float64Array(16), o.aO(m.posMatrix, 0, o.W, 0, o.W, 0, 1), n[c] = m;
            } else if (u.canonical.isChildOf(t.canonical)) {
              const m = t.clone();
              m.posMatrix = new Float64Array(16);
              const T = u.canonical.z - t.canonical.z, s = u.canonical.x - (u.canonical.x >> T << T), l = u.canonical.y - (u.canonical.y >> T << T), p = o.W >> T;
              o.aO(m.posMatrix, 0, p, 0, p, 0, 1), o.H(m.posMatrix, m.posMatrix, [-s * p, -l * p, 0]), n[c] = m;
            } else if (t.canonical.isChildOf(u.canonical)) {
              const m = t.clone();
              m.posMatrix = new Float64Array(16);
              const T = t.canonical.z - u.canonical.z, s = t.canonical.x - (t.canonical.x >> T << T), l = t.canonical.y - (t.canonical.y >> T << T), p = o.W >> T;
              o.aO(m.posMatrix, 0, o.W, 0, o.W, 0, 1), o.H(m.posMatrix, m.posMatrix, [s * p, l * p, 0]), o.J(m.posMatrix, m.posMatrix, [1 / 2 ** T, 1 / 2 ** T, 0]), n[c] = m;
            }
          }
          return n;
        }
        getSourceTile(t, n) {
          const c = this.sourceCache._source;
          let u = t.overscaledZ - this.deltaZoom;
          if (u > c.maxzoom && (u = c.maxzoom), u < c.minzoom) return null;
          this._sourceTileCache[t.key] || (this._sourceTileCache[t.key] = t.scaledTo(u).key);
          let m = this.sourceCache.getTileByID(this._sourceTileCache[t.key]);
          if ((!m || !m.dem) && n) for (; u >= c.minzoom && (!m || !m.dem); ) m = this.sourceCache.getTileByID(t.scaledTo(u--).key);
          return m;
        }
        tilesAfterTime(t = Date.now()) {
          return Object.values(this._tiles).filter((n) => n.timeAdded >= t);
        }
      }
      class Vs {
        constructor(t, n, c) {
          this.painter = t, this.sourceCache = new Rt(n), this.options = c, this.exaggeration = typeof c.exaggeration == "number" ? c.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(t, n, c, u = o.W) {
          var m;
          if (!(n >= 0 && n < u && c >= 0 && c < u)) return 0;
          const T = this.getTerrainData(t), s = (m = T.tile) === null || m === void 0 ? void 0 : m.dem;
          if (!s) return 0;
          const l = function(z, N, R) {
            var G = N[0], ie = N[1];
            return z[0] = R[0] * G + R[4] * ie + R[12], z[1] = R[1] * G + R[5] * ie + R[13], z;
          }([], [n / u * o.W, c / u * o.W], T.u_terrain_matrix), p = [l[0] * s.dim, l[1] * s.dim], b = Math.floor(p[0]), P = Math.floor(p[1]), C = p[0] - b, E = p[1] - P;
          return s.get(b, P) * (1 - C) * (1 - E) + s.get(b + 1, P) * C * (1 - E) + s.get(b, P + 1) * (1 - C) * E + s.get(b + 1, P + 1) * C * E;
        }
        getElevationForLngLatZoom(t, n) {
          const { tileID: c, mercatorX: u, mercatorY: m } = this._getOverscaledTileIDFromLngLatZoom(t, n);
          return this.getElevation(c, u % o.W, m % o.W, o.W);
        }
        getElevation(t, n, c, u = o.W) {
          return this.getDEMElevation(t, n, c, u) * this.exaggeration;
        }
        getTerrainData(t) {
          if (!this._emptyDemTexture) {
            const u = this.painter.context, m = new o.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new ae(u, m, u.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new ae(u, new o.R({ width: 1, height: 1 }), u.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = o.an([]);
          }
          const n = this.sourceCache.getSourceTile(t, !0);
          if (n && n.dem && (!n.demTexture || n.needsTerrainPrepare)) {
            const u = this.painter.context;
            n.demTexture = this.painter.getTileTexture(n.dem.stride), n.demTexture ? n.demTexture.update(n.dem.getPixels(), { premultiply: !1 }) : n.demTexture = new ae(u, n.dem.getPixels(), u.gl.RGBA, { premultiply: !1 }), n.demTexture.bind(u.gl.NEAREST, u.gl.CLAMP_TO_EDGE), n.needsTerrainPrepare = !1;
          }
          const c = n && n + n.tileID.key + t.key;
          if (c && !this._demMatrixCache[c]) {
            const u = this.sourceCache.sourceCache._source.maxzoom;
            let m = t.canonical.z - n.tileID.canonical.z;
            t.overscaledZ > t.canonical.z && (t.canonical.z >= u ? m = t.canonical.z - u : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const T = t.canonical.x - (t.canonical.x >> m << m), s = t.canonical.y - (t.canonical.y >> m << m), l = o.ba(new Float64Array(16), [1 / (o.W << m), 1 / (o.W << m), 0]);
            o.H(l, l, [T * o.W, s * o.W, 0]), this._demMatrixCache[t.key] = { matrix: l, coord: t };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: n && n.dem && n.dem.dim || 1, u_terrain_matrix: c ? this._demMatrixCache[t.key].matrix : this._emptyDemMatrix, u_terrain_unpack: n && n.dem && n.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (n && n.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: n };
        }
        getFramebuffer(t) {
          const n = this.painter, c = n.width / devicePixelRatio, u = n.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === c && this._fbo.height === u || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new ae(n.context, { width: c, height: u, data: null }, n.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(n.context.gl.NEAREST, n.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new ae(n.context, { width: c, height: u, data: null }, n.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(n.context.gl.NEAREST, n.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = n.context.createFramebuffer(c, u, !0, !1), this._fbo.depthAttachment.set(n.context.createRenderbuffer(n.context.gl.DEPTH_COMPONENT16, c, u))), this._fbo.colorAttachment.set(t === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const t = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const n = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let m = 0, T = 0; m < this._coordsTextureSize; m++) for (let s = 0; s < this._coordsTextureSize; s++, T += 4) n[T + 0] = 255 & s, n[T + 1] = 255 & m, n[T + 2] = s >> 8 << 4 | m >> 8, n[T + 3] = 0;
          const c = new o.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(n.buffer)), u = new ae(t, c, t.gl.RGBA, { premultiply: !1 });
          return u.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE), this._coordsTexture = u, u;
        }
        pointCoordinate(t) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const n = new Uint8Array(4), c = this.painter.context, u = c.gl, m = Math.round(t.x * this.painter.pixelRatio / devicePixelRatio), T = Math.round(t.y * this.painter.pixelRatio / devicePixelRatio), s = Math.round(this.painter.height / devicePixelRatio);
          c.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), u.readPixels(m, s - T - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, n), c.bindFramebuffer.set(null);
          const l = n[0] + (n[2] >> 4 << 8), p = n[1] + ((15 & n[2]) << 8), b = this.coordsIndex[255 - n[3]], P = b && this.sourceCache.getTileByID(b);
          if (!P) return null;
          const C = this._coordsTextureSize, E = (1 << P.tileID.canonical.z) * C;
          return new o.Y((P.tileID.canonical.x * C + l) / E + P.tileID.wrap, (P.tileID.canonical.y * C + p) / E, this.getElevation(P.tileID, l, p, C));
        }
        depthAtPoint(t) {
          const n = new Uint8Array(4), c = this.painter.context, u = c.gl;
          return c.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), u.readPixels(t.x, this.painter.height / devicePixelRatio - t.y - 1, 1, 1, u.RGBA, u.UNSIGNED_BYTE, n), c.bindFramebuffer.set(null), (n[0] / 16777216 + n[1] / 65536 + n[2] / 256 + n[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh) return this._mesh;
          const t = this.painter.context, n = new o.bb(), c = new o.aY(), u = this.meshSize, m = o.W / u, T = u * u;
          for (let P = 0; P <= u; P++) for (let C = 0; C <= u; C++) n.emplaceBack(C * m, P * m, 0);
          for (let P = 0; P < T; P += u + 1) for (let C = 0; C < u; C++) c.emplaceBack(C + P, u + C + P + 1, u + C + P + 2), c.emplaceBack(C + P, u + C + P + 2, C + P + 1);
          const s = n.length, l = s + 2 * (u + 1);
          for (const P of [0, 1]) for (let C = 0; C <= u; C++) for (const E of [0, 1]) n.emplaceBack(C * m, P * o.W, E);
          for (let P = 0; P < 2 * u; P += 2) c.emplaceBack(l + P, l + P + 1, l + P + 3), c.emplaceBack(l + P, l + P + 3, l + P + 2), c.emplaceBack(s + P, s + P + 3, s + P + 1), c.emplaceBack(s + P, s + P + 2, s + P + 3);
          const p = n.length, b = p + 2 * (u + 1);
          for (const P of [0, 1]) for (let C = 0; C <= u; C++) for (const E of [0, 1]) n.emplaceBack(P * o.W, C * m, E);
          for (let P = 0; P < 2 * u; P += 2) c.emplaceBack(p + P, p + P + 1, p + P + 3), c.emplaceBack(p + P, p + P + 3, p + P + 2), c.emplaceBack(b + P, b + P + 3, b + P + 1), c.emplaceBack(b + P, b + P + 2, b + P + 3);
          return this._mesh = { indexBuffer: t.createIndexBuffer(c), vertexBuffer: t.createVertexBuffer(n, xa.members), segments: o.$.simpleSegment(0, 0, n.length, c.length) }, this._mesh;
        }
        getMeshFrameDelta(t) {
          return 2 * Math.PI * o.bc / Math.pow(2, t) / 5;
        }
        getMinTileElevationForLngLatZoom(t, n) {
          var c;
          const { tileID: u } = this._getOverscaledTileIDFromLngLatZoom(t, n);
          return (c = this.getMinMaxElevation(u).minElevation) !== null && c !== void 0 ? c : 0;
        }
        getMinMaxElevation(t) {
          const n = this.getTerrainData(t).tile, c = { minElevation: null, maxElevation: null };
          return n && n.dem && (c.minElevation = n.dem.min * this.exaggeration, c.maxElevation = n.dem.max * this.exaggeration), c;
        }
        _getOverscaledTileIDFromLngLatZoom(t, n) {
          const c = o.Y.fromLngLat(t.wrap()), u = (1 << n) * o.W, m = c.x * u, T = c.y * u, s = Math.floor(m / o.W), l = Math.floor(T / o.W);
          return { tileID: new o.Q(n, 0, n, s, l), mercatorX: m, mercatorY: T };
        }
      }
      class on {
        constructor(t, n, c) {
          this._context = t, this._size = n, this._tileSize = c, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const t of this._objects) t.texture.destroy(), t.fbo.destroy();
        }
        _createObject(t) {
          const n = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), c = new ae(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return c.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), n.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), n.colorAttachment.set(c.texture), { id: t, fbo: n, texture: c, stamp: -1, inUse: !1 };
        }
        getObjectForId(t) {
          return this._objects[t];
        }
        useObject(t) {
          t.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((n) => t.id !== n), this._recentlyUsed.push(t.id);
        }
        stampObject(t) {
          t.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const n of this._recentlyUsed) if (!this._objects[n].inUse) return this._objects[n];
          if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const t = this._createObject(this._objects.length);
          return this._objects.push(t), t;
        }
        freeObject(t) {
          t.inUse = !1;
        }
        freeAllObjects() {
          for (const t of this._objects) this.freeObject(t);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((t) => !t.inUse) === !1;
        }
      }
      const jr = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
      class ac {
        constructor(t, n) {
          this.painter = t, this.terrain = n, this.pool = new on(t.context, 30, n.sourceCache.tileSize * n.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(t) {
          return this.pool.getObjectForId(t.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(t, n) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t._order.filter((c) => !t._layers[c].isHidden(n)), this._coordsDescendingInv = {};
          for (const c in t.sourceCaches) {
            this._coordsDescendingInv[c] = {};
            const u = t.sourceCaches[c].getVisibleCoordinates();
            for (const m of u) {
              const T = this.terrain.sourceCache.getTerrainCoords(m);
              for (const s in T) this._coordsDescendingInv[c][s] || (this._coordsDescendingInv[c][s] = []), this._coordsDescendingInv[c][s].push(T[s]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const c of t._order) {
            const u = t._layers[c], m = u.source;
            if (jr[u.type] && !this._coordsDescendingInvStr[m]) {
              this._coordsDescendingInvStr[m] = {};
              for (const T in this._coordsDescendingInv[m]) this._coordsDescendingInvStr[m][T] = this._coordsDescendingInv[m][T].map((s) => s.key).sort().join();
            }
          }
          for (const c of this._renderableTiles) for (const u in this._coordsDescendingInvStr) {
            const m = this._coordsDescendingInvStr[u][c.tileID.key];
            m && m !== c.rttCoords[u] && (c.rtt = []);
          }
        }
        renderLayer(t) {
          if (t.isHidden(this.painter.transform.zoom)) return !1;
          const n = t.type, c = this.painter, u = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t.id;
          if (jr[n] && (this._prevType && jr[this._prevType] || this._stacks.push([]), this._prevType = n, this._stacks[this._stacks.length - 1].push(t.id), !u)) return !0;
          if (jr[this._prevType] || jr[n] && u) {
            this._prevType = n;
            const m = this._stacks.length - 1, T = this._stacks[m] || [];
            for (const s of this._renderableTiles) {
              if (this.pool.isFull() && (rs(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(s), s.rtt[m]) {
                const p = this.pool.getObjectForId(s.rtt[m].id);
                if (p.stamp === s.rtt[m].stamp) {
                  this.pool.useObject(p);
                  continue;
                }
              }
              const l = this.pool.getOrCreateFreeObject();
              this.pool.useObject(l), this.pool.stampObject(l), s.rtt[m] = { id: l.id, stamp: l.stamp }, c.context.bindFramebuffer.set(l.fbo.framebuffer), c.context.clear({ color: o.aP.transparent, stencil: 0 }), c.currentStencilSource = void 0;
              for (let p = 0; p < T.length; p++) {
                const b = c.style._layers[T[p]], P = b.source ? this._coordsDescendingInv[b.source][s.tileID.key] : [s.tileID];
                c.context.viewport.set([0, 0, l.fbo.width, l.fbo.height]), c._renderTileClippingMasks(b, P), c.renderLayer(c, c.style.sourceCaches[b.source], b, P), b.source && (s.rttCoords[b.source] = this._coordsDescendingInvStr[b.source][s.tileID.key]);
              }
            }
            return rs(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), jr[n];
          }
          return !1;
        }
      }
      const Pt = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, bs = D, On = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: sc, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, refreshExpiredTiles: !0, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0 }, oc = (f) => {
        f.touchstart = f.dragStart, f.touchmoveWindow = f.dragMove, f.touchend = f.dragEnd;
      }, Bl = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class Ol {
        constructor(t, n, c = !1) {
          this.mousedown = (T) => {
            this.startMouse(o.e({}, T, { ctrlKey: !0, preventDefault: () => T.preventDefault() }), U.mousePos(this.element, T)), U.addEventListener(window, "mousemove", this.mousemove), U.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (T) => {
            this.moveMouse(T, U.mousePos(this.element, T));
          }, this.mouseup = (T) => {
            this.mouseRotate.dragEnd(T), this.mousePitch && this.mousePitch.dragEnd(T), this.offTemp();
          }, this.touchstart = (T) => {
            T.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = U.touchPos(this.element, T.targetTouches)[0], this.startTouch(T, this._startPos), U.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), U.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (T) => {
            T.targetTouches.length !== 1 ? this.reset() : (this._lastPos = U.touchPos(this.element, T.targetTouches)[0], this.moveTouch(T, this._lastPos));
          }, this.touchend = (T) => {
            T.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const u = t.dragRotate._mouseRotate.getClickTolerance(), m = t.dragRotate._mousePitch.getClickTolerance();
          this.element = n, this.mouseRotate = mn({ clickTolerance: u, enable: !0 }), this.touchRotate = (({ enable: T, clickTolerance: s, bearingDegreesPerPixelMoved: l = 0.8 }) => {
            const p = new hr();
            return new va({ clickTolerance: s, move: (b, P) => ({ bearingDelta: (P.x - b.x) * l }), moveStateManager: p, enable: T, assignEvents: oc });
          })({ clickTolerance: u, enable: !0 }), this.map = t, c && (this.mousePitch = ho({ clickTolerance: m, enable: !0 }), this.touchPitch = (({ enable: T, clickTolerance: s, pitchDegreesPerPixelMoved: l = -0.5 }) => {
            const p = new hr();
            return new va({ clickTolerance: s, move: (b, P) => ({ pitchDelta: (P.y - b.y) * l }), moveStateManager: p, enable: T, assignEvents: oc });
          })({ clickTolerance: m, enable: !0 })), U.addEventListener(n, "mousedown", this.mousedown), U.addEventListener(n, "touchstart", this.touchstart, { passive: !1 }), U.addEventListener(n, "touchcancel", this.reset);
        }
        startMouse(t, n) {
          this.mouseRotate.dragStart(t, n), this.mousePitch && this.mousePitch.dragStart(t, n), U.disableDrag();
        }
        startTouch(t, n) {
          this.touchRotate.dragStart(t, n), this.touchPitch && this.touchPitch.dragStart(t, n), U.disableDrag();
        }
        moveMouse(t, n) {
          const c = this.map, { bearingDelta: u } = this.mouseRotate.dragMove(t, n) || {};
          if (u && c.setBearing(c.getBearing() + u), this.mousePitch) {
            const { pitchDelta: m } = this.mousePitch.dragMove(t, n) || {};
            m && c.setPitch(c.getPitch() + m);
          }
        }
        moveTouch(t, n) {
          const c = this.map, { bearingDelta: u } = this.touchRotate.dragMove(t, n) || {};
          if (u && c.setBearing(c.getBearing() + u), this.touchPitch) {
            const { pitchDelta: m } = this.touchPitch.dragMove(t, n) || {};
            m && c.setPitch(c.getPitch() + m);
          }
        }
        off() {
          const t = this.element;
          U.removeEventListener(t, "mousedown", this.mousedown), U.removeEventListener(t, "touchstart", this.touchstart, { passive: !1 }), U.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), U.removeEventListener(window, "touchend", this.touchend), U.removeEventListener(t, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          U.enableDrag(), U.removeEventListener(window, "mousemove", this.mousemove), U.removeEventListener(window, "mouseup", this.mouseup), U.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), U.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let $s;
      function jl(f, t, n) {
        const c = new o.M(f.lng, f.lat);
        if (f = new o.M(f.lng, f.lat), t) {
          const u = new o.M(f.lng - 360, f.lat), m = new o.M(f.lng + 360, f.lat), T = n.locationPoint(f).distSqr(t);
          n.locationPoint(u).distSqr(t) < T ? f = u : n.locationPoint(m).distSqr(t) < T && (f = m);
        }
        for (; Math.abs(f.lng - n.center.lng) > 180; ) {
          const u = n.locationPoint(f);
          if (u.x >= 0 && u.y >= 0 && u.x <= n.width && u.y <= n.height) break;
          f.lng > n.center.lng ? f.lng -= 360 : f.lng += 360;
        }
        return f.lng !== c.lng && n.locationPoint(f).y > n.height / 2 - n.getHorizon() ? f : c;
      }
      const hl = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function ba(f, t, n) {
        const c = f.classList;
        for (const u in hl) c.remove(`maplibregl-${n}-anchor-${u}`);
        c.add(`maplibregl-${n}-anchor-${t}`);
      }
      class ji extends o.E {
        constructor(t) {
          if (super(), this._onKeyPress = (n) => {
            const c = n.code, u = n.charCode || n.keyCode;
            c !== "Space" && c !== "Enter" && u !== 32 && u !== 13 || this.togglePopup();
          }, this._onMapClick = (n) => {
            const c = n.originalEvent.target, u = this._element;
            this._popup && (c === u || u.contains(c)) && this.togglePopup();
          }, this._update = (n) => {
            var c;
            if (!this._map) return;
            const u = this._map.loaded() && !this._map.isMoving();
            ((n == null ? void 0 : n.type) === "terrain" || (n == null ? void 0 : n.type) === "render" && !u) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? jl(this._lngLat, this._flatPos, this._map.transform) : (c = this._lngLat) === null || c === void 0 ? void 0 : c.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let m = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? m = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (m = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let T = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? T = "rotateX(0deg)" : this._pitchAlignment === "map" && (T = `rotateX(${this._map.getPitch()}deg)`), n && n.type !== "moveend" || (this._pos = this._pos.round()), U.setTransform(this._element, `${hl[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${T} ${m}`), q.frameAsync(new AbortController()).then(() => {
              this._updateOpacity(n && n.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (n) => {
            if (!this._isDragging) {
              const c = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = n.point.dist(this._pointerdownPos) >= c;
            }
            this._isDragging && (this._pos = n.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.k("dragstart"))), this.fire(new o.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (n) => {
            this._element.contains(n.originalEvent.target) && (n.preventDefault(), this._positionDelta = n.point.sub(this._pos).add(this._offset), this._pointerdownPos = n.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment !== "auto" ? t.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(t == null ? void 0 : t.opacity, t == null ? void 0 : t.opacityWhenCovered), t && t.element) this._element = t.element, this._offset = o.P.convert(t && t.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = U.create("div");
            const n = U.createNS("http://www.w3.org/2000/svg", "svg"), c = 41, u = 27;
            n.setAttributeNS(null, "display", "block"), n.setAttributeNS(null, "height", `${c}px`), n.setAttributeNS(null, "width", `${u}px`), n.setAttributeNS(null, "viewBox", `0 0 ${u} ${c}`);
            const m = U.createNS("http://www.w3.org/2000/svg", "g");
            m.setAttributeNS(null, "stroke", "none"), m.setAttributeNS(null, "stroke-width", "1"), m.setAttributeNS(null, "fill", "none"), m.setAttributeNS(null, "fill-rule", "evenodd");
            const T = U.createNS("http://www.w3.org/2000/svg", "g");
            T.setAttributeNS(null, "fill-rule", "nonzero");
            const s = U.createNS("http://www.w3.org/2000/svg", "g");
            s.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), s.setAttributeNS(null, "fill", "#000000");
            const l = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const G of l) {
              const ie = U.createNS("http://www.w3.org/2000/svg", "ellipse");
              ie.setAttributeNS(null, "opacity", "0.04"), ie.setAttributeNS(null, "cx", "10.5"), ie.setAttributeNS(null, "cy", "5.80029008"), ie.setAttributeNS(null, "rx", G.rx), ie.setAttributeNS(null, "ry", G.ry), s.appendChild(ie);
            }
            const p = U.createNS("http://www.w3.org/2000/svg", "g");
            p.setAttributeNS(null, "fill", this._color);
            const b = U.createNS("http://www.w3.org/2000/svg", "path");
            b.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), p.appendChild(b);
            const P = U.createNS("http://www.w3.org/2000/svg", "g");
            P.setAttributeNS(null, "opacity", "0.25"), P.setAttributeNS(null, "fill", "#000000");
            const C = U.createNS("http://www.w3.org/2000/svg", "path");
            C.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), P.appendChild(C);
            const E = U.createNS("http://www.w3.org/2000/svg", "g");
            E.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), E.setAttributeNS(null, "fill", "#FFFFFF");
            const z = U.createNS("http://www.w3.org/2000/svg", "g");
            z.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const N = U.createNS("http://www.w3.org/2000/svg", "circle");
            N.setAttributeNS(null, "fill", "#000000"), N.setAttributeNS(null, "opacity", "0.25"), N.setAttributeNS(null, "cx", "5.5"), N.setAttributeNS(null, "cy", "5.5"), N.setAttributeNS(null, "r", "5.4999962");
            const R = U.createNS("http://www.w3.org/2000/svg", "circle");
            R.setAttributeNS(null, "fill", "#FFFFFF"), R.setAttributeNS(null, "cx", "5.5"), R.setAttributeNS(null, "cy", "5.5"), R.setAttributeNS(null, "r", "5.4999962"), z.appendChild(N), z.appendChild(R), T.appendChild(s), T.appendChild(p), T.appendChild(P), T.appendChild(E), T.appendChild(z), n.appendChild(T), n.setAttributeNS(null, "height", c * this._scale + "px"), n.setAttributeNS(null, "width", u * this._scale + "px"), this._element.appendChild(n), this._offset = o.P.convert(t && t.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (n) => {
            n.preventDefault();
          }), this._element.addEventListener("mousedown", (n) => {
            n.preventDefault();
          }), ba(this._element, this._anchor, "marker"), t && t.className) for (const n of t.className.split(" ")) this._element.classList.add(n);
          this._popup = null;
        }
        addTo(t) {
          return this.remove(), this._map = t, this._element.setAttribute("aria-label", t._getUIString("Marker.Title")), t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), t.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), U.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t) {
          return this._lngLat = o.M.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(t) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
            if (!("offset" in t.options)) {
              const u = Math.abs(13.5) / Math.SQRT2;
              t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [u, -1 * (38.1 - 13.5 + u)], "bottom-right": [-u, -1 * (38.1 - 13.5 + u)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = t, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const t = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : t ? (t.isOpen() ? t.remove() : (t.setLngLat(this._lngLat), t.addTo(this._map)), this) : this;
        }
        _updateOpacity(t = !1) {
          var n, c;
          if (!(!((n = this._map) === null || n === void 0) && n.terrain)) return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (t) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const u = this._map, m = u.terrain.depthAtPoint(this._pos), T = u.terrain.getElevationForLngLatZoom(this._lngLat, u.transform.tileZoom);
          if (u.transform.lngLatToCameraDepth(this._lngLat, T) - m < 6e-3) return void (this._element.style.opacity = this._opacity);
          const s = -this._offset.y / u.transform._pixelPerMeter, l = Math.sin(u.getPitch() * Math.PI / 180) * s, p = u.terrain.depthAtPoint(new o.P(this._pos.x, this._pos.y - this._offset.y)), b = u.transform.lngLatToCameraDepth(this._lngLat, T + l) - p > 6e-3;
          !((c = this._popup) === null || c === void 0) && c.isOpen() && b && this._popup.remove(), this._element.style.opacity = b ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t) {
          return this._offset = o.P.convert(t), this._update(), this;
        }
        addClassName(t) {
          this._element.classList.add(t);
        }
        removeClassName(t) {
          this._element.classList.remove(t);
        }
        toggleClassName(t) {
          return this._element.classList.toggle(t);
        }
        setDraggable(t) {
          return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(t) {
          return this._rotation = t || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(t) {
          return this._rotationAlignment = t || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(t) {
          return this._pitchAlignment = t && t !== "auto" ? t : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(t, n) {
          return t === void 0 && n === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t !== void 0 && (this._opacity = t), n !== void 0 && (this._opacityWhenCovered = n), this._map && this._updateOpacity(!0), this;
        }
      }
      const Ba = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let ws = 0, wa = !1;
      const ql = { maxWidth: 100, unit: "metric" };
      function Ul(f, t, n) {
        const c = n && n.maxWidth || 100, u = f._container.clientHeight / 2, m = f.unproject([0, u]), T = f.unproject([c, u]), s = m.distanceTo(T);
        if (n && n.unit === "imperial") {
          const l = 3.2808 * s;
          l > 5280 ? go(t, c, l / 5280, f._getUIString("ScaleControl.Miles")) : go(t, c, l, f._getUIString("ScaleControl.Feet"));
        } else n && n.unit === "nautical" ? go(t, c, s / 1852, f._getUIString("ScaleControl.NauticalMiles")) : s >= 1e3 ? go(t, c, s / 1e3, f._getUIString("ScaleControl.Kilometers")) : go(t, c, s, f._getUIString("ScaleControl.Meters"));
      }
      function go(f, t, n, c) {
        const u = function(m) {
          const T = Math.pow(10, `${Math.floor(m)}`.length - 1);
          let s = m / T;
          return s = s >= 10 ? 10 : s >= 5 ? 5 : s >= 3 ? 3 : s >= 2 ? 2 : s >= 1 ? 1 : function(l) {
            const p = Math.pow(10, Math.ceil(-Math.log(l) / Math.LN10));
            return Math.round(l * p) / p;
          }(s), T * s;
        }(n);
        f.style.width = t * (u / n) + "px", f.innerHTML = `${u}&nbsp;${c}`;
      }
      const Ss = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, ul = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function Vt(f) {
        if (f) {
          if (typeof f == "number") {
            const t = Math.round(Math.abs(f) / Math.SQRT2);
            return { center: new o.P(0, 0), top: new o.P(0, f), "top-left": new o.P(t, t), "top-right": new o.P(-t, t), bottom: new o.P(0, -f), "bottom-left": new o.P(t, -t), "bottom-right": new o.P(-t, -t), left: new o.P(f, 0), right: new o.P(-f, 0) };
          }
          if (f instanceof o.P || Array.isArray(f)) {
            const t = o.P.convert(f);
            return { center: t, top: t, "top-left": t, "top-right": t, bottom: t, "bottom-left": t, "bottom-right": t, left: t, right: t };
          }
          return { center: o.P.convert(f.center || [0, 0]), top: o.P.convert(f.top || [0, 0]), "top-left": o.P.convert(f["top-left"] || [0, 0]), "top-right": o.P.convert(f["top-right"] || [0, 0]), bottom: o.P.convert(f.bottom || [0, 0]), "bottom-left": o.P.convert(f["bottom-left"] || [0, 0]), "bottom-right": o.P.convert(f["bottom-right"] || [0, 0]), left: o.P.convert(f.left || [0, 0]), right: o.P.convert(f.right || [0, 0]) };
        }
        return Vt(new o.P(0, 0));
      }
      const ni = D;
      v.AJAXError = o.bf, v.Evented = o.E, v.LngLat = o.M, v.MercatorCoordinate = o.Y, v.Point = o.P, v.addProtocol = o.bg, v.config = o.a, v.removeProtocol = o.bh, v.AttributionControl = Nl, v.BoxZoomHandler = pr, v.CanvasSource = ei, v.CooperativeGesturesHandler = Bn, v.DoubleClickZoomHandler = Ml, v.DragPanHandler = zl, v.DragRotateHandler = mo, v.EdgeInsets = un, v.FullscreenControl = class extends o.E {
        constructor(f = {}) {
          super(), this._onFullscreenChange = () => {
            var t;
            let n = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; !((t = n == null ? void 0 : n.shadowRoot) === null || t === void 0) && t.fullscreenElement; ) n = n.shadowRoot.fullscreenElement;
            n === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = !1, f && f.container && (f.container instanceof HTMLElement ? this._container = f.container : o.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(f) {
          return this._map = f, this._container || (this._container = this._map.getContainer()), this._controlContainer = U.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          U.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const f = this._fullscreenButton = U.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          U.create("span", "maplibregl-ctrl-icon", f).setAttribute("aria-hidden", "true"), f.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const f = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", f), this._fullscreenButton.title = f;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new o.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new o.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, v.GeoJSONSource = ut, v.GeolocateControl = class extends o.E {
        constructor(f) {
          super(), this._onSuccess = (t) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new o.k("outofmaxbounds", t)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new o.k("geolocate", t)), this._finish();
            }
          }, this._updateCamera = (t) => {
            const n = new o.M(t.coords.longitude, t.coords.latitude), c = t.coords.accuracy, u = this._map.getBearing(), m = o.e({ bearing: u }, this.options.fitBoundsOptions), T = Ut.fromLngLat(n, c);
            this._map.fitBounds(T, m, { geolocateSource: !0 });
          }, this._updateMarker = (t) => {
            if (t) {
              const n = new o.M(t.coords.longitude, t.coords.latitude);
              this._accuracyCircleMarker.setLngLat(n).addTo(this._map), this._userLocationDotMarker.setLngLat(n).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (t) => {
            if (this._map) {
              if (this.options.trackUserLocation) if (t.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (t.code === 3 && wa) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new o.k("error", t)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = (t) => {
            if (this._map) {
              if (this._container.addEventListener("contextmenu", (n) => n.preventDefault()), this._geolocateButton = U.create("button", "maplibregl-ctrl-geolocate", this._container), U.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", t === !1) {
                o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
              } else {
                const n = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = U.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ji({ element: this._dotElement }), this._circleElement = U.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ji({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (n) => {
                n.geolocateSource || this._watchState !== "ACTIVE_LOCK" || n.originalEvent && n.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new o.k("trackuserlocationend")), this.fire(new o.k("userlocationlostfocus")));
              });
            }
          }, this.options = o.e({}, Ba, f);
        }
        onAdd(f) {
          return this._map = f, this._container = U.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), function() {
            return o._(this, arguments, void 0, function* (t = !1) {
              if ($s !== void 0 && !t) return $s;
              if (window.navigator.permissions === void 0) return $s = !!window.navigator.geolocation, $s;
              try {
                $s = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
              } catch {
                $s = !!window.navigator.geolocation;
              }
              return $s;
            });
          }().then((t) => this._setupUI(t)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), U.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, ws = 0, wa = !1;
        }
        _isOutOfMapMaxBounds(f) {
          const t = this._map.getMaxBounds(), n = f.coords;
          return t && (n.longitude < t.getWest() || n.longitude > t.getEast() || n.latitude < t.getSouth() || n.latitude > t.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const f = this._map.getBounds(), t = f.getSouthEast(), n = f.getNorthEast(), c = t.distanceTo(n), u = Math.ceil(this._accuracy / (c / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${u}px`, this._circleElement.style.height = `${u}px`;
        }
        trigger() {
          if (!this._setup) return o.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new o.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                ws--, wa = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new o.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.k("trackuserlocationstart")), this.fire(new o.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let f;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ws++, ws > 1 ? (f = { maximumAge: 6e5, timeout: 0 }, wa = !0) : (f = this.options.positionOptions, wa = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, f);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, v.Hash = ga, v.ImageSource = Lt, v.KeyboardHandler = xs, v.LngLatBounds = Ut, v.LogoControl = Rl, v.Map = class extends Cc {
        constructor(f) {
          o.bd.mark(o.be.create);
          const t = Object.assign(Object.assign({}, On), f);
          if (t.minZoom != null && t.maxZoom != null && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (t.minPitch != null && t.maxPitch != null && t.minPitch > t.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (t.minPitch != null && t.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (t.maxPitch != null && t.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (super(new ma(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), { bearingSnap: t.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Uo(), this._controls = [], this._mapId = o.a3(), this._contextLost = (n) => {
            n.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new o.k("webglcontextlost", { originalEvent: n }));
          }, this._contextRestored = (n) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new o.k("webglcontextrestored", { originalEvent: n }));
          }, this._onMapScroll = (n) => {
            if (n.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = t.interactive, this._maxTileCacheSize = t.maxTileCacheSize, this._maxTileCacheZoomLevels = t.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat === !0, this._preserveDrawingBuffer = t.preserveDrawingBuffer === !0, this._antialias = t.antialias === !0, this._trackResize = t.trackResize === !0, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles === !0, this._fadeDuration = t.fadeDuration, this._crossSourceCollisions = t.crossSourceCollisions === !0, this._collectResourceTiming = t.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Pt), t.locale), this._clickTolerance = t.clickTolerance, this._overridePixelRatio = t.pixelRatio, this._maxCanvasSize = t.maxCanvasSize, this.transformCameraUpdate = t.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = t.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Fe.addThrottleControl(() => this.isMoving()), this._requestManager = new it(t.transformRequest), typeof t.container == "string") {
            if (this._container = document.getElementById(t.container), !this._container) throw new Error(`Container '${t.container}' not found.`);
          } else {
            if (!(t.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t.container;
          }
          if (t.maxBounds && this.setMaxBounds(t.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)).on("moveend", () => this._update(!1)).on("zoom", () => this._update(!0)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }).once("idle", () => {
            this._idleTriggered = !0;
          }), typeof window < "u") {
            addEventListener("online", this._onWindowOnline, !1);
            let n = !1;
            const c = Nn((u) => {
              this._trackResize && !this._removed && this.resize(u)._update();
            }, 50);
            this._resizeObserver = new ResizeObserver((u) => {
              n ? c(u) : n = !0;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new Us(this, t), this._hash = t.hash && new ga(typeof t.hash == "string" && t.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t.center, zoom: t.zoom, bearing: t.bearing, pitch: t.pitch }), t.bounds && (this.resize(), this.fitBounds(t.bounds, o.e({}, t.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = t.localIdeographFontFamily, this._validateStyle = t.validateStyle, t.style && this.setStyle(t.style, { localIdeographFontFamily: t.localIdeographFontFamily }), t.attributionControl && this.addControl(new Nl(typeof t.attributionControl == "boolean" ? void 0 : t.attributionControl)), t.maplibreLogo && this.addControl(new Rl(), t.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (n) => {
            this._update(n.dataType === "style"), this.fire(new o.k(`${n.dataType}data`, n));
          }), this.on("dataloading", (n) => {
            this.fire(new o.k(`${n.dataType}dataloading`, n));
          }), this.on("dataabort", (n) => {
            this.fire(new o.k("sourcedataabort", n));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(f, t) {
          if (t === void 0 && (t = f.getDefaultPosition ? f.getDefaultPosition() : "top-right"), !f || !f.onAdd) return this.fire(new o.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const n = f.onAdd(this);
          this._controls.push(f);
          const c = this._controlPositions[t];
          return t.indexOf("bottom") !== -1 ? c.insertBefore(n, c.firstChild) : c.appendChild(n), this;
        }
        removeControl(f) {
          if (!f || !f.onRemove) return this.fire(new o.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const t = this._controls.indexOf(f);
          return t > -1 && this._controls.splice(t, 1), f.onRemove(this), this;
        }
        hasControl(f) {
          return this._controls.indexOf(f) > -1;
        }
        calculateCameraOptionsFromTo(f, t, n, c) {
          return c == null && this.terrain && (c = this.terrain.getElevationForLngLatZoom(n, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(f, t, n, c);
        }
        resize(f) {
          var t;
          const n = this._containerDimensions(), c = n[0], u = n[1], m = this._getClampedPixelRatio(c, u);
          if (this._resizeCanvas(c, u, m), this.painter.resize(c, u, m), this.painter.overLimit()) {
            const s = this.painter.context.gl;
            this._maxCanvasSize = [s.drawingBufferWidth, s.drawingBufferHeight];
            const l = this._getClampedPixelRatio(c, u);
            this._resizeCanvas(c, u, l), this.painter.resize(c, u, l);
          }
          this.transform.resize(c, u), (t = this._requestedCameraState) === null || t === void 0 || t.resize(c, u);
          const T = !this._moving;
          return T && (this.stop(), this.fire(new o.k("movestart", f)).fire(new o.k("move", f))), this.fire(new o.k("resize", f)), T && this.fire(new o.k("moveend", f)), this;
        }
        _getClampedPixelRatio(f, t) {
          const { 0: n, 1: c } = this._maxCanvasSize, u = this.getPixelRatio(), m = f * u, T = t * u;
          return Math.min(m > n ? n / m : 1, T > c ? c / T : 1) * u;
        }
        getPixelRatio() {
          var f;
          return (f = this._overridePixelRatio) !== null && f !== void 0 ? f : devicePixelRatio;
        }
        setPixelRatio(f) {
          this._overridePixelRatio = f, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(f) {
          return this.transform.setMaxBounds(Ut.convert(f)), this._update();
        }
        setMinZoom(f) {
          if ((f = f ?? -2) >= -2 && f <= this.transform.maxZoom) return this.transform.minZoom = f, this._update(), this.getZoom() < f && this.setZoom(f), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(f) {
          if ((f = f ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = f, this._update(), this.getZoom() > f && this.setZoom(f), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(f) {
          if ((f = f ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (f >= 0 && f <= this.transform.maxPitch) return this.transform.minPitch = f, this._update(), this.getPitch() < f && this.setPitch(f), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(f) {
          if ((f = f ?? 60) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (f >= this.transform.minPitch) return this.transform.maxPitch = f, this._update(), this.getPitch() > f && this.setPitch(f), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(f) {
          return this.transform.renderWorldCopies = f, this._update();
        }
        project(f) {
          return this.transform.locationPoint(o.M.convert(f), this.style && this.terrain);
        }
        unproject(f) {
          return this.transform.pointLocation(o.P.convert(f), this.terrain);
        }
        isMoving() {
          var f;
          return this._moving || ((f = this.handlers) === null || f === void 0 ? void 0 : f.isMoving());
        }
        isZooming() {
          var f;
          return this._zooming || ((f = this.handlers) === null || f === void 0 ? void 0 : f.isZooming());
        }
        isRotating() {
          var f;
          return this._rotating || ((f = this.handlers) === null || f === void 0 ? void 0 : f.isRotating());
        }
        _createDelegatedListener(f, t, n) {
          if (f === "mouseenter" || f === "mouseover") {
            let c = !1;
            return { layer: t, listener: n, delegates: { mousemove: (m) => {
              const T = this.getLayer(t) ? this.queryRenderedFeatures(m.point, { layers: [t] }) : [];
              T.length ? c || (c = !0, n.call(this, new Pr(f, this, m.originalEvent, { features: T }))) : c = !1;
            }, mouseout: () => {
              c = !1;
            } } };
          }
          if (f === "mouseleave" || f === "mouseout") {
            let c = !1;
            return { layer: t, listener: n, delegates: { mousemove: (T) => {
              (this.getLayer(t) ? this.queryRenderedFeatures(T.point, { layers: [t] }) : []).length ? c = !0 : c && (c = !1, n.call(this, new Pr(f, this, T.originalEvent)));
            }, mouseout: (T) => {
              c && (c = !1, n.call(this, new Pr(f, this, T.originalEvent)));
            } } };
          }
          {
            const c = (u) => {
              const m = this.getLayer(t) ? this.queryRenderedFeatures(u.point, { layers: [t] }) : [];
              m.length && (u.features = m, n.call(this, u), delete u.features);
            };
            return { layer: t, listener: n, delegates: { [f]: c } };
          }
        }
        on(f, t, n) {
          if (n === void 0) return super.on(f, t);
          const c = this._createDelegatedListener(f, t, n);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[f] = this._delegatedListeners[f] || [], this._delegatedListeners[f].push(c);
          for (const u in c.delegates) this.on(u, c.delegates[u]);
          return this;
        }
        once(f, t, n) {
          if (n === void 0) return super.once(f, t);
          const c = this._createDelegatedListener(f, t, n);
          for (const u in c.delegates) this.once(u, c.delegates[u]);
          return this;
        }
        off(f, t, n) {
          return n === void 0 ? super.off(f, t) : (this._delegatedListeners && this._delegatedListeners[f] && ((c) => {
            const u = this._delegatedListeners[f];
            for (let m = 0; m < u.length; m++) {
              const T = u[m];
              if (T.layer === t && T.listener === n) {
                for (const s in T.delegates) this.off(s, T.delegates[s]);
                return u.splice(m, 1), this;
              }
            }
          })(), this);
        }
        queryRenderedFeatures(f, t) {
          if (!this.style) return [];
          let n;
          const c = f instanceof o.P || Array.isArray(f), u = c ? f : [[0, 0], [this.transform.width, this.transform.height]];
          if (t = t || (c ? {} : f) || {}, u instanceof o.P || typeof u[0] == "number") n = [o.P.convert(u)];
          else {
            const m = o.P.convert(u[0]), T = o.P.convert(u[1]);
            n = [m, new o.P(T.x, m.y), T, new o.P(m.x, T.y), m];
          }
          return this.style.queryRenderedFeatures(n, t, this.transform);
        }
        querySourceFeatures(f, t) {
          return this.style.querySourceFeatures(f, t);
        }
        setStyle(f, t) {
          return (t = o.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, t)).diff !== !1 && t.localIdeographFontFamily === this._localIdeographFontFamily && this.style && f ? (this._diffStyle(f, t), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._updateStyle(f, t));
        }
        setTransformRequest(f) {
          return this._requestManager.setTransformRequest(f), this;
        }
        _getUIString(f) {
          const t = this._locale[f];
          if (t == null) throw new Error(`Missing UI string '${f}'`);
          return t;
        }
        _updateStyle(f, t) {
          if (t.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(f, t));
          const n = this.style && t.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!f)), f ? (this.style = new Ga(this, t || {}), this.style.setEventedParent(this, { style: this.style }), typeof f == "string" ? this.style.loadURL(f, t, n) : this.style.loadJSON(f, t, n), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Ga(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(f, t) {
          if (typeof f == "string") {
            const n = this._requestManager.transformRequest(f, "Style");
            o.h(n, new AbortController()).then((c) => {
              this._updateDiff(c.data, t);
            }).catch((c) => {
              c && this.fire(new o.j(c));
            });
          } else typeof f == "object" && this._updateDiff(f, t);
        }
        _updateDiff(f, t) {
          try {
            this.style.setState(f, t) && this._update(!0);
          } catch (n) {
            o.w(`Unable to perform style diff: ${n.message || n.error || n}.  Rebuilding the style from scratch.`), this._updateStyle(f, t);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : o.w("There is no style added to the map.");
        }
        addSource(f, t) {
          return this._lazyInitEmptyStyle(), this.style.addSource(f, t), this._update(!0);
        }
        isSourceLoaded(f) {
          const t = this.style && this.style.sourceCaches[f];
          if (t !== void 0) return t.loaded();
          this.fire(new o.j(new Error(`There is no source with ID '${f}'`)));
        }
        setTerrain(f) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), f) {
            const t = this.style.sourceCaches[f.source];
            if (!t) throw new Error(`cannot load terrain, because there exists no source with ID: ${f.source}`);
            this.terrain === null && t.reload();
            for (const n in this.style._layers) {
              const c = this.style._layers[n];
              c.type === "hillshade" && c.source === f.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new Vs(this.painter, t, f), this.painter.renderToTexture = new ac(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (n) => {
              n.dataType === "style" ? this.terrain.sourceCache.freeRtt() : n.dataType === "source" && n.tile && (n.sourceId !== f.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(n.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new o.k("terrain", { terrain: f })), this;
        }
        getTerrain() {
          var f, t;
          return (t = (f = this.terrain) === null || f === void 0 ? void 0 : f.options) !== null && t !== void 0 ? t : null;
        }
        areTilesLoaded() {
          const f = this.style && this.style.sourceCaches;
          for (const t in f) {
            const n = f[t]._tiles;
            for (const c in n) {
              const u = n[c];
              if (u.state !== "loaded" && u.state !== "errored") return !1;
            }
          }
          return !0;
        }
        removeSource(f) {
          return this.style.removeSource(f), this._update(!0);
        }
        getSource(f) {
          return this.style.getSource(f);
        }
        addImage(f, t, n = {}) {
          const { pixelRatio: c = 1, sdf: u = !1, stretchX: m, stretchY: T, content: s, textFitWidth: l, textFitHeight: p } = n;
          if (this._lazyInitEmptyStyle(), !(t instanceof HTMLImageElement || o.b(t))) {
            if (t.width === void 0 || t.height === void 0) return this.fire(new o.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: b, height: P, data: C } = t, E = t;
              return this.style.addImage(f, { data: new o.R({ width: b, height: P }, new Uint8Array(C)), pixelRatio: c, stretchX: m, stretchY: T, content: s, textFitWidth: l, textFitHeight: p, sdf: u, version: 0, userImage: E }), E.onAdd && E.onAdd(this, f), this;
            }
          }
          {
            const { width: b, height: P, data: C } = q.getImageData(t);
            this.style.addImage(f, { data: new o.R({ width: b, height: P }, C), pixelRatio: c, stretchX: m, stretchY: T, content: s, textFitWidth: l, textFitHeight: p, sdf: u, version: 0 });
          }
        }
        updateImage(f, t) {
          const n = this.style.getImage(f);
          if (!n) return this.fire(new o.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const c = t instanceof HTMLImageElement || o.b(t) ? q.getImageData(t) : t, { width: u, height: m, data: T } = c;
          if (u === void 0 || m === void 0) return this.fire(new o.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (u !== n.data.width || m !== n.data.height) return this.fire(new o.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const s = !(t instanceof HTMLImageElement || o.b(t));
          return n.data.replace(T, s), this.style.updateImage(f, n), this;
        }
        getImage(f) {
          return this.style.getImage(f);
        }
        hasImage(f) {
          return f ? !!this.style.getImage(f) : (this.fire(new o.j(new Error("Missing required image id"))), !1);
        }
        removeImage(f) {
          this.style.removeImage(f);
        }
        loadImage(f) {
          return Fe.getImage(this._requestManager.transformRequest(f, "Image"), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(f, t) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(f, t), this._update(!0);
        }
        moveLayer(f, t) {
          return this.style.moveLayer(f, t), this._update(!0);
        }
        removeLayer(f) {
          return this.style.removeLayer(f), this._update(!0);
        }
        getLayer(f) {
          return this.style.getLayer(f);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(f, t, n) {
          return this.style.setLayerZoomRange(f, t, n), this._update(!0);
        }
        setFilter(f, t, n = {}) {
          return this.style.setFilter(f, t, n), this._update(!0);
        }
        getFilter(f) {
          return this.style.getFilter(f);
        }
        setPaintProperty(f, t, n, c = {}) {
          return this.style.setPaintProperty(f, t, n, c), this._update(!0);
        }
        getPaintProperty(f, t) {
          return this.style.getPaintProperty(f, t);
        }
        setLayoutProperty(f, t, n, c = {}) {
          return this.style.setLayoutProperty(f, t, n, c), this._update(!0);
        }
        getLayoutProperty(f, t) {
          return this.style.getLayoutProperty(f, t);
        }
        setGlyphs(f, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(f, t), this._update(!0);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(f, t, n = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(f, t, n, (c) => {
            c || this._update(!0);
          }), this;
        }
        removeSprite(f) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(f), this._update(!0);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(f, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(f, t, (n) => {
            n || this._update(!0);
          }), this;
        }
        setLight(f, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(f, t), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setFeatureState(f, t) {
          return this.style.setFeatureState(f, t), this._update();
        }
        removeFeatureState(f, t) {
          return this.style.removeFeatureState(f, t), this._update();
        }
        getFeatureState(f) {
          return this.style.getFeatureState(f);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let f = 0, t = 0;
          return this._container && (f = this._container.clientWidth || 400, t = this._container.clientHeight || 300), [f, t];
        }
        _setupContainer() {
          const f = this._container;
          f.classList.add("maplibregl-map");
          const t = this._canvasContainer = U.create("div", "maplibregl-canvas-container", f);
          this._interactive && t.classList.add("maplibregl-interactive"), this._canvas = U.create("canvas", "maplibregl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const n = this._containerDimensions(), c = this._getClampedPixelRatio(n[0], n[1]);
          this._resizeCanvas(n[0], n[1], c);
          const u = this._controlContainer = U.create("div", "maplibregl-control-container", f), m = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((T) => {
            m[T] = U.create("div", `maplibregl-ctrl-${T} `, u);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(f, t, n) {
          this._canvas.width = Math.floor(n * f), this._canvas.height = Math.floor(n * t), this._canvas.style.width = `${f}px`, this._canvas.style.height = `${t}px`;
        }
        _setupPainter() {
          const f = { alpha: !0, stencil: !0, depth: !0, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 };
          let t = null;
          this._canvas.addEventListener("webglcontextcreationerror", (c) => {
            t = { requestedAttributes: f }, c && (t.statusMessage = c.statusMessage, t.type = c.type);
          }, { once: !0 });
          const n = this._canvas.getContext("webgl2", f) || this._canvas.getContext("webgl", f);
          if (!n) {
            const c = "Failed to initialize WebGL";
            throw t ? (t.message = c, new Error(JSON.stringify(t))) : new Error(c);
          }
          this.painter = new _i(n, this.transform), B.testSupport(n);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(f) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || f, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(f) {
          return this._update(), this._renderTaskQueue.add(f);
        }
        _cancelRenderFrame(f) {
          this._renderTaskQueue.remove(f);
        }
        _render(f) {
          const t = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(f), this._removed) return;
          let n = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const u = this.transform.zoom, m = q.now();
            this.style.zoomHistory.update(u, m);
            const T = new o.a8(u, { now: m, fadeDuration: t, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), s = T.crossFadingFactor();
            s === 1 && s === this._crossFadingFactor || (n = !0, this._crossFadingFactor = s), this.style.update(T);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, t, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: t, showPadding: this.showPadding }), this.fire(new o.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.bd.mark(o.be.load), this.fire(new o.k("load"))), this.style && (this.style.hasTransitions() || n) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const c = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return c || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.k("idle")), !this._loaded || this._fullyLoaded || c || (this._fullyLoaded = !0, o.bd.mark(o.be.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var f;
          this._hash && this._hash.remove();
          for (const n of this._controls) n.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Fe.removeThrottleControl(this._imageQueueHandle), (f = this._resizeObserver) === null || f === void 0 || f.disconnect();
          const t = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t != null && t.loseContext && t.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), U.remove(this._canvasContainer), U.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), o.bd.clearMetrics(), this._removed = !0, this.fire(new o.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), q.frameAsync(this._frameRequest).then((f) => {
            o.bd.frame(f), this._frameRequest = null, this._render(f);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(f) {
          this._showTileBoundaries !== f && (this._showTileBoundaries = f, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(f) {
          this._showPadding !== f && (this._showPadding = f, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(f) {
          this._showCollisionBoxes !== f && (this._showCollisionBoxes = f, f ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(f) {
          this._showOverdrawInspector !== f && (this._showOverdrawInspector = f, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(f) {
          this._repaint !== f && (this._repaint = f, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(f) {
          this._vertices = f, this._update();
        }
        get version() {
          return bs;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, v.MapMouseEvent = Pr, v.MapTouchEvent = Or, v.MapWheelEvent = _s, v.Marker = ji, v.NavigationControl = class {
        constructor(f) {
          this._updateZoomButtons = () => {
            const t = this._map.getZoom(), n = t === this._map.getMaxZoom(), c = t === this._map.getMinZoom();
            this._zoomInButton.disabled = n, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", n.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
          }, this._rotateCompassArrow = () => {
            const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = t;
          }, this._setButtonTitle = (t, n) => {
            const c = this._map._getUIString(`NavigationControl.${n}`);
            t.title = c, t.setAttribute("aria-label", c);
          }, this.options = o.e({}, Bl, f), this._container = U.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t) => this._map.zoomIn({}, { originalEvent: t })), U.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t) => this._map.zoomOut({}, { originalEvent: t })), U.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t }) : this._map.resetNorth({}, { originalEvent: t });
          }), this._compassIcon = U.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(f) {
          return this._map = f, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ol(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          U.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(f, t) {
          const n = U.create("button", f, this._container);
          return n.type = "button", n.addEventListener("click", t), n;
        }
      }, v.Popup = class extends o.E {
        constructor(f) {
          super(), this.remove = () => (this._content && U.remove(this._content), this._container && (U.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new o.k("close"))), this), this._onMouseUp = (t) => {
            this._update(t.point);
          }, this._onMouseMove = (t) => {
            this._update(t.point);
          }, this._onDrag = (t) => {
            this._update(t.point);
          }, this._update = (t) => {
            var n;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = U.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = U.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const s of this.options.className.split(" ")) this._container.classList.add(s);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? jl(this._lngLat, this._flatPos, this._map.transform) : (n = this._lngLat) === null || n === void 0 ? void 0 : n.wrap(), this._trackPointer && !t) return;
            const c = this._flatPos = this._pos = this._trackPointer && t ? t : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && t ? t : this._map.transform.locationPoint(this._lngLat));
            let u = this.options.anchor;
            const m = Vt(this.options.offset);
            if (!u) {
              const s = this._container.offsetWidth, l = this._container.offsetHeight;
              let p;
              p = c.y + m.bottom.y < l ? ["top"] : c.y > this._map.transform.height - l ? ["bottom"] : [], c.x < s / 2 ? p.push("left") : c.x > this._map.transform.width - s / 2 && p.push("right"), u = p.length === 0 ? "bottom" : p.join("-");
            }
            let T = c.add(m[u]);
            this.options.subpixelPositioning || (T = T.round()), U.setTransform(this._container, `${hl[u]} translate(${T.x}px,${T.y}px)`), ba(this._container, u, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = o.e(Object.create(Ss), f);
        }
        addTo(f) {
          return this._map && this.remove(), this._map = f, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(f) {
          return this._lngLat = o.M.convert(f), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(f) {
          return this.setDOMContent(document.createTextNode(f));
        }
        setHTML(f) {
          const t = document.createDocumentFragment(), n = document.createElement("body");
          let c;
          for (n.innerHTML = f; c = n.firstChild, c; ) t.appendChild(c);
          return this.setDOMContent(t);
        }
        getMaxWidth() {
          var f;
          return (f = this._container) === null || f === void 0 ? void 0 : f.style.maxWidth;
        }
        setMaxWidth(f) {
          return this.options.maxWidth = f, this._update(), this;
        }
        setDOMContent(f) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = U.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(f), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(f) {
          return this._container && this._container.classList.add(f), this;
        }
        removeClassName(f) {
          return this._container && this._container.classList.remove(f), this;
        }
        setOffset(f) {
          return this.options.offset = f, this._update(), this;
        }
        toggleClassName(f) {
          if (this._container) return this._container.classList.toggle(f);
        }
        setSubpixelPositioning(f) {
          this.options.subpixelPositioning = f;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = U.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const f = this._container.querySelector(ul);
          f && f.focus();
        }
      }, v.RasterDEMTileSource = Ht, v.RasterTileSource = hi, v.ScaleControl = class {
        constructor(f) {
          this._onMove = () => {
            Ul(this._map, this._container, this.options);
          }, this.setUnit = (t) => {
            this.options.unit = t, Ul(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, ql), f);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(f) {
          return this._map = f, this._container = U.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", f.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          U.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, v.ScrollZoomHandler = qo, v.Style = Ga, v.TerrainControl = class {
        constructor(f) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = f;
        }
        onAdd(f) {
          return this._map = f, this._container = U.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = U.create("button", "maplibregl-ctrl-terrain", this._container), U.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          U.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, v.TwoFingersTouchPitchHandler = jo, v.TwoFingersTouchRotateHandler = po, v.TwoFingersTouchZoomHandler = Na, v.TwoFingersTouchZoomRotateHandler = Fl, v.VectorTileSource = te, v.VideoSource = Ct, v.addSourceType = (f, t) => o._(void 0, void 0, void 0, function* () {
        if (fi(f)) throw new Error(`A source type called "${f}" already exists.`);
        ((n, c) => {
          pi[n] = c;
        })(f, t);
      }), v.clearPrewarmedResources = function() {
        const f = Ee;
        f && (f.isPreloaded() && f.numActive() === 1 ? (f.release(K), Ee = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, v.getMaxParallelImageRequests = function() {
        return o.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, v.getRTLTextPluginStatus = function() {
        return Jt().getRTLTextPluginStatus();
      }, v.getVersion = function() {
        return ni;
      }, v.getWorkerCount = function() {
        return ge.workerCount;
      }, v.getWorkerUrl = function() {
        return o.a.WORKER_URL;
      }, v.importScriptInWorkers = function(f) {
        return Ye().broadcast("IS", f);
      }, v.prewarm = function() {
        Ve().acquire(K);
      }, v.setMaxParallelImageRequests = function(f) {
        o.a.MAX_PARALLEL_IMAGE_REQUESTS = f;
      }, v.setRTLTextPlugin = function(f, t) {
        return Jt().setRTLTextPlugin(f, t);
      }, v.setWorkerCount = function(f) {
        ge.workerCount = f;
      }, v.setWorkerUrl = function(f) {
        o.a.WORKER_URL = f;
      };
    });
    var A = _;
    return A;
  });
})(Hp);
var og = Hp.exports, lg = Object.defineProperty, cg = (w, g, _) => g in w ? lg(w, g, { enumerable: !0, configurable: !0, writable: !0, value: _ }) : w[g] = _, Vi = (w, g, _) => cg(w, typeof g != "symbol" ? g + "" : g, _);
class hg {
  constructor(g) {
    Vi(this, "map"), Vi(this, "width"), Vi(this, "height"), Vi(this, "svgCanvas"), Vi(this, "xLine"), Vi(this, "yLine"), Vi(this, "color", "#535353"), this.map = g, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var g, _;
    this.width = (g = this.map) == null ? void 0 : g.getCanvas().clientWidth, this.height = (_ = this.map) == null ? void 0 : _.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const g = this.width / 2, _ = this.height / 2;
      this.yLine.setAttribute("x1", `${g}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${g}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${_}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${_}px`);
    } else
      console.error("element value is null");
  }
  createCanvas(g) {
    if (this.width !== void 0 && this.height !== void 0) {
      const _ = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      _.style.position = "relative", _.setAttribute("width", `${this.width}px`), _.setAttribute("height", `${this.height}px`);
      const x = this.width / 2, I = this.height / 2;
      this.yLine = _.appendChild(
        this.createLine(x, 0, x, this.height, this.color, "2px")
      ), this.xLine = _.appendChild(
        this.createLine(0, I, this.width, I, this.color, "2px")
      ), g == null || g.appendChild(_), this.svgCanvas = _;
    }
  }
  createLine(g, _, x, I, A, v) {
    const o = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return o.setAttribute("x1", g), o.setAttribute("y1", _), o.setAttribute("x2", x), o.setAttribute("y2", I), o.setAttribute("stroke-dasharray", "5,5"), o.setAttribute("stroke", A), o.setAttribute("stroke-width", v), o;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const Ip = {
  72: 72,
  96: 96,
  200: 200,
  300: 300,
  400: 400
}, Ko = {
  JPEG: "jpg",
  PNG: "png",
  PDF: "pdf",
  SVG: "svg"
}, Mh = {
  Landscape: "landscape",
  Portrait: "portrait"
}, Ql = {
  LARGE: [474, 406.2],
  //5600 x 4800
  LANDSCAPE: [609.4, 304.65],
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, tc = {
  // don't use inch unit. because page size setting is using mm unit.
  in: "in",
  mm: "mm"
};
class ug {
  constructor(g) {
    Vi(this, "map"), Vi(this, "width"), Vi(this, "height"), Vi(this, "unit"), Vi(this, "svgCanvas"), Vi(this, "svgPath");
    var _, x, I;
    if (this.map = g, this.map === void 0)
      return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const A = (_ = this.map) == null ? void 0 : _.getCanvas().clientWidth, v = (x = this.map) == null ? void 0 : x.getCanvas().clientHeight, o = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    o.style.position = "absolute", o.style.top = "0px", o.style.left = "0px", o.setAttribute("width", `${A}px`), o.setAttribute("height", `${v}px`);
    const D = document.createElementNS("http://www.w3.org/2000/svg", "path");
    D.setAttribute("style", "fill:#888888;stroke-width:0"), D.setAttribute("fill-opacity", "0.5"), o.append(D), (I = this.map) == null || I.getCanvasContainer().appendChild(o), this.svgCanvas = o, this.svgPath = D;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(g, _) {
    this.width = g, this.height = _, this.unit = tc.mm, this.generateCutOut();
  }
  generateCutOut() {
    var g, _;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0)
      return;
    const x = this.toPixels(this.width), I = this.toPixels(this.height), A = (g = this.map) == null ? void 0 : g.getCanvas().clientWidth, v = (_ = this.map) == null ? void 0 : _.getCanvas().clientHeight, o = A / 2 - x / 2, D = o + x, j = v / 2 - I / 2, V = j + I;
    this.svgCanvas.setAttribute("width", `${A}px`), this.svgCanvas.setAttribute("height", `${v}px`), this.svgPath.setAttribute(
      "d",
      `M 0 0 L ${A} 0 L ${A} ${v} L 0 ${v} M ${o} ${j} L ${o} ${V} L ${D} ${V} L ${D} ${j}`
    );
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(g, _ = 96) {
    return this.unit === tc.mm && (_ /= 25.4), _ * g;
  }
}
const Yp = {
  PageSize: "Page Size",
  PageOrientation: "Page Orientation",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generate",
  LanguageName: "English",
  LanguageCode: "en"
}, dg = {
  PageSize: "Taille de page",
  PageOrientation: "Orientation de la page",
  Format: "Format",
  DPI: "DPI",
  Generate: "Gnrer",
  LanguageName: "Franais",
  LanguageCode: "fr"
}, pg = {
  PageSize: "Sivukoko",
  PageOrientation: "Sivun suunta",
  Format: "Muoto",
  DPI: "DPI",
  Generate: "Generoi",
  LanguageName: "Suomalainen",
  LanguageCode: "fi"
}, fg = {
  PageSize: "Papierformat",
  PageOrientation: "Papierausrichtung",
  Format: "Dateiformat",
  DPI: "Druckauflsung",
  Generate: "Erstellen",
  LanguageName: "Deutsch",
  LanguageCode: "de"
}, mg = {
  PageSize: "Sidstorlek",
  PageOrientation: "Sidorientering",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generera",
  LanguageName: "Svenska",
  LanguageCode: "sv"
}, gg = {
  PageSize: "Tamao de pgina",
  PageOrientation: "Orientacin de pgina",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Generar",
  LanguageName: "Espaola",
  LanguageCode: "es"
}, yg = {
  PageSize: "Mida",
  PageOrientation: "Orientaci",
  Format: "Format",
  DPI: "DPI",
  Generate: "Genera",
  LanguageName: "Catalan",
  LanguageCode: "ca"
}, _g = {
  PageSize: "Kch thc trang",
  PageOrientation: "Loi trang",
  Format: "nh dng",
  DPI: "Mt  im nh (DPI)",
  Generate: "To",
  LanguageName: "Ting Vit",
  LanguageCode: "vi"
}, vg = {
  PageSize: " ",
  PageOrientation: " ",
  Format: "",
  DPI: "DPI",
  Generate: "",
  LanguageName: "",
  LanguageCode: "uk"
}, xg = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "",
  Generate: "",
  LanguageName: "",
  LanguageCode: "zhHans"
}, bg = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "",
  Generate: "",
  LanguageName: "",
  LanguageCode: "zhHant"
}, wg = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "DPI",
  Generate: "",
  LanguageName: "",
  LanguageCode: "ja"
}, Sg = {
  PageSize: "Tamanho da pgina",
  PageOrientation: "Orientao da pgina",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Gerar",
  LanguageName: "Portugus",
  LanguageCode: "pt"
}, Ag = [
  Yp,
  dg,
  pg,
  fg,
  mg,
  gg,
  yg,
  _g,
  vg,
  xg,
  bg,
  wg,
  Sg
], Pg = (w) => Ag.find((g) => g.LanguageCode === w) ?? Yp;
(function(w) {
  var g = {};
  function _(x) {
    if (g[x]) return g[x].exports;
    var I = g[x] = { i: x, l: !1, exports: {} };
    return w[x].call(I.exports, I, I.exports, _), I.l = !0, I.exports;
  }
  _.m = w, _.c = g, _.d = function(x, I, A) {
    _.o(x, I) || Object.defineProperty(x, I, { enumerable: !0, get: A });
  }, _.r = function(x) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(x, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(x, "__esModule", { value: !0 });
  }, _.t = function(x, I) {
    if (1 & I && (x = _(x)), 8 & I || 4 & I && typeof x == "object" && x && x.__esModule) return x;
    var A = /* @__PURE__ */ Object.create(null);
    if (_.r(A), Object.defineProperty(A, "default", { enumerable: !0, value: x }), 2 & I && typeof x != "string") for (var v in x) _.d(A, v, (function(o) {
      return x[o];
    }).bind(null, v));
    return A;
  }, _.n = function(x) {
    var I = x && x.__esModule ? function() {
      return x.default;
    } : function() {
      return x;
    };
    return _.d(I, "a", I), I;
  }, _.o = function(x, I) {
    return Object.prototype.hasOwnProperty.call(x, I);
  }, _.p = "", _(_.s = 0);
})([function(w, g, _) {
  w.exports = _(1);
}, function(w, g) {
  function _(I, A) {
    for (var v = 0; v < A.length; v++) {
      var o = A[v];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(I, o.key, o);
    }
  }
  var x = function() {
    function I() {
      (function(o, D) {
        if (!(o instanceof D)) throw new TypeError("Cannot call a class as a function");
      })(this, I), this.options = { overlayBackgroundColor: "#666666", overlayOpacity: 0.6, spinnerIcon: "ball-circus", spinnerColor: "#000", spinnerSize: "3x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetY: 0, offsetX: 0, lockScroll: !1, containerID: null, spinnerZIndex: 99999, overlayZIndex: 99998 }, this.stylesheetBaseURL = "https://cdn.jsdelivr.net/npm/load-awesome@1.1.0/css/", this.spinner = null, this.spinnerStylesheetURL = null, this.numberOfEmptyDivForSpinner = { "ball-8bits": 16, "ball-atom": 4, "ball-beat": 3, "ball-circus": 5, "ball-climbing-dot": 1, "ball-clip-rotate": 1, "ball-clip-rotate-multiple": 2, "ball-clip-rotate-pulse": 2, "ball-elastic-dots": 5, "ball-fall": 3, "ball-fussion": 4, "ball-grid-beat": 9, "ball-grid-pulse": 9, "ball-newton-cradle": 4, "ball-pulse": 3, "ball-pulse-rise": 5, "ball-pulse-sync": 3, "ball-rotate": 1, "ball-running-dots": 5, "ball-scale": 1, "ball-scale-multiple": 3, "ball-scale-pulse": 2, "ball-scale-ripple": 1, "ball-scale-ripple-multiple": 3, "ball-spin": 8, "ball-spin-clockwise": 8, "ball-spin-clockwise-fade": 8, "ball-spin-clockwise-fade-rotating": 8, "ball-spin-fade": 8, "ball-spin-fade-rotating": 8, "ball-spin-rotate": 2, "ball-square-clockwise-spin": 8, "ball-square-spin": 8, "ball-triangle-path": 3, "ball-zig-zag": 2, "ball-zig-zag-deflect": 2, cog: 1, "cube-transition": 2, fire: 3, "line-scale": 5, "line-scale-party": 5, "line-scale-pulse-out": 5, "line-scale-pulse-out-rapid": 5, "line-spin-clockwise-fade": 8, "line-spin-clockwise-fade-rotating": 8, "line-spin-fade": 8, "line-spin-fade-rotating": 8, pacman: 6, "square-jelly-box": 2, "square-loader": 1, "square-spin": 1, timer: 1, "triangle-skew-spin": 1 };
    }
    var A, v;
    return A = I, (v = [{ key: "show", value: function(o) {
      this.setOptions(o), this.addSpinnerStylesheet(), this.generateSpinnerElement(), this.options.lockScroll && (document.body.style.overflow = "hidden", document.documentElement.style.overflow = "hidden"), this.generateAndAddOverlayElement();
    } }, { key: "hide", value: function() {
      this.options.lockScroll && (document.body.style.overflow = "", document.documentElement.style.overflow = "");
      var o = document.getElementById("loading-overlay-stylesheet");
      o && (o.disabled = !0, o.parentNode.removeChild(o), document.getElementById(this.options.overlayIDName).remove(), document.getElementById(this.options.spinnerIDName).remove());
    } }, { key: "setOptions", value: function(o) {
      if (o !== void 0) for (var D in o) this.options[D] = o[D];
    } }, { key: "generateAndAddOverlayElement", value: function() {
      var o = "50%";
      this.options.offsetX !== 0 && (o = "calc(50% + " + this.options.offsetX + ")");
      var D = "50%";
      if (this.options.offsetY !== 0 && (D = "calc(50% + " + this.options.offsetY + ")"), this.options.containerID && document.body.contains(document.getElementById(this.options.containerID))) {
        var j = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: absolute; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, '; z-index: 50; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: absolute; top: ').concat(D, "; left: ").concat(o, '; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: 9999;">').concat(this.spinner, "</div>"), V = document.getElementById(this.options.containerID);
        return V.style.position = "relative", void V.insertAdjacentHTML("beforeend", j);
      }
      var q = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: fixed; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, "; z-index: ").concat(this.options.overlayZIndex, '; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: fixed; top: ').concat(D, "; left: ").concat(o, "; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: ").concat(this.options.spinnerZIndex, ';">').concat(this.spinner, "</div>");
      document.body.insertAdjacentHTML("beforeend", q);
    } }, { key: "generateSpinnerElement", value: function() {
      var o = this, D = Object.keys(this.numberOfEmptyDivForSpinner).find(function(V) {
        return V === o.options.spinnerIcon;
      }), j = this.generateEmptyDivElement(this.numberOfEmptyDivForSpinner[D]);
      this.spinner = '<div style="color: '.concat(this.options.spinnerColor, '" class="la-').concat(this.options.spinnerIcon, " la-").concat(this.options.spinnerSize, '">').concat(j, "</div>");
    } }, { key: "addSpinnerStylesheet", value: function() {
      this.setSpinnerStylesheetURL();
      var o = document.createElement("link");
      o.setAttribute("id", "loading-overlay-stylesheet"), o.setAttribute("rel", "stylesheet"), o.setAttribute("type", "text/css"), o.setAttribute("href", this.spinnerStylesheetURL), document.getElementsByTagName("head")[0].appendChild(o);
    } }, { key: "setSpinnerStylesheetURL", value: function() {
      this.spinnerStylesheetURL = this.stylesheetBaseURL + this.options.spinnerIcon + ".min.css";
    } }, { key: "generateEmptyDivElement", value: function(o) {
      for (var D = "", j = 1; j <= o; j++) D += "<div></div>";
      return D;
    } }]) && _(A.prototype, v), I;
  }();
  window.JsLoadingOverlay = new x(), w.exports = JsLoadingOverlay;
}]);
function or(w) {
  "@babel/helpers - typeof";
  return or = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
    return typeof g;
  } : function(g) {
    return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
  }, or(w);
}
var ks = Uint8Array, hs = Uint16Array, th = Uint32Array, Vh = new ks([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), $h = new ks([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), ju = new ks([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Jp = function(w, g) {
  for (var _ = new hs(31), x = 0; x < 31; ++x)
    _[x] = g += 1 << w[x - 1];
  for (var I = new th(_[30]), x = 1; x < 30; ++x)
    for (var A = _[x]; A < _[x + 1]; ++A)
      I[A] = A - _[x] << 5 | x;
  return [_, I];
}, Kp = Jp(Vh, 2), Qp = Kp[0], qu = Kp[1];
Qp[28] = 258, qu[258] = 28;
var ef = Jp($h, 0), Ig = ef[0], Tp = ef[1], Uu = new hs(32768);
for (var Sr = 0; Sr < 32768; ++Sr) {
  var Sl = (Sr & 43690) >>> 1 | (Sr & 21845) << 1;
  Sl = (Sl & 52428) >>> 2 | (Sl & 13107) << 2, Sl = (Sl & 61680) >>> 4 | (Sl & 3855) << 4, Uu[Sr] = ((Sl & 65280) >>> 8 | (Sl & 255) << 8) >>> 1;
}
var ko = function(w, g, _) {
  for (var x = w.length, I = 0, A = new hs(g); I < x; ++I)
    ++A[w[I] - 1];
  var v = new hs(g);
  for (I = 0; I < g; ++I)
    v[I] = v[I - 1] + A[I - 1] << 1;
  var o;
  if (_) {
    o = new hs(1 << g);
    var D = 15 - g;
    for (I = 0; I < x; ++I)
      if (w[I])
        for (var j = I << 4 | w[I], V = g - w[I], q = v[w[I] - 1]++ << V, U = q | (1 << V) - 1; q <= U; ++q)
          o[Uu[q] >>> D] = j;
  } else
    for (o = new hs(x), I = 0; I < x; ++I)
      o[I] = Uu[v[w[I] - 1]++] >>> 15 - w[I];
  return o;
}, Il = new ks(288);
for (var Sr = 0; Sr < 144; ++Sr)
  Il[Sr] = 8;
for (var Sr = 144; Sr < 256; ++Sr)
  Il[Sr] = 9;
for (var Sr = 256; Sr < 280; ++Sr)
  Il[Sr] = 7;
for (var Sr = 280; Sr < 288; ++Sr)
  Il[Sr] = 8;
var ih = new ks(32);
for (var Sr = 0; Sr < 32; ++Sr)
  ih[Sr] = 5;
var Tg = /* @__PURE__ */ ko(Il, 9, 0), kg = /* @__PURE__ */ ko(Il, 9, 1), Lg = /* @__PURE__ */ ko(ih, 5, 0), Cg = /* @__PURE__ */ ko(ih, 5, 1), Mu = function(w) {
  for (var g = w[0], _ = 1; _ < w.length; ++_)
    w[_] > g && (g = w[_]);
  return g;
}, Va = function(w, g, _) {
  var x = g / 8 >> 0;
  return (w[x] | w[x + 1] << 8) >>> (g & 7) & _;
}, Du = function(w, g) {
  var _ = g / 8 >> 0;
  return (w[_] | w[_ + 1] << 8 | w[_ + 2] << 16) >>> (g & 7);
}, Ku = function(w) {
  return (w / 8 >> 0) + (w & 7 && 1);
}, tf = function(w, g, _) {
  (_ == null || _ > w.length) && (_ = w.length);
  var x = new (w instanceof hs ? hs : w instanceof th ? th : ks)(_ - g);
  return x.set(w.subarray(g, _)), x;
}, Eg = function(w, g, _) {
  var x = w.length, I = !g || _, A = !_ || _.i;
  _ || (_ = {}), g || (g = new ks(x * 3));
  var v = function(Be) {
    var Ve = g.length;
    if (Be > Ve) {
      var We = new ks(Math.max(Ve * 2, Be));
      We.set(g), g = We;
    }
  }, o = _.f || 0, D = _.p || 0, j = _.b || 0, V = _.l, q = _.d, U = _.m, B = _.n, ye = x * 8;
  do {
    if (!V) {
      _.f = o = Va(w, D, 1);
      var oe = Va(w, D + 1, 3);
      if (D += 3, oe)
        if (oe == 1)
          V = kg, q = Cg, U = 9, B = 5;
        else if (oe == 2) {
          var xe = Va(w, D, 31) + 257, se = Va(w, D + 10, 15) + 4, ve = xe + Va(w, D + 5, 31) + 1;
          D += 14;
          for (var Fe = new ks(ve), it = new ks(19), Ke = 0; Ke < se; ++Ke)
            it[ju[Ke]] = Va(w, D + Ke * 3, 7);
          D += se * 3;
          var gt = Mu(it), $e = (1 << gt) - 1;
          if (!A && D + ve * (gt + 7) > ye)
            break;
          for (var Le = ko(it, gt, 1), Ke = 0; Ke < ve; ) {
            var dt = Le[Va(w, D, $e)];
            D += dt & 15;
            var at = dt >>> 4;
            if (at < 16)
              Fe[Ke++] = at;
            else {
              var ae = 0, he = 0;
              for (at == 16 ? (he = 3 + Va(w, D, 3), D += 2, ae = Fe[Ke - 1]) : at == 17 ? (he = 3 + Va(w, D, 7), D += 3) : at == 18 && (he = 11 + Va(w, D, 127), D += 7); he--; )
                Fe[Ke++] = ae;
            }
          }
          var Ie = Fe.subarray(0, xe), Se = Fe.subarray(xe);
          U = Mu(Ie), B = Mu(Se), V = ko(Ie, U, 1), q = ko(Se, B, 1);
        } else
          throw "invalid block type";
      else {
        var at = Ku(D) + 4, et = w[at - 4] | w[at - 3] << 8, Qe = at + et;
        if (Qe > x) {
          if (A)
            throw "unexpected EOF";
          break;
        }
        I && v(j + et), g.set(w.subarray(at, Qe), j), _.b = j += et, _.p = D = Qe * 8;
        continue;
      }
      if (D > ye)
        throw "unexpected EOF";
    }
    I && v(j + 131072);
    for (var rt = (1 << U) - 1, Ze = (1 << B) - 1, ct = U + B + 18; A || D + ct < ye; ) {
      var ae = V[Du(w, D) & rt], nt = ae >>> 4;
      if (D += ae & 15, D > ye)
        throw "unexpected EOF";
      if (!ae)
        throw "invalid length/literal";
      if (nt < 256)
        g[j++] = nt;
      else if (nt == 256) {
        V = null;
        break;
      } else {
        var wt = nt - 254;
        if (nt > 264) {
          var Ke = nt - 257, K = Vh[Ke];
          wt = Va(w, D, (1 << K) - 1) + Qp[Ke], D += K;
        }
        var ge = q[Du(w, D) & Ze], we = ge >>> 4;
        if (!ge)
          throw "invalid distance";
        D += ge & 15;
        var Se = Ig[we];
        if (we > 3) {
          var K = $h[we];
          Se += Du(w, D) & (1 << K) - 1, D += K;
        }
        if (D > ye)
          throw "unexpected EOF";
        I && v(j + 131072);
        for (var Ee = j + wt; j < Ee; j += 4)
          g[j] = g[j - Se], g[j + 1] = g[j + 1 - Se], g[j + 2] = g[j + 2 - Se], g[j + 3] = g[j + 3 - Se];
        j = Ee;
      }
    }
    _.l = V, _.p = D, _.b = j, V && (o = 1, _.m = U, _.d = q, _.n = B);
  } while (!o);
  return j == g.length ? g : tf(g, 0, j);
}, Jo = function(w, g, _) {
  _ <<= g & 7;
  var x = g / 8 >> 0;
  w[x] |= _, w[x + 1] |= _ >>> 8;
}, Kc = function(w, g, _) {
  _ <<= g & 7;
  var x = g / 8 >> 0;
  w[x] |= _, w[x + 1] |= _ >>> 8, w[x + 2] |= _ >>> 16;
}, zu = function(w, g) {
  for (var _ = [], x = 0; x < w.length; ++x)
    w[x] && _.push({ s: x, f: w[x] });
  var I = _.length, A = _.slice();
  if (!I)
    return [new ks(0), 0];
  if (I == 1) {
    var v = new ks(_[0].s + 1);
    return v[_[0].s] = 1, [v, 1];
  }
  _.sort(function(Ke, gt) {
    return Ke.f - gt.f;
  }), _.push({ s: -1, f: 25001 });
  var o = _[0], D = _[1], j = 0, V = 1, q = 2;
  for (_[0] = { s: -1, f: o.f + D.f, l: o, r: D }; V != I - 1; )
    o = _[_[j].f < _[q].f ? j++ : q++], D = _[j != V && _[j].f < _[q].f ? j++ : q++], _[V++] = { s: -1, f: o.f + D.f, l: o, r: D };
  for (var U = A[0].s, x = 1; x < I; ++x)
    A[x].s > U && (U = A[x].s);
  var B = new hs(U + 1), ye = Vu(_[V - 1], B, 0);
  if (ye > g) {
    var x = 0, oe = 0, xe = ye - g, se = 1 << xe;
    for (A.sort(function(gt, $e) {
      return B[$e.s] - B[gt.s] || gt.f - $e.f;
    }); x < I; ++x) {
      var ve = A[x].s;
      if (B[ve] > g)
        oe += se - (1 << ye - B[ve]), B[ve] = g;
      else
        break;
    }
    for (oe >>>= xe; oe > 0; ) {
      var Fe = A[x].s;
      B[Fe] < g ? oe -= 1 << g - B[Fe]++ - 1 : ++x;
    }
    for (; x >= 0 && oe; --x) {
      var it = A[x].s;
      B[it] == g && (--B[it], ++oe);
    }
    ye = g;
  }
  return [new ks(B), ye];
}, Vu = function(w, g, _) {
  return w.s == -1 ? Math.max(Vu(w.l, g, _ + 1), Vu(w.r, g, _ + 1)) : g[w.s] = _;
}, kp = function(w) {
  for (var g = w.length; g && !w[--g]; )
    ;
  for (var _ = new hs(++g), x = 0, I = w[0], A = 1, v = function(D) {
    _[x++] = D;
  }, o = 1; o <= g; ++o)
    if (w[o] == I && o != g)
      ++A;
    else {
      if (!I && A > 2) {
        for (; A > 138; A -= 138)
          v(32754);
        A > 2 && (v(A > 10 ? A - 11 << 5 | 28690 : A - 3 << 5 | 12305), A = 0);
      } else if (A > 3) {
        for (v(I), --A; A > 6; A -= 6)
          v(8304);
        A > 2 && (v(A - 3 << 5 | 8208), A = 0);
      }
      for (; A--; )
        v(I);
      A = 1, I = w[o];
    }
  return [_.subarray(0, x), g];
}, Qc = function(w, g) {
  for (var _ = 0, x = 0; x < g.length; ++x)
    _ += w[x] * g[x];
  return _;
}, $u = function(w, g, _) {
  var x = _.length, I = Ku(g + 2);
  w[I] = x & 255, w[I + 1] = x >>> 8, w[I + 2] = w[I] ^ 255, w[I + 3] = w[I + 1] ^ 255;
  for (var A = 0; A < x; ++A)
    w[I + A + 4] = _[A];
  return (I + 4 + x) * 8;
}, Lp = function(w, g, _, x, I, A, v, o, D, j, V) {
  Jo(g, V++, _), ++I[256];
  for (var q = zu(I, 15), U = q[0], B = q[1], ye = zu(A, 15), oe = ye[0], xe = ye[1], se = kp(U), ve = se[0], Fe = se[1], it = kp(oe), Ke = it[0], gt = it[1], $e = new hs(19), Le = 0; Le < ve.length; ++Le)
    $e[ve[Le] & 31]++;
  for (var Le = 0; Le < Ke.length; ++Le)
    $e[Ke[Le] & 31]++;
  for (var dt = zu($e, 7), at = dt[0], ae = dt[1], he = 19; he > 4 && !at[ju[he - 1]]; --he)
    ;
  var Ie = j + 5 << 3, Se = Qc(I, Il) + Qc(A, ih) + v, et = Qc(I, U) + Qc(A, oe) + v + 14 + 3 * he + Qc($e, at) + (2 * $e[16] + 3 * $e[17] + 7 * $e[18]);
  if (Ie <= Se && Ie <= et)
    return $u(g, V, w.subarray(D, D + j));
  var Qe, rt, Ze, ct;
  if (Jo(g, V, 1 + (et < Se)), V += 2, et < Se) {
    Qe = ko(U, B, 0), rt = U, Ze = ko(oe, xe, 0), ct = oe;
    var nt = ko(at, ae, 0);
    Jo(g, V, Fe - 257), Jo(g, V + 5, gt - 1), Jo(g, V + 10, he - 4), V += 14;
    for (var Le = 0; Le < he; ++Le)
      Jo(g, V + 3 * Le, at[ju[Le]]);
    V += 3 * he;
    for (var wt = [ve, Ke], K = 0; K < 2; ++K)
      for (var ge = wt[K], Le = 0; Le < ge.length; ++Le) {
        var we = ge[Le] & 31;
        Jo(g, V, nt[we]), V += at[we], we > 15 && (Jo(g, V, ge[Le] >>> 5 & 127), V += ge[Le] >>> 12);
      }
  } else
    Qe = Tg, rt = Il, Ze = Lg, ct = ih;
  for (var Le = 0; Le < o; ++Le)
    if (x[Le] > 255) {
      var we = x[Le] >>> 18 & 31;
      Kc(g, V, Qe[we + 257]), V += rt[we + 257], we > 7 && (Jo(g, V, x[Le] >>> 23 & 31), V += Vh[we]);
      var Ee = x[Le] & 31;
      Kc(g, V, Ze[Ee]), V += ct[Ee], Ee > 3 && (Kc(g, V, x[Le] >>> 5 & 8191), V += $h[Ee]);
    } else
      Kc(g, V, Qe[x[Le]]), V += rt[x[Le]];
  return Kc(g, V, Qe[256]), V + rt[256];
}, Mg = /* @__PURE__ */ new th([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Dg = function(w, g, _, x, I, A) {
  var v = w.length, o = new ks(x + v + 5 * (1 + Math.floor(v / 7e3)) + I), D = o.subarray(x, o.length - I), j = 0;
  if (!g || v < 8)
    for (var V = 0; V <= v; V += 65535) {
      var q = V + 65535;
      q < v ? j = $u(D, j, w.subarray(V, q)) : (D[V] = A, j = $u(D, j, w.subarray(V, v)));
    }
  else {
    for (var U = Mg[g - 1], B = U >>> 13, ye = U & 8191, oe = (1 << _) - 1, xe = new hs(32768), se = new hs(oe + 1), ve = Math.ceil(_ / 3), Fe = 2 * ve, it = function(Ut) {
      return (w[Ut] ^ w[Ut + 1] << ve ^ w[Ut + 2] << Fe) & oe;
    }, Ke = new th(25e3), gt = new hs(288), $e = new hs(32), Le = 0, dt = 0, V = 0, at = 0, ae = 0, he = 0; V < v; ++V) {
      var Ie = it(V), Se = V & 32767, et = se[Ie];
      if (xe[Se] = et, se[Ie] = Se, ae <= V) {
        var Qe = v - V;
        if ((Le > 7e3 || at > 24576) && Qe > 423) {
          j = Lp(w, D, 0, Ke, gt, $e, dt, at, he, V - he, j), at = Le = dt = 0, he = V;
          for (var rt = 0; rt < 286; ++rt)
            gt[rt] = 0;
          for (var rt = 0; rt < 30; ++rt)
            $e[rt] = 0;
        }
        var Ze = 2, ct = 0, nt = ye, wt = Se - et & 32767;
        if (Qe > 2 && Ie == it(V - wt))
          for (var K = Math.min(B, Qe) - 1, ge = Math.min(32767, V), we = Math.min(258, Qe); wt <= ge && --nt && Se != et; ) {
            if (w[V + Ze] == w[V + Ze - wt]) {
              for (var Ee = 0; Ee < we && w[V + Ee] == w[V + Ee - wt]; ++Ee)
                ;
              if (Ee > Ze) {
                if (Ze = Ee, ct = wt, Ee > K)
                  break;
                for (var Be = Math.min(wt, Ee - 2), Ve = 0, rt = 0; rt < Be; ++rt) {
                  var We = V - wt + rt + 32768 & 32767, Ye = xe[We], bt = We - Ye + 32768 & 32767;
                  bt > Ve && (Ve = bt, et = We);
                }
              }
            }
            Se = et, et = xe[Se], wt += Se - et + 32768 & 32767;
          }
        if (ct) {
          Ke[at++] = 268435456 | qu[Ze] << 18 | Tp[ct];
          var xt = qu[Ze] & 31, kt = Tp[ct] & 31;
          dt += Vh[xt] + $h[kt], ++gt[257 + xt], ++$e[kt], ae = V + Ze, ++Le;
        } else
          Ke[at++] = w[V], ++gt[w[V]];
      }
    }
    j = Lp(w, D, A, Ke, gt, $e, dt, at, he, V - he, j);
  }
  return tf(o, 0, x + Ku(j) + I);
}, zg = function() {
  var w = 1, g = 0;
  return {
    p: function(_) {
      for (var x = w, I = g, A = _.length, v = 0; v != A; ) {
        for (var o = Math.min(v + 5552, A); v < o; ++v)
          x += _[v], I += x;
        x %= 65521, I %= 65521;
      }
      w = x, g = I;
    },
    d: function() {
      return (w >>> 8 << 16 | (g & 255) << 8 | g >>> 8) + ((w & 255) << 23) * 2;
    }
  };
}, Fg = function(w, g, _, x, I) {
  return Dg(w, g.level == null ? 6 : g.level, g.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(w.length))) * 1.5) : 12 + g.mem, _, x, !I);
}, Ng = function(w, g, _) {
  for (; _; ++g)
    w[g] = _, _ >>>= 8;
}, Rg = function(w, g) {
  var _ = g.level, x = _ == 0 ? 0 : _ < 6 ? 1 : _ == 9 ? 3 : 2;
  w[0] = 120, w[1] = x << 6 | (x ? 32 - 2 * x : 1);
}, Bg = function(w) {
  if ((w[0] & 15) != 8 || w[0] >>> 4 > 7 || (w[0] << 8 | w[1]) % 31)
    throw "invalid zlib data";
  if (w[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Zu(w, g) {
  g === void 0 && (g = {});
  var _ = zg();
  _.p(w);
  var x = Fg(w, g, 2, 4);
  return Rg(x, g), Ng(x, x.length - 4, _.d()), x;
}
function Og(w, g) {
  return Eg((Bg(w), w.subarray(2, -4)), g);
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var xi = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function Fu() {
  xi.console && typeof xi.console.log == "function" && xi.console.log.apply(xi.console, arguments);
}
var mr = { log: Fu, warn: function(w) {
  xi.console && (typeof xi.console.warn == "function" ? xi.console.warn.apply(xi.console, arguments) : Fu.call(null, arguments));
}, error: function(w) {
  xi.console && (typeof xi.console.error == "function" ? xi.console.error.apply(xi.console, arguments) : Fu(w));
} };
function Nu(w, g, _) {
  var x = new XMLHttpRequest();
  x.open("GET", w), x.responseType = "blob", x.onload = function() {
    Jl(x.response, g, _);
  }, x.onerror = function() {
    mr.error("could not download file");
  }, x.send();
}
function Cp(w) {
  var g = new XMLHttpRequest();
  g.open("HEAD", w, !1);
  try {
    g.send();
  } catch {
  }
  return g.status >= 200 && g.status <= 299;
}
function Dh(w) {
  try {
    w.dispatchEvent(new MouseEvent("click"));
  } catch {
    var g = document.createEvent("MouseEvents");
    g.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), w.dispatchEvent(g);
  }
}
var eh, Wu, Jl = xi.saveAs || ((typeof window > "u" ? "undefined" : or(window)) !== "object" || window !== xi ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(w, g, _) {
  var x = xi.URL || xi.webkitURL, I = document.createElement("a");
  g = g || w.name || "download", I.download = g, I.rel = "noopener", typeof w == "string" ? (I.href = w, I.origin !== location.origin ? Cp(I.href) ? Nu(w, g, _) : Dh(I, I.target = "_blank") : Dh(I)) : (I.href = x.createObjectURL(w), setTimeout(function() {
    x.revokeObjectURL(I.href);
  }, 4e4), setTimeout(function() {
    Dh(I);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(w, g, _) {
  if (g = g || w.name || "download", typeof w == "string") if (Cp(w)) Nu(w, g, _);
  else {
    var x = document.createElement("a");
    x.href = w, x.target = "_blank", setTimeout(function() {
      Dh(x);
    });
  }
  else navigator.msSaveOrOpenBlob(function(I, A) {
    return A === void 0 ? A = { autoBom: !1 } : or(A) !== "object" && (mr.warn("Deprecated: Expected third argument to be a object"), A = { autoBom: !A }), A.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(I.type) ? new Blob(["\uFEFF", I], { type: I.type }) : I;
  }(w, _), g);
} : function(w, g, _, x) {
  if ((x = x || open("", "_blank")) && (x.document.title = x.document.body.innerText = "downloading..."), typeof w == "string") return Nu(w, g, _);
  var I = w.type === "application/octet-stream", A = /constructor/i.test(xi.HTMLElement) || xi.safari, v = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((v || I && A) && (typeof FileReader > "u" ? "undefined" : or(FileReader)) === "object") {
    var o = new FileReader();
    o.onloadend = function() {
      var V = o.result;
      V = v ? V : V.replace(/^data:[^;]*;/, "data:attachment/file;"), x ? x.location.href = V : location = V, x = null;
    }, o.readAsDataURL(w);
  } else {
    var D = xi.URL || xi.webkitURL, j = D.createObjectURL(w);
    x ? x.location = j : location.href = j, x = null, setTimeout(function() {
      D.revokeObjectURL(j);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function rf(w) {
  var g;
  w = w || "", this.ok = !1, w.charAt(0) == "#" && (w = w.substr(1, 6)), w = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[w = (w = w.replace(/ /g, "")).toLowerCase()] || w;
  for (var _ = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(o) {
    return [parseInt(o[1]), parseInt(o[2]), parseInt(o[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(o) {
    return [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(o) {
    return [parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16)];
  } }], x = 0; x < _.length; x++) {
    var I = _[x].re, A = _[x].process, v = I.exec(w);
    v && (g = A(v), this.r = g[0], this.g = g[1], this.b = g[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var o = this.r.toString(16), D = this.g.toString(16), j = this.b.toString(16);
    return o.length == 1 && (o = "0" + o), D.length == 1 && (D = "0" + D), j.length == 1 && (j = "0" + j), "#" + o + D + j;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function Ru(w, g) {
  var _ = w[0], x = w[1], I = w[2], A = w[3];
  _ = Gn(_, x, I, A, g[0], 7, -680876936), A = Gn(A, _, x, I, g[1], 12, -389564586), I = Gn(I, A, _, x, g[2], 17, 606105819), x = Gn(x, I, A, _, g[3], 22, -1044525330), _ = Gn(_, x, I, A, g[4], 7, -176418897), A = Gn(A, _, x, I, g[5], 12, 1200080426), I = Gn(I, A, _, x, g[6], 17, -1473231341), x = Gn(x, I, A, _, g[7], 22, -45705983), _ = Gn(_, x, I, A, g[8], 7, 1770035416), A = Gn(A, _, x, I, g[9], 12, -1958414417), I = Gn(I, A, _, x, g[10], 17, -42063), x = Gn(x, I, A, _, g[11], 22, -1990404162), _ = Gn(_, x, I, A, g[12], 7, 1804603682), A = Gn(A, _, x, I, g[13], 12, -40341101), I = Gn(I, A, _, x, g[14], 17, -1502002290), _ = Hn(_, x = Gn(x, I, A, _, g[15], 22, 1236535329), I, A, g[1], 5, -165796510), A = Hn(A, _, x, I, g[6], 9, -1069501632), I = Hn(I, A, _, x, g[11], 14, 643717713), x = Hn(x, I, A, _, g[0], 20, -373897302), _ = Hn(_, x, I, A, g[5], 5, -701558691), A = Hn(A, _, x, I, g[10], 9, 38016083), I = Hn(I, A, _, x, g[15], 14, -660478335), x = Hn(x, I, A, _, g[4], 20, -405537848), _ = Hn(_, x, I, A, g[9], 5, 568446438), A = Hn(A, _, x, I, g[14], 9, -1019803690), I = Hn(I, A, _, x, g[3], 14, -187363961), x = Hn(x, I, A, _, g[8], 20, 1163531501), _ = Hn(_, x, I, A, g[13], 5, -1444681467), A = Hn(A, _, x, I, g[2], 9, -51403784), I = Hn(I, A, _, x, g[7], 14, 1735328473), _ = Xn(_, x = Hn(x, I, A, _, g[12], 20, -1926607734), I, A, g[5], 4, -378558), A = Xn(A, _, x, I, g[8], 11, -2022574463), I = Xn(I, A, _, x, g[11], 16, 1839030562), x = Xn(x, I, A, _, g[14], 23, -35309556), _ = Xn(_, x, I, A, g[1], 4, -1530992060), A = Xn(A, _, x, I, g[4], 11, 1272893353), I = Xn(I, A, _, x, g[7], 16, -155497632), x = Xn(x, I, A, _, g[10], 23, -1094730640), _ = Xn(_, x, I, A, g[13], 4, 681279174), A = Xn(A, _, x, I, g[0], 11, -358537222), I = Xn(I, A, _, x, g[3], 16, -722521979), x = Xn(x, I, A, _, g[6], 23, 76029189), _ = Xn(_, x, I, A, g[9], 4, -640364487), A = Xn(A, _, x, I, g[12], 11, -421815835), I = Xn(I, A, _, x, g[15], 16, 530742520), _ = Yn(_, x = Xn(x, I, A, _, g[2], 23, -995338651), I, A, g[0], 6, -198630844), A = Yn(A, _, x, I, g[7], 10, 1126891415), I = Yn(I, A, _, x, g[14], 15, -1416354905), x = Yn(x, I, A, _, g[5], 21, -57434055), _ = Yn(_, x, I, A, g[12], 6, 1700485571), A = Yn(A, _, x, I, g[3], 10, -1894986606), I = Yn(I, A, _, x, g[10], 15, -1051523), x = Yn(x, I, A, _, g[1], 21, -2054922799), _ = Yn(_, x, I, A, g[8], 6, 1873313359), A = Yn(A, _, x, I, g[15], 10, -30611744), I = Yn(I, A, _, x, g[6], 15, -1560198380), x = Yn(x, I, A, _, g[13], 21, 1309151649), _ = Yn(_, x, I, A, g[4], 6, -145523070), A = Yn(A, _, x, I, g[11], 10, -1120210379), I = Yn(I, A, _, x, g[2], 15, 718787259), x = Yn(x, I, A, _, g[9], 21, -343485551), w[0] = Pl(_, w[0]), w[1] = Pl(x, w[1]), w[2] = Pl(I, w[2]), w[3] = Pl(A, w[3]);
}
function Zh(w, g, _, x, I, A) {
  return g = Pl(Pl(g, w), Pl(x, A)), Pl(g << I | g >>> 32 - I, _);
}
function Gn(w, g, _, x, I, A, v) {
  return Zh(g & _ | ~g & x, w, g, I, A, v);
}
function Hn(w, g, _, x, I, A, v) {
  return Zh(g & x | _ & ~x, w, g, I, A, v);
}
function Xn(w, g, _, x, I, A, v) {
  return Zh(g ^ _ ^ x, w, g, I, A, v);
}
function Yn(w, g, _, x, I, A, v) {
  return Zh(_ ^ (g | ~x), w, g, I, A, v);
}
function nf(w) {
  var g, _ = w.length, x = [1732584193, -271733879, -1732584194, 271733878];
  for (g = 64; g <= w.length; g += 64) Ru(x, jg(w.substring(g - 64, g)));
  w = w.substring(g - 64);
  var I = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (g = 0; g < w.length; g++) I[g >> 2] |= w.charCodeAt(g) << (g % 4 << 3);
  if (I[g >> 2] |= 128 << (g % 4 << 3), g > 55) for (Ru(x, I), g = 0; g < 16; g++) I[g] = 0;
  return I[14] = 8 * _, Ru(x, I), x;
}
function jg(w) {
  var g, _ = [];
  for (g = 0; g < 64; g += 4) _[g >> 2] = w.charCodeAt(g) + (w.charCodeAt(g + 1) << 8) + (w.charCodeAt(g + 2) << 16) + (w.charCodeAt(g + 3) << 24);
  return _;
}
eh = xi.atob.bind(xi), Wu = xi.btoa.bind(xi);
var Ep = "0123456789abcdef".split("");
function qg(w) {
  for (var g = "", _ = 0; _ < 4; _++) g += Ep[w >> 8 * _ + 4 & 15] + Ep[w >> 8 * _ & 15];
  return g;
}
function Ug(w) {
  return String.fromCharCode((255 & w) >> 0, (65280 & w) >> 8, (16711680 & w) >> 16, (4278190080 & w) >> 24);
}
function Gu(w) {
  return nf(w).map(Ug).join("");
}
var Vg = function(w) {
  for (var g = 0; g < w.length; g++) w[g] = qg(w[g]);
  return w.join("");
}(nf("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Pl(w, g) {
  if (Vg) {
    var _ = (65535 & w) + (65535 & g);
    return (w >> 16) + (g >> 16) + (_ >> 16) << 16 | 65535 & _;
  }
  return w + g & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function Hu(w, g) {
  var _, x, I, A;
  if (w !== _) {
    for (var v = (I = w, A = 1 + (256 / w.length >> 0), new Array(A + 1).join(I)), o = [], D = 0; D < 256; D++) o[D] = D;
    var j = 0;
    for (D = 0; D < 256; D++) {
      var V = o[D];
      j = (j + V + v.charCodeAt(D)) % 256, o[D] = o[j], o[j] = V;
    }
    _ = w, x = o;
  } else o = x;
  var q = g.length, U = 0, B = 0, ye = "";
  for (D = 0; D < q; D++) B = (B + (V = o[U = (U + 1) % 256])) % 256, o[U] = o[B], o[B] = V, v = o[(o[U] + o[B]) % 256], ye += String.fromCharCode(g.charCodeAt(D) ^ v);
  return ye;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var Mp = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function Sc(w, g, _, x) {
  this.v = 1, this.r = 2;
  var I = 192;
  w.forEach(function(o) {
    if (Mp.perm !== void 0) throw new Error("Invalid permission: " + o);
    I += Mp[o];
  }), this.padding = "(N^NuAd\0NV\b..\0h>/\fdSiz";
  var A = (g + this.padding).substr(0, 32), v = (_ + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(A, v), this.P = -(1 + (255 ^ I)), this.encryptionKey = Gu(A + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(x)).substr(0, 5), this.U = Hu(this.encryptionKey, this.padding);
}
function Ac(w) {
  if (/[^\u0000-\u00ff]/.test(w)) throw new Error("Invalid PDF Name Object: " + w + ", Only accept ASCII characters.");
  for (var g = "", _ = w.length, x = 0; x < _; x++) {
    var I = w.charCodeAt(x);
    I < 33 || I === 35 || I === 37 || I === 40 || I === 41 || I === 47 || I === 60 || I === 62 || I === 91 || I === 93 || I === 123 || I === 125 || I > 126 ? g += "#" + ("0" + I.toString(16)).slice(-2) : g += w[x];
  }
  return g;
}
function Dp(w) {
  if (or(w) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var g = {};
  this.subscribe = function(_, x, I) {
    if (I = I || !1, typeof _ != "string" || typeof x != "function" || typeof I != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    g.hasOwnProperty(_) || (g[_] = {});
    var A = Math.random().toString(35);
    return g[_][A] = [x, !!I], A;
  }, this.unsubscribe = function(_) {
    for (var x in g) if (g[x][_]) return delete g[x][_], Object.keys(g[x]).length === 0 && delete g[x], !0;
    return !1;
  }, this.publish = function(_) {
    if (g.hasOwnProperty(_)) {
      var x = Array.prototype.slice.call(arguments, 1), I = [];
      for (var A in g[_]) {
        var v = g[_][A];
        try {
          v[0].apply(w, x);
        } catch (o) {
          xi.console && mr.error("jsPDF PubSub Error", o.message, o);
        }
        v[1] && I.push(A);
      }
      I.length && I.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return g;
  };
}
function qh(w) {
  if (!(this instanceof qh)) return new qh(w);
  var g = "opacity,stroke-opacity".split(",");
  for (var _ in w) w.hasOwnProperty(_) && g.indexOf(_) >= 0 && (this[_] = w[_]);
  this.id = "", this.objectNumber = -1;
}
function sf(w, g) {
  this.gState = w, this.matrix = g, this.id = "", this.objectNumber = -1;
}
function Kl(w, g, _, x, I) {
  if (!(this instanceof Kl)) return new Kl(w, g, _, x, I);
  this.type = w === "axial" ? 2 : 3, this.coords = g, this.colors = _, sf.call(this, x, I);
}
function Pc(w, g, _, x, I) {
  if (!(this instanceof Pc)) return new Pc(w, g, _, x, I);
  this.boundingBox = w, this.xStep = g, this.yStep = _, this.stream = "", this.cloneIndex = 0, sf.call(this, x, I);
}
function vi(w) {
  var g, _ = typeof arguments[0] == "string" ? arguments[0] : "p", x = arguments[1], I = arguments[2], A = arguments[3], v = [], o = 1, D = 16, j = "S", V = null;
  or(w = w || {}) === "object" && (_ = w.orientation, x = w.unit || x, I = w.format || I, A = w.compress || w.compressPdf || A, (V = w.encryption || null) !== null && (V.userPassword = V.userPassword || "", V.ownerPassword = V.ownerPassword || "", V.userPermissions = V.userPermissions || []), o = typeof w.userUnit == "number" ? Math.abs(w.userUnit) : 1, w.precision !== void 0 && (g = w.precision), w.floatPrecision !== void 0 && (D = w.floatPrecision), j = w.defaultPathOperation || "S"), v = w.filters || (A === !0 ? ["FlateEncode"] : v), x = x || "mm", _ = ("" + (_ || "P")).toLowerCase();
  var q = w.putOnlyUsedFonts || !1, U = {}, B = { internal: {}, __private__: {} };
  B.__private__.PubSub = Dp;
  var ye = "1.3", oe = B.__private__.getPdfVersion = function() {
    return ye;
  };
  B.__private__.setPdfVersion = function(L) {
    ye = L;
  };
  var xe = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  B.__private__.getPageFormats = function() {
    return xe;
  };
  var se = B.__private__.getPageFormat = function(L) {
    return xe[L];
  };
  I = I || "a4";
  var ve = { COMPAT: "compat", ADVANCED: "advanced" }, Fe = ve.COMPAT;
  function it() {
    this.saveGraphicsState(), te(new pe(Dt, 0, 0, -Dt, 0, ha() * Dt).toString() + " cm"), this.setFontSize(this.getFontSize() / Dt), j = "n", Fe = ve.ADVANCED;
  }
  function Ke() {
    this.restoreGraphicsState(), j = "S", Fe = ve.COMPAT;
  }
  var gt = B.__private__.combineFontStyleAndFontWeight = function(L, X) {
    if (L == "bold" && X == "normal" || L == "bold" && X == 400 || L == "normal" && X == "italic" || L == "bold" && X == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return X && (L = X == 400 || X === "normal" ? L === "italic" ? "italic" : "normal" : X != 700 && X !== "bold" || L !== "normal" ? (X == 700 ? "bold" : X) + "" + L : "bold"), L;
  };
  B.advancedAPI = function(L) {
    var X = Fe === ve.COMPAT;
    return X && it.call(this), typeof L != "function" || (L(this), X && Ke.call(this)), this;
  }, B.compatAPI = function(L) {
    var X = Fe === ve.ADVANCED;
    return X && Ke.call(this), typeof L != "function" || (L(this), X && it.call(this)), this;
  }, B.isAdvancedAPI = function() {
    return Fe === ve.ADVANCED;
  };
  var $e, Le = function(L) {
    if (Fe !== ve.ADVANCED) throw new Error(L + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, dt = B.roundToPrecision = B.__private__.roundToPrecision = function(L, X) {
    var _e = g || X;
    if (isNaN(L) || isNaN(_e)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return L.toFixed(_e).replace(/0+$/, "");
  };
  $e = B.hpf = B.__private__.hpf = typeof D == "number" ? function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return dt(L, D);
  } : D === "smart" ? function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return dt(L, L > -1 && L < 1 ? 16 : 5);
  } : function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return dt(L, 16);
  };
  var at = B.f2 = B.__private__.f2 = function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.f2");
    return dt(L, 2);
  }, ae = B.__private__.f3 = function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.f3");
    return dt(L, 3);
  }, he = B.scale = B.__private__.scale = function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.scale");
    return Fe === ve.COMPAT ? L * Dt : Fe === ve.ADVANCED ? L : void 0;
  }, Ie = function(L) {
    return Fe === ve.COMPAT ? ha() - L : Fe === ve.ADVANCED ? L : void 0;
  }, Se = function(L) {
    return he(Ie(L));
  };
  B.__private__.setPrecision = B.setPrecision = function(L) {
    typeof parseInt(L, 10) == "number" && (g = parseInt(L, 10));
  };
  var et, Qe = "00000000000000000000000000000000", rt = B.__private__.getFileId = function() {
    return Qe;
  }, Ze = B.__private__.setFileId = function(L) {
    return Qe = L !== void 0 && /^[a-fA-F0-9]{32}$/.test(L) ? L.toUpperCase() : Qe.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), V !== null && (_r = new Sc(V.userPermissions, V.userPassword, V.ownerPassword, Qe)), Qe;
  };
  B.setFileId = function(L) {
    return Ze(L), this;
  }, B.getFileId = function() {
    return rt();
  };
  var ct = B.__private__.convertDateToPDFDate = function(L) {
    var X = L.getTimezoneOffset(), _e = X < 0 ? "+" : "-", ke = Math.floor(Math.abs(X / 60)), je = Math.abs(X % 60), tt = [_e, we(ke), "'", we(je), "'"].join("");
    return ["D:", L.getFullYear(), we(L.getMonth() + 1), we(L.getDate()), we(L.getHours()), we(L.getMinutes()), we(L.getSeconds()), tt].join("");
  }, nt = B.__private__.convertPDFDateToDate = function(L) {
    var X = parseInt(L.substr(2, 4), 10), _e = parseInt(L.substr(6, 2), 10) - 1, ke = parseInt(L.substr(8, 2), 10), je = parseInt(L.substr(10, 2), 10), tt = parseInt(L.substr(12, 2), 10), yt = parseInt(L.substr(14, 2), 10);
    return new Date(X, _e, ke, je, tt, yt, 0);
  }, wt = B.__private__.setCreationDate = function(L) {
    var X;
    if (L === void 0 && (L = /* @__PURE__ */ new Date()), L instanceof Date) X = ct(L);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(L)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      X = L;
    }
    return et = X;
  }, K = B.__private__.getCreationDate = function(L) {
    var X = et;
    return L === "jsDate" && (X = nt(et)), X;
  };
  B.setCreationDate = function(L) {
    return wt(L), this;
  }, B.getCreationDate = function(L) {
    return K(L);
  };
  var ge, we = B.__private__.padd2 = function(L) {
    return ("0" + parseInt(L)).slice(-2);
  }, Ee = B.__private__.padd2Hex = function(L) {
    return ("00" + (L = L.toString())).substr(L.length);
  }, Be = 0, Ve = [], We = [], Ye = 0, bt = [], xt = [], kt = !1, zt = We, Ut = function() {
    Be = 0, Ye = 0, We = [], Ve = [], bt = [], ti = It(), mi = It();
  };
  B.__private__.setCustomOutputDestination = function(L) {
    kt = !0, zt = L;
  };
  var st = function(L) {
    kt || (zt = L);
  };
  B.__private__.resetCustomOutputDestination = function() {
    kt = !1, zt = We;
  };
  var te = B.__private__.out = function(L) {
    return L = L.toString(), Ye += L.length + 1, zt.push(L), zt;
  }, hi = B.__private__.write = function(L) {
    return te(arguments.length === 1 ? L.toString() : Array.prototype.join.call(arguments, " "));
  }, Ht = B.__private__.getArrayBuffer = function(L) {
    for (var X = L.length, _e = new ArrayBuffer(X), ke = new Uint8Array(_e); X--; ) ke[X] = L.charCodeAt(X);
    return _e;
  }, ut = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  B.__private__.getStandardFonts = function() {
    return ut;
  };
  var _t = w.fontSize || 16;
  B.__private__.setFontSize = B.setFontSize = function(L) {
    return _t = Fe === ve.ADVANCED ? L / Dt : L, this;
  };
  var Lt, Ct = B.__private__.getFontSize = B.getFontSize = function() {
    return Fe === ve.COMPAT ? _t : _t * Dt;
  }, ei = w.R2L || !1;
  B.__private__.setR2L = B.setR2L = function(L) {
    return ei = L, this;
  }, B.__private__.getR2L = B.getR2L = function() {
    return ei;
  };
  var pi, fi = B.__private__.setZoomMode = function(L) {
    var X = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(L)) Lt = L;
    else if (isNaN(L)) {
      if (X.indexOf(L) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + L + '" is not recognized.');
      Lt = L;
    } else Lt = parseInt(L, 10);
  };
  B.__private__.getZoomMode = function() {
    return Lt;
  };
  var wi, Ci = B.__private__.setPageMode = function(L) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(L) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + L + '" is not recognized.');
    pi = L;
  };
  B.__private__.getPageMode = function() {
    return pi;
  };
  var pt = B.__private__.setLayoutMode = function(L) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(L) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + L + '" is not recognized.');
    wi = L;
  };
  B.__private__.getLayoutMode = function() {
    return wi;
  }, B.__private__.setDisplayMode = B.setDisplayMode = function(L, X, _e) {
    return fi(L), pt(X), Ci(_e), this;
  };
  var Jt = { title: "", subject: "", author: "", keywords: "", creator: "" };
  B.__private__.getDocumentProperty = function(L) {
    if (Object.keys(Jt).indexOf(L) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return Jt[L];
  }, B.__private__.getDocumentProperties = function() {
    return Jt;
  }, B.__private__.setDocumentProperties = B.setProperties = B.setDocumentProperties = function(L) {
    for (var X in Jt) Jt.hasOwnProperty(X) && L[X] && (Jt[X] = L[X]);
    return this;
  }, B.__private__.setDocumentProperty = function(L, X) {
    if (Object.keys(Jt).indexOf(L) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return Jt[L] = X;
  };
  var ui, Dt, gr, lt, li, Bt = {}, ki = {}, lr = [], Ft = {}, nn = {}, Oi = {}, $i = {}, de = null, Z = 0, W = [], J = new Dp(B), fe = w.hotfixes || [], Ae = {}, Ce = {}, Me = [], pe = function L(X, _e, ke, je, tt, yt) {
    if (!(this instanceof L)) return new L(X, _e, ke, je, tt, yt);
    isNaN(X) && (X = 1), isNaN(_e) && (_e = 0), isNaN(ke) && (ke = 0), isNaN(je) && (je = 1), isNaN(tt) && (tt = 0), isNaN(yt) && (yt = 0), this._matrix = [X, _e, ke, je, tt, yt];
  };
  Object.defineProperty(pe.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(L) {
    this._matrix[0] = L;
  } }), Object.defineProperty(pe.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(L) {
    this._matrix[1] = L;
  } }), Object.defineProperty(pe.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(L) {
    this._matrix[2] = L;
  } }), Object.defineProperty(pe.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(L) {
    this._matrix[3] = L;
  } }), Object.defineProperty(pe.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(L) {
    this._matrix[4] = L;
  } }), Object.defineProperty(pe.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(L) {
    this._matrix[5] = L;
  } }), Object.defineProperty(pe.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(L) {
    this._matrix[0] = L;
  } }), Object.defineProperty(pe.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(L) {
    this._matrix[1] = L;
  } }), Object.defineProperty(pe.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(L) {
    this._matrix[2] = L;
  } }), Object.defineProperty(pe.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(L) {
    this._matrix[3] = L;
  } }), Object.defineProperty(pe.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(L) {
    this._matrix[4] = L;
  } }), Object.defineProperty(pe.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(L) {
    this._matrix[5] = L;
  } }), Object.defineProperty(pe.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(pe.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(pe.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(pe.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), pe.prototype.join = function(L) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map($e).join(L);
  }, pe.prototype.multiply = function(L) {
    var X = L.sx * this.sx + L.shy * this.shx, _e = L.sx * this.shy + L.shy * this.sy, ke = L.shx * this.sx + L.sy * this.shx, je = L.shx * this.shy + L.sy * this.sy, tt = L.tx * this.sx + L.ty * this.shx + this.tx, yt = L.tx * this.shy + L.ty * this.sy + this.ty;
    return new pe(X, _e, ke, je, tt, yt);
  }, pe.prototype.decompose = function() {
    var L = this.sx, X = this.shy, _e = this.shx, ke = this.sy, je = this.tx, tt = this.ty, yt = Math.sqrt(L * L + X * X), jt = (L /= yt) * _e + (X /= yt) * ke;
    _e -= L * jt, ke -= X * jt;
    var oi = Math.sqrt(_e * _e + ke * ke);
    return jt /= oi, L * (ke /= oi) < X * (_e /= oi) && (L = -L, X = -X, jt = -jt, yt = -yt), { scale: new pe(yt, 0, 0, oi, 0, 0), translate: new pe(1, 0, 0, 1, je, tt), rotate: new pe(L, X, -X, L, 0, 0), skew: new pe(1, 0, jt, 1, 0, 0) };
  }, pe.prototype.toString = function(L) {
    return this.join(" ");
  }, pe.prototype.inversed = function() {
    var L = this.sx, X = this.shy, _e = this.shx, ke = this.sy, je = this.tx, tt = this.ty, yt = 1 / (L * ke - X * _e), jt = ke * yt, oi = -X * yt, yi = -_e * yt, Yt = L * yt;
    return new pe(jt, oi, yi, Yt, -jt * je - yi * tt, -oi * je - Yt * tt);
  }, pe.prototype.applyToPoint = function(L) {
    var X = L.x * this.sx + L.y * this.shx + this.tx, _e = L.x * this.shy + L.y * this.sy + this.ty;
    return new Mn(X, _e);
  }, pe.prototype.applyToRectangle = function(L) {
    var X = this.applyToPoint(L), _e = this.applyToPoint(new Mn(L.x + L.w, L.y + L.h));
    return new lo(X.x, X.y, _e.x - X.x, _e.y - X.y);
  }, pe.prototype.clone = function() {
    var L = this.sx, X = this.shy, _e = this.shx, ke = this.sy, je = this.tx, tt = this.ty;
    return new pe(L, X, _e, ke, je, tt);
  }, B.Matrix = pe;
  var Oe = B.matrixMult = function(L, X) {
    return X.multiply(L);
  }, ot = new pe(1, 0, 0, 1, 0, 0);
  B.unitMatrix = B.identityMatrix = ot;
  var Je = function(L, X) {
    if (!nn[L]) {
      var _e = (X instanceof Kl ? "Sh" : "P") + (Object.keys(Ft).length + 1).toString(10);
      X.id = _e, nn[L] = _e, Ft[_e] = X, J.publish("addPattern", X);
    }
  };
  B.ShadingPattern = Kl, B.TilingPattern = Pc, B.addShadingPattern = function(L, X) {
    return Le("addShadingPattern()"), Je(L, X), this;
  }, B.beginTilingPattern = function(L) {
    Le("beginTilingPattern()"), nl(L.boundingBox[0], L.boundingBox[1], L.boundingBox[2] - L.boundingBox[0], L.boundingBox[3] - L.boundingBox[1], L.matrix);
  }, B.endTilingPattern = function(L, X) {
    Le("endTilingPattern()"), X.stream = xt[ge].join(`
`), Je(L, X), J.publish("endTilingPattern", X), Me.pop().restore();
  };
  var Ge = B.__private__.newObject = function() {
    var L = It();
    return Nt(L, !0), L;
  }, It = B.__private__.newObjectDeferred = function() {
    return Be++, Ve[Be] = function() {
      return Ye;
    }, Be;
  }, Nt = function(L, X) {
    return X = typeof X == "boolean" && X, Ve[L] = Ye, X && te(L + " 0 obj"), L;
  }, gi = B.__private__.newAdditionalObject = function() {
    var L = { objId: It(), content: "" };
    return bt.push(L), L;
  }, ti = It(), mi = It(), Ii = B.__private__.decodeColorString = function(L) {
    var X = L.split(" ");
    if (X.length !== 2 || X[1] !== "g" && X[1] !== "G")
      X.length === 5 && (X[4] === "k" || X[4] === "K") && (X = [(1 - X[0]) * (1 - X[3]), (1 - X[1]) * (1 - X[3]), (1 - X[2]) * (1 - X[3]), "r"]);
    else {
      var _e = parseFloat(X[0]);
      X = [_e, _e, _e, "r"];
    }
    for (var ke = "#", je = 0; je < 3; je++) ke += ("0" + Math.floor(255 * parseFloat(X[je])).toString(16)).slice(-2);
    return ke;
  }, Ei = B.__private__.encodeColorString = function(L) {
    var X;
    typeof L == "string" && (L = { ch1: L });
    var _e = L.ch1, ke = L.ch2, je = L.ch3, tt = L.ch4, yt = L.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof _e == "string" && _e.charAt(0) !== "#") {
      var jt = new rf(_e);
      if (jt.ok) _e = jt.toHex();
      else if (!/^\d*\.?\d*$/.test(_e)) throw new Error('Invalid color "' + _e + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof _e == "string" && /^#[0-9A-Fa-f]{3}$/.test(_e) && (_e = "#" + _e[1] + _e[1] + _e[2] + _e[2] + _e[3] + _e[3]), typeof _e == "string" && /^#[0-9A-Fa-f]{6}$/.test(_e)) {
      var oi = parseInt(_e.substr(1), 16);
      _e = oi >> 16 & 255, ke = oi >> 8 & 255, je = 255 & oi;
    }
    if (ke === void 0 || tt === void 0 && _e === ke && ke === je) if (typeof _e == "string") X = _e + " " + yt[0];
    else switch (L.precision) {
      case 2:
        X = at(_e / 255) + " " + yt[0];
        break;
      case 3:
      default:
        X = ae(_e / 255) + " " + yt[0];
    }
    else if (tt === void 0 || or(tt) === "object") {
      if (tt && !isNaN(tt.a) && tt.a === 0) return X = ["1.", "1.", "1.", yt[1]].join(" ");
      if (typeof _e == "string") X = [_e, ke, je, yt[1]].join(" ");
      else switch (L.precision) {
        case 2:
          X = [at(_e / 255), at(ke / 255), at(je / 255), yt[1]].join(" ");
          break;
        default:
        case 3:
          X = [ae(_e / 255), ae(ke / 255), ae(je / 255), yt[1]].join(" ");
      }
    } else if (typeof _e == "string") X = [_e, ke, je, tt, yt[2]].join(" ");
    else switch (L.precision) {
      case 2:
        X = [at(_e), at(ke), at(je), at(tt), yt[2]].join(" ");
        break;
      case 3:
      default:
        X = [ae(_e), ae(ke), ae(je), ae(tt), yt[2]].join(" ");
    }
    return X;
  }, Ui = B.__private__.getFilters = function() {
    return v;
  }, ai = B.__private__.putStream = function(L) {
    var X = (L = L || {}).data || "", _e = L.filters || Ui(), ke = L.alreadyAppliedFilters || [], je = L.addLength1 || !1, tt = X.length, yt = L.objectId, jt = function(Ai) {
      return Ai;
    };
    if (V !== null && yt === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    V !== null && (jt = _r.encryptor(yt, 0));
    var oi = {};
    _e === !0 && (_e = ["FlateEncode"]);
    var yi = L.additionalKeyValues || [], Yt = (oi = vi.API.processDataByFilters !== void 0 ? vi.API.processDataByFilters(X, _e) : { data: X, reverseChain: [] }).reverseChain + (Array.isArray(ke) ? ke.join(" ") : ke.toString());
    if (oi.data.length !== 0 && (yi.push({ key: "Length", value: oi.data.length }), je === !0 && yi.push({ key: "Length1", value: tt })), Yt.length != 0) if (Yt.split("/").length - 1 == 1) yi.push({ key: "Filter", value: Yt });
    else {
      yi.push({ key: "Filter", value: "[" + Yt + "]" });
      for (var Di = 0; Di < yi.length; Di += 1) if (yi[Di].key === "DecodeParms") {
        for (var Zt = [], rr = 0; rr < oi.reverseChain.split("/").length - 1; rr += 1) Zt.push("null");
        Zt.push(yi[Di].value), yi[Di].value = "[" + Zt.join(" ") + "]";
      }
    }
    te("<<");
    for (var Si = 0; Si < yi.length; Si++) te("/" + yi[Si].key + " " + yi[Si].value);
    te(">>"), oi.data.length !== 0 && (te("stream"), te(jt(oi.data)), te("endstream"));
  }, Fi = B.__private__.putPage = function(L) {
    var X = L.number, _e = L.data, ke = L.objId, je = L.contentsObjId;
    Nt(ke, !0), te("<</Type /Page"), te("/Parent " + L.rootDictionaryObjId + " 0 R"), te("/Resources " + L.resourceDictionaryObjId + " 0 R"), te("/MediaBox [" + parseFloat($e(L.mediaBox.bottomLeftX)) + " " + parseFloat($e(L.mediaBox.bottomLeftY)) + " " + $e(L.mediaBox.topRightX) + " " + $e(L.mediaBox.topRightY) + "]"), L.cropBox !== null && te("/CropBox [" + $e(L.cropBox.bottomLeftX) + " " + $e(L.cropBox.bottomLeftY) + " " + $e(L.cropBox.topRightX) + " " + $e(L.cropBox.topRightY) + "]"), L.bleedBox !== null && te("/BleedBox [" + $e(L.bleedBox.bottomLeftX) + " " + $e(L.bleedBox.bottomLeftY) + " " + $e(L.bleedBox.topRightX) + " " + $e(L.bleedBox.topRightY) + "]"), L.trimBox !== null && te("/TrimBox [" + $e(L.trimBox.bottomLeftX) + " " + $e(L.trimBox.bottomLeftY) + " " + $e(L.trimBox.topRightX) + " " + $e(L.trimBox.topRightY) + "]"), L.artBox !== null && te("/ArtBox [" + $e(L.artBox.bottomLeftX) + " " + $e(L.artBox.bottomLeftY) + " " + $e(L.artBox.topRightX) + " " + $e(L.artBox.topRightY) + "]"), typeof L.userUnit == "number" && L.userUnit !== 1 && te("/UserUnit " + L.userUnit), J.publish("putPage", { objId: ke, pageContext: W[X], pageNumber: X, page: _e }), te("/Contents " + je + " 0 R"), te(">>"), te("endobj");
    var tt = _e.join(`
`);
    return Fe === ve.ADVANCED && (tt += `
Q`), Nt(je, !0), ai({ data: tt, filters: Ui(), objectId: je }), te("endobj"), ke;
  }, er = B.__private__.putPages = function() {
    var L, X, _e = [];
    for (L = 1; L <= Z; L++) W[L].objId = It(), W[L].contentsObjId = It();
    for (L = 1; L <= Z; L++) _e.push(Fi({ number: L, data: xt[L], objId: W[L].objId, contentsObjId: W[L].contentsObjId, mediaBox: W[L].mediaBox, cropBox: W[L].cropBox, bleedBox: W[L].bleedBox, trimBox: W[L].trimBox, artBox: W[L].artBox, userUnit: W[L].userUnit, rootDictionaryObjId: ti, resourceDictionaryObjId: mi }));
    Nt(ti, !0), te("<</Type /Pages");
    var ke = "/Kids [";
    for (X = 0; X < Z; X++) ke += _e[X] + " 0 R ";
    te(ke + "]"), te("/Count " + Z), te(">>"), te("endobj"), J.publish("postPutPages");
  }, Mr = function(L) {
    J.publish("putFont", { font: L, out: te, newObject: Ge, putStream: ai }), L.isAlreadyPutted !== !0 && (L.objectNumber = Ge(), te("<<"), te("/Type /Font"), te("/BaseFont /" + Ac(L.postScriptName)), te("/Subtype /Type1"), typeof L.encoding == "string" && te("/Encoding /" + L.encoding), te("/FirstChar 32"), te("/LastChar 255"), te(">>"), te("endobj"));
  }, Nr = function() {
    for (var L in Bt) Bt.hasOwnProperty(L) && (q === !1 || q === !0 && U.hasOwnProperty(L)) && Mr(Bt[L]);
  }, cr = function(L) {
    L.objectNumber = Ge();
    var X = [];
    X.push({ key: "Type", value: "/XObject" }), X.push({ key: "Subtype", value: "/Form" }), X.push({ key: "BBox", value: "[" + [$e(L.x), $e(L.y), $e(L.x + L.width), $e(L.y + L.height)].join(" ") + "]" }), X.push({ key: "Matrix", value: "[" + L.matrix.toString() + "]" });
    var _e = L.pages[1].join(`
`);
    ai({ data: _e, additionalKeyValues: X, objectId: L.objectNumber }), te("endobj");
  }, Jn = function() {
    for (var L in Ae) Ae.hasOwnProperty(L) && cr(Ae[L]);
  }, Qo = function(L, X) {
    var _e, ke = [], je = 1 / (X - 1);
    for (_e = 0; _e < 1; _e += je) ke.push(_e);
    if (ke.push(1), L[0].offset != 0) {
      var tt = { offset: 0, color: L[0].color };
      L.unshift(tt);
    }
    if (L[L.length - 1].offset != 1) {
      var yt = { offset: 1, color: L[L.length - 1].color };
      L.push(yt);
    }
    for (var jt = "", oi = 0, yi = 0; yi < ke.length; yi++) {
      for (_e = ke[yi]; _e > L[oi + 1].offset; ) oi++;
      var Yt = L[oi].offset, Di = (_e - Yt) / (L[oi + 1].offset - Yt), Zt = L[oi].color, rr = L[oi + 1].color;
      jt += Ee(Math.round((1 - Di) * Zt[0] + Di * rr[0]).toString(16)) + Ee(Math.round((1 - Di) * Zt[1] + Di * rr[1]).toString(16)) + Ee(Math.round((1 - Di) * Zt[2] + Di * rr[2]).toString(16));
    }
    return jt.trim();
  }, Ri = function(L, X) {
    X || (X = 21);
    var _e = Ge(), ke = Qo(L.colors, X), je = [];
    je.push({ key: "FunctionType", value: "0" }), je.push({ key: "Domain", value: "[0.0 1.0]" }), je.push({ key: "Size", value: "[" + X + "]" }), je.push({ key: "BitsPerSample", value: "8" }), je.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), je.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ai({ data: ke, additionalKeyValues: je, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: _e }), te("endobj"), L.objectNumber = Ge(), te("<< /ShadingType " + L.type), te("/ColorSpace /DeviceRGB");
    var tt = "/Coords [" + $e(parseFloat(L.coords[0])) + " " + $e(parseFloat(L.coords[1])) + " ";
    L.type === 2 ? tt += $e(parseFloat(L.coords[2])) + " " + $e(parseFloat(L.coords[3])) : tt += $e(parseFloat(L.coords[2])) + " " + $e(parseFloat(L.coords[3])) + " " + $e(parseFloat(L.coords[4])) + " " + $e(parseFloat(L.coords[5])), te(tt += "]"), L.matrix && te("/Matrix [" + L.matrix.toString() + "]"), te("/Function " + _e + " 0 R"), te("/Extend [true true]"), te(">>"), te("endobj");
  }, Co = function(L, X) {
    var _e = It(), ke = Ge();
    X.push({ resourcesOid: _e, objectOid: ke }), L.objectNumber = ke;
    var je = [];
    je.push({ key: "Type", value: "/Pattern" }), je.push({ key: "PatternType", value: "1" }), je.push({ key: "PaintType", value: "1" }), je.push({ key: "TilingType", value: "1" }), je.push({ key: "BBox", value: "[" + L.boundingBox.map($e).join(" ") + "]" }), je.push({ key: "XStep", value: $e(L.xStep) }), je.push({ key: "YStep", value: $e(L.yStep) }), je.push({ key: "Resources", value: _e + " 0 R" }), L.matrix && je.push({ key: "Matrix", value: "[" + L.matrix.toString() + "]" }), ai({ data: L.stream, additionalKeyValues: je, objectId: L.objectNumber }), te("endobj");
  }, ea = function(L) {
    var X;
    for (X in Ft) Ft.hasOwnProperty(X) && (Ft[X] instanceof Kl ? Ri(Ft[X]) : Ft[X] instanceof Pc && Co(Ft[X], L));
  }, Yr = function(L) {
    for (var X in L.objectNumber = Ge(), te("<<"), L) switch (X) {
      case "opacity":
        te("/ca " + at(L[X]));
        break;
      case "stroke-opacity":
        te("/CA " + at(L[X]));
    }
    te(">>"), te("endobj");
  }, Jr = function() {
    var L;
    for (L in Oi) Oi.hasOwnProperty(L) && Yr(Oi[L]);
  }, Cs = function() {
    for (var L in te("/XObject <<"), Ae) Ae.hasOwnProperty(L) && Ae[L].objectNumber >= 0 && te("/" + L + " " + Ae[L].objectNumber + " 0 R");
    J.publish("putXobjectDict"), te(">>");
  }, Kr = function() {
    _r.oid = Ge(), te("<<"), te("/Filter /Standard"), te("/V " + _r.v), te("/R " + _r.r), te("/U <" + _r.toHexString(_r.U) + ">"), te("/O <" + _r.toHexString(_r.O) + ">"), te("/P " + _r.P), te(">>"), te("endobj");
  }, sn = function() {
    for (var L in te("/Font <<"), Bt) Bt.hasOwnProperty(L) && (q === !1 || q === !0 && U.hasOwnProperty(L)) && te("/" + L + " " + Bt[L].objectNumber + " 0 R");
    te(">>");
  }, el = function() {
    if (Object.keys(Ft).length > 0) {
      for (var L in te("/Shading <<"), Ft) Ft.hasOwnProperty(L) && Ft[L] instanceof Kl && Ft[L].objectNumber >= 0 && te("/" + L + " " + Ft[L].objectNumber + " 0 R");
      J.publish("putShadingPatternDict"), te(">>");
    }
  }, cn = function(L) {
    if (Object.keys(Ft).length > 0) {
      for (var X in te("/Pattern <<"), Ft) Ft.hasOwnProperty(X) && Ft[X] instanceof B.TilingPattern && Ft[X].objectNumber >= 0 && Ft[X].objectNumber < L && te("/" + X + " " + Ft[X].objectNumber + " 0 R");
      J.publish("putTilingPatternDict"), te(">>");
    }
  }, yr = function() {
    if (Object.keys(Oi).length > 0) {
      var L;
      for (L in te("/ExtGState <<"), Oi) Oi.hasOwnProperty(L) && Oi[L].objectNumber >= 0 && te("/" + L + " " + Oi[L].objectNumber + " 0 R");
      J.publish("putGStateDict"), te(">>");
    }
  }, tr = function(L) {
    Nt(L.resourcesOid, !0), te("<<"), te("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), sn(), el(), cn(L.objectOid), yr(), Cs(), te(">>"), te("endobj");
  }, us = function() {
    var L = [];
    Nr(), Jr(), Jn(), ea(L), J.publish("putResources"), L.forEach(tr), tr({ resourcesOid: mi, objectOid: Number.MAX_SAFE_INTEGER }), J.publish("postPutResources");
  }, ir = function() {
    J.publish("putAdditionalObjects");
    for (var L = 0; L < bt.length; L++) {
      var X = bt[L];
      Nt(X.objId, !0), te(X.content), te("endobj");
    }
    J.publish("postPutAdditionalObjects");
  }, ds = function(L) {
    ki[L.fontName] = ki[L.fontName] || {}, ki[L.fontName][L.fontStyle] = L.id;
  }, an = function(L, X, _e, ke, je) {
    var tt = { id: "F" + (Object.keys(Bt).length + 1).toString(10), postScriptName: L, fontName: X, fontStyle: _e, encoding: ke, isStandardFont: je || !1, metadata: {} };
    return J.publish("addFont", { font: tt, instance: this }), Bt[tt.id] = tt, ds(tt), tt.id;
  }, Ga = function(L) {
    for (var X = 0, _e = ut.length; X < _e; X++) {
      var ke = an.call(this, L[X][0], L[X][1], L[X][2], ut[X][3], !0);
      q === !1 && (U[ke] = !0);
      var je = L[X][0].split("-");
      ds({ id: ke, fontName: je[0], fontStyle: je[1] || "" });
    }
    J.publish("addFonts", { fonts: Bt, dictionary: ki });
  }, Ar = function(L) {
    return L.foo = function() {
      try {
        return L.apply(this, arguments);
      } catch (ke) {
        var X = ke.stack || "";
        ~X.indexOf(" at ") && (X = X.split(" at ")[1]);
        var _e = "Error in function " + X.split(`
`)[0].split("<")[0] + ": " + ke.message;
        if (!xi.console) throw new Error(_e);
        xi.console.error(_e, ke), xi.alert && alert(_e);
      }
    }, L.foo.bar = L, L.foo;
  }, ta = function(L, X) {
    var _e, ke, je, tt, yt, jt, oi, yi, Yt;
    if (je = (X = X || {}).sourceEncoding || "Unicode", yt = X.outputEncoding, (X.autoencode || yt) && Bt[ui].metadata && Bt[ui].metadata[je] && Bt[ui].metadata[je].encoding && (tt = Bt[ui].metadata[je].encoding, !yt && Bt[ui].encoding && (yt = Bt[ui].encoding), !yt && tt.codePages && (yt = tt.codePages[0]), typeof yt == "string" && (yt = tt[yt]), yt)) {
      for (oi = !1, jt = [], _e = 0, ke = L.length; _e < ke; _e++) (yi = yt[L.charCodeAt(_e)]) ? jt.push(String.fromCharCode(yi)) : jt.push(L[_e]), jt[_e].charCodeAt(0) >> 8 && (oi = !0);
      L = jt.join("");
    }
    for (_e = L.length; oi === void 0 && _e !== 0; ) L.charCodeAt(_e - 1) >> 8 && (oi = !0), _e--;
    if (!oi) return L;
    for (jt = X.noBOM ? [] : [254, 255], _e = 0, ke = L.length; _e < ke; _e++) {
      if ((Yt = (yi = L.charCodeAt(_e)) >> 8) >> 8) throw new Error("Character at position " + _e + " of string '" + L + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      jt.push(Yt), jt.push(yi - (Yt << 8));
    }
    return String.fromCharCode.apply(void 0, jt);
  }, Dr = B.__private__.pdfEscape = B.pdfEscape = function(L, X) {
    return ta(L, X).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, Mi = B.__private__.beginPage = function(L) {
    xt[++Z] = [], W[Z] = { objId: 0, contentsObjId: 0, userUnit: Number(o), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(L[0]), topRightY: Number(L[1]) } }, Ha(Z), st(xt[ge]);
  }, Ta = function(L, X) {
    var _e, ke, je;
    switch (_ = X || _, typeof L == "string" && (_e = se(L.toLowerCase()), Array.isArray(_e) && (ke = _e[0], je = _e[1])), Array.isArray(L) && (ke = L[0] * Dt, je = L[1] * Dt), isNaN(ke) && (ke = I[0], je = I[1]), (ke > 14400 || je > 14400) && (mr.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), ke = Math.min(14400, ke), je = Math.min(14400, je)), I = [ke, je], _.substr(0, 1)) {
      case "l":
        je > ke && (I = [je, ke]);
        break;
      case "p":
        ke > je && (I = [je, ke]);
    }
    Mi(I), zi(zs), te(Qn), ao !== 0 && te(ao + " J"), oo !== 0 && te(oo + " j"), J.publish("addPage", { pageNumber: Z });
  }, ia = function(L) {
    L > 0 && L <= Z && (xt.splice(L, 1), W.splice(L, 1), Z--, ge > Z && (ge = Z), this.setPage(ge));
  }, Ha = function(L) {
    L > 0 && L <= Z && (ge = L);
  }, Xa = B.__private__.getNumberOfPages = B.getNumberOfPages = function() {
    return xt.length - 1;
  }, ra = function(L, X, _e) {
    var ke, je = void 0;
    return _e = _e || {}, L = L !== void 0 ? L : Bt[ui].fontName, X = X !== void 0 ? X : Bt[ui].fontStyle, ke = L.toLowerCase(), ki[ke] !== void 0 && ki[ke][X] !== void 0 ? je = ki[ke][X] : ki[L] !== void 0 && ki[L][X] !== void 0 ? je = ki[L][X] : _e.disableWarning === !1 && mr.warn("Unable to look up font label for font '" + L + "', '" + X + "'. Refer to getFontList() for available fonts."), je || _e.noFallback || (je = ki.times[X]) == null && (je = ki.times.normal), je;
  }, Eo = B.__private__.putInfo = function() {
    var L = Ge(), X = function(ke) {
      return ke;
    };
    for (var _e in V !== null && (X = _r.encryptor(L, 0)), te("<<"), te("/Producer (" + Dr(X("jsPDF " + vi.version)) + ")"), Jt) Jt.hasOwnProperty(_e) && Jt[_e] && te("/" + _e.substr(0, 1).toUpperCase() + _e.substr(1) + " (" + Dr(X(Jt[_e])) + ")");
    te("/CreationDate (" + Dr(X(et)) + ")"), te(">>"), te("endobj");
  }, na = B.__private__.putCatalog = function(L) {
    var X = (L = L || {}).rootDictionaryObjId || ti;
    switch (Ge(), te("<<"), te("/Type /Catalog"), te("/Pages " + X + " 0 R"), Lt || (Lt = "fullwidth"), Lt) {
      case "fullwidth":
        te("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        te("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        te("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        te("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var _e = "" + Lt;
        _e.substr(_e.length - 1) === "%" && (Lt = parseInt(Lt) / 100), typeof Lt == "number" && te("/OpenAction [3 0 R /XYZ null null " + at(Lt) + "]");
    }
    switch (wi || (wi = "continuous"), wi) {
      case "continuous":
        te("/PageLayout /OneColumn");
        break;
      case "single":
        te("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        te("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        te("/PageLayout /TwoColumnRight");
    }
    pi && te("/PageMode /" + pi), J.publish("putCatalog"), te(">>"), te("endobj");
  }, ka = B.__private__.putTrailer = function() {
    te("trailer"), te("<<"), te("/Size " + (Be + 1)), te("/Root " + Be + " 0 R"), te("/Info " + (Be - 1) + " 0 R"), V !== null && te("/Encrypt " + _r.oid + " 0 R"), te("/ID [ <" + Qe + "> <" + Qe + "> ]"), te(">>");
  }, Ya = B.__private__.putHeader = function() {
    te("%PDF-" + ye), te("%");
  }, La = B.__private__.putXRef = function() {
    var L = "0000000000";
    te("xref"), te("0 " + (Be + 1)), te("0000000000 65535 f ");
    for (var X = 1; X <= Be; X++)
      typeof Ve[X] == "function" ? te((L + Ve[X]()).slice(-10) + " 00000 n ") : Ve[X] !== void 0 ? te((L + Ve[X]).slice(-10) + " 00000 n ") : te("0000000000 00000 n ");
  }, Es = B.__private__.buildDocument = function() {
    Ut(), st(We), J.publish("buildDocument"), Ya(), er(), ir(), us(), V !== null && Kr(), Eo(), na();
    var L = Ye;
    return La(), ka(), te("startxref"), te("" + L), te("%%EOF"), st(xt[ge]), We.join(`
`);
  }, Ja = B.__private__.getBlob = function(L) {
    return new Blob([Ht(L)], { type: "application/pdf" });
  }, sa = B.output = B.__private__.output = Ar(function(L, X) {
    switch (typeof (X = X || {}) == "string" ? X = { filename: X } : X.filename = X.filename || "generated.pdf", L) {
      case void 0:
        return Es();
      case "save":
        B.save(X.filename);
        break;
      case "arraybuffer":
        return Ht(Es());
      case "blob":
        return Ja(Es());
      case "bloburi":
      case "bloburl":
        if (xi.URL !== void 0 && typeof xi.URL.createObjectURL == "function") return xi.URL && xi.URL.createObjectURL(Ja(Es())) || void 0;
        mr.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var _e = "", ke = Es();
        try {
          _e = Wu(ke);
        } catch {
          _e = Wu(unescape(encodeURIComponent(ke)));
        }
        return "data:application/pdf;filename=" + X.filename + ";base64," + _e;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(xi) === "[object Window]") {
          var je = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", tt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          X.pdfObjectUrl && (je = X.pdfObjectUrl, tt = "");
          var yt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + je + '"' + tt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(X) + ");<\/script></body></html>", jt = xi.open();
          return jt !== null && jt.document.write(yt), jt;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(xi) === "[object Window]") {
          var oi = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (X.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + X.filename + '" width="500px" height="400px" /></body></html>', yi = xi.open();
          if (yi !== null) {
            yi.document.write(oi);
            var Yt = this;
            yi.document.documentElement.querySelector("#pdfViewer").onload = function() {
              yi.document.title = X.filename, yi.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Yt.output("bloburl"));
            };
          }
          return yi;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(xi) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var Di = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", X) + '"></iframe></body></html>', Zt = xi.open();
        if (Zt !== null && (Zt.document.write(Di), Zt.document.title = X.filename), Zt || typeof safari > "u") return Zt;
        break;
      case "datauri":
      case "dataurl":
        return xi.document.location.href = this.output("datauristring", X);
      default:
        return null;
    }
  }), Mo = function(L) {
    return Array.isArray(fe) === !0 && fe.indexOf(L) > -1;
  };
  switch (x) {
    case "pt":
      Dt = 1;
      break;
    case "mm":
      Dt = 72 / 25.4;
      break;
    case "cm":
      Dt = 72 / 2.54;
      break;
    case "in":
      Dt = 72;
      break;
    case "px":
      Dt = Mo("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Dt = 12;
      break;
    case "ex":
      Dt = 6;
      break;
    default:
      if (typeof x != "number") throw new Error("Invalid unit: " + x);
      Dt = x;
  }
  var _r = null;
  wt(), Ze();
  var Ka = function(L) {
    return V !== null ? _r.encryptor(L, 0) : function(X) {
      return X;
    };
  }, Rr = B.__private__.getPageInfo = B.getPageInfo = function(L) {
    if (isNaN(L) || L % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: W[L].objId, pageNumber: L, pageContext: W[L] };
  }, ri = B.__private__.getPageInfoByObjId = function(L) {
    if (isNaN(L) || L % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var X in W) if (W[X].objId === L) break;
    return Rr(X);
  }, Do = B.__private__.getCurrentPageInfo = B.getCurrentPageInfo = function() {
    return { objId: W[ge].objId, pageNumber: ge, pageContext: W[ge] };
  };
  B.addPage = function() {
    return Ta.apply(this, arguments), this;
  }, B.setPage = function() {
    return Ha.apply(this, arguments), st.call(this, xt[ge]), this;
  }, B.insertPage = function(L) {
    return this.addPage(), this.movePage(ge, L), this;
  }, B.movePage = function(L, X) {
    var _e, ke;
    if (L > X) {
      _e = xt[L], ke = W[L];
      for (var je = L; je > X; je--) xt[je] = xt[je - 1], W[je] = W[je - 1];
      xt[X] = _e, W[X] = ke, this.setPage(X);
    } else if (L < X) {
      _e = xt[L], ke = W[L];
      for (var tt = L; tt < X; tt++) xt[tt] = xt[tt + 1], W[tt] = W[tt + 1];
      xt[X] = _e, W[X] = ke, this.setPage(X);
    }
    return this;
  }, B.deletePage = function() {
    return ia.apply(this, arguments), this;
  }, B.__private__.text = B.text = function(L, X, _e, ke, je) {
    var tt, yt, jt, oi, yi, Yt, Di, Zt, rr, Si = (ke = ke || {}).scope || this;
    if (typeof L == "number" && typeof X == "number" && (typeof _e == "string" || Array.isArray(_e))) {
      var Ai = _e;
      _e = X, X = L, L = Ai;
    }
    if (arguments[3] instanceof pe ? (Le("The transform parameter of text() with a Matrix value"), rr = je) : (jt = arguments[4], oi = arguments[5], or(Di = arguments[3]) === "object" && Di !== null || (typeof jt == "string" && (oi = jt, jt = null), typeof Di == "string" && (oi = Di, Di = null), typeof Di == "number" && (jt = Di, Di = null), ke = { flags: Di, angle: jt, align: oi })), isNaN(X) || isNaN(_e) || L == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (L.length === 0) return Si;
    var br = "", Dn = !1, hn = typeof ke.lineHeightFactor == "number" ? ke.lineHeightFactor : Ds, Ns = Si.internal.scaleFactor;
    function Bo(Zi) {
      return Zi = Zi.split("	").join(Array(ke.TabLen || 9).join(" ")), Dr(Zi, Di);
    }
    function ua(Zi) {
      for (var Ji, Ki = Zi.concat(), pr = [], An = Ki.length; An--; ) typeof (Ji = Ki.shift()) == "string" ? pr.push(Ji) : Array.isArray(Zi) && (Ji.length === 1 || Ji[1] === void 0 && Ji[2] === void 0) ? pr.push(Ji[0]) : pr.push([Ji[0], Ji[1], Ji[2]]);
      return pr;
    }
    function da(Zi, Ji) {
      var Ki;
      if (typeof Zi == "string") Ki = Ji(Zi)[0];
      else if (Array.isArray(Zi)) {
        for (var pr, An, Os = Zi.concat(), js = [], Fa = Os.length; Fa--; ) typeof (pr = Os.shift()) == "string" ? js.push(Ji(pr)[0]) : Array.isArray(pr) && typeof pr[0] == "string" && (An = Ji(pr[0], pr[1], pr[2]), js.push([An[0], An[1], An[2]]));
        Ki = js;
      }
      return Ki;
    }
    var gs = !1, pa = !0;
    if (typeof L == "string") gs = !0;
    else if (Array.isArray(L)) {
      var zn = L.concat();
      yt = [];
      for (var Fn, Hi = zn.length; Hi--; ) (typeof (Fn = zn.shift()) != "string" || Array.isArray(Fn) && typeof Fn[0] != "string") && (pa = !1);
      gs = pa;
    }
    if (gs === !1) throw new Error('Type of text must be string or Array. "' + L + '" is not recognized.');
    typeof L == "string" && (L = L.match(/[\r?\n]/) ? L.split(/\r\n|\r|\n/g) : [L]);
    var Ma = _t / Si.internal.scaleFactor, Da = Ma * (hn - 1);
    switch (ke.baseline) {
      case "bottom":
        _e -= Da;
        break;
      case "top":
        _e += Ma - Da;
        break;
      case "hanging":
        _e += Ma - 2 * Da;
        break;
      case "middle":
        _e += Ma / 2 - Da;
    }
    if ((Yt = ke.maxWidth || 0) > 0 && (typeof L == "string" ? L = Si.splitTextToSize(L, Yt) : Object.prototype.toString.call(L) === "[object Array]" && (L = L.reduce(function(Zi, Ji) {
      return Zi.concat(Si.splitTextToSize(Ji, Yt));
    }, []))), tt = { text: L, x: X, y: _e, options: ke, mutex: { pdfEscape: Dr, activeFontKey: ui, fonts: Bt, activeFontSize: _t } }, J.publish("preProcessText", tt), L = tt.text, jt = (ke = tt.options).angle, !(rr instanceof pe) && jt && typeof jt == "number") {
      jt *= Math.PI / 180, ke.rotationDirection === 0 && (jt = -jt), Fe === ve.ADVANCED && (jt = -jt);
      var fa = Math.cos(jt), es = Math.sin(jt);
      rr = new pe(fa, es, -es, fa, 0, 0);
    } else jt && jt instanceof pe && (rr = jt);
    Fe !== ve.ADVANCED || rr || (rr = ot), (yi = ke.charSpace || la) !== void 0 && (br += $e(he(yi)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (Zt = ke.horizontalScale) !== void 0 && (br += $e(100 * Zt) + ` Tz
`), ke.lang;
    var $r = -1, co = ke.renderingMode !== void 0 ? ke.renderingMode : ke.stroke, Rs = Si.internal.getCurrentPageInfo().pageContext;
    switch (co) {
      case 0:
      case !1:
      case "fill":
        $r = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        $r = 1;
        break;
      case 2:
      case "fillThenStroke":
        $r = 2;
        break;
      case 3:
      case "invisible":
        $r = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        $r = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        $r = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        $r = 6;
        break;
      case 7:
      case "addToPathForClipping":
        $r = 7;
    }
    var za = Rs.usedRenderingMode !== void 0 ? Rs.usedRenderingMode : -1;
    $r !== -1 ? br += $r + ` Tr
` : za !== -1 && (br += `0 Tr
`), $r !== -1 && (Rs.usedRenderingMode = $r), oi = ke.align || "left";
    var Sn, ts = _t * hn, is = Si.internal.pageSize.getWidth(), al = Bt[ui];
    yi = ke.charSpace || la, Yt = ke.maxWidth || 0, Di = Object.assign({ autoencode: !0, noBOM: !0 }, ke.flags);
    var rs = [];
    if (Object.prototype.toString.call(L) === "[object Array]") {
      var _i;
      yt = ua(L), oi !== "left" && (Sn = yt.map(function(Zi) {
        return Si.getStringUnitWidth(Zi, { font: al, charSpace: yi, fontSize: _t, doKerning: !1 }) * _t / Ns;
      }));
      var Qr, ns = 0;
      if (oi === "right") {
        X -= Sn[0], L = [], Hi = yt.length;
        for (var un = 0; un < Hi; un++) un === 0 ? (Qr = Fs(X), _i = Kn(_e)) : (Qr = he(ns - Sn[un]), _i = -ts), L.push([yt[un], Qr, _i]), ns = Sn[un];
      } else if (oi === "center") {
        X -= Sn[0] / 2, L = [], Hi = yt.length;
        for (var dn = 0; dn < Hi; dn++) dn === 0 ? (Qr = Fs(X), _i = Kn(_e)) : (Qr = he((ns - Sn[dn]) / 2), _i = -ts), L.push([yt[dn], Qr, _i]), ns = Sn[dn];
      } else if (oi === "left") {
        L = [], Hi = yt.length;
        for (var ma = 0; ma < Hi; ma++) L.push(yt[ma]);
      } else {
        if (oi !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        L = [], Hi = yt.length, Yt = Yt !== 0 ? Yt : is;
        for (var Nn = 0; Nn < Hi; Nn++) _i = Nn === 0 ? Kn(_e) : -ts, Qr = Nn === 0 ? Fs(X) : 0, Nn < Hi - 1 ? rs.push($e(he((Yt - Sn[Nn]) / (yt[Nn].split(" ").length - 1)))) : rs.push(0), L.push([yt[Nn], Qr, _i]);
      }
    }
    var ga = typeof ke.R2L == "boolean" ? ke.R2L : ei;
    ga === !0 && (L = da(L, function(Zi, Ji, Ki) {
      return [Zi.split("").reverse().join(""), Ji, Ki];
    })), tt = { text: L, x: X, y: _e, options: ke, mutex: { pdfEscape: Dr, activeFontKey: ui, fonts: Bt, activeFontSize: _t } }, J.publish("postProcessText", tt), L = tt.text, Dn = tt.mutex.isHex || !1;
    var ya = Bt[ui].encoding;
    ya !== "WinAnsiEncoding" && ya !== "StandardEncoding" || (L = da(L, function(Zi, Ji, Ki) {
      return [Bo(Zi), Ji, Ki];
    })), yt = ua(L), L = [];
    for (var ys, pn, Rn, Bs = 0, _a = 1, ss = Array.isArray(yt[0]) ? _a : Bs, fn = "", Pr = function(Zi, Ji, Ki) {
      var pr = "";
      return Ki instanceof pe ? (Ki = typeof ke.angle == "number" ? Oe(Ki, new pe(1, 0, 0, 1, Zi, Ji)) : Oe(new pe(1, 0, 0, 1, Zi, Ji), Ki), Fe === ve.ADVANCED && (Ki = Oe(new pe(1, 0, 0, -1, 0, 0), Ki)), pr = Ki.join(" ") + ` Tm
`) : pr = $e(Zi) + " " + $e(Ji) + ` Td
`, pr;
    }, Or = 0; Or < yt.length; Or++) {
      switch (fn = "", ss) {
        case _a:
          Rn = (Dn ? "<" : "(") + yt[Or][0] + (Dn ? ">" : ")"), ys = parseFloat(yt[Or][1]), pn = parseFloat(yt[Or][2]);
          break;
        case Bs:
          Rn = (Dn ? "<" : "(") + yt[Or] + (Dn ? ">" : ")"), ys = Fs(X), pn = Kn(_e);
      }
      rs !== void 0 && rs[Or] !== void 0 && (fn = rs[Or] + ` Tw
`), Or === 0 ? L.push(fn + Pr(ys, pn, rr) + Rn) : ss === Bs ? L.push(fn + Rn) : ss === _a && L.push(fn + Pr(ys, pn, rr) + Rn);
    }
    L = ss === Bs ? L.join(` Tj
T* `) : L.join(` Tj
`), L += ` Tj
`;
    var _s = `BT
/`;
    return _s += ui + " " + _t + ` Tf
`, _s += $e(_t * hn) + ` TL
`, _s += Ca + `
`, _s += br, _s += L, te(_s += "ET"), U[ui] = !0, Si;
  };
  var Qa = B.__private__.clip = B.clip = function(L) {
    return te(L === "evenodd" ? "W*" : "W"), this;
  };
  B.clipEvenOdd = function() {
    return Qa("evenodd");
  }, B.__private__.discardPath = B.discardPath = function() {
    return te("n"), this;
  };
  var En = B.__private__.isValidStyle = function(L) {
    var X = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(L) !== -1 && (X = !0), X;
  };
  B.__private__.setDefaultPathOperation = B.setDefaultPathOperation = function(L) {
    return En(L) && (j = L), this;
  };
  var eo = B.__private__.getStyle = B.getStyle = function(L) {
    var X = j;
    switch (L) {
      case "D":
      case "S":
        X = "S";
        break;
      case "F":
        X = "f";
        break;
      case "FD":
      case "DF":
        X = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        X = L;
    }
    return X;
  }, Ms = B.close = function() {
    return te("h"), this;
  };
  B.stroke = function() {
    return te("S"), this;
  }, B.fill = function(L) {
    return to("f", L), this;
  }, B.fillEvenOdd = function(L) {
    return to("f*", L), this;
  }, B.fillStroke = function(L) {
    return to("B", L), this;
  }, B.fillStrokeEvenOdd = function(L) {
    return to("B*", L), this;
  };
  var to = function(L, X) {
    or(X) === "object" ? kl(X, L) : te(L);
  }, io = function(L) {
    L === null || Fe === ve.ADVANCED && L === void 0 || (L = eo(L), te(L));
  };
  function tl(L, X, _e, ke, je) {
    var tt = new Pc(X || this.boundingBox, _e || this.xStep, ke || this.yStep, this.gState, je || this.matrix);
    tt.stream = this.stream;
    var yt = L + "$$" + this.cloneIndex++ + "$$";
    return Je(yt, tt), tt;
  }
  var kl = function(L, X) {
    var _e = nn[L.key], ke = Ft[_e];
    if (ke instanceof Kl) te("q"), te(Ll(X)), ke.gState && B.setGState(ke.gState), te(L.matrix.toString() + " cm"), te("/" + _e + " sh"), te("Q");
    else if (ke instanceof Pc) {
      var je = new pe(1, 0, 0, -1, 0, ha());
      L.matrix && (je = je.multiply(L.matrix || ot), _e = tl.call(ke, L.key, L.boundingBox, L.xStep, L.yStep, je).id), te("q"), te("/Pattern cs"), te("/" + _e + " scn"), ke.gState && B.setGState(ke.gState), te(X), te("Q");
    }
  }, Ll = function(L) {
    switch (L) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, zo = B.moveTo = function(L, X) {
    return te($e(he(L)) + " " + $e(Se(X)) + " m"), this;
  }, ps = B.lineTo = function(L, X) {
    return te($e(he(L)) + " " + $e(Se(X)) + " l"), this;
  }, fs = B.curveTo = function(L, X, _e, ke, je, tt) {
    return te([$e(he(L)), $e(Se(X)), $e(he(_e)), $e(Se(ke)), $e(he(je)), $e(Se(tt)), "c"].join(" ")), this;
  };
  B.__private__.line = B.line = function(L, X, _e, ke, je) {
    if (isNaN(L) || isNaN(X) || isNaN(_e) || isNaN(ke) || !En(je)) throw new Error("Invalid arguments passed to jsPDF.line");
    return Fe === ve.COMPAT ? this.lines([[_e - L, ke - X]], L, X, [1, 1], je || "S") : this.lines([[_e - L, ke - X]], L, X, [1, 1]).stroke();
  }, B.__private__.lines = B.lines = function(L, X, _e, ke, je, tt) {
    var yt, jt, oi, yi, Yt, Di, Zt, rr, Si, Ai, br, Dn;
    if (typeof L == "number" && (Dn = _e, _e = X, X = L, L = Dn), ke = ke || [1, 1], tt = tt || !1, isNaN(X) || isNaN(_e) || !Array.isArray(L) || !Array.isArray(ke) || !En(je) || typeof tt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (zo(X, _e), yt = ke[0], jt = ke[1], yi = L.length, Ai = X, br = _e, oi = 0; oi < yi; oi++) (Yt = L[oi]).length === 2 ? (Ai = Yt[0] * yt + Ai, br = Yt[1] * jt + br, ps(Ai, br)) : (Di = Yt[0] * yt + Ai, Zt = Yt[1] * jt + br, rr = Yt[2] * yt + Ai, Si = Yt[3] * jt + br, Ai = Yt[4] * yt + Ai, br = Yt[5] * jt + br, fs(Di, Zt, rr, Si, Ai, br));
    return tt && Ms(), io(je), this;
  }, B.path = function(L) {
    for (var X = 0; X < L.length; X++) {
      var _e = L[X], ke = _e.c;
      switch (_e.op) {
        case "m":
          zo(ke[0], ke[1]);
          break;
        case "l":
          ps(ke[0], ke[1]);
          break;
        case "c":
          fs.apply(this, ke);
          break;
        case "h":
          Ms();
      }
    }
    return this;
  }, B.__private__.rect = B.rect = function(L, X, _e, ke, je) {
    if (isNaN(L) || isNaN(X) || isNaN(_e) || isNaN(ke) || !En(je)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return Fe === ve.COMPAT && (ke = -ke), te([$e(he(L)), $e(Se(X)), $e(he(_e)), $e(he(ke)), "re"].join(" ")), io(je), this;
  }, B.__private__.triangle = B.triangle = function(L, X, _e, ke, je, tt, yt) {
    if (isNaN(L) || isNaN(X) || isNaN(_e) || isNaN(ke) || isNaN(je) || isNaN(tt) || !En(yt)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[_e - L, ke - X], [je - _e, tt - ke], [L - je, X - tt]], L, X, [1, 1], yt, !0), this;
  }, B.__private__.roundedRect = B.roundedRect = function(L, X, _e, ke, je, tt, yt) {
    if (isNaN(L) || isNaN(X) || isNaN(_e) || isNaN(ke) || isNaN(je) || isNaN(tt) || !En(yt)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var jt = 4 / 3 * (Math.SQRT2 - 1);
    return je = Math.min(je, 0.5 * _e), tt = Math.min(tt, 0.5 * ke), this.lines([[_e - 2 * je, 0], [je * jt, 0, je, tt - tt * jt, je, tt], [0, ke - 2 * tt], [0, tt * jt, -je * jt, tt, -je, tt], [2 * je - _e, 0], [-je * jt, 0, -je, -tt * jt, -je, -tt], [0, 2 * tt - ke], [0, -tt * jt, je * jt, -tt, je, -tt]], L + je, X, [1, 1], yt, !0), this;
  }, B.__private__.ellipse = B.ellipse = function(L, X, _e, ke, je) {
    if (isNaN(L) || isNaN(X) || isNaN(_e) || isNaN(ke) || !En(je)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var tt = 4 / 3 * (Math.SQRT2 - 1) * _e, yt = 4 / 3 * (Math.SQRT2 - 1) * ke;
    return zo(L + _e, X), fs(L + _e, X - yt, L + tt, X - ke, L, X - ke), fs(L - tt, X - ke, L - _e, X - yt, L - _e, X), fs(L - _e, X + yt, L - tt, X + ke, L, X + ke), fs(L + tt, X + ke, L + _e, X + yt, L + _e, X), io(je), this;
  }, B.__private__.circle = B.circle = function(L, X, _e, ke) {
    if (isNaN(L) || isNaN(X) || isNaN(_e) || !En(ke)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(L, X, _e, _e, ke);
  }, B.setFont = function(L, X, _e) {
    return _e && (X = gt(X, _e)), ui = ra(L, X, { disableWarning: !1 }), this;
  };
  var ro = B.__private__.getFont = B.getFont = function() {
    return Bt[ra.apply(B, arguments)];
  };
  B.__private__.getFontList = B.getFontList = function() {
    var L, X, _e = {};
    for (L in ki) if (ki.hasOwnProperty(L)) for (X in _e[L] = [], ki[L]) ki[L].hasOwnProperty(X) && _e[L].push(X);
    return _e;
  }, B.addFont = function(L, X, _e, ke, je) {
    var tt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && tt.indexOf(arguments[3]) !== -1 ? je = arguments[3] : arguments[3] && tt.indexOf(arguments[3]) == -1 && (_e = gt(_e, ke)), je = je || "Identity-H", an.call(this, L, X, _e, je);
  };
  var Ds, zs = w.lineWidth || 0.200025, Br = B.__private__.getLineWidth = B.getLineWidth = function() {
    return zs;
  }, zi = B.__private__.setLineWidth = B.setLineWidth = function(L) {
    return zs = L, te($e(he(L)) + " w"), this;
  };
  B.__private__.setLineDash = vi.API.setLineDash = vi.API.setLineDashPattern = function(L, X) {
    if (L = L || [], X = X || 0, isNaN(X) || !Array.isArray(L)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return L = L.map(function(_e) {
      return $e(he(_e));
    }).join(" "), X = $e(he(X)), te("[" + L + "] " + X + " d"), this;
  };
  var no = B.__private__.getLineHeight = B.getLineHeight = function() {
    return _t * Ds;
  };
  B.__private__.getLineHeight = B.getLineHeight = function() {
    return _t * Ds;
  };
  var aa = B.__private__.setLineHeightFactor = B.setLineHeightFactor = function(L) {
    return typeof (L = L || 1.15) == "number" && (Ds = L), this;
  }, oa = B.__private__.getLineHeightFactor = B.getLineHeightFactor = function() {
    return Ds;
  };
  aa(w.lineHeight);
  var Fs = B.__private__.getHorizontalCoordinate = function(L) {
    return he(L);
  }, Kn = B.__private__.getVerticalCoordinate = function(L) {
    return Fe === ve.ADVANCED ? L : W[ge].mediaBox.topRightY - W[ge].mediaBox.bottomLeftY - he(L);
  }, Cl = B.__private__.getHorizontalCoordinateString = B.getHorizontalCoordinateString = function(L) {
    return $e(Fs(L));
  }, wn = B.__private__.getVerticalCoordinateString = B.getVerticalCoordinateString = function(L) {
    return $e(Kn(L));
  }, Qn = w.strokeColor || "0 G";
  B.__private__.getStrokeColor = B.getDrawColor = function() {
    return Ii(Qn);
  }, B.__private__.setStrokeColor = B.setDrawColor = function(L, X, _e, ke) {
    return Qn = Ei({ ch1: L, ch2: X, ch3: _e, ch4: ke, pdfColorType: "draw", precision: 2 }), te(Qn), this;
  };
  var so = w.fillColor || "0 g";
  B.__private__.getFillColor = B.getFillColor = function() {
    return Ii(so);
  }, B.__private__.setFillColor = B.setFillColor = function(L, X, _e, ke) {
    return so = Ei({ ch1: L, ch2: X, ch3: _e, ch4: ke, pdfColorType: "fill", precision: 2 }), te(so), this;
  };
  var Ca = w.textColor || "0 g", il = B.__private__.getTextColor = B.getTextColor = function() {
    return Ii(Ca);
  };
  B.__private__.setTextColor = B.setTextColor = function(L, X, _e, ke) {
    return Ca = Ei({ ch1: L, ch2: X, ch3: _e, ch4: ke, pdfColorType: "text", precision: 3 }), this;
  };
  var la = w.charSpace, rl = B.__private__.getCharSpace = B.getCharSpace = function() {
    return parseFloat(la || 0);
  };
  B.__private__.setCharSpace = B.setCharSpace = function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return la = L, this;
  };
  var ao = 0;
  B.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, B.__private__.setLineCap = B.setLineCap = function(L) {
    var X = B.CapJoinStyles[L];
    if (X === void 0) throw new Error("Line cap style of '" + L + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return ao = X, te(X + " J"), this;
  };
  var oo = 0;
  B.__private__.setLineJoin = B.setLineJoin = function(L) {
    var X = B.CapJoinStyles[L];
    if (X === void 0) throw new Error("Line join style of '" + L + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return oo = X, te(X + " j"), this;
  }, B.__private__.setLineMiterLimit = B.__private__.setMiterLimit = B.setLineMiterLimit = B.setMiterLimit = function(L) {
    if (L = L || 0, isNaN(L)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return te($e(he(L)) + " M"), this;
  }, B.GState = qh, B.setGState = function(L) {
    (L = typeof L == "string" ? Oi[$i[L]] : Fo(null, L)).equals(de) || (te("/" + L.id + " gs"), de = L);
  };
  var Fo = function(L, X) {
    if (!L || !$i[L]) {
      var _e = !1;
      for (var ke in Oi) if (Oi.hasOwnProperty(ke) && Oi[ke].equals(X)) {
        _e = !0;
        break;
      }
      if (_e) X = Oi[ke];
      else {
        var je = "GS" + (Object.keys(Oi).length + 1).toString(10);
        Oi[je] = X, X.id = je;
      }
      return L && ($i[L] = X.id), J.publish("addGState", X), X;
    }
  };
  B.addGState = function(L, X) {
    return Fo(L, X), this;
  }, B.saveGraphicsState = function() {
    return te("q"), lr.push({ key: ui, size: _t, color: Ca }), this;
  }, B.restoreGraphicsState = function() {
    te("Q");
    var L = lr.pop();
    return ui = L.key, _t = L.size, Ca = L.color, de = null, this;
  }, B.setCurrentTransformationMatrix = function(L) {
    return te(L.toString() + " cm"), this;
  }, B.comment = function(L) {
    return te("#" + L), this;
  };
  var Mn = function(L, X) {
    var _e = L || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return _e;
    }, set: function(tt) {
      isNaN(tt) || (_e = parseFloat(tt));
    } });
    var ke = X || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return ke;
    }, set: function(tt) {
      isNaN(tt) || (ke = parseFloat(tt));
    } });
    var je = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return je;
    }, set: function(tt) {
      je = tt.toString();
    } }), this;
  }, lo = function(L, X, _e, ke) {
    Mn.call(this, L, X), this.type = "rect";
    var je = _e || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return je;
    }, set: function(yt) {
      isNaN(yt) || (je = parseFloat(yt));
    } });
    var tt = ke || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return tt;
    }, set: function(yt) {
      isNaN(yt) || (tt = parseFloat(yt));
    } }), this;
  }, No = function() {
    this.page = Z, this.currentPage = ge, this.pages = xt.slice(0), this.pagesContext = W.slice(0), this.x = gr, this.y = lt, this.matrix = li, this.width = Ea(ge), this.height = ha(ge), this.outputDestination = zt, this.id = "", this.objectNumber = -1;
  };
  No.prototype.restore = function() {
    Z = this.page, ge = this.currentPage, W = this.pagesContext, xt = this.pages, gr = this.x, lt = this.y, li = this.matrix, ca(ge, this.width), Ro(ge, this.height), zt = this.outputDestination;
  };
  var nl = function(L, X, _e, ke, je) {
    Me.push(new No()), Z = ge = 0, xt = [], gr = L, lt = X, li = je, Mi([_e, ke]);
  }, sl = function(L) {
    if (Ce[L]) Me.pop().restore();
    else {
      var X = new No(), _e = "Xo" + (Object.keys(Ae).length + 1).toString(10);
      X.id = _e, Ce[L] = _e, Ae[_e] = X, J.publish("addFormObject", X), Me.pop().restore();
    }
  };
  for (var ms in B.beginFormObject = function(L, X, _e, ke, je) {
    return nl(L, X, _e, ke, je), this;
  }, B.endFormObject = function(L) {
    return sl(L), this;
  }, B.doFormObject = function(L, X) {
    var _e = Ae[Ce[L]];
    return te("q"), te(X.toString() + " cm"), te("/" + _e.id + " Do"), te("Q"), this;
  }, B.getFormObject = function(L) {
    var X = Ae[Ce[L]];
    return { x: X.x, y: X.y, width: X.width, height: X.height, matrix: X.matrix };
  }, B.save = function(L, X) {
    return L = L || "generated.pdf", (X = X || {}).returnPromise = X.returnPromise || !1, X.returnPromise === !1 ? (Jl(Ja(Es()), L), typeof Jl.unload == "function" && xi.setTimeout && setTimeout(Jl.unload, 911), this) : new Promise(function(_e, ke) {
      try {
        var je = Jl(Ja(Es()), L);
        typeof Jl.unload == "function" && xi.setTimeout && setTimeout(Jl.unload, 911), _e(je);
      } catch (tt) {
        ke(tt.message);
      }
    });
  }, vi.API) vi.API.hasOwnProperty(ms) && (ms === "events" && vi.API.events.length ? function(L, X) {
    var _e, ke, je;
    for (je = X.length - 1; je !== -1; je--) _e = X[je][0], ke = X[je][1], L.subscribe.apply(L, [_e].concat(typeof ke == "function" ? [ke] : ke));
  }(J, vi.API.events) : B[ms] = vi.API[ms]);
  var Ea = B.getPageWidth = function(L) {
    return (W[L = L || ge].mediaBox.topRightX - W[L].mediaBox.bottomLeftX) / Dt;
  }, ca = B.setPageWidth = function(L, X) {
    W[L].mediaBox.topRightX = X * Dt + W[L].mediaBox.bottomLeftX;
  }, ha = B.getPageHeight = function(L) {
    return (W[L = L || ge].mediaBox.topRightY - W[L].mediaBox.bottomLeftY) / Dt;
  }, Ro = B.setPageHeight = function(L, X) {
    W[L].mediaBox.topRightY = X * Dt + W[L].mediaBox.bottomLeftY;
  };
  return B.internal = { pdfEscape: Dr, getStyle: eo, getFont: ro, getFontSize: Ct, getCharSpace: rl, getTextColor: il, getLineHeight: no, getLineHeightFactor: oa, getLineWidth: Br, write: hi, getHorizontalCoordinate: Fs, getVerticalCoordinate: Kn, getCoordinateString: Cl, getVerticalCoordinateString: wn, collections: {}, newObject: Ge, newAdditionalObject: gi, newObjectDeferred: It, newObjectDeferredBegin: Nt, getFilters: Ui, putStream: ai, events: J, scaleFactor: Dt, pageSize: { getWidth: function() {
    return Ea(ge);
  }, setWidth: function(L) {
    ca(ge, L);
  }, getHeight: function() {
    return ha(ge);
  }, setHeight: function(L) {
    Ro(ge, L);
  } }, encryptionOptions: V, encryption: _r, getEncryptor: Ka, output: sa, getNumberOfPages: Xa, pages: xt, out: te, f2: at, f3: ae, getPageInfo: Rr, getPageInfoByObjId: ri, getCurrentPageInfo: Do, getPDFVersion: oe, Point: Mn, Rectangle: lo, Matrix: pe, hasHotfix: Mo }, Object.defineProperty(B.internal.pageSize, "width", { get: function() {
    return Ea(ge);
  }, set: function(L) {
    ca(ge, L);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(B.internal.pageSize, "height", { get: function() {
    return ha(ge);
  }, set: function(L) {
    Ro(ge, L);
  }, enumerable: !0, configurable: !0 }), Ga.call(B, ut), ui = "F1", Ta(I, _), J.publish("initialized"), B;
}
Sc.prototype.lsbFirstWord = function(w) {
  return String.fromCharCode(w >> 0 & 255, w >> 8 & 255, w >> 16 & 255, w >> 24 & 255);
}, Sc.prototype.toHexString = function(w) {
  return w.split("").map(function(g) {
    return ("0" + (255 & g.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, Sc.prototype.hexToBytes = function(w) {
  for (var g = [], _ = 0; _ < w.length; _ += 2) g.push(String.fromCharCode(parseInt(w.substr(_, 2), 16)));
  return g.join("");
}, Sc.prototype.processOwnerPassword = function(w, g) {
  return Hu(Gu(g).substr(0, 5), w);
}, Sc.prototype.encryptor = function(w, g) {
  var _ = Gu(this.encryptionKey + String.fromCharCode(255 & w, w >> 8 & 255, w >> 16 & 255, 255 & g, g >> 8 & 255)).substr(0, 10);
  return function(x) {
    return Hu(_, x);
  };
}, qh.prototype.equals = function(w) {
  var g, _ = "id,objectNumber,equals";
  if (!w || or(w) !== or(this)) return !1;
  var x = 0;
  for (g in this) if (!(_.indexOf(g) >= 0)) {
    if (this.hasOwnProperty(g) && !w.hasOwnProperty(g) || this[g] !== w[g]) return !1;
    x++;
  }
  for (g in w) w.hasOwnProperty(g) && _.indexOf(g) < 0 && x--;
  return x === 0;
}, vi.API = { events: [] }, vi.version = "2.5.1";
var Vr = vi.API, Qu = 1, ic = function(w) {
  return w.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, bc = function(w) {
  return w.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Pi = function(w) {
  return w.toFixed(2);
}, Al = function(w) {
  return w.toFixed(5);
};
Vr.__acroform__ = {};
var Ls = function(w, g) {
  w.prototype = Object.create(g.prototype), w.prototype.constructor = w;
}, zp = function(w) {
  return w * Qu;
}, Io = function(w) {
  var g = new of(), _ = Qt.internal.getHeight(w) || 0, x = Qt.internal.getWidth(w) || 0;
  return g.BBox = [0, 0, Number(Pi(x)), Number(Pi(_))], g;
}, $g = Vr.__acroform__.setBit = function(w, g) {
  if (w = w || 0, g = g || 0, isNaN(w) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return w |= 1 << g;
}, Zg = Vr.__acroform__.clearBit = function(w, g) {
  if (w = w || 0, g = g || 0, isNaN(w) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return w &= ~(1 << g);
}, Wg = Vr.__acroform__.getBit = function(w, g) {
  if (isNaN(w) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return w & 1 << g ? 1 : 0;
}, Gr = Vr.__acroform__.getBitForPdf = function(w, g) {
  if (isNaN(w) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return Wg(w, g - 1);
}, Hr = Vr.__acroform__.setBitForPdf = function(w, g) {
  if (isNaN(w) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return $g(w, g - 1);
}, Xr = Vr.__acroform__.clearBitForPdf = function(w, g) {
  if (isNaN(w) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Zg(w, g - 1);
}, Gg = Vr.__acroform__.calculateCoordinates = function(w, g) {
  var _ = g.internal.getHorizontalCoordinate, x = g.internal.getVerticalCoordinate, I = w[0], A = w[1], v = w[2], o = w[3], D = {};
  return D.lowerLeft_X = _(I) || 0, D.lowerLeft_Y = x(A + o) || 0, D.upperRight_X = _(I + v) || 0, D.upperRight_Y = x(A) || 0, [Number(Pi(D.lowerLeft_X)), Number(Pi(D.lowerLeft_Y)), Number(Pi(D.upperRight_X)), Number(Pi(D.upperRight_Y))];
}, Hg = function(w) {
  if (w.appearanceStreamContent) return w.appearanceStreamContent;
  if (w.V || w.DV) {
    var g = [], _ = w._V || w.DV, x = Xu(w, _), I = w.scope.internal.getFont(w.fontName, w.fontStyle).id;
    g.push("/Tx BMC"), g.push("q"), g.push("BT"), g.push(w.scope.__private__.encodeColorString(w.color)), g.push("/" + I + " " + Pi(x.fontSize) + " Tf"), g.push("1 0 0 1 0 0 Tm"), g.push(x.text), g.push("ET"), g.push("Q"), g.push("EMC");
    var A = Io(w);
    return A.scope = w.scope, A.stream = g.join(`
`), A;
  }
}, Xu = function(w, g) {
  var _ = w.fontSize === 0 ? w.maxFontSize : w.fontSize, x = { text: "", fontSize: "" }, I = (g = (g = g.substr(0, 1) == "(" ? g.substr(1) : g).substr(g.length - 1) == ")" ? g.substr(0, g.length - 1) : g).split(" ");
  I = w.multiline ? I.map(function(ae) {
    return ae.split(`
`);
  }) : I.map(function(ae) {
    return [ae];
  });
  var A = _, v = Qt.internal.getHeight(w) || 0;
  v = v < 0 ? -v : v;
  var o = Qt.internal.getWidth(w) || 0;
  o = o < 0 ? -o : o;
  var D = function(ae, he, Ie) {
    if (ae + 1 < I.length) {
      var Se = he + " " + I[ae + 1][0];
      return zh(Se, w, Ie).width <= o - 4;
    }
    return !1;
  };
  A++;
  e: for (; A > 0; ) {
    g = "", A--;
    var j, V, q = zh("3", w, A).height, U = w.multiline ? v - A : (v - q) / 2, B = U += 2, ye = 0, oe = 0, xe = 0;
    if (A <= 0) {
      g = `(...) Tj
`, g += "% Width of Text: " + zh(g, w, A = 12).width + ", FieldWidth:" + o + `
`;
      break;
    }
    for (var se = "", ve = 0, Fe = 0; Fe < I.length; Fe++) if (I.hasOwnProperty(Fe)) {
      var it = !1;
      if (I[Fe].length !== 1 && xe !== I[Fe].length - 1) {
        if ((q + 2) * (ve + 2) + 2 > v) continue e;
        se += I[Fe][xe], it = !0, oe = Fe, Fe--;
      } else {
        se = (se += I[Fe][xe] + " ").substr(se.length - 1) == " " ? se.substr(0, se.length - 1) : se;
        var Ke = parseInt(Fe), gt = D(Ke, se, A), $e = Fe >= I.length - 1;
        if (gt && !$e) {
          se += " ", xe = 0;
          continue;
        }
        if (gt || $e) {
          if ($e) oe = Ke;
          else if (w.multiline && (q + 2) * (ve + 2) + 2 > v) continue e;
        } else {
          if (!w.multiline || (q + 2) * (ve + 2) + 2 > v) continue e;
          oe = Ke;
        }
      }
      for (var Le = "", dt = ye; dt <= oe; dt++) {
        var at = I[dt];
        if (w.multiline) {
          if (dt === oe) {
            Le += at[xe] + " ", xe = (xe + 1) % at.length;
            continue;
          }
          if (dt === ye) {
            Le += at[at.length - 1] + " ";
            continue;
          }
        }
        Le += at[0] + " ";
      }
      switch (Le = Le.substr(Le.length - 1) == " " ? Le.substr(0, Le.length - 1) : Le, V = zh(Le, w, A).width, w.textAlign) {
        case "right":
          j = o - V - 2;
          break;
        case "center":
          j = (o - V) / 2;
          break;
        case "left":
        default:
          j = 2;
      }
      g += Pi(j) + " " + Pi(B) + ` Td
`, g += "(" + ic(Le) + `) Tj
`, g += -Pi(j) + ` 0 Td
`, B = -(A + 2), V = 0, ye = it ? oe : oe + 1, ve++, se = "";
    }
    break;
  }
  return x.text = g, x.fontSize = A, x;
}, zh = function(w, g, _) {
  var x = g.scope.internal.getFont(g.fontName, g.fontStyle), I = g.scope.getStringUnitWidth(w, { font: x, fontSize: parseFloat(_), charSpace: 0 }) * parseFloat(_);
  return { height: g.scope.getStringUnitWidth("3", { font: x, fontSize: parseFloat(_), charSpace: 0 }) * parseFloat(_) * 1.5, width: I };
}, Xg = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, Yg = function(w, g) {
  var _ = { type: "reference", object: w };
  g.internal.getPageInfo(w.page).pageContext.annotations.find(function(x) {
    return x.type === _.type && x.object === _.object;
  }) === void 0 && g.internal.getPageInfo(w.page).pageContext.annotations.push(_);
}, Jg = function(w, g) {
  for (var _ in w) if (w.hasOwnProperty(_)) {
    var x = _, I = w[_];
    g.internal.newObjectDeferredBegin(I.objId, !0), or(I) === "object" && typeof I.putStream == "function" && I.putStream(), delete w[x];
  }
}, Kg = function(w, g) {
  if (g.scope = w, w.internal !== void 0 && (w.internal.acroformPlugin === void 0 || w.internal.acroformPlugin.isInitialized === !1)) {
    if (Za.FieldNum = 0, w.internal.acroformPlugin = JSON.parse(JSON.stringify(Xg)), w.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    Qu = w.internal.scaleFactor, w.internal.acroformPlugin.acroFormDictionaryRoot = new lf(), w.internal.acroformPlugin.acroFormDictionaryRoot.scope = w, w.internal.acroformPlugin.acroFormDictionaryRoot._eventID = w.internal.events.subscribe("postPutResources", function() {
      (function(_) {
        _.internal.events.unsubscribe(_.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete _.internal.acroformPlugin.acroFormDictionaryRoot._eventID, _.internal.acroformPlugin.printedOut = !0;
      })(w);
    }), w.internal.events.subscribe("buildDocument", function() {
      (function(_) {
        _.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var x = _.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var I in x) if (x.hasOwnProperty(I)) {
          var A = x[I];
          A.objId = void 0, A.hasAnnotation && Yg(A, _);
        }
      })(w);
    }), w.internal.events.subscribe("putCatalog", function() {
      (function(_) {
        if (_.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        _.internal.write("/AcroForm " + _.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(w);
    }), w.internal.events.subscribe("postPutPages", function(_) {
      (function(x, I) {
        var A = !x;
        for (var v in x || (I.internal.newObjectDeferredBegin(I.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), I.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), x = x || I.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (x.hasOwnProperty(v)) {
          var o = x[v], D = [], j = o.Rect;
          if (o.Rect && (o.Rect = Gg(o.Rect, I)), I.internal.newObjectDeferredBegin(o.objId, !0), o.DA = Qt.createDefaultAppearanceStream(o), or(o) === "object" && typeof o.getKeyValueListForStream == "function" && (D = o.getKeyValueListForStream()), o.Rect = j, o.hasAppearanceStream && !o.appearanceStreamContent) {
            var V = Hg(o);
            D.push({ key: "AP", value: "<</N " + V + ">>" }), I.internal.acroformPlugin.xForms.push(V);
          }
          if (o.appearanceStreamContent) {
            var q = "";
            for (var U in o.appearanceStreamContent) if (o.appearanceStreamContent.hasOwnProperty(U)) {
              var B = o.appearanceStreamContent[U];
              if (q += "/" + U + " ", q += "<<", Object.keys(B).length >= 1 || Array.isArray(B)) {
                for (var v in B) if (B.hasOwnProperty(v)) {
                  var ye = B[v];
                  typeof ye == "function" && (ye = ye.call(I, o)), q += "/" + v + " " + ye + " ", I.internal.acroformPlugin.xForms.indexOf(ye) >= 0 || I.internal.acroformPlugin.xForms.push(ye);
                }
              } else typeof (ye = B) == "function" && (ye = ye.call(I, o)), q += "/" + v + " " + ye, I.internal.acroformPlugin.xForms.indexOf(ye) >= 0 || I.internal.acroformPlugin.xForms.push(ye);
              q += ">>";
            }
            D.push({ key: "AP", value: `<<
` + q + ">>" });
          }
          I.internal.putStream({ additionalKeyValues: D, objectId: o.objId }), I.internal.out("endobj");
        }
        A && Jg(I.internal.acroformPlugin.xForms, I);
      })(_, w);
    }), w.internal.acroformPlugin.isInitialized = !0;
  }
}, af = Vr.__acroform__.arrayToPdfArray = function(w, g, _) {
  var x = function(v) {
    return v;
  };
  if (Array.isArray(w)) {
    for (var I = "[", A = 0; A < w.length; A++) switch (A !== 0 && (I += " "), or(w[A])) {
      case "boolean":
      case "number":
      case "object":
        I += w[A].toString();
        break;
      case "string":
        w[A].substr(0, 1) !== "/" ? (g !== void 0 && _ && (x = _.internal.getEncryptor(g)), I += "(" + ic(x(w[A].toString())) + ")") : I += w[A].toString();
    }
    return I += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Bu = function(w, g, _) {
  var x = function(I) {
    return I;
  };
  return g !== void 0 && _ && (x = _.internal.getEncryptor(g)), (w = w || "").toString(), w = "(" + ic(x(w)) + ")";
}, To = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(w) {
    this._objId = w;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
To.prototype.toString = function() {
  return this.objId + " 0 R";
}, To.prototype.putStream = function() {
  var w = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: w, objectId: this.objId }), this.scope.internal.out("endobj");
}, To.prototype.getKeyValueListForStream = function() {
  var w = [], g = Object.getOwnPropertyNames(this).filter(function(A) {
    return A != "content" && A != "appearanceStreamContent" && A != "scope" && A != "objId" && A.substring(0, 1) != "_";
  });
  for (var _ in g) if (Object.getOwnPropertyDescriptor(this, g[_]).configurable === !1) {
    var x = g[_], I = this[x];
    I && (Array.isArray(I) ? w.push({ key: x, value: af(I, this.objId, this.scope) }) : I instanceof To ? (I.scope = this.scope, w.push({ key: x, value: I.objId + " 0 R" })) : typeof I != "function" && w.push({ key: x, value: I }));
  }
  return w;
};
var of = function() {
  To.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var w, g = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return g;
  }, set: function(_) {
    g = _;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(_) {
    w = _.trim();
  }, get: function() {
    return w || null;
  } });
};
Ls(of, To);
var lf = function() {
  To.call(this);
  var w, g = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return g.length > 0 ? g : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return g;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (w) {
      var _ = function(x) {
        return x;
      };
      return this.scope && (_ = this.scope.internal.getEncryptor(this.objId)), "(" + ic(_(w)) + ")";
    }
  }, set: function(_) {
    w = _;
  } });
};
Ls(lf, To);
var Za = function w() {
  To.call(this);
  var g = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return g;
  }, set: function(se) {
    if (isNaN(se)) throw new Error('Invalid value "' + se + '" for attribute F supplied.');
    g = se;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(g, 3);
  }, set: function(se) {
    se ? this.F = Hr(g, 3) : this.F = Xr(g, 3);
  } });
  var _ = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return _;
  }, set: function(se) {
    if (isNaN(se)) throw new Error('Invalid value "' + se + '" for attribute Ff supplied.');
    _ = se;
  } });
  var x = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (x.length !== 0) return x;
  }, set: function(se) {
    x = se !== void 0 ? se : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !x || isNaN(x[0]) ? 0 : x[0];
  }, set: function(se) {
    x[0] = se;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !x || isNaN(x[1]) ? 0 : x[1];
  }, set: function(se) {
    x[1] = se;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !x || isNaN(x[2]) ? 0 : x[2];
  }, set: function(se) {
    x[2] = se;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !x || isNaN(x[3]) ? 0 : x[3];
  }, set: function(se) {
    x[3] = se;
  } });
  var I = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return I;
  }, set: function(se) {
    switch (se) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        I = se;
        break;
      default:
        throw new Error('Invalid value "' + se + '" for attribute FT supplied.');
    }
  } });
  var A = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!A || A.length < 1) {
      if (this instanceof Uh) return;
      A = "FieldObject" + w.FieldNum++;
    }
    var se = function(ve) {
      return ve;
    };
    return this.scope && (se = this.scope.internal.getEncryptor(this.objId)), "(" + ic(se(A)) + ")";
  }, set: function(se) {
    A = se.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return A;
  }, set: function(se) {
    A = se;
  } });
  var v = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return v;
  }, set: function(se) {
    v = se;
  } });
  var o = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(se) {
    o = se;
  } });
  var D = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return D;
  }, set: function(se) {
    D = se;
  } });
  var j = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return j === void 0 ? 50 / Qu : j;
  }, set: function(se) {
    j = se;
  } });
  var V = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return V;
  }, set: function(se) {
    V = se;
  } });
  var q = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!q || this instanceof Uh || this instanceof ec)) return Bu(q, this.objId, this.scope);
  }, set: function(se) {
    se = se.toString(), q = se;
  } });
  var U = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (U) return this instanceof bn ? U : Bu(U, this.objId, this.scope);
  }, set: function(se) {
    se = se.toString(), U = this instanceof bn ? se : se.substr(0, 1) === "(" ? bc(se.substr(1, se.length - 2)) : bc(se);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof bn ? bc(U.substr(1, U.length - 1)) : U;
  }, set: function(se) {
    se = se.toString(), U = this instanceof bn ? "/" + se : se;
  } });
  var B = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (B) return B;
  }, set: function(se) {
    this.V = se;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (B) return this instanceof bn ? B : Bu(B, this.objId, this.scope);
  }, set: function(se) {
    se = se.toString(), B = this instanceof bn ? se : se.substr(0, 1) === "(" ? bc(se.substr(1, se.length - 2)) : bc(se);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof bn ? bc(B.substr(1, B.length - 1)) : B;
  }, set: function(se) {
    se = se.toString(), B = this instanceof bn ? "/" + se : se;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var ye, oe = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return oe;
  }, set: function(se) {
    se = !!se, oe = se;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (ye) return ye;
  }, set: function(se) {
    ye = se;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 1);
  }, set: function(se) {
    se ? this.Ff = Hr(this.Ff, 1) : this.Ff = Xr(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 2);
  }, set: function(se) {
    se ? this.Ff = Hr(this.Ff, 2) : this.Ff = Xr(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 3);
  }, set: function(se) {
    se ? this.Ff = Hr(this.Ff, 3) : this.Ff = Xr(this.Ff, 3);
  } });
  var xe = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (xe !== null) return xe;
  }, set: function(se) {
    if ([0, 1, 2].indexOf(se) === -1) throw new Error('Invalid value "' + se + '" for attribute Q supplied.');
    xe = se;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var se;
    switch (xe) {
      case 0:
      default:
        se = "left";
        break;
      case 1:
        se = "center";
        break;
      case 2:
        se = "right";
    }
    return se;
  }, configurable: !0, enumerable: !0, set: function(se) {
    switch (se) {
      case "right":
      case 2:
        xe = 2;
        break;
      case "center":
      case 1:
        xe = 1;
        break;
      case "left":
      case 0:
      default:
        xe = 0;
    }
  } });
};
Ls(Za, To);
var Ic = function() {
  Za.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var w = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return w;
  }, set: function(_) {
    w = _;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return w;
  }, set: function(_) {
    w = _;
  } });
  var g = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return af(g, this.objId, this.scope);
  }, set: function(_) {
    var x, I;
    I = [], typeof (x = _) == "string" && (I = function(A, v, o) {
      o || (o = 1);
      for (var D, j = []; D = v.exec(A); ) j.push(D[o]);
      return j;
    }(x, /\((.*?)\)/g)), g = I;
  } }), this.getOptions = function() {
    return g;
  }, this.setOptions = function(_) {
    g = _, this.sort && g.sort();
  }, this.addOption = function(_) {
    _ = (_ = _ || "").toString(), g.push(_), this.sort && g.sort();
  }, this.removeOption = function(_, x) {
    for (x = x || !1, _ = (_ = _ || "").toString(); g.indexOf(_) !== -1 && (g.splice(g.indexOf(_), 1), x !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 18);
  }, set: function(_) {
    _ ? this.Ff = Hr(this.Ff, 18) : this.Ff = Xr(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 19);
  }, set: function(_) {
    this.combo === !0 && (_ ? this.Ff = Hr(this.Ff, 19) : this.Ff = Xr(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 20);
  }, set: function(_) {
    _ ? (this.Ff = Hr(this.Ff, 20), g.sort()) : this.Ff = Xr(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 22);
  }, set: function(_) {
    _ ? this.Ff = Hr(this.Ff, 22) : this.Ff = Xr(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 23);
  }, set: function(_) {
    _ ? this.Ff = Hr(this.Ff, 23) : this.Ff = Xr(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 27);
  }, set: function(_) {
    _ ? this.Ff = Hr(this.Ff, 27) : this.Ff = Xr(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
Ls(Ic, Za);
var Tc = function() {
  Ic.call(this), this.fontName = "helvetica", this.combo = !1;
};
Ls(Tc, Ic);
var kc = function() {
  Tc.call(this), this.combo = !0;
};
Ls(kc, Tc);
var Rh = function() {
  kc.call(this), this.edit = !0;
};
Ls(Rh, kc);
var bn = function() {
  Za.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 15);
  }, set: function(_) {
    _ ? this.Ff = Hr(this.Ff, 15) : this.Ff = Xr(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 16);
  }, set: function(_) {
    _ ? this.Ff = Hr(this.Ff, 16) : this.Ff = Xr(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 17);
  }, set: function(_) {
    _ ? this.Ff = Hr(this.Ff, 17) : this.Ff = Xr(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 26);
  }, set: function(_) {
    _ ? this.Ff = Hr(this.Ff, 26) : this.Ff = Xr(this.Ff, 26);
  } });
  var w, g = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var _ = function(A) {
      return A;
    };
    if (this.scope && (_ = this.scope.internal.getEncryptor(this.objId)), Object.keys(g).length !== 0) {
      var x, I = [];
      for (x in I.push("<<"), g) I.push("/" + x + " (" + ic(_(g[x])) + ")");
      return I.push(">>"), I.join(`
`);
    }
  }, set: function(_) {
    or(_) === "object" && (g = _);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return g.CA || "";
  }, set: function(_) {
    typeof _ == "string" && (g.CA = _);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return w;
  }, set: function(_) {
    w = _;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return w.substr(1, w.length - 1);
  }, set: function(_) {
    w = "/" + _;
  } });
};
Ls(bn, Za);
var Bh = function() {
  bn.call(this), this.pushButton = !0;
};
Ls(Bh, bn);
var Lc = function() {
  bn.call(this), this.radio = !0, this.pushButton = !1;
  var w = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return w;
  }, set: function(g) {
    w = g !== void 0 ? g : [];
  } });
};
Ls(Lc, bn);
var Uh = function() {
  var w, g;
  Za.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return w;
  }, set: function(I) {
    w = I;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return g;
  }, set: function(I) {
    g = I;
  } });
  var _, x = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var I = function(o) {
      return o;
    };
    this.scope && (I = this.scope.internal.getEncryptor(this.objId));
    var A, v = [];
    for (A in v.push("<<"), x) v.push("/" + A + " (" + ic(I(x[A])) + ")");
    return v.push(">>"), v.join(`
`);
  }, set: function(I) {
    or(I) === "object" && (x = I);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return x.CA || "";
  }, set: function(I) {
    typeof I == "string" && (x.CA = I);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return _;
  }, set: function(I) {
    _ = I;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return _.substr(1, _.length - 1);
  }, set: function(I) {
    _ = "/" + I;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = Qt.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
Ls(Uh, Za), Lc.prototype.setAppearance = function(w) {
  if (!("createAppearanceStream" in w) || !("getCA" in w)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var g in this.Kids) if (this.Kids.hasOwnProperty(g)) {
    var _ = this.Kids[g];
    _.appearanceStreamContent = w.createAppearanceStream(_.optionName), _.caption = w.getCA();
  }
}, Lc.prototype.createOption = function(w) {
  var g = new Uh();
  return g.Parent = this, g.optionName = w, this.Kids.push(g), Qg.call(this.scope, g), g;
};
var Oh = function() {
  bn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = Qt.CheckBox.createAppearanceStream();
};
Ls(Oh, bn);
var ec = function() {
  Za.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 13);
  }, set: function(g) {
    g ? this.Ff = Hr(this.Ff, 13) : this.Ff = Xr(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 21);
  }, set: function(g) {
    g ? this.Ff = Hr(this.Ff, 21) : this.Ff = Xr(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 23);
  }, set: function(g) {
    g ? this.Ff = Hr(this.Ff, 23) : this.Ff = Xr(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 24);
  }, set: function(g) {
    g ? this.Ff = Hr(this.Ff, 24) : this.Ff = Xr(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 25);
  }, set: function(g) {
    g ? this.Ff = Hr(this.Ff, 25) : this.Ff = Xr(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 26);
  }, set: function(g) {
    g ? this.Ff = Hr(this.Ff, 26) : this.Ff = Xr(this.Ff, 26);
  } });
  var w = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return w;
  }, set: function(g) {
    w = g;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return w;
  }, set: function(g) {
    Number.isInteger(g) && (w = g);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
Ls(ec, Za);
var jh = function() {
  ec.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!Gr(this.Ff, 14);
  }, set: function(w) {
    w ? this.Ff = Hr(this.Ff, 14) : this.Ff = Xr(this.Ff, 14);
  } }), this.password = !0;
};
Ls(jh, ec);
var Qt = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: Qt.CheckBox.YesNormal }, D: { On: Qt.CheckBox.YesPushDown, Off: Qt.CheckBox.OffPushDown } };
}, YesPushDown: function(w) {
  var g = Io(w);
  g.scope = w.scope;
  var _ = [], x = w.scope.internal.getFont(w.fontName, w.fontStyle).id, I = w.scope.__private__.encodeColorString(w.color), A = Xu(w, w.caption);
  return _.push("0.749023 g"), _.push("0 0 " + Pi(Qt.internal.getWidth(w)) + " " + Pi(Qt.internal.getHeight(w)) + " re"), _.push("f"), _.push("BMC"), _.push("q"), _.push("0 0 1 rg"), _.push("/" + x + " " + Pi(A.fontSize) + " Tf " + I), _.push("BT"), _.push(A.text), _.push("ET"), _.push("Q"), _.push("EMC"), g.stream = _.join(`
`), g;
}, YesNormal: function(w) {
  var g = Io(w);
  g.scope = w.scope;
  var _ = w.scope.internal.getFont(w.fontName, w.fontStyle).id, x = w.scope.__private__.encodeColorString(w.color), I = [], A = Qt.internal.getHeight(w), v = Qt.internal.getWidth(w), o = Xu(w, w.caption);
  return I.push("1 g"), I.push("0 0 " + Pi(v) + " " + Pi(A) + " re"), I.push("f"), I.push("q"), I.push("0 0 1 rg"), I.push("0 0 " + Pi(v - 1) + " " + Pi(A - 1) + " re"), I.push("W"), I.push("n"), I.push("0 g"), I.push("BT"), I.push("/" + _ + " " + Pi(o.fontSize) + " Tf " + x), I.push(o.text), I.push("ET"), I.push("Q"), g.stream = I.join(`
`), g;
}, OffPushDown: function(w) {
  var g = Io(w);
  g.scope = w.scope;
  var _ = [];
  return _.push("0.749023 g"), _.push("0 0 " + Pi(Qt.internal.getWidth(w)) + " " + Pi(Qt.internal.getHeight(w)) + " re"), _.push("f"), g.stream = _.join(`
`), g;
} }, RadioButton: { Circle: { createAppearanceStream: function(w) {
  var g = { D: { Off: Qt.RadioButton.Circle.OffPushDown }, N: {} };
  return g.N[w] = Qt.RadioButton.Circle.YesNormal, g.D[w] = Qt.RadioButton.Circle.YesPushDown, g;
}, getCA: function() {
  return "l";
}, YesNormal: function(w) {
  var g = Io(w);
  g.scope = w.scope;
  var _ = [], x = Qt.internal.getWidth(w) <= Qt.internal.getHeight(w) ? Qt.internal.getWidth(w) / 4 : Qt.internal.getHeight(w) / 4;
  x = Number((0.9 * x).toFixed(5));
  var I = Qt.internal.Bezier_C, A = Number((x * I).toFixed(5));
  return _.push("q"), _.push("1 0 0 1 " + Al(Qt.internal.getWidth(w) / 2) + " " + Al(Qt.internal.getHeight(w) / 2) + " cm"), _.push(x + " 0 m"), _.push(x + " " + A + " " + A + " " + x + " 0 " + x + " c"), _.push("-" + A + " " + x + " -" + x + " " + A + " -" + x + " 0 c"), _.push("-" + x + " -" + A + " -" + A + " -" + x + " 0 -" + x + " c"), _.push(A + " -" + x + " " + x + " -" + A + " " + x + " 0 c"), _.push("f"), _.push("Q"), g.stream = _.join(`
`), g;
}, YesPushDown: function(w) {
  var g = Io(w);
  g.scope = w.scope;
  var _ = [], x = Qt.internal.getWidth(w) <= Qt.internal.getHeight(w) ? Qt.internal.getWidth(w) / 4 : Qt.internal.getHeight(w) / 4;
  x = Number((0.9 * x).toFixed(5));
  var I = Number((2 * x).toFixed(5)), A = Number((I * Qt.internal.Bezier_C).toFixed(5)), v = Number((x * Qt.internal.Bezier_C).toFixed(5));
  return _.push("0.749023 g"), _.push("q"), _.push("1 0 0 1 " + Al(Qt.internal.getWidth(w) / 2) + " " + Al(Qt.internal.getHeight(w) / 2) + " cm"), _.push(I + " 0 m"), _.push(I + " " + A + " " + A + " " + I + " 0 " + I + " c"), _.push("-" + A + " " + I + " -" + I + " " + A + " -" + I + " 0 c"), _.push("-" + I + " -" + A + " -" + A + " -" + I + " 0 -" + I + " c"), _.push(A + " -" + I + " " + I + " -" + A + " " + I + " 0 c"), _.push("f"), _.push("Q"), _.push("0 g"), _.push("q"), _.push("1 0 0 1 " + Al(Qt.internal.getWidth(w) / 2) + " " + Al(Qt.internal.getHeight(w) / 2) + " cm"), _.push(x + " 0 m"), _.push(x + " " + v + " " + v + " " + x + " 0 " + x + " c"), _.push("-" + v + " " + x + " -" + x + " " + v + " -" + x + " 0 c"), _.push("-" + x + " -" + v + " -" + v + " -" + x + " 0 -" + x + " c"), _.push(v + " -" + x + " " + x + " -" + v + " " + x + " 0 c"), _.push("f"), _.push("Q"), g.stream = _.join(`
`), g;
}, OffPushDown: function(w) {
  var g = Io(w);
  g.scope = w.scope;
  var _ = [], x = Qt.internal.getWidth(w) <= Qt.internal.getHeight(w) ? Qt.internal.getWidth(w) / 4 : Qt.internal.getHeight(w) / 4;
  x = Number((0.9 * x).toFixed(5));
  var I = Number((2 * x).toFixed(5)), A = Number((I * Qt.internal.Bezier_C).toFixed(5));
  return _.push("0.749023 g"), _.push("q"), _.push("1 0 0 1 " + Al(Qt.internal.getWidth(w) / 2) + " " + Al(Qt.internal.getHeight(w) / 2) + " cm"), _.push(I + " 0 m"), _.push(I + " " + A + " " + A + " " + I + " 0 " + I + " c"), _.push("-" + A + " " + I + " -" + I + " " + A + " -" + I + " 0 c"), _.push("-" + I + " -" + A + " -" + A + " -" + I + " 0 -" + I + " c"), _.push(A + " -" + I + " " + I + " -" + A + " " + I + " 0 c"), _.push("f"), _.push("Q"), g.stream = _.join(`
`), g;
} }, Cross: { createAppearanceStream: function(w) {
  var g = { D: { Off: Qt.RadioButton.Cross.OffPushDown }, N: {} };
  return g.N[w] = Qt.RadioButton.Cross.YesNormal, g.D[w] = Qt.RadioButton.Cross.YesPushDown, g;
}, getCA: function() {
  return "8";
}, YesNormal: function(w) {
  var g = Io(w);
  g.scope = w.scope;
  var _ = [], x = Qt.internal.calculateCross(w);
  return _.push("q"), _.push("1 1 " + Pi(Qt.internal.getWidth(w) - 2) + " " + Pi(Qt.internal.getHeight(w) - 2) + " re"), _.push("W"), _.push("n"), _.push(Pi(x.x1.x) + " " + Pi(x.x1.y) + " m"), _.push(Pi(x.x2.x) + " " + Pi(x.x2.y) + " l"), _.push(Pi(x.x4.x) + " " + Pi(x.x4.y) + " m"), _.push(Pi(x.x3.x) + " " + Pi(x.x3.y) + " l"), _.push("s"), _.push("Q"), g.stream = _.join(`
`), g;
}, YesPushDown: function(w) {
  var g = Io(w);
  g.scope = w.scope;
  var _ = Qt.internal.calculateCross(w), x = [];
  return x.push("0.749023 g"), x.push("0 0 " + Pi(Qt.internal.getWidth(w)) + " " + Pi(Qt.internal.getHeight(w)) + " re"), x.push("f"), x.push("q"), x.push("1 1 " + Pi(Qt.internal.getWidth(w) - 2) + " " + Pi(Qt.internal.getHeight(w) - 2) + " re"), x.push("W"), x.push("n"), x.push(Pi(_.x1.x) + " " + Pi(_.x1.y) + " m"), x.push(Pi(_.x2.x) + " " + Pi(_.x2.y) + " l"), x.push(Pi(_.x4.x) + " " + Pi(_.x4.y) + " m"), x.push(Pi(_.x3.x) + " " + Pi(_.x3.y) + " l"), x.push("s"), x.push("Q"), g.stream = x.join(`
`), g;
}, OffPushDown: function(w) {
  var g = Io(w);
  g.scope = w.scope;
  var _ = [];
  return _.push("0.749023 g"), _.push("0 0 " + Pi(Qt.internal.getWidth(w)) + " " + Pi(Qt.internal.getHeight(w)) + " re"), _.push("f"), g.stream = _.join(`
`), g;
} } }, createDefaultAppearanceStream: function(w) {
  var g = w.scope.internal.getFont(w.fontName, w.fontStyle).id, _ = w.scope.__private__.encodeColorString(w.color);
  return "/" + g + " " + w.fontSize + " Tf " + _;
} };
Qt.internal = { Bezier_C: 0.551915024494, calculateCross: function(w) {
  var g = Qt.internal.getWidth(w), _ = Qt.internal.getHeight(w), x = Math.min(g, _);
  return { x1: { x: (g - x) / 2, y: (_ - x) / 2 + x }, x2: { x: (g - x) / 2 + x, y: (_ - x) / 2 }, x3: { x: (g - x) / 2, y: (_ - x) / 2 }, x4: { x: (g - x) / 2 + x, y: (_ - x) / 2 + x } };
} }, Qt.internal.getWidth = function(w) {
  var g = 0;
  return or(w) === "object" && (g = zp(w.Rect[2])), g;
}, Qt.internal.getHeight = function(w) {
  var g = 0;
  return or(w) === "object" && (g = zp(w.Rect[3])), g;
};
var Qg = Vr.addField = function(w) {
  if (Kg(this, w), !(w instanceof Za)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var g;
  return (g = w).scope.internal.acroformPlugin.printedOut && (g.scope.internal.acroformPlugin.printedOut = !1, g.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), g.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(g), w.page = w.scope.internal.getCurrentPageInfo().pageNumber, this;
};
Vr.AcroFormChoiceField = Ic, Vr.AcroFormListBox = Tc, Vr.AcroFormComboBox = kc, Vr.AcroFormEditBox = Rh, Vr.AcroFormButton = bn, Vr.AcroFormPushButton = Bh, Vr.AcroFormRadioButton = Lc, Vr.AcroFormCheckBox = Oh, Vr.AcroFormTextField = ec, Vr.AcroFormPasswordField = jh, Vr.AcroFormAppearance = Qt, Vr.AcroForm = { ChoiceField: Ic, ListBox: Tc, ComboBox: kc, EditBox: Rh, Button: bn, PushButton: Bh, RadioButton: Lc, CheckBox: Oh, TextField: ec, PasswordField: jh, Appearance: Qt }, vi.AcroForm = { ChoiceField: Ic, ListBox: Tc, ComboBox: kc, EditBox: Rh, Button: bn, PushButton: Bh, RadioButton: Lc, CheckBox: Oh, TextField: ec, PasswordField: jh, Appearance: Qt };
function cf(w) {
  return w.reduce(function(g, _, x) {
    return g[_] = x, g;
  }, {});
}
(function(w) {
  w.__addimage__ = {};
  var g = "UNKNOWN", _ = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, x = w.__addimage__.getImageFileTypeByImageData = function(ae, he) {
    var Ie, Se, et, Qe, rt, Ze = g;
    if ((he = he || g) === "RGBA" || ae.data !== void 0 && ae.data instanceof Uint8ClampedArray && "height" in ae && "width" in ae) return "RGBA";
    if (gt(ae)) for (rt in _) for (et = _[rt], Ie = 0; Ie < et.length; Ie += 1) {
      for (Qe = !0, Se = 0; Se < et[Ie].length; Se += 1) if (et[Ie][Se] !== void 0 && et[Ie][Se] !== ae[Se]) {
        Qe = !1;
        break;
      }
      if (Qe === !0) {
        Ze = rt;
        break;
      }
    }
    else for (rt in _) for (et = _[rt], Ie = 0; Ie < et.length; Ie += 1) {
      for (Qe = !0, Se = 0; Se < et[Ie].length; Se += 1) if (et[Ie][Se] !== void 0 && et[Ie][Se] !== ae.charCodeAt(Se)) {
        Qe = !1;
        break;
      }
      if (Qe === !0) {
        Ze = rt;
        break;
      }
    }
    return Ze === g && he !== g && (Ze = he), Ze;
  }, I = function ae(he) {
    for (var Ie = this.internal.write, Se = this.internal.putStream, et = (0, this.internal.getFilters)(); et.indexOf("FlateEncode") !== -1; ) et.splice(et.indexOf("FlateEncode"), 1);
    he.objectId = this.internal.newObject();
    var Qe = [];
    if (Qe.push({ key: "Type", value: "/XObject" }), Qe.push({ key: "Subtype", value: "/Image" }), Qe.push({ key: "Width", value: he.width }), Qe.push({ key: "Height", value: he.height }), he.colorSpace === xe.INDEXED ? Qe.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (he.palette.length / 3 - 1) + " " + ("sMask" in he && he.sMask !== void 0 ? he.objectId + 2 : he.objectId + 1) + " 0 R]" }) : (Qe.push({ key: "ColorSpace", value: "/" + he.colorSpace }), he.colorSpace === xe.DEVICE_CMYK && Qe.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), Qe.push({ key: "BitsPerComponent", value: he.bitsPerComponent }), "decodeParameters" in he && he.decodeParameters !== void 0 && Qe.push({ key: "DecodeParms", value: "<<" + he.decodeParameters + ">>" }), "transparency" in he && Array.isArray(he.transparency)) {
      for (var rt = "", Ze = 0, ct = he.transparency.length; Ze < ct; Ze++) rt += he.transparency[Ze] + " " + he.transparency[Ze] + " ";
      Qe.push({ key: "Mask", value: "[" + rt + "]" });
    }
    he.sMask !== void 0 && Qe.push({ key: "SMask", value: he.objectId + 1 + " 0 R" });
    var nt = he.filter !== void 0 ? ["/" + he.filter] : void 0;
    if (Se({ data: he.data, additionalKeyValues: Qe, alreadyAppliedFilters: nt, objectId: he.objectId }), Ie("endobj"), "sMask" in he && he.sMask !== void 0) {
      var wt = "/Predictor " + he.predictor + " /Colors 1 /BitsPerComponent " + he.bitsPerComponent + " /Columns " + he.width, K = { width: he.width, height: he.height, colorSpace: "DeviceGray", bitsPerComponent: he.bitsPerComponent, decodeParameters: wt, data: he.sMask };
      "filter" in he && (K.filter = he.filter), ae.call(this, K);
    }
    if (he.colorSpace === xe.INDEXED) {
      var ge = this.internal.newObject();
      Se({ data: Le(new Uint8Array(he.palette)), objectId: ge }), Ie("endobj");
    }
  }, A = function() {
    var ae = this.internal.collections.addImage_images;
    for (var he in ae) I.call(this, ae[he]);
  }, v = function() {
    var ae, he = this.internal.collections.addImage_images, Ie = this.internal.write;
    for (var Se in he) Ie("/I" + (ae = he[Se]).index, ae.objectId, "0", "R");
  }, o = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", A), this.internal.events.subscribe("putXobjectDict", v));
  }, D = function() {
    var ae = this.internal.collections.addImage_images;
    return o.call(this), ae;
  }, j = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, V = function(ae) {
    return typeof w["process" + ae.toUpperCase()] == "function";
  }, q = function(ae) {
    return or(ae) === "object" && ae.nodeType === 1;
  }, U = function(ae, he) {
    if (ae.nodeName === "IMG" && ae.hasAttribute("src")) {
      var Ie = "" + ae.getAttribute("src");
      if (Ie.indexOf("data:image/") === 0) return eh(unescape(Ie).split("base64,").pop());
      var Se = w.loadFile(Ie, !0);
      if (Se !== void 0) return Se;
    }
    if (ae.nodeName === "CANVAS") {
      if (ae.width === 0 || ae.height === 0) throw new Error("Given canvas must have data. Canvas width: " + ae.width + ", height: " + ae.height);
      var et;
      switch (he) {
        case "PNG":
          et = "image/png";
          break;
        case "WEBP":
          et = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          et = "image/jpeg";
      }
      return eh(ae.toDataURL(et, 1).split("base64,").pop());
    }
  }, B = function(ae) {
    var he = this.internal.collections.addImage_images;
    if (he) {
      for (var Ie in he) if (ae === he[Ie].alias) return he[Ie];
    }
  }, ye = function(ae, he, Ie) {
    return ae || he || (ae = -96, he = -96), ae < 0 && (ae = -1 * Ie.width * 72 / ae / this.internal.scaleFactor), he < 0 && (he = -1 * Ie.height * 72 / he / this.internal.scaleFactor), ae === 0 && (ae = he * Ie.width / Ie.height), he === 0 && (he = ae * Ie.height / Ie.width), [ae, he];
  }, oe = function(ae, he, Ie, Se, et, Qe) {
    var rt = ye.call(this, Ie, Se, et), Ze = this.internal.getCoordinateString, ct = this.internal.getVerticalCoordinateString, nt = D.call(this);
    if (Ie = rt[0], Se = rt[1], nt[et.index] = et, Qe) {
      Qe *= Math.PI / 180;
      var wt = Math.cos(Qe), K = Math.sin(Qe), ge = function(Ee) {
        return Ee.toFixed(4);
      }, we = [ge(wt), ge(K), ge(-1 * K), ge(wt), 0, 0, "cm"];
    }
    this.internal.write("q"), Qe ? (this.internal.write([1, "0", "0", 1, Ze(ae), ct(he + Se), "cm"].join(" ")), this.internal.write(we.join(" ")), this.internal.write([Ze(Ie), "0", "0", Ze(Se), "0", "0", "cm"].join(" "))) : this.internal.write([Ze(Ie), "0", "0", Ze(Se), Ze(ae), ct(he + Se), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + et.index + " Do"), this.internal.write("Q");
  }, xe = w.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  w.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var se = w.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, ve = w.__addimage__.sHashCode = function(ae) {
    var he, Ie, Se = 0;
    if (typeof ae == "string") for (Ie = ae.length, he = 0; he < Ie; he++) Se = (Se << 5) - Se + ae.charCodeAt(he), Se |= 0;
    else if (gt(ae)) for (Ie = ae.byteLength / 2, he = 0; he < Ie; he++) Se = (Se << 5) - Se + ae[he], Se |= 0;
    return Se;
  }, Fe = w.__addimage__.validateStringAsBase64 = function(ae) {
    (ae = ae || "").toString().trim();
    var he = !0;
    return ae.length === 0 && (he = !1), ae.length % 4 != 0 && (he = !1), /^[A-Za-z0-9+/]+$/.test(ae.substr(0, ae.length - 2)) === !1 && (he = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(ae.substr(-2)) === !1 && (he = !1), he;
  }, it = w.__addimage__.extractImageFromDataUrl = function(ae) {
    var he = (ae = ae || "").split("base64,"), Ie = null;
    if (he.length === 2) {
      var Se = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(he[0]);
      Array.isArray(Se) && (Ie = { mimeType: Se[1], charset: Se[2], data: he[1] });
    }
    return Ie;
  }, Ke = w.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  w.__addimage__.isArrayBuffer = function(ae) {
    return Ke() && ae instanceof ArrayBuffer;
  };
  var gt = w.__addimage__.isArrayBufferView = function(ae) {
    return Ke() && typeof Uint32Array < "u" && (ae instanceof Int8Array || ae instanceof Uint8Array || typeof Uint8ClampedArray < "u" && ae instanceof Uint8ClampedArray || ae instanceof Int16Array || ae instanceof Uint16Array || ae instanceof Int32Array || ae instanceof Uint32Array || ae instanceof Float32Array || ae instanceof Float64Array);
  }, $e = w.__addimage__.binaryStringToUint8Array = function(ae) {
    for (var he = ae.length, Ie = new Uint8Array(he), Se = 0; Se < he; Se++) Ie[Se] = ae.charCodeAt(Se);
    return Ie;
  }, Le = w.__addimage__.arrayBufferToBinaryString = function(ae) {
    for (var he = "", Ie = gt(ae) ? ae : new Uint8Array(ae), Se = 0; Se < Ie.length; Se += 8192) he += String.fromCharCode.apply(null, Ie.subarray(Se, Se + 8192));
    return he;
  };
  w.addImage = function() {
    var ae, he, Ie, Se, et, Qe, rt, Ze, ct;
    if (typeof arguments[1] == "number" ? (he = g, Ie = arguments[1], Se = arguments[2], et = arguments[3], Qe = arguments[4], rt = arguments[5], Ze = arguments[6], ct = arguments[7]) : (he = arguments[1], Ie = arguments[2], Se = arguments[3], et = arguments[4], Qe = arguments[5], rt = arguments[6], Ze = arguments[7], ct = arguments[8]), or(ae = arguments[0]) === "object" && !q(ae) && "imageData" in ae) {
      var nt = ae;
      ae = nt.imageData, he = nt.format || he || g, Ie = nt.x || Ie || 0, Se = nt.y || Se || 0, et = nt.w || nt.width || et, Qe = nt.h || nt.height || Qe, rt = nt.alias || rt, Ze = nt.compression || Ze, ct = nt.rotation || nt.angle || ct;
    }
    var wt = this.internal.getFilters();
    if (Ze === void 0 && wt.indexOf("FlateEncode") !== -1 && (Ze = "SLOW"), isNaN(Ie) || isNaN(Se)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    o.call(this);
    var K = dt.call(this, ae, he, rt, Ze);
    return oe.call(this, Ie, Se, et, Qe, K, ct), this;
  };
  var dt = function(ae, he, Ie, Se) {
    var et, Qe, rt;
    if (typeof ae == "string" && x(ae) === g) {
      ae = unescape(ae);
      var Ze = at(ae, !1);
      (Ze !== "" || (Ze = w.loadFile(ae, !0)) !== void 0) && (ae = Ze);
    }
    if (q(ae) && (ae = U(ae, he)), he = x(ae, he), !V(he)) throw new Error("addImage does not support files of type '" + he + "', please ensure that a plugin for '" + he + "' support is added.");
    if (((rt = Ie) == null || rt.length === 0) && (Ie = function(ct) {
      return typeof ct == "string" || gt(ct) ? ve(ct) : gt(ct.data) ? ve(ct.data) : null;
    }(ae)), (et = B.call(this, Ie)) || (Ke() && (ae instanceof Uint8Array || he === "RGBA" || (Qe = ae, ae = $e(ae))), et = this["process" + he.toUpperCase()](ae, j.call(this), Ie, function(ct) {
      return ct && typeof ct == "string" && (ct = ct.toUpperCase()), ct in w.image_compression ? ct : se.NONE;
    }(Se), Qe)), !et) throw new Error("An unknown error occurred whilst processing the image.");
    return et;
  }, at = w.__addimage__.convertBase64ToBinaryString = function(ae, he) {
    var Ie;
    he = typeof he != "boolean" || he;
    var Se, et = "";
    if (typeof ae == "string") {
      Se = (Ie = it(ae)) !== null ? Ie.data : ae;
      try {
        et = eh(Se);
      } catch (Qe) {
        if (he) throw Fe(Se) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + Qe.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return et;
  };
  w.getImageProperties = function(ae) {
    var he, Ie, Se = "";
    if (q(ae) && (ae = U(ae)), typeof ae == "string" && x(ae) === g && ((Se = at(ae, !1)) === "" && (Se = w.loadFile(ae) || ""), ae = Se), Ie = x(ae), !V(Ie)) throw new Error("addImage does not support files of type '" + Ie + "', please ensure that a plugin for '" + Ie + "' support is added.");
    if (!Ke() || ae instanceof Uint8Array || (ae = $e(ae)), !(he = this["process" + Ie.toUpperCase()](ae))) throw new Error("An unknown error occurred whilst processing the image");
    return he.fileType = Ie, he;
  };
})(vi.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  var g = function(_) {
    if (_ !== void 0 && _ != "") return !0;
  };
  vi.API.events.push(["addPage", function(_) {
    this.internal.getPageInfo(_.pageNumber).pageContext.annotations = [];
  }]), w.events.push(["putPage", function(_) {
    for (var x, I, A, v = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, D = this.internal.getPageInfoByObjId(_.objId), j = _.pageContext.annotations, V = !1, q = 0; q < j.length && !V; q++) switch ((x = j[q]).type) {
      case "link":
        (g(x.options.url) || g(x.options.pageNumber)) && (V = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        V = !0;
    }
    if (V != 0) {
      this.internal.write("/Annots [");
      for (var U = 0; U < j.length; U++) {
        x = j[U];
        var B = this.internal.pdfEscape, ye = this.internal.getEncryptor(_.objId);
        switch (x.type) {
          case "reference":
            this.internal.write(" " + x.object.objId + " 0 R ");
            break;
          case "text":
            var oe = this.internal.newAdditionalObject(), xe = this.internal.newAdditionalObject(), se = this.internal.getEncryptor(oe.objId), ve = x.title || "Note";
            A = "<</Type /Annot /Subtype /Text " + (I = "/Rect [" + v(x.bounds.x) + " " + o(x.bounds.y + x.bounds.h) + " " + v(x.bounds.x + x.bounds.w) + " " + o(x.bounds.y) + "] ") + "/Contents (" + B(se(x.contents)) + ")", A += " /Popup " + xe.objId + " 0 R", A += " /P " + D.objId + " 0 R", A += " /T (" + B(se(ve)) + ") >>", oe.content = A;
            var Fe = oe.objId + " 0 R";
            A = "<</Type /Annot /Subtype /Popup " + (I = "/Rect [" + v(x.bounds.x + 30) + " " + o(x.bounds.y + x.bounds.h) + " " + v(x.bounds.x + x.bounds.w + 30) + " " + o(x.bounds.y) + "] ") + " /Parent " + Fe, x.open && (A += " /Open true"), A += " >>", xe.content = A, this.internal.write(oe.objId, "0 R", xe.objId, "0 R");
            break;
          case "freetext":
            I = "/Rect [" + v(x.bounds.x) + " " + o(x.bounds.y) + " " + v(x.bounds.x + x.bounds.w) + " " + o(x.bounds.y + x.bounds.h) + "] ";
            var it = x.color || "#000000";
            A = "<</Type /Annot /Subtype /FreeText " + I + "/Contents (" + B(ye(x.contents)) + ")", A += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + it + ")", A += " /Border [0 0 0]", A += " >>", this.internal.write(A);
            break;
          case "link":
            if (x.options.name) {
              var Ke = this.annotations._nameMap[x.options.name];
              x.options.pageNumber = Ke.page, x.options.top = Ke.y;
            } else x.options.top || (x.options.top = 0);
            if (I = "/Rect [" + x.finalBounds.x + " " + x.finalBounds.y + " " + x.finalBounds.w + " " + x.finalBounds.h + "] ", A = "", x.options.url) A = "<</Type /Annot /Subtype /Link " + I + "/Border [0 0 0] /A <</S /URI /URI (" + B(ye(x.options.url)) + ") >>";
            else if (x.options.pageNumber)
              switch (A = "<</Type /Annot /Subtype /Link " + I + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(x.options.pageNumber).objId + " 0 R", x.options.magFactor = x.options.magFactor || "XYZ", x.options.magFactor) {
                case "Fit":
                  A += " /Fit]";
                  break;
                case "FitH":
                  A += " /FitH " + x.options.top + "]";
                  break;
                case "FitV":
                  x.options.left = x.options.left || 0, A += " /FitV " + x.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var gt = o(x.options.top);
                  x.options.left = x.options.left || 0, x.options.zoom === void 0 && (x.options.zoom = 0), A += " /XYZ " + x.options.left + " " + gt + " " + x.options.zoom + "]";
              }
            A != "" && (A += " >>", this.internal.write(A));
        }
      }
      this.internal.write("]");
    }
  }]), w.createAnnotation = function(_) {
    var x = this.internal.getCurrentPageInfo();
    switch (_.type) {
      case "link":
        this.link(_.bounds.x, _.bounds.y, _.bounds.w, _.bounds.h, _);
        break;
      case "text":
      case "freetext":
        x.pageContext.annotations.push(_);
    }
  }, w.link = function(_, x, I, A, v) {
    var o = this.internal.getCurrentPageInfo(), D = this.internal.getCoordinateString, j = this.internal.getVerticalCoordinateString;
    o.pageContext.annotations.push({ finalBounds: { x: D(_), y: j(x), w: D(_ + I), h: j(x + A) }, options: v, type: "link" });
  }, w.textWithLink = function(_, x, I, A) {
    var v, o, D = this.getTextWidth(_), j = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (A.maxWidth !== void 0) {
      o = A.maxWidth;
      var V = this.splitTextToSize(_, o).length;
      v = Math.ceil(j * V);
    } else o = D, v = j;
    return this.text(_, x, I, A), I += 0.2 * j, A.align === "center" && (x -= D / 2), A.align === "right" && (x -= D), this.link(x, I - j, o, v, A), D;
  }, w.getTextWidth = function(_) {
    var x = this.internal.getFontSize();
    return this.getStringUnitWidth(_) * x / this.internal.scaleFactor;
  };
}(vi.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  var g = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, _ = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, x = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, I = [1570, 1571, 1573, 1575];
  w.__arabicParser__ = {};
  var A = w.__arabicParser__.isInArabicSubstitutionA = function(oe) {
    return g[oe.charCodeAt(0)] !== void 0;
  }, v = w.__arabicParser__.isArabicLetter = function(oe) {
    return typeof oe == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(oe);
  }, o = w.__arabicParser__.isArabicEndLetter = function(oe) {
    return v(oe) && A(oe) && g[oe.charCodeAt(0)].length <= 2;
  }, D = w.__arabicParser__.isArabicAlfLetter = function(oe) {
    return v(oe) && I.indexOf(oe.charCodeAt(0)) >= 0;
  };
  w.__arabicParser__.arabicLetterHasIsolatedForm = function(oe) {
    return v(oe) && A(oe) && g[oe.charCodeAt(0)].length >= 1;
  };
  var j = w.__arabicParser__.arabicLetterHasFinalForm = function(oe) {
    return v(oe) && A(oe) && g[oe.charCodeAt(0)].length >= 2;
  };
  w.__arabicParser__.arabicLetterHasInitialForm = function(oe) {
    return v(oe) && A(oe) && g[oe.charCodeAt(0)].length >= 3;
  };
  var V = w.__arabicParser__.arabicLetterHasMedialForm = function(oe) {
    return v(oe) && A(oe) && g[oe.charCodeAt(0)].length == 4;
  }, q = w.__arabicParser__.resolveLigatures = function(oe) {
    var xe = 0, se = _, ve = "", Fe = 0;
    for (xe = 0; xe < oe.length; xe += 1) se[oe.charCodeAt(xe)] !== void 0 ? (Fe++, typeof (se = se[oe.charCodeAt(xe)]) == "number" && (ve += String.fromCharCode(se), se = _, Fe = 0), xe === oe.length - 1 && (se = _, ve += oe.charAt(xe - (Fe - 1)), xe -= Fe - 1, Fe = 0)) : (se = _, ve += oe.charAt(xe - Fe), xe -= Fe, Fe = 0);
    return ve;
  };
  w.__arabicParser__.isArabicDiacritic = function(oe) {
    return oe !== void 0 && x[oe.charCodeAt(0)] !== void 0;
  };
  var U = w.__arabicParser__.getCorrectForm = function(oe, xe, se) {
    return v(oe) ? A(oe) === !1 ? -1 : !j(oe) || !v(xe) && !v(se) || !v(se) && o(xe) || o(oe) && !v(xe) || o(oe) && D(xe) || o(oe) && o(xe) ? 0 : V(oe) && v(xe) && !o(xe) && v(se) && j(se) ? 3 : o(oe) || !v(se) ? 1 : 2 : -1;
  }, B = function(oe) {
    var xe = 0, se = 0, ve = 0, Fe = "", it = "", Ke = "", gt = (oe = oe || "").split("\\s+"), $e = [];
    for (xe = 0; xe < gt.length; xe += 1) {
      for ($e.push(""), se = 0; se < gt[xe].length; se += 1) Fe = gt[xe][se], it = gt[xe][se - 1], Ke = gt[xe][se + 1], v(Fe) ? (ve = U(Fe, it, Ke), $e[xe] += ve !== -1 ? String.fromCharCode(g[Fe.charCodeAt(0)][ve]) : Fe) : $e[xe] += Fe;
      $e[xe] = q($e[xe]);
    }
    return $e.join(" ");
  }, ye = w.__arabicParser__.processArabic = w.processArabic = function() {
    var oe, xe = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, se = [];
    if (Array.isArray(xe)) {
      var ve = 0;
      for (se = [], ve = 0; ve < xe.length; ve += 1) Array.isArray(xe[ve]) ? se.push([B(xe[ve][0]), xe[ve][1], xe[ve][2]]) : se.push([B(xe[ve])]);
      oe = se;
    } else oe = B(xe);
    return typeof arguments[0] == "string" ? oe : (arguments[0].text = oe, arguments[0]);
  };
  w.events.push(["preProcessText", ye]);
}(vi.API), vi.API.autoPrint = function(w) {
  var g;
  switch ((w = w || {}).variant = w.variant || "non-conform", w.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        g = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + g + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  var g = function() {
    var _ = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return _;
    }, set: function(o) {
      _ = o;
    } });
    var x = 150;
    Object.defineProperty(this, "width", { get: function() {
      return x;
    }, set: function(o) {
      x = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 150 : o, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = x + 1);
    } });
    var I = 300;
    Object.defineProperty(this, "height", { get: function() {
      return I;
    }, set: function(o) {
      I = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 300 : o, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = I + 1);
    } });
    var A = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return A;
    }, set: function(o) {
      A = o;
    } });
    var v = {};
    Object.defineProperty(this, "style", { get: function() {
      return v;
    }, set: function(o) {
      v = o;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  g.prototype.getContext = function(_, x) {
    var I;
    if ((_ = _ || "2d") !== "2d") return null;
    for (I in x) this.pdf.context2d.hasOwnProperty(I) && (this.pdf.context2d[I] = x[I]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, g.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, w.events.push(["initialized", function() {
    this.canvas = new g(), this.canvas.pdf = this;
  }]);
}(vi.API), function(w) {
  var g = { left: 0, top: 0, bottom: 0, right: 0 }, _ = !1, x = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, g), this.internal.__cell__.margins.width = this.getPageWidth(), I.call(this));
  }, I = function() {
    this.internal.__cell__.lastCell = new A(), this.internal.__cell__.pages = 1;
  }, A = function() {
    var D = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return D;
    }, set: function(oe) {
      D = oe;
    } });
    var j = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return j;
    }, set: function(oe) {
      j = oe;
    } });
    var V = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return V;
    }, set: function(oe) {
      V = oe;
    } });
    var q = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return q;
    }, set: function(oe) {
      q = oe;
    } });
    var U = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return U;
    }, set: function(oe) {
      U = oe;
    } });
    var B = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return B;
    }, set: function(oe) {
      B = oe;
    } });
    var ye = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return ye;
    }, set: function(oe) {
      ye = oe;
    } }), this;
  };
  A.prototype.clone = function() {
    return new A(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, A.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, w.setHeaderFunction = function(D) {
    return x.call(this), this.internal.__cell__.headerFunction = typeof D == "function" ? D : void 0, this;
  }, w.getTextDimensions = function(D, j) {
    x.call(this);
    var V = (j = j || {}).fontSize || this.getFontSize(), q = j.font || this.getFont(), U = j.scaleFactor || this.internal.scaleFactor, B = 0, ye = 0, oe = 0, xe = this;
    if (!Array.isArray(D) && typeof D != "string") {
      if (typeof D != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      D = String(D);
    }
    var se = j.maxWidth;
    se > 0 ? typeof D == "string" ? D = this.splitTextToSize(D, se) : Object.prototype.toString.call(D) === "[object Array]" && (D = D.reduce(function(Fe, it) {
      return Fe.concat(xe.splitTextToSize(it, se));
    }, [])) : D = Array.isArray(D) ? D : [D];
    for (var ve = 0; ve < D.length; ve++) B < (oe = this.getStringUnitWidth(D[ve], { font: q }) * V) && (B = oe);
    return B !== 0 && (ye = D.length), { w: B /= U, h: Math.max((ye * V * this.getLineHeightFactor() - V * (this.getLineHeightFactor() - 1)) / U, 0) };
  }, w.cellAddPage = function() {
    x.call(this), this.addPage();
    var D = this.internal.__cell__.margins || g;
    return this.internal.__cell__.lastCell = new A(D.left, D.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var v = w.cell = function() {
    var D;
    D = arguments[0] instanceof A ? arguments[0] : new A(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), x.call(this);
    var j = this.internal.__cell__.lastCell, V = this.internal.__cell__.padding, q = this.internal.__cell__.margins || g, U = this.internal.__cell__.tableHeaderRow, B = this.internal.__cell__.printHeaders;
    return j.lineNumber !== void 0 && (j.lineNumber === D.lineNumber ? (D.x = (j.x || 0) + (j.width || 0), D.y = j.y || 0) : j.y + j.height + D.height + q.bottom > this.getPageHeight() ? (this.cellAddPage(), D.y = q.top, B && U && (this.printHeaderRow(D.lineNumber, !0), D.y += U[0].height)) : D.y = j.y + j.height || D.y), D.text[0] !== void 0 && (this.rect(D.x, D.y, D.width, D.height, _ === !0 ? "FD" : void 0), D.align === "right" ? this.text(D.text, D.x + D.width - V, D.y + V, { align: "right", baseline: "top" }) : D.align === "center" ? this.text(D.text, D.x + D.width / 2, D.y + V, { align: "center", baseline: "top", maxWidth: D.width - V - V }) : this.text(D.text, D.x + V, D.y + V, { align: "left", baseline: "top", maxWidth: D.width - V - V })), this.internal.__cell__.lastCell = D, this;
  };
  w.table = function(D, j, V, q, U) {
    if (x.call(this), !V) throw new Error("No data for PDF table.");
    var B, ye, oe, xe, se = [], ve = [], Fe = [], it = {}, Ke = {}, gt = [], $e = [], Le = (U = U || {}).autoSize || !1, dt = U.printHeaders !== !1, at = U.css && U.css["font-size"] !== void 0 ? 16 * U.css["font-size"] : U.fontSize || 12, ae = U.margins || Object.assign({ width: this.getPageWidth() }, g), he = typeof U.padding == "number" ? U.padding : 3, Ie = U.headerBackgroundColor || "#c8c8c8", Se = U.headerTextColor || "#000";
    if (I.call(this), this.internal.__cell__.printHeaders = dt, this.internal.__cell__.margins = ae, this.internal.__cell__.table_font_size = at, this.internal.__cell__.padding = he, this.internal.__cell__.headerBackgroundColor = Ie, this.internal.__cell__.headerTextColor = Se, this.setFontSize(at), q == null) ve = se = Object.keys(V[0]), Fe = se.map(function() {
      return "left";
    });
    else if (Array.isArray(q) && or(q[0]) === "object") for (se = q.map(function(nt) {
      return nt.name;
    }), ve = q.map(function(nt) {
      return nt.prompt || nt.name || "";
    }), Fe = q.map(function(nt) {
      return nt.align || "left";
    }), B = 0; B < q.length; B += 1) Ke[q[B].name] = q[B].width * (19.049976 / 25.4);
    else Array.isArray(q) && typeof q[0] == "string" && (ve = se = q, Fe = se.map(function() {
      return "left";
    }));
    if (Le || Array.isArray(q) && typeof q[0] == "string") for (B = 0; B < se.length; B += 1) {
      for (it[xe = se[B]] = V.map(function(nt) {
        return nt[xe];
      }), this.setFont(void 0, "bold"), gt.push(this.getTextDimensions(ve[B], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), ye = it[xe], this.setFont(void 0, "normal"), oe = 0; oe < ye.length; oe += 1) gt.push(this.getTextDimensions(ye[oe], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      Ke[xe] = Math.max.apply(null, gt) + he + he, gt = [];
    }
    if (dt) {
      var et = {};
      for (B = 0; B < se.length; B += 1) et[se[B]] = {}, et[se[B]].text = ve[B], et[se[B]].align = Fe[B];
      var Qe = o.call(this, et, Ke);
      $e = se.map(function(nt) {
        return new A(D, j, Ke[nt], Qe, et[nt].text, void 0, et[nt].align);
      }), this.setTableHeaderRow($e), this.printHeaderRow(1, !1);
    }
    var rt = q.reduce(function(nt, wt) {
      return nt[wt.name] = wt.align, nt;
    }, {});
    for (B = 0; B < V.length; B += 1) {
      "rowStart" in U && U.rowStart instanceof Function && U.rowStart({ row: B, data: V[B] }, this);
      var Ze = o.call(this, V[B], Ke);
      for (oe = 0; oe < se.length; oe += 1) {
        var ct = V[B][se[oe]];
        "cellStart" in U && U.cellStart instanceof Function && U.cellStart({ row: B, col: oe, data: ct }, this), v.call(this, new A(D, j, Ke[se[oe]], Ze, ct, B + 2, rt[se[oe]]));
      }
    }
    return this.internal.__cell__.table_x = D, this.internal.__cell__.table_y = j, this;
  };
  var o = function(D, j) {
    var V = this.internal.__cell__.padding, q = this.internal.__cell__.table_font_size, U = this.internal.scaleFactor;
    return Object.keys(D).map(function(B) {
      var ye = D[B];
      return this.splitTextToSize(ye.hasOwnProperty("text") ? ye.text : ye, j[B] - V - V);
    }, this).map(function(B) {
      return this.getLineHeightFactor() * B.length * q / U + V + V;
    }, this).reduce(function(B, ye) {
      return Math.max(B, ye);
    }, 0);
  };
  w.setTableHeaderRow = function(D) {
    x.call(this), this.internal.__cell__.tableHeaderRow = D;
  }, w.printHeaderRow = function(D, j) {
    if (x.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var V;
    if (_ = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var q = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new A(q[0], q[1], q[2], q[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var U = [], B = 0; B < this.internal.__cell__.tableHeaderRow.length; B += 1) {
      V = this.internal.__cell__.tableHeaderRow[B].clone(), j && (V.y = this.internal.__cell__.margins.top || 0, U.push(V)), V.lineNumber = D;
      var ye = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), v.call(this, V), this.setTextColor(ye);
    }
    U.length > 0 && this.setTableHeaderRow(U), this.setFont(void 0, "normal"), _ = !1;
  };
}(vi.API);
var hf = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, uf = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Yu = cf(uf), df = [100, 200, 300, 400, 500, 600, 700, 800, 900], e0 = cf(df);
function Ju(w) {
  var g = w.family.replace(/"|'/g, "").toLowerCase(), _ = function(A) {
    return hf[A = A || "normal"] ? A : "normal";
  }(w.style), x = function(A) {
    if (!A) return 400;
    if (typeof A == "number") return A >= 100 && A <= 900 && A % 100 == 0 ? A : 400;
    if (/^\d00$/.test(A)) return parseInt(A);
    switch (A) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(w.weight), I = function(A) {
    return typeof Yu[A = A || "normal"] == "number" ? A : "normal";
  }(w.stretch);
  return { family: g, style: _, weight: x, stretch: I, src: w.src || [], ref: w.ref || { name: g, style: [I, _, x].join(" ") } };
}
function Fp(w, g, _, x) {
  var I;
  for (I = _; I >= 0 && I < g.length; I += x) if (w[g[I]]) return w[g[I]];
  for (I = _; I >= 0 && I < g.length; I -= x) if (w[g[I]]) return w[g[I]];
}
var t0 = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Np = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Rp(w) {
  return [w.stretch, w.style, w.weight, w.family].join(" ");
}
function i0(w, g, _) {
  for (var x = (_ = _ || {}).defaultFontFamily || "times", I = Object.assign({}, t0, _.genericFontFamilies || {}), A = null, v = null, o = 0; o < g.length; ++o) if (I[(A = Ju(g[o])).family] && (A.family = I[A.family]), w.hasOwnProperty(A.family)) {
    v = w[A.family];
    break;
  }
  if (!(v = v || w[x])) throw new Error("Could not find a font-family for the rule '" + Rp(A) + "' and default family '" + x + "'.");
  if (v = function(D, j) {
    if (j[D]) return j[D];
    var V = Yu[D], q = V <= Yu.normal ? -1 : 1, U = Fp(j, uf, V, q);
    if (!U) throw new Error("Could not find a matching font-stretch value for " + D);
    return U;
  }(A.stretch, v), v = function(D, j) {
    if (j[D]) return j[D];
    for (var V = hf[D], q = 0; q < V.length; ++q) if (j[V[q]]) return j[V[q]];
    throw new Error("Could not find a matching font-style for " + D);
  }(A.style, v), !(v = function(D, j) {
    if (j[D]) return j[D];
    if (D === 400 && j[500]) return j[500];
    if (D === 500 && j[400]) return j[400];
    var V = e0[D], q = Fp(j, df, V, D < 400 ? -1 : 1);
    if (!q) throw new Error("Could not find a matching font-weight for value " + D);
    return q;
  }(A.weight, v))) throw new Error("Failed to resolve a font for the rule '" + Rp(A) + "'.");
  return v;
}
function Bp(w) {
  return w.trimLeft();
}
function r0(w, g) {
  for (var _ = 0; _ < w.length; ) {
    if (w.charAt(_) === g) return [w.substring(0, _), w.substring(_ + 1)];
    _ += 1;
  }
  return null;
}
function n0(w) {
  var g = w.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return g === null ? null : [g[0], w.substring(g[0].length)];
}
var Fh, Op, jp, qp = ["times"];
(function(w) {
  var g, _, x, I, A, v, o, D, j, V = function(K) {
    return K = K || {}, this.isStrokeTransparent = K.isStrokeTransparent || !1, this.strokeOpacity = K.strokeOpacity || 1, this.strokeStyle = K.strokeStyle || "#000000", this.fillStyle = K.fillStyle || "#000000", this.isFillTransparent = K.isFillTransparent || !1, this.fillOpacity = K.fillOpacity || 1, this.font = K.font || "10px sans-serif", this.textBaseline = K.textBaseline || "alphabetic", this.textAlign = K.textAlign || "left", this.lineWidth = K.lineWidth || 1, this.lineJoin = K.lineJoin || "miter", this.lineCap = K.lineCap || "butt", this.path = K.path || [], this.transform = K.transform !== void 0 ? K.transform.clone() : new D(), this.globalCompositeOperation = K.globalCompositeOperation || "normal", this.globalAlpha = K.globalAlpha || 1, this.clip_path = K.clip_path || [], this.currentPoint = K.currentPoint || new v(), this.miterLimit = K.miterLimit || 10, this.lastPoint = K.lastPoint || new v(), this.lineDashOffset = K.lineDashOffset || 0, this.lineDash = K.lineDash || [], this.margin = K.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = K.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof K.ignoreClearRect != "boolean" || K.ignoreClearRect, this;
  };
  w.events.push(["initialized", function() {
    this.context2d = new q(this), g = this.internal.f2, _ = this.internal.getCoordinateString, x = this.internal.getVerticalCoordinateString, I = this.internal.getHorizontalCoordinate, A = this.internal.getVerticalCoordinate, v = this.internal.Point, o = this.internal.Rectangle, D = this.internal.Matrix, j = new V();
  }]);
  var q = function(K) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var ge = K;
    Object.defineProperty(this, "pdf", { get: function() {
      return ge;
    } });
    var we = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return we;
    }, set: function(st) {
      we = !!st;
    } });
    var Ee = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Ee;
    }, set: function(st) {
      Ee = !!st;
    } });
    var Be = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return Be;
    }, set: function(st) {
      isNaN(st) || (Be = st);
    } });
    var Ve = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return Ve;
    }, set: function(st) {
      isNaN(st) || (Ve = st);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return j.margin;
    }, set: function(st) {
      var te;
      typeof st == "number" ? te = [st, st, st, st] : ((te = new Array(4))[0] = st[0], te[1] = st.length >= 2 ? st[1] : te[0], te[2] = st.length >= 3 ? st[2] : te[0], te[3] = st.length >= 4 ? st[3] : te[1]), j.margin = te;
    } });
    var We = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return We;
    }, set: function(st) {
      We = st;
    } });
    var Ye = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return Ye;
    }, set: function(st) {
      Ye = st;
    } });
    var bt = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return bt;
    }, set: function(st) {
      bt = st;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return j;
    }, set: function(st) {
      st instanceof V && (j = st);
    } }), Object.defineProperty(this, "path", { get: function() {
      return j.path;
    }, set: function(st) {
      j.path = st;
    } });
    var xt = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return xt;
    }, set: function(st) {
      xt = st;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(st) {
      var te;
      te = U(st), this.ctx.fillStyle = te.style, this.ctx.isFillTransparent = te.a === 0, this.ctx.fillOpacity = te.a, this.pdf.setFillColor(te.r, te.g, te.b, { a: te.a }), this.pdf.setTextColor(te.r, te.g, te.b, { a: te.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(st) {
      var te = U(st);
      this.ctx.strokeStyle = te.style, this.ctx.isStrokeTransparent = te.a === 0, this.ctx.strokeOpacity = te.a, te.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (te.a, this.pdf.setDrawColor(te.r, te.g, te.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(st) {
      ["butt", "round", "square"].indexOf(st) !== -1 && (this.ctx.lineCap = st, this.pdf.setLineCap(st));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(st) {
      isNaN(st) || (this.ctx.lineWidth = st, this.pdf.setLineWidth(st));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(st) {
      ["bevel", "round", "miter"].indexOf(st) !== -1 && (this.ctx.lineJoin = st, this.pdf.setLineJoin(st));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(st) {
      isNaN(st) || (this.ctx.miterLimit = st, this.pdf.setMiterLimit(st));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(st) {
      this.ctx.textBaseline = st;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(st) {
      ["right", "end", "center", "left", "start"].indexOf(st) !== -1 && (this.ctx.textAlign = st);
    } });
    var kt = null;
    function zt(st, te) {
      if (kt === null) {
        var hi = function(Ht) {
          var ut = [];
          return Object.keys(Ht).forEach(function(_t) {
            Ht[_t].forEach(function(Lt) {
              var Ct = null;
              switch (Lt) {
                case "bold":
                  Ct = { family: _t, weight: "bold" };
                  break;
                case "italic":
                  Ct = { family: _t, style: "italic" };
                  break;
                case "bolditalic":
                  Ct = { family: _t, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  Ct = { family: _t };
              }
              Ct !== null && (Ct.ref = { name: _t, style: Lt }, ut.push(Ct));
            });
          }), ut;
        }(st.getFontList());
        kt = function(Ht) {
          for (var ut = {}, _t = 0; _t < Ht.length; ++_t) {
            var Lt = Ju(Ht[_t]), Ct = Lt.family, ei = Lt.stretch, pi = Lt.style, fi = Lt.weight;
            ut[Ct] = ut[Ct] || {}, ut[Ct][ei] = ut[Ct][ei] || {}, ut[Ct][ei][pi] = ut[Ct][ei][pi] || {}, ut[Ct][ei][pi][fi] = Lt;
          }
          return ut;
        }(hi.concat(te));
      }
      return kt;
    }
    var Ut = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return Ut;
    }, set: function(st) {
      kt = null, Ut = st;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(st) {
      var te;
      if (this.ctx.font = st, (te = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(st)) !== null) {
        var hi = te[1], Ht = (te[2], te[3]), ut = te[4], _t = (te[5], te[6]), Lt = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(ut)[2];
        ut = Math.floor(Lt === "px" ? parseFloat(ut) * this.pdf.internal.scaleFactor : Lt === "em" ? parseFloat(ut) * this.pdf.getFontSize() : parseFloat(ut) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(ut);
        var Ct = function(Jt) {
          var ui, Dt, gr = [], lt = Jt.trim();
          if (lt === "") return qp;
          if (lt in Np) return [Np[lt]];
          for (; lt !== ""; ) {
            switch (Dt = null, ui = (lt = Bp(lt)).charAt(0)) {
              case '"':
              case "'":
                Dt = r0(lt.substring(1), ui);
                break;
              default:
                Dt = n0(lt);
            }
            if (Dt === null || (gr.push(Dt[0]), (lt = Bp(Dt[1])) !== "" && lt.charAt(0) !== ",")) return qp;
            lt = lt.replace(/^,/, "");
          }
          return gr;
        }(_t);
        if (this.fontFaces) {
          var ei = i0(zt(this.pdf, this.fontFaces), Ct.map(function(Jt) {
            return { family: Jt, stretch: "normal", weight: Ht, style: hi };
          }));
          this.pdf.setFont(ei.ref.name, ei.ref.style);
        } else {
          var pi = "";
          (Ht === "bold" || parseInt(Ht, 10) >= 700 || hi === "bold") && (pi = "bold"), hi === "italic" && (pi += "italic"), pi.length === 0 && (pi = "normal");
          for (var fi = "", wi = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, Ci = 0; Ci < Ct.length; Ci++) {
            if (this.pdf.internal.getFont(Ct[Ci], pi, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              fi = Ct[Ci];
              break;
            }
            if (pi === "bolditalic" && this.pdf.internal.getFont(Ct[Ci], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) fi = Ct[Ci], pi = "bold";
            else if (this.pdf.internal.getFont(Ct[Ci], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              fi = Ct[Ci], pi = "normal";
              break;
            }
          }
          if (fi === "") {
            for (var pt = 0; pt < Ct.length; pt++) if (wi[Ct[pt]]) {
              fi = wi[Ct[pt]];
              break;
            }
          }
          fi = fi === "" ? "Times" : fi, this.pdf.setFont(fi, pi);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(st) {
      this.ctx.globalCompositeOperation = st;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(st) {
      this.ctx.globalAlpha = st;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(st) {
      this.ctx.lineDashOffset = st, wt.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(st) {
      this.ctx.lineDash = st, wt.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(st) {
      this.ctx.ignoreClearRect = !!st;
    } });
  };
  q.prototype.setLineDash = function(K) {
    this.lineDash = K;
  }, q.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, q.prototype.fill = function() {
    it.call(this, "fill", !1);
  }, q.prototype.stroke = function() {
    it.call(this, "stroke", !1);
  }, q.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, q.prototype.moveTo = function(K, ge) {
    if (isNaN(K) || isNaN(ge)) throw mr.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var we = this.ctx.transform.applyToPoint(new v(K, ge));
    this.path.push({ type: "mt", x: we.x, y: we.y }), this.ctx.lastPoint = new v(K, ge);
  }, q.prototype.closePath = function() {
    var K = new v(0, 0), ge = 0;
    for (ge = this.path.length - 1; ge !== -1; ge--) if (this.path[ge].type === "begin" && or(this.path[ge + 1]) === "object" && typeof this.path[ge + 1].x == "number") {
      K = new v(this.path[ge + 1].x, this.path[ge + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new v(K.x, K.y);
  }, q.prototype.lineTo = function(K, ge) {
    if (isNaN(K) || isNaN(ge)) throw mr.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var we = this.ctx.transform.applyToPoint(new v(K, ge));
    this.path.push({ type: "lt", x: we.x, y: we.y }), this.ctx.lastPoint = new v(we.x, we.y);
  }, q.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), it.call(this, null, !0);
  }, q.prototype.quadraticCurveTo = function(K, ge, we, Ee) {
    if (isNaN(we) || isNaN(Ee) || isNaN(K) || isNaN(ge)) throw mr.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var Be = this.ctx.transform.applyToPoint(new v(we, Ee)), Ve = this.ctx.transform.applyToPoint(new v(K, ge));
    this.path.push({ type: "qct", x1: Ve.x, y1: Ve.y, x: Be.x, y: Be.y }), this.ctx.lastPoint = new v(Be.x, Be.y);
  }, q.prototype.bezierCurveTo = function(K, ge, we, Ee, Be, Ve) {
    if (isNaN(Be) || isNaN(Ve) || isNaN(K) || isNaN(ge) || isNaN(we) || isNaN(Ee)) throw mr.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var We = this.ctx.transform.applyToPoint(new v(Be, Ve)), Ye = this.ctx.transform.applyToPoint(new v(K, ge)), bt = this.ctx.transform.applyToPoint(new v(we, Ee));
    this.path.push({ type: "bct", x1: Ye.x, y1: Ye.y, x2: bt.x, y2: bt.y, x: We.x, y: We.y }), this.ctx.lastPoint = new v(We.x, We.y);
  }, q.prototype.arc = function(K, ge, we, Ee, Be, Ve) {
    if (isNaN(K) || isNaN(ge) || isNaN(we) || isNaN(Ee) || isNaN(Be)) throw mr.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (Ve = !!Ve, !this.ctx.transform.isIdentity) {
      var We = this.ctx.transform.applyToPoint(new v(K, ge));
      K = We.x, ge = We.y;
      var Ye = this.ctx.transform.applyToPoint(new v(0, we)), bt = this.ctx.transform.applyToPoint(new v(0, 0));
      we = Math.sqrt(Math.pow(Ye.x - bt.x, 2) + Math.pow(Ye.y - bt.y, 2));
    }
    Math.abs(Be - Ee) >= 2 * Math.PI && (Ee = 0, Be = 2 * Math.PI), this.path.push({ type: "arc", x: K, y: ge, radius: we, startAngle: Ee, endAngle: Be, counterclockwise: Ve });
  }, q.prototype.arcTo = function(K, ge, we, Ee, Be) {
    throw new Error("arcTo not implemented.");
  }, q.prototype.rect = function(K, ge, we, Ee) {
    if (isNaN(K) || isNaN(ge) || isNaN(we) || isNaN(Ee)) throw mr.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(K, ge), this.lineTo(K + we, ge), this.lineTo(K + we, ge + Ee), this.lineTo(K, ge + Ee), this.lineTo(K, ge), this.lineTo(K + we, ge), this.lineTo(K, ge);
  }, q.prototype.fillRect = function(K, ge, we, Ee) {
    if (isNaN(K) || isNaN(ge) || isNaN(we) || isNaN(Ee)) throw mr.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!B.call(this)) {
      var Be = {};
      this.lineCap !== "butt" && (Be.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (Be.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(K, ge, we, Ee), this.fill(), Be.hasOwnProperty("lineCap") && (this.lineCap = Be.lineCap), Be.hasOwnProperty("lineJoin") && (this.lineJoin = Be.lineJoin);
    }
  }, q.prototype.strokeRect = function(K, ge, we, Ee) {
    if (isNaN(K) || isNaN(ge) || isNaN(we) || isNaN(Ee)) throw mr.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    ye.call(this) || (this.beginPath(), this.rect(K, ge, we, Ee), this.stroke());
  }, q.prototype.clearRect = function(K, ge, we, Ee) {
    if (isNaN(K) || isNaN(ge) || isNaN(we) || isNaN(Ee)) throw mr.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(K, ge, we, Ee));
  }, q.prototype.save = function(K) {
    K = typeof K != "boolean" || K;
    for (var ge = this.pdf.internal.getCurrentPageInfo().pageNumber, we = 0; we < this.pdf.internal.getNumberOfPages(); we++) this.pdf.setPage(we + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(ge), K) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Ee = new V(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Ee;
    }
  }, q.prototype.restore = function(K) {
    K = typeof K != "boolean" || K;
    for (var ge = this.pdf.internal.getCurrentPageInfo().pageNumber, we = 0; we < this.pdf.internal.getNumberOfPages(); we++) this.pdf.setPage(we + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(ge), K && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, q.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var U = function(K) {
    var ge, we, Ee, Be;
    if (K.isCanvasGradient === !0 && (K = K.getColor()), !K) return { r: 0, g: 0, b: 0, a: 0, style: K };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(K)) ge = 0, we = 0, Ee = 0, Be = 0;
    else {
      var Ve = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(K);
      if (Ve !== null) ge = parseInt(Ve[1]), we = parseInt(Ve[2]), Ee = parseInt(Ve[3]), Be = 1;
      else if ((Ve = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(K)) !== null) ge = parseInt(Ve[1]), we = parseInt(Ve[2]), Ee = parseInt(Ve[3]), Be = parseFloat(Ve[4]);
      else {
        if (Be = 1, typeof K == "string" && K.charAt(0) !== "#") {
          var We = new rf(K);
          K = We.ok ? We.toHex() : "#000000";
        }
        K.length === 4 ? (ge = K.substring(1, 2), ge += ge, we = K.substring(2, 3), we += we, Ee = K.substring(3, 4), Ee += Ee) : (ge = K.substring(1, 3), we = K.substring(3, 5), Ee = K.substring(5, 7)), ge = parseInt(ge, 16), we = parseInt(we, 16), Ee = parseInt(Ee, 16);
      }
    }
    return { r: ge, g: we, b: Ee, a: Be, style: K };
  }, B = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, ye = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  q.prototype.fillText = function(K, ge, we, Ee) {
    if (isNaN(ge) || isNaN(we) || typeof K != "string") throw mr.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Ee = isNaN(Ee) ? void 0 : Ee, !B.call(this)) {
      var Be = Ze(this.ctx.transform.rotation), Ve = this.ctx.transform.scaleX;
      he.call(this, { text: K, x: ge, y: we, scale: Ve, angle: Be, align: this.textAlign, maxWidth: Ee });
    }
  }, q.prototype.strokeText = function(K, ge, we, Ee) {
    if (isNaN(ge) || isNaN(we) || typeof K != "string") throw mr.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!ye.call(this)) {
      Ee = isNaN(Ee) ? void 0 : Ee;
      var Be = Ze(this.ctx.transform.rotation), Ve = this.ctx.transform.scaleX;
      he.call(this, { text: K, x: ge, y: we, scale: Ve, renderingMode: "stroke", angle: Be, align: this.textAlign, maxWidth: Ee });
    }
  }, q.prototype.measureText = function(K) {
    if (typeof K != "string") throw mr.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var ge = this.pdf, we = this.pdf.internal.scaleFactor, Ee = ge.internal.getFontSize(), Be = ge.getStringUnitWidth(K) * Ee / ge.internal.scaleFactor, Ve = function(We) {
      var Ye = (We = We || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return Ye;
      } }), this;
    };
    return new Ve({ width: Be *= Math.round(96 * we / 72 * 1e4) / 1e4 });
  }, q.prototype.scale = function(K, ge) {
    if (isNaN(K) || isNaN(ge)) throw mr.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var we = new D(K, 0, 0, ge, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(we);
  }, q.prototype.rotate = function(K) {
    if (isNaN(K)) throw mr.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var ge = new D(Math.cos(K), Math.sin(K), -Math.sin(K), Math.cos(K), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(ge);
  }, q.prototype.translate = function(K, ge) {
    if (isNaN(K) || isNaN(ge)) throw mr.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var we = new D(1, 0, 0, 1, K, ge);
    this.ctx.transform = this.ctx.transform.multiply(we);
  }, q.prototype.transform = function(K, ge, we, Ee, Be, Ve) {
    if (isNaN(K) || isNaN(ge) || isNaN(we) || isNaN(Ee) || isNaN(Be) || isNaN(Ve)) throw mr.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var We = new D(K, ge, we, Ee, Be, Ve);
    this.ctx.transform = this.ctx.transform.multiply(We);
  }, q.prototype.setTransform = function(K, ge, we, Ee, Be, Ve) {
    K = isNaN(K) ? 1 : K, ge = isNaN(ge) ? 0 : ge, we = isNaN(we) ? 0 : we, Ee = isNaN(Ee) ? 1 : Ee, Be = isNaN(Be) ? 0 : Be, Ve = isNaN(Ve) ? 0 : Ve, this.ctx.transform = new D(K, ge, we, Ee, Be, Ve);
  };
  var oe = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  q.prototype.drawImage = function(K, ge, we, Ee, Be, Ve, We, Ye, bt) {
    var xt = this.pdf.getImageProperties(K), kt = 1, zt = 1, Ut = 1, st = 1;
    Ee !== void 0 && Ye !== void 0 && (Ut = Ye / Ee, st = bt / Be, kt = xt.width / Ee * Ye / Ee, zt = xt.height / Be * bt / Be), Ve === void 0 && (Ve = ge, We = we, ge = 0, we = 0), Ee !== void 0 && Ye === void 0 && (Ye = Ee, bt = Be), Ee === void 0 && Ye === void 0 && (Ye = xt.width, bt = xt.height);
    for (var te, hi = this.ctx.transform.decompose(), Ht = Ze(hi.rotate.shx), ut = new D(), _t = (ut = (ut = (ut = ut.multiply(hi.translate)).multiply(hi.skew)).multiply(hi.scale)).applyToRectangle(new o(Ve - ge * Ut, We - we * st, Ee * kt, Be * zt)), Lt = xe.call(this, _t), Ct = [], ei = 0; ei < Lt.length; ei += 1) Ct.indexOf(Lt[ei]) === -1 && Ct.push(Lt[ei]);
    if (Fe(Ct), this.autoPaging) for (var pi = Ct[0], fi = Ct[Ct.length - 1], wi = pi; wi < fi + 1; wi++) {
      this.pdf.setPage(wi);
      var Ci = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], pt = wi === 1 ? this.posY + this.margin[0] : this.margin[0], Jt = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], ui = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Dt = wi === 1 ? 0 : Jt + (wi - 2) * ui;
      if (this.ctx.clip_path.length !== 0) {
        var gr = this.path;
        te = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = ve(te, this.posX + this.margin[3], -Dt + pt + this.ctx.prevPageLastElemOffset), Ke.call(this, "fill", !0), this.path = gr;
      }
      var lt = JSON.parse(JSON.stringify(_t));
      lt = ve([lt], this.posX + this.margin[3], -Dt + pt + this.ctx.prevPageLastElemOffset)[0];
      var li = (wi > pi || wi < fi) && oe.call(this);
      li && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ci, ui, null).clip().discardPath()), this.pdf.addImage(K, "JPEG", lt.x, lt.y, lt.w, lt.h, null, null, Ht), li && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(K, "JPEG", _t.x, _t.y, _t.w, _t.h, null, null, Ht);
  };
  var xe = function(K, ge, we) {
    var Ee = [];
    ge = ge || this.pdf.internal.pageSize.width, we = we || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var Be = this.posY + this.ctx.prevPageLastElemOffset;
    switch (K.type) {
      default:
      case "mt":
      case "lt":
        Ee.push(Math.floor((K.y + Be) / we) + 1);
        break;
      case "arc":
        Ee.push(Math.floor((K.y + Be - K.radius) / we) + 1), Ee.push(Math.floor((K.y + Be + K.radius) / we) + 1);
        break;
      case "qct":
        var Ve = ct(this.ctx.lastPoint.x, this.ctx.lastPoint.y, K.x1, K.y1, K.x, K.y);
        Ee.push(Math.floor((Ve.y + Be) / we) + 1), Ee.push(Math.floor((Ve.y + Ve.h + Be) / we) + 1);
        break;
      case "bct":
        var We = nt(this.ctx.lastPoint.x, this.ctx.lastPoint.y, K.x1, K.y1, K.x2, K.y2, K.x, K.y);
        Ee.push(Math.floor((We.y + Be) / we) + 1), Ee.push(Math.floor((We.y + We.h + Be) / we) + 1);
        break;
      case "rect":
        Ee.push(Math.floor((K.y + Be) / we) + 1), Ee.push(Math.floor((K.y + K.h + Be) / we) + 1);
    }
    for (var Ye = 0; Ye < Ee.length; Ye += 1) for (; this.pdf.internal.getNumberOfPages() < Ee[Ye]; ) se.call(this);
    return Ee;
  }, se = function() {
    var K = this.fillStyle, ge = this.strokeStyle, we = this.font, Ee = this.lineCap, Be = this.lineWidth, Ve = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = K, this.strokeStyle = ge, this.font = we, this.lineCap = Ee, this.lineWidth = Be, this.lineJoin = Ve;
  }, ve = function(K, ge, we) {
    for (var Ee = 0; Ee < K.length; Ee++) switch (K[Ee].type) {
      case "bct":
        K[Ee].x2 += ge, K[Ee].y2 += we;
      case "qct":
        K[Ee].x1 += ge, K[Ee].y1 += we;
      case "mt":
      case "lt":
      case "arc":
      default:
        K[Ee].x += ge, K[Ee].y += we;
    }
    return K;
  }, Fe = function(K) {
    return K.sort(function(ge, we) {
      return ge - we;
    });
  }, it = function(K, ge) {
    for (var we, Ee, Be = this.fillStyle, Ve = this.strokeStyle, We = this.lineCap, Ye = this.lineWidth, bt = Math.abs(Ye * this.ctx.transform.scaleX), xt = this.lineJoin, kt = JSON.parse(JSON.stringify(this.path)), zt = JSON.parse(JSON.stringify(this.path)), Ut = [], st = 0; st < zt.length; st++) if (zt[st].x !== void 0) for (var te = xe.call(this, zt[st]), hi = 0; hi < te.length; hi += 1) Ut.indexOf(te[hi]) === -1 && Ut.push(te[hi]);
    for (var Ht = 0; Ht < Ut.length; Ht++) for (; this.pdf.internal.getNumberOfPages() < Ut[Ht]; ) se.call(this);
    if (Fe(Ut), this.autoPaging) for (var ut = Ut[0], _t = Ut[Ut.length - 1], Lt = ut; Lt < _t + 1; Lt++) {
      this.pdf.setPage(Lt), this.fillStyle = Be, this.strokeStyle = Ve, this.lineCap = We, this.lineWidth = bt, this.lineJoin = xt;
      var Ct = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], ei = Lt === 1 ? this.posY + this.margin[0] : this.margin[0], pi = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], fi = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], wi = Lt === 1 ? 0 : pi + (Lt - 2) * fi;
      if (this.ctx.clip_path.length !== 0) {
        var Ci = this.path;
        we = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = ve(we, this.posX + this.margin[3], -wi + ei + this.ctx.prevPageLastElemOffset), Ke.call(this, K, !0), this.path = Ci;
      }
      if (Ee = JSON.parse(JSON.stringify(kt)), this.path = ve(Ee, this.posX + this.margin[3], -wi + ei + this.ctx.prevPageLastElemOffset), ge === !1 || Lt === 0) {
        var pt = (Lt > ut || Lt < _t) && oe.call(this);
        pt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ct, fi, null).clip().discardPath()), Ke.call(this, K, ge), pt && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = Ye;
    }
    else this.lineWidth = bt, Ke.call(this, K, ge), this.lineWidth = Ye;
    this.path = kt;
  }, Ke = function(K, ge) {
    if ((K !== "stroke" || ge || !ye.call(this)) && (K === "stroke" || ge || !B.call(this))) {
      for (var we, Ee, Be = [], Ve = this.path, We = 0; We < Ve.length; We++) {
        var Ye = Ve[We];
        switch (Ye.type) {
          case "begin":
            Be.push({ begin: !0 });
            break;
          case "close":
            Be.push({ close: !0 });
            break;
          case "mt":
            Be.push({ start: Ye, deltas: [], abs: [] });
            break;
          case "lt":
            var bt = Be.length;
            if (Ve[We - 1] && !isNaN(Ve[We - 1].x) && (we = [Ye.x - Ve[We - 1].x, Ye.y - Ve[We - 1].y], bt > 0)) {
              for (; bt >= 0; bt--) if (Be[bt - 1].close !== !0 && Be[bt - 1].begin !== !0) {
                Be[bt - 1].deltas.push(we), Be[bt - 1].abs.push(Ye);
                break;
              }
            }
            break;
          case "bct":
            we = [Ye.x1 - Ve[We - 1].x, Ye.y1 - Ve[We - 1].y, Ye.x2 - Ve[We - 1].x, Ye.y2 - Ve[We - 1].y, Ye.x - Ve[We - 1].x, Ye.y - Ve[We - 1].y], Be[Be.length - 1].deltas.push(we);
            break;
          case "qct":
            var xt = Ve[We - 1].x + 2 / 3 * (Ye.x1 - Ve[We - 1].x), kt = Ve[We - 1].y + 2 / 3 * (Ye.y1 - Ve[We - 1].y), zt = Ye.x + 2 / 3 * (Ye.x1 - Ye.x), Ut = Ye.y + 2 / 3 * (Ye.y1 - Ye.y), st = Ye.x, te = Ye.y;
            we = [xt - Ve[We - 1].x, kt - Ve[We - 1].y, zt - Ve[We - 1].x, Ut - Ve[We - 1].y, st - Ve[We - 1].x, te - Ve[We - 1].y], Be[Be.length - 1].deltas.push(we);
            break;
          case "arc":
            Be.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(Be[Be.length - 1].abs) && Be[Be.length - 1].abs.push(Ye);
        }
      }
      Ee = ge ? null : K === "stroke" ? "stroke" : "fill";
      for (var hi = !1, Ht = 0; Ht < Be.length; Ht++) if (Be[Ht].arc) for (var ut = Be[Ht].abs, _t = 0; _t < ut.length; _t++) {
        var Lt = ut[_t];
        Lt.type === "arc" ? Le.call(this, Lt.x, Lt.y, Lt.radius, Lt.startAngle, Lt.endAngle, Lt.counterclockwise, void 0, ge, !hi) : Ie.call(this, Lt.x, Lt.y), hi = !0;
      }
      else if (Be[Ht].close === !0) this.pdf.internal.out("h"), hi = !1;
      else if (Be[Ht].begin !== !0) {
        var Ct = Be[Ht].start.x, ei = Be[Ht].start.y;
        Se.call(this, Be[Ht].deltas, Ct, ei), hi = !0;
      }
      Ee && dt.call(this, Ee), ge && at.call(this);
    }
  }, gt = function(K) {
    var ge = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, we = ge * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return K - we;
      case "top":
        return K + ge - we;
      case "hanging":
        return K + ge - 2 * we;
      case "middle":
        return K + ge / 2 - we;
      case "ideographic":
        return K;
      case "alphabetic":
      default:
        return K;
    }
  }, $e = function(K) {
    return K + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  q.prototype.createLinearGradient = function() {
    var K = function() {
    };
    return K.colorStops = [], K.addColorStop = function(ge, we) {
      this.colorStops.push([ge, we]);
    }, K.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, K.isCanvasGradient = !0, K;
  }, q.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, q.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var Le = function(K, ge, we, Ee, Be, Ve, We, Ye, bt) {
    for (var xt = Qe.call(this, we, Ee, Be, Ve), kt = 0; kt < xt.length; kt++) {
      var zt = xt[kt];
      kt === 0 && (bt ? ae.call(this, zt.x1 + K, zt.y1 + ge) : Ie.call(this, zt.x1 + K, zt.y1 + ge)), et.call(this, K, ge, zt.x2, zt.y2, zt.x3, zt.y3, zt.x4, zt.y4);
    }
    Ye ? at.call(this) : dt.call(this, We);
  }, dt = function(K) {
    switch (K) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, at = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, ae = function(K, ge) {
    this.pdf.internal.out(_(K) + " " + x(ge) + " m");
  }, he = function(K) {
    var ge;
    switch (K.align) {
      case "right":
      case "end":
        ge = "right";
        break;
      case "center":
        ge = "center";
        break;
      case "left":
      case "start":
      default:
        ge = "left";
    }
    var we = this.pdf.getTextDimensions(K.text), Ee = gt.call(this, K.y), Be = $e.call(this, Ee) - we.h, Ve = this.ctx.transform.applyToPoint(new v(K.x, Ee)), We = this.ctx.transform.decompose(), Ye = new D();
    Ye = (Ye = (Ye = Ye.multiply(We.translate)).multiply(We.skew)).multiply(We.scale);
    for (var bt, xt, kt, zt = this.ctx.transform.applyToRectangle(new o(K.x, Ee, we.w, we.h)), Ut = Ye.applyToRectangle(new o(K.x, Be, we.w, we.h)), st = xe.call(this, Ut), te = [], hi = 0; hi < st.length; hi += 1) te.indexOf(st[hi]) === -1 && te.push(st[hi]);
    if (Fe(te), this.autoPaging) for (var Ht = te[0], ut = te[te.length - 1], _t = Ht; _t < ut + 1; _t++) {
      this.pdf.setPage(_t);
      var Lt = _t === 1 ? this.posY + this.margin[0] : this.margin[0], Ct = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], ei = this.pdf.internal.pageSize.height - this.margin[2], pi = ei - this.margin[0], fi = this.pdf.internal.pageSize.width - this.margin[1], wi = fi - this.margin[3], Ci = _t === 1 ? 0 : Ct + (_t - 2) * pi;
      if (this.ctx.clip_path.length !== 0) {
        var pt = this.path;
        bt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = ve(bt, this.posX + this.margin[3], -1 * Ci + Lt), Ke.call(this, "fill", !0), this.path = pt;
      }
      var Jt = ve([JSON.parse(JSON.stringify(Ut))], this.posX + this.margin[3], -Ci + Lt + this.ctx.prevPageLastElemOffset)[0];
      K.scale >= 0.01 && (xt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(xt * K.scale), kt = this.lineWidth, this.lineWidth = kt * K.scale);
      var ui = this.autoPaging !== "text";
      if (ui || Jt.y + Jt.h <= ei) {
        if (ui || Jt.y >= Lt && Jt.x <= fi) {
          var Dt = ui ? K.text : this.pdf.splitTextToSize(K.text, K.maxWidth || fi - Jt.x)[0], gr = ve([JSON.parse(JSON.stringify(zt))], this.posX + this.margin[3], -Ci + Lt + this.ctx.prevPageLastElemOffset)[0], lt = ui && (_t > Ht || _t < ut) && oe.call(this);
          lt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], wi, pi, null).clip().discardPath()), this.pdf.text(Dt, gr.x, gr.y, { angle: K.angle, align: ge, renderingMode: K.renderingMode }), lt && this.pdf.restoreGraphicsState();
        }
      } else Jt.y < ei && (this.ctx.prevPageLastElemOffset += ei - Jt.y);
      K.scale >= 0.01 && (this.pdf.setFontSize(xt), this.lineWidth = kt);
    }
    else K.scale >= 0.01 && (xt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(xt * K.scale), kt = this.lineWidth, this.lineWidth = kt * K.scale), this.pdf.text(K.text, Ve.x + this.posX, Ve.y + this.posY, { angle: K.angle, align: ge, renderingMode: K.renderingMode, maxWidth: K.maxWidth }), K.scale >= 0.01 && (this.pdf.setFontSize(xt), this.lineWidth = kt);
  }, Ie = function(K, ge, we, Ee) {
    we = we || 0, Ee = Ee || 0, this.pdf.internal.out(_(K + we) + " " + x(ge + Ee) + " l");
  }, Se = function(K, ge, we) {
    return this.pdf.lines(K, ge, we, null, null);
  }, et = function(K, ge, we, Ee, Be, Ve, We, Ye) {
    this.pdf.internal.out([g(I(we + K)), g(A(Ee + ge)), g(I(Be + K)), g(A(Ve + ge)), g(I(We + K)), g(A(Ye + ge)), "c"].join(" "));
  }, Qe = function(K, ge, we, Ee) {
    for (var Be = 2 * Math.PI, Ve = Math.PI / 2; ge > we; ) ge -= Be;
    var We = Math.abs(we - ge);
    We < Be && Ee && (We = Be - We);
    for (var Ye = [], bt = Ee ? -1 : 1, xt = ge; We > 1e-5; ) {
      var kt = xt + bt * Math.min(We, Ve);
      Ye.push(rt.call(this, K, xt, kt)), We -= Math.abs(kt - xt), xt = kt;
    }
    return Ye;
  }, rt = function(K, ge, we) {
    var Ee = (we - ge) / 2, Be = K * Math.cos(Ee), Ve = K * Math.sin(Ee), We = Be, Ye = -Ve, bt = We * We + Ye * Ye, xt = bt + We * Be + Ye * Ve, kt = 4 / 3 * (Math.sqrt(2 * bt * xt) - xt) / (We * Ve - Ye * Be), zt = We - kt * Ye, Ut = Ye + kt * We, st = zt, te = -Ut, hi = Ee + ge, Ht = Math.cos(hi), ut = Math.sin(hi);
    return { x1: K * Math.cos(ge), y1: K * Math.sin(ge), x2: zt * Ht - Ut * ut, y2: zt * ut + Ut * Ht, x3: st * Ht - te * ut, y3: st * ut + te * Ht, x4: K * Math.cos(we), y4: K * Math.sin(we) };
  }, Ze = function(K) {
    return 180 * K / Math.PI;
  }, ct = function(K, ge, we, Ee, Be, Ve) {
    var We = K + 0.5 * (we - K), Ye = ge + 0.5 * (Ee - ge), bt = Be + 0.5 * (we - Be), xt = Ve + 0.5 * (Ee - Ve), kt = Math.min(K, Be, We, bt), zt = Math.max(K, Be, We, bt), Ut = Math.min(ge, Ve, Ye, xt), st = Math.max(ge, Ve, Ye, xt);
    return new o(kt, Ut, zt - kt, st - Ut);
  }, nt = function(K, ge, we, Ee, Be, Ve, We, Ye) {
    var bt, xt, kt, zt, Ut, st, te, hi, Ht, ut, _t, Lt, Ct, ei, pi = we - K, fi = Ee - ge, wi = Be - we, Ci = Ve - Ee, pt = We - Be, Jt = Ye - Ve;
    for (xt = 0; xt < 41; xt++) Ht = (te = (kt = K + (bt = xt / 40) * pi) + bt * ((Ut = we + bt * wi) - kt)) + bt * (Ut + bt * (Be + bt * pt - Ut) - te), ut = (hi = (zt = ge + bt * fi) + bt * ((st = Ee + bt * Ci) - zt)) + bt * (st + bt * (Ve + bt * Jt - st) - hi), xt == 0 ? (_t = Ht, Lt = ut, Ct = Ht, ei = ut) : (_t = Math.min(_t, Ht), Lt = Math.min(Lt, ut), Ct = Math.max(Ct, Ht), ei = Math.max(ei, ut));
    return new o(Math.round(_t), Math.round(Lt), Math.round(Ct - _t), Math.round(ei - Lt));
  }, wt = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var K, ge, we = (K = this.ctx.lineDash, ge = this.ctx.lineDashOffset, JSON.stringify({ lineDash: K, lineDashOffset: ge }));
      this.prevLineDash !== we && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = we);
    }
  };
})(vi.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  var g = function(A) {
    var v, o, D, j, V, q, U, B, ye, oe;
    for (o = [], D = 0, j = (A += v = "\0\0\0\0".slice(A.length % 4 || 4)).length; j > D; D += 4) (V = (A.charCodeAt(D) << 24) + (A.charCodeAt(D + 1) << 16) + (A.charCodeAt(D + 2) << 8) + A.charCodeAt(D + 3)) !== 0 ? (q = (V = ((V = ((V = ((V = (V - (oe = V % 85)) / 85) - (ye = V % 85)) / 85) - (B = V % 85)) / 85) - (U = V % 85)) / 85) % 85, o.push(q + 33, U + 33, B + 33, ye + 33, oe + 33)) : o.push(122);
    return function(xe, se) {
      for (var ve = se; ve > 0; ve--) xe.pop();
    }(o, v.length), String.fromCharCode.apply(String, o) + "~>";
  }, _ = function(A) {
    var v, o, D, j, V, q = String, U = "length", B = 255, ye = "charCodeAt", oe = "slice", xe = "replace";
    for (A[oe](-2), A = A[oe](0, -2)[xe](/\s/g, "")[xe]("z", "!!!!!"), D = [], j = 0, V = (A += v = "uuuuu"[oe](A[U] % 5 || 5))[U]; V > j; j += 5) o = 52200625 * (A[ye](j) - 33) + 614125 * (A[ye](j + 1) - 33) + 7225 * (A[ye](j + 2) - 33) + 85 * (A[ye](j + 3) - 33) + (A[ye](j + 4) - 33), D.push(B & o >> 24, B & o >> 16, B & o >> 8, B & o);
    return function(se, ve) {
      for (var Fe = ve; Fe > 0; Fe--) se.pop();
    }(D, v[U]), q.fromCharCode.apply(q, D);
  }, x = function(A) {
    var v = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((A = A.replace(/\s/g, "")).indexOf(">") !== -1 && (A = A.substr(0, A.indexOf(">"))), A.length % 2 && (A += "0"), v.test(A) === !1) return "";
    for (var o = "", D = 0; D < A.length; D += 2) o += String.fromCharCode("0x" + (A[D] + A[D + 1]));
    return o;
  }, I = function(A) {
    for (var v = new Uint8Array(A.length), o = A.length; o--; ) v[o] = A.charCodeAt(o);
    return A = (v = Zu(v)).reduce(function(D, j) {
      return D + String.fromCharCode(j);
    }, "");
  };
  w.processDataByFilters = function(A, v) {
    var o = 0, D = A || "", j = [];
    for (typeof (v = v || []) == "string" && (v = [v]), o = 0; o < v.length; o += 1) switch (v[o]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        D = _(D), j.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        D = g(D), j.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        D = x(D), j.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        D = D.split("").map(function(V) {
          return ("0" + V.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", j.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        D = I(D), j.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + v[o] + '" is not implemented');
    }
    return { data: D, reverseChain: j.reverse().join(" ") };
  };
}(vi.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  w.loadFile = function(g, _, x) {
    return function(I, A, v) {
      A = A !== !1, v = typeof v == "function" ? v : function() {
      };
      var o = void 0;
      try {
        o = function(D, j, V) {
          var q = new XMLHttpRequest(), U = 0, B = function(ye) {
            var oe = ye.length, xe = [], se = String.fromCharCode;
            for (U = 0; U < oe; U += 1) xe.push(se(255 & ye.charCodeAt(U)));
            return xe.join("");
          };
          if (q.open("GET", D, !j), q.overrideMimeType("text/plain; charset=x-user-defined"), j === !1 && (q.onload = function() {
            q.status === 200 ? V(B(this.responseText)) : V(void 0);
          }), q.send(null), j && q.status === 200) return B(q.responseText);
        }(I, A, v);
      } catch {
      }
      return o;
    }(g, _, x);
  }, w.loadImageFile = w.loadFile;
}(vi.API), function(w) {
  function g() {
    return (xi.html2canvas ? Promise.resolve(xi.html2canvas) : import("./html2canvas.esm-d2sM-0Wm-BdPOovWT.mjs")).catch(function(v) {
      return Promise.reject(new Error("Could not load html2canvas: " + v));
    }).then(function(v) {
      return v.default ? v.default : v;
    });
  }
  function _() {
    return (xi.DOMPurify ? Promise.resolve(xi.DOMPurify) : import("./purify.es-B7BPtUgm-D-kGXswo.mjs")).catch(function(v) {
      return Promise.reject(new Error("Could not load dompurify: " + v));
    }).then(function(v) {
      return v.default ? v.default : v;
    });
  }
  var x = function(v) {
    var o = or(v);
    return o === "undefined" ? "undefined" : o === "string" || v instanceof String ? "string" : o === "number" || v instanceof Number ? "number" : o === "function" || v instanceof Function ? "function" : v && v.constructor === Array ? "array" : v && v.nodeType === 1 ? "element" : o === "object" ? "object" : "unknown";
  }, I = function(v, o) {
    var D = document.createElement(v);
    for (var j in o.className && (D.className = o.className), o.innerHTML && o.dompurify && (D.innerHTML = o.dompurify.sanitize(o.innerHTML)), o.style) D.style[j] = o.style[j];
    return D;
  }, A = function v(o) {
    var D = Object.assign(v.convert(Promise.resolve()), JSON.parse(JSON.stringify(v.template))), j = v.convert(Promise.resolve(), D);
    return j = (j = j.setProgress(1, v, 1, [v])).set(o);
  };
  (A.prototype = Object.create(Promise.prototype)).constructor = A, A.convert = function(v, o) {
    return v.__proto__ = o || A.prototype, v;
  }, A.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, A.prototype.from = function(v, o) {
    return this.then(function() {
      switch (o = o || function(D) {
        switch (x(D)) {
          case "string":
            return "string";
          case "element":
            return D.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(v)) {
        case "string":
          return this.then(_).then(function(D) {
            return this.set({ src: I("div", { innerHTML: v, dompurify: D }) });
          });
        case "element":
          return this.set({ src: v });
        case "canvas":
          return this.set({ canvas: v });
        case "img":
          return this.set({ img: v });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, A.prototype.to = function(v) {
    switch (v) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, A.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var v = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, o = function D(j, V) {
        for (var q = j.nodeType === 3 ? document.createTextNode(j.nodeValue) : j.cloneNode(!1), U = j.firstChild; U; U = U.nextSibling) V !== !0 && U.nodeType === 1 && U.nodeName === "SCRIPT" || q.appendChild(D(U, V));
        return j.nodeType === 1 && (j.nodeName === "CANVAS" ? (q.width = j.width, q.height = j.height, q.getContext("2d").drawImage(j, 0, 0)) : j.nodeName !== "TEXTAREA" && j.nodeName !== "SELECT" || (q.value = j.value), q.addEventListener("load", function() {
          q.scrollTop = j.scrollTop, q.scrollLeft = j.scrollLeft;
        }, !0)), q;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      o.tagName === "BODY" && (v.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = I("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = I("div", { className: "html2pdf__container", style: v }), this.prop.container.appendChild(o), this.prop.container.firstChild.appendChild(I("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, A.prototype.toCanvas = function() {
    var v = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(v).then(g).then(function(o) {
      var D = Object.assign({}, this.opt.html2canvas);
      return delete D.onrendered, o(this.prop.container, D);
    }).then(function(o) {
      (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, A.prototype.toContext2d = function() {
    var v = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(v).then(g).then(function(o) {
      var D = this.opt.jsPDF, j = this.opt.fontFaces, V = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, q = Object.assign({ async: !0, allowTaint: !0, scale: V, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete q.onrendered, D.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, D.context2d.posX = this.opt.x, D.context2d.posY = this.opt.y, D.context2d.margin = this.opt.margin, D.context2d.fontFaces = j, j) for (var U = 0; U < j.length; ++U) {
        var B = j[U], ye = B.src.find(function(oe) {
          return oe.format === "truetype";
        });
        ye && D.addFont(ye.url, B.ref.name, B.ref.style);
      }
      return q.windowHeight = q.windowHeight || 0, q.windowHeight = q.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : q.windowHeight, D.context2d.save(!0), o(this.prop.container, q);
    }).then(function(o) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, A.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var v = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = v;
    });
  }, A.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, A.prototype.output = function(v, o, D) {
    return (D = D || "pdf").toLowerCase() === "img" || D.toLowerCase() === "image" ? this.outputImg(v, o) : this.outputPdf(v, o);
  }, A.prototype.outputPdf = function(v, o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(v, o);
    });
  }, A.prototype.outputImg = function(v) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (v) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + v + '" is not supported.';
      }
    });
  }, A.prototype.save = function(v) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(v ? { filename: v } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, A.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, A.prototype.set = function(v) {
    if (x(v) !== "object") return this;
    var o = Object.keys(v || {}).map(function(D) {
      if (D in A.template.prop) return function() {
        this.prop[D] = v[D];
      };
      switch (D) {
        case "margin":
          return this.setMargin.bind(this, v.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = v.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, v.pageSize);
        default:
          return function() {
            this.opt[D] = v[D];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(o);
    });
  }, A.prototype.get = function(v, o) {
    return this.then(function() {
      var D = v in A.template.prop ? this.prop[v] : this.opt[v];
      return o ? o(D) : D;
    });
  }, A.prototype.setMargin = function(v) {
    return this.then(function() {
      switch (x(v)) {
        case "number":
          v = [v, v, v, v];
        case "array":
          if (v.length === 2 && (v = [v[0], v[1], v[0], v[1]]), v.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = v;
    }).then(this.setPageSize);
  }, A.prototype.setPageSize = function(v) {
    function o(D, j) {
      return Math.floor(D * j / 72 * 96);
    }
    return this.then(function() {
      (v = v || vi.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (v.inner = { width: v.width - this.opt.margin[1] - this.opt.margin[3], height: v.height - this.opt.margin[0] - this.opt.margin[2] }, v.inner.px = { width: o(v.inner.width, v.k), height: o(v.inner.height, v.k) }, v.inner.ratio = v.inner.height / v.inner.width), this.prop.pageSize = v;
    });
  }, A.prototype.setProgress = function(v, o, D, j) {
    return v != null && (this.progress.val = v), o != null && (this.progress.state = o), D != null && (this.progress.n = D), j != null && (this.progress.stack = j), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, A.prototype.updateProgress = function(v, o, D, j) {
    return this.setProgress(v ? this.progress.val + v : null, o || null, D ? this.progress.n + D : null, j ? this.progress.stack.concat(j) : null);
  }, A.prototype.then = function(v, o) {
    var D = this;
    return this.thenCore(v, o, function(j, V) {
      return D.updateProgress(null, null, 1, [j]), Promise.prototype.then.call(this, function(q) {
        return D.updateProgress(null, j), q;
      }).then(j, V).then(function(q) {
        return D.updateProgress(1), q;
      });
    });
  }, A.prototype.thenCore = function(v, o, D) {
    D = D || Promise.prototype.then, v && (v = v.bind(this)), o && (o = o.bind(this));
    var j = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : A.convert(Object.assign({}, this), Promise.prototype), V = D.call(j, v, o);
    return A.convert(V, this.__proto__);
  }, A.prototype.thenExternal = function(v, o) {
    return Promise.prototype.then.call(this, v, o);
  }, A.prototype.thenList = function(v) {
    var o = this;
    return v.forEach(function(D) {
      o = o.thenCore(D);
    }), o;
  }, A.prototype.catch = function(v) {
    v && (v = v.bind(this));
    var o = Promise.prototype.catch.call(this, v);
    return A.convert(o, this);
  }, A.prototype.catchExternal = function(v) {
    return Promise.prototype.catch.call(this, v);
  }, A.prototype.error = function(v) {
    return this.then(function() {
      throw new Error(v);
    });
  }, A.prototype.using = A.prototype.set, A.prototype.saveAs = A.prototype.save, A.prototype.export = A.prototype.output, A.prototype.run = A.prototype.then, vi.getPageSize = function(v, o, D) {
    if (or(v) === "object") {
      var j = v;
      v = j.orientation, o = j.unit || o, D = j.format || D;
    }
    o = o || "mm", D = D || "a4", v = ("" + (v || "P")).toLowerCase();
    var V, q = ("" + D).toLowerCase(), U = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (o) {
      case "pt":
        V = 1;
        break;
      case "mm":
        V = 72 / 25.4;
        break;
      case "cm":
        V = 72 / 2.54;
        break;
      case "in":
        V = 72;
        break;
      case "px":
        V = 0.75;
        break;
      case "pc":
      case "em":
        V = 12;
        break;
      case "ex":
        V = 6;
        break;
      default:
        throw "Invalid unit: " + o;
    }
    var B, ye = 0, oe = 0;
    if (U.hasOwnProperty(q)) ye = U[q][1] / V, oe = U[q][0] / V;
    else try {
      ye = D[1], oe = D[0];
    } catch {
      throw new Error("Invalid format: " + D);
    }
    if (v === "p" || v === "portrait") v = "p", oe > ye && (B = oe, oe = ye, ye = B);
    else {
      if (v !== "l" && v !== "landscape") throw "Invalid orientation: " + v;
      v = "l", ye > oe && (B = oe, oe = ye, ye = B);
    }
    return { width: oe, height: ye, unit: o, k: V, orientation: v };
  }, w.html = function(v, o) {
    (o = o || {}).callback = o.callback || function() {
    }, o.html2canvas = o.html2canvas || {}, o.html2canvas.canvas = o.html2canvas.canvas || this.canvas, o.jsPDF = o.jsPDF || this, o.fontFaces = o.fontFaces ? o.fontFaces.map(Ju) : null;
    var D = new A(o);
    return o.worker ? D : D.from(v).doCallback();
  };
}(vi.API), vi.API.addJS = function(w) {
  return jp = w, this.internal.events.subscribe("postPutResources", function() {
    Fh = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Fh + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), Op = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + jp + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Fh !== void 0 && Op !== void 0 && this.internal.out("/Names <</JavaScript " + Fh + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  var g;
  w.events.push(["postPutResources", function() {
    var _ = this, x = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var I = _.outline.render().split(/\r\n/), A = 0; A < I.length; A++) {
      var v = I[A], o = x.exec(v);
      if (o != null) {
        var D = o[1];
        _.internal.newObjectDeferredBegin(D, !1);
      }
      _.internal.write(v);
    }
    if (this.outline.createNamedDestinations) {
      var j = this.internal.pages.length, V = [];
      for (A = 0; A < j; A++) {
        var q = _.internal.newObject();
        V.push(q);
        var U = _.internal.getPageInfo(A + 1);
        _.internal.write("<< /D[" + U.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var B = _.internal.newObject();
      for (_.internal.write("<< /Names [ "), A = 0; A < V.length; A++) _.internal.write("(page_" + (A + 1) + ")" + V[A] + " 0 R");
      _.internal.write(" ] >>", "endobj"), g = _.internal.newObject(), _.internal.write("<< /Dests " + B + " 0 R"), _.internal.write(">>", "endobj");
    }
  }]), w.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + g + " 0 R"));
  }]), w.events.push(["initialized", function() {
    var _ = this;
    _.outline = { createNamedDestinations: !1, root: { children: [] } }, _.outline.add = function(x, I, A) {
      var v = { title: I, options: A, children: [] };
      return x == null && (x = this.root), x.children.push(v), v;
    }, _.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = _, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, _.outline.genIds_r = function(x) {
      x.id = _.internal.newObjectDeferred();
      for (var I = 0; I < x.children.length; I++) this.genIds_r(x.children[I]);
    }, _.outline.renderRoot = function(x) {
      this.objStart(x), this.line("/Type /Outlines"), x.children.length > 0 && (this.line("/First " + this.makeRef(x.children[0])), this.line("/Last " + this.makeRef(x.children[x.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, x)), this.objEnd();
    }, _.outline.renderItems = function(x) {
      for (var I = this.ctx.pdf.internal.getVerticalCoordinateString, A = 0; A < x.children.length; A++) {
        var v = x.children[A];
        this.objStart(v), this.line("/Title " + this.makeString(v.title)), this.line("/Parent " + this.makeRef(x)), A > 0 && this.line("/Prev " + this.makeRef(x.children[A - 1])), A < x.children.length - 1 && this.line("/Next " + this.makeRef(x.children[A + 1])), v.children.length > 0 && (this.line("/First " + this.makeRef(v.children[0])), this.line("/Last " + this.makeRef(v.children[v.children.length - 1])));
        var o = this.count = this.count_r({ count: 0 }, v);
        if (o > 0 && this.line("/Count " + o), v.options && v.options.pageNumber) {
          var D = _.internal.getPageInfo(v.options.pageNumber);
          this.line("/Dest [" + D.objId + " 0 R /XYZ 0 " + I(0) + " 0]");
        }
        this.objEnd();
      }
      for (var j = 0; j < x.children.length; j++) this.renderItems(x.children[j]);
    }, _.outline.line = function(x) {
      this.ctx.val += x + `\r
`;
    }, _.outline.makeRef = function(x) {
      return x.id + " 0 R";
    }, _.outline.makeString = function(x) {
      return "(" + _.internal.pdfEscape(x) + ")";
    }, _.outline.objStart = function(x) {
      this.ctx.val += `\r
` + x.id + ` 0 obj\r
<<\r
`;
    }, _.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, _.outline.count_r = function(x, I) {
      for (var A = 0; A < I.children.length; A++) x.count++, this.count_r(x, I.children[A]);
      return x.count;
    };
  }]);
}(vi.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  var g = [192, 193, 194, 195, 196, 197, 198, 199];
  w.processJPEG = function(_, x, I, A, v, o) {
    var D, j = this.decode.DCT_DECODE, V = null;
    if (typeof _ == "string" || this.__addimage__.isArrayBuffer(_) || this.__addimage__.isArrayBufferView(_)) {
      switch (_ = v || _, _ = this.__addimage__.isArrayBuffer(_) ? new Uint8Array(_) : _, (D = function(q) {
        for (var U, B = 256 * q.charCodeAt(4) + q.charCodeAt(5), ye = q.length, oe = { width: 0, height: 0, numcomponents: 1 }, xe = 4; xe < ye; xe += 2) {
          if (xe += B, g.indexOf(q.charCodeAt(xe + 1)) !== -1) {
            U = 256 * q.charCodeAt(xe + 5) + q.charCodeAt(xe + 6), oe = { width: 256 * q.charCodeAt(xe + 7) + q.charCodeAt(xe + 8), height: U, numcomponents: q.charCodeAt(xe + 9) };
            break;
          }
          B = 256 * q.charCodeAt(xe + 2) + q.charCodeAt(xe + 3);
        }
        return oe;
      }(_ = this.__addimage__.isArrayBufferView(_) ? this.__addimage__.arrayBufferToBinaryString(_) : _)).numcomponents) {
        case 1:
          o = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o = this.color_spaces.DEVICE_RGB;
      }
      V = { data: _, width: D.width, height: D.height, colorSpace: o, bitsPerComponent: 8, filter: j, index: x, alias: I };
    }
    return V;
  };
}(vi.API);
var wc, Nh, Up, Vp, $p, s0 = function() {
  var w, g, _;
  function x(A) {
    var v, o, D, j, V, q, U, B, ye, oe, xe, se, ve, Fe;
    for (this.data = A, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, q = null; ; ) {
      switch (v = this.readUInt32(), ye = (function() {
        var it, Ke;
        for (Ke = [], it = 0; it < 4; ++it) Ke.push(String.fromCharCode(this.data[this.pos++]));
        return Ke;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(v);
          break;
        case "fcTL":
          q && this.animation.frames.push(q), this.pos += 4, q = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, V = this.readUInt16(), j = this.readUInt16() || 100, q.delay = 1e3 * V / j, q.disposeOp = this.data[this.pos++], q.blendOp = this.data[this.pos++], q.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (ye === "fdAT" && (this.pos += 4, v -= 4), A = (q != null ? q.data : void 0) || this.imgData, se = 0; 0 <= v ? se < v : se > v; 0 <= v ? ++se : --se) A.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (D = this.palette.length / 3, this.transparency.indexed = this.read(v), this.transparency.indexed.length > D) throw new Error("More transparent colors than palette size");
              if ((oe = D - this.transparency.indexed.length) > 0) for (ve = 0; 0 <= oe ? ve < oe : ve > oe; 0 <= oe ? ++ve : --ve) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(v)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(v);
          }
          break;
        case "tEXt":
          U = (xe = this.read(v)).indexOf(0), B = String.fromCharCode.apply(String, xe.slice(0, U)), this.text[B] = String.fromCharCode.apply(String, xe.slice(U + 1));
          break;
        case "IEND":
          return q && this.animation.frames.push(q), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (Fe = this.colorType) === 4 || Fe === 6, o = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * o, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += v;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  x.prototype.read = function(A) {
    var v, o;
    for (o = [], v = 0; 0 <= A ? v < A : v > A; 0 <= A ? ++v : --v) o.push(this.data[this.pos++]);
    return o;
  }, x.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, x.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, x.prototype.decodePixels = function(A) {
    var v = this.pixelBitlength / 8, o = new Uint8Array(this.width * this.height * v), D = 0, j = this;
    if (A == null && (A = this.imgData), A.length === 0) return new Uint8Array(0);
    function V(q, U, B, ye) {
      var oe, xe, se, ve, Fe, it, Ke, gt, $e, Le, dt, at, ae, he, Ie, Se, et, Qe, rt, Ze, ct, nt = Math.ceil((j.width - q) / B), wt = Math.ceil((j.height - U) / ye), K = j.width == nt && j.height == wt;
      for (he = v * nt, at = K ? o : new Uint8Array(he * wt), it = A.length, ae = 0, xe = 0; ae < wt && D < it; ) {
        switch (A[D++]) {
          case 0:
            for (ve = et = 0; et < he; ve = et += 1) at[xe++] = A[D++];
            break;
          case 1:
            for (ve = Qe = 0; Qe < he; ve = Qe += 1) oe = A[D++], Fe = ve < v ? 0 : at[xe - v], at[xe++] = (oe + Fe) % 256;
            break;
          case 2:
            for (ve = rt = 0; rt < he; ve = rt += 1) oe = A[D++], se = (ve - ve % v) / v, Ie = ae && at[(ae - 1) * he + se * v + ve % v], at[xe++] = (Ie + oe) % 256;
            break;
          case 3:
            for (ve = Ze = 0; Ze < he; ve = Ze += 1) oe = A[D++], se = (ve - ve % v) / v, Fe = ve < v ? 0 : at[xe - v], Ie = ae && at[(ae - 1) * he + se * v + ve % v], at[xe++] = (oe + Math.floor((Fe + Ie) / 2)) % 256;
            break;
          case 4:
            for (ve = ct = 0; ct < he; ve = ct += 1) oe = A[D++], se = (ve - ve % v) / v, Fe = ve < v ? 0 : at[xe - v], ae === 0 ? Ie = Se = 0 : (Ie = at[(ae - 1) * he + se * v + ve % v], Se = se && at[(ae - 1) * he + (se - 1) * v + ve % v]), Ke = Fe + Ie - Se, gt = Math.abs(Ke - Fe), Le = Math.abs(Ke - Ie), dt = Math.abs(Ke - Se), $e = gt <= Le && gt <= dt ? Fe : Le <= dt ? Ie : Se, at[xe++] = (oe + $e) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + A[D - 1]);
        }
        if (!K) {
          var ge = ((U + ae * ye) * j.width + q) * v, we = ae * he;
          for (ve = 0; ve < nt; ve += 1) {
            for (var Ee = 0; Ee < v; Ee += 1) o[ge++] = at[we++];
            ge += (B - 1) * v;
          }
        }
        ae++;
      }
    }
    return A = Og(A), j.interlaceMethod == 1 ? (V(0, 0, 8, 8), V(4, 0, 8, 8), V(0, 4, 4, 8), V(2, 0, 4, 4), V(0, 2, 2, 4), V(1, 0, 2, 2), V(0, 1, 1, 2)) : V(0, 0, 1, 1), o;
  }, x.prototype.decodePalette = function() {
    var A, v, o, D, j, V, q, U, B;
    for (o = this.palette, V = this.transparency.indexed || [], j = new Uint8Array((V.length || 0) + o.length), D = 0, A = 0, v = q = 0, U = o.length; q < U; v = q += 3) j[D++] = o[v], j[D++] = o[v + 1], j[D++] = o[v + 2], j[D++] = (B = V[A++]) != null ? B : 255;
    return j;
  }, x.prototype.copyToImageData = function(A, v) {
    var o, D, j, V, q, U, B, ye, oe, xe, se;
    if (D = this.colors, oe = null, o = this.hasAlphaChannel, this.palette.length && (oe = (se = this._decodedPalette) != null ? se : this._decodedPalette = this.decodePalette(), D = 4, o = !0), ye = (j = A.data || A).length, q = oe || v, V = U = 0, D === 1) for (; V < ye; ) B = oe ? 4 * v[V / 4] : U, xe = q[B++], j[V++] = xe, j[V++] = xe, j[V++] = xe, j[V++] = o ? q[B++] : 255, U = B;
    else for (; V < ye; ) B = oe ? 4 * v[V / 4] : U, j[V++] = q[B++], j[V++] = q[B++], j[V++] = q[B++], j[V++] = o ? q[B++] : 255, U = B;
  }, x.prototype.decode = function() {
    var A;
    return A = new Uint8Array(this.width * this.height * 4), this.copyToImageData(A, this.decodePixels()), A;
  };
  var I = function() {
    if (Object.prototype.toString.call(xi) === "[object Window]") {
      try {
        g = xi.document.createElement("canvas"), _ = g.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return I(), w = function(A) {
    var v;
    if (I() === !0) return _.width = A.width, _.height = A.height, _.clearRect(0, 0, A.width, A.height), _.putImageData(A, 0, 0), (v = new Image()).src = g.toDataURL(), v;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, x.prototype.decodeFrames = function(A) {
    var v, o, D, j, V, q, U, B;
    if (this.animation) {
      for (B = [], o = V = 0, q = (U = this.animation.frames).length; V < q; o = ++V) v = U[o], D = A.createImageData(v.width, v.height), j = this.decodePixels(new Uint8Array(v.data)), this.copyToImageData(D, j), v.imageData = D, B.push(v.image = w(D));
      return B;
    }
  }, x.prototype.renderFrame = function(A, v) {
    var o, D, j;
    return o = (D = this.animation.frames)[v], j = D[v - 1], v === 0 && A.clearRect(0, 0, this.width, this.height), (j != null ? j.disposeOp : void 0) === 1 ? A.clearRect(j.xOffset, j.yOffset, j.width, j.height) : (j != null ? j.disposeOp : void 0) === 2 && A.putImageData(j.imageData, j.xOffset, j.yOffset), o.blendOp === 0 && A.clearRect(o.xOffset, o.yOffset, o.width, o.height), A.drawImage(o.image, o.xOffset, o.yOffset);
  }, x.prototype.animate = function(A) {
    var v, o, D, j, V, q, U = this;
    return o = 0, q = this.animation, j = q.numFrames, D = q.frames, V = q.numPlays, (v = function() {
      var B, ye;
      if (B = o++ % j, ye = D[B], U.renderFrame(A, B), j > 1 && o / j < V) return U.animation._timeout = setTimeout(v, ye.delay);
    })();
  }, x.prototype.stopAnimation = function() {
    var A;
    return clearTimeout((A = this.animation) != null ? A._timeout : void 0);
  }, x.prototype.render = function(A) {
    var v, o;
    return A._png && A._png.stopAnimation(), A._png = this, A.width = this.width, A.height = this.height, v = A.getContext("2d"), this.animation ? (this.decodeFrames(v), this.animate(v)) : (o = v.createImageData(this.width, this.height), this.copyToImageData(o, this.decodePixels()), v.putImageData(o, 0, 0));
  }, x;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function a0(w) {
  var g = 0;
  if (w[g++] !== 71 || w[g++] !== 73 || w[g++] !== 70 || w[g++] !== 56 || (w[g++] + 1 & 253) != 56 || w[g++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var _ = w[g++] | w[g++] << 8, x = w[g++] | w[g++] << 8, I = w[g++], A = I >> 7, v = 1 << (7 & I) + 1;
  w[g++], w[g++];
  var o = null, D = null;
  A && (o = g, D = v, g += 3 * v);
  var j = !0, V = [], q = 0, U = null, B = 0, ye = null;
  for (this.width = _, this.height = x; j && g < w.length; ) switch (w[g++]) {
    case 33:
      switch (w[g++]) {
        case 255:
          if (w[g] !== 11 || w[g + 1] == 78 && w[g + 2] == 69 && w[g + 3] == 84 && w[g + 4] == 83 && w[g + 5] == 67 && w[g + 6] == 65 && w[g + 7] == 80 && w[g + 8] == 69 && w[g + 9] == 50 && w[g + 10] == 46 && w[g + 11] == 48 && w[g + 12] == 3 && w[g + 13] == 1 && w[g + 16] == 0) g += 14, ye = w[g++] | w[g++] << 8, g++;
          else for (g += 12; ; ) {
            if (!((ae = w[g++]) >= 0)) throw Error("Invalid block size");
            if (ae === 0) break;
            g += ae;
          }
          break;
        case 249:
          if (w[g++] !== 4 || w[g + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var oe = w[g++];
          q = w[g++] | w[g++] << 8, U = w[g++], !(1 & oe) && (U = null), B = oe >> 2 & 7, g++;
          break;
        case 254:
          for (; ; ) {
            if (!((ae = w[g++]) >= 0)) throw Error("Invalid block size");
            if (ae === 0) break;
            g += ae;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + w[g - 1].toString(16));
      }
      break;
    case 44:
      var xe = w[g++] | w[g++] << 8, se = w[g++] | w[g++] << 8, ve = w[g++] | w[g++] << 8, Fe = w[g++] | w[g++] << 8, it = w[g++], Ke = it >> 6 & 1, gt = 1 << (7 & it) + 1, $e = o, Le = D, dt = !1;
      it >> 7 && (dt = !0, $e = g, Le = gt, g += 3 * gt);
      var at = g;
      for (g++; ; ) {
        var ae;
        if (!((ae = w[g++]) >= 0)) throw Error("Invalid block size");
        if (ae === 0) break;
        g += ae;
      }
      V.push({ x: xe, y: se, width: ve, height: Fe, has_local_palette: dt, palette_offset: $e, palette_size: Le, data_offset: at, data_length: g - at, transparent_index: U, interlaced: !!Ke, delay: q, disposal: B });
      break;
    case 59:
      j = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + w[g - 1].toString(16));
  }
  this.numFrames = function() {
    return V.length;
  }, this.loopCount = function() {
    return ye;
  }, this.frameInfo = function(he) {
    if (he < 0 || he >= V.length) throw new Error("Frame index out of range.");
    return V[he];
  }, this.decodeAndBlitFrameBGRA = function(he, Ie) {
    var Se = this.frameInfo(he), et = Se.width * Se.height, Qe = new Uint8Array(et);
    Zp(w, Se.data_offset, Qe, et);
    var rt = Se.palette_offset, Ze = Se.transparent_index;
    Ze === null && (Ze = 256);
    var ct = Se.width, nt = _ - ct, wt = ct, K = 4 * (Se.y * _ + Se.x), ge = 4 * ((Se.y + Se.height) * _ + Se.x), we = K, Ee = 4 * nt;
    Se.interlaced === !0 && (Ee += 4 * _ * 7);
    for (var Be = 8, Ve = 0, We = Qe.length; Ve < We; ++Ve) {
      var Ye = Qe[Ve];
      if (wt === 0 && (wt = ct, (we += Ee) >= ge && (Ee = 4 * nt + 4 * _ * (Be - 1), we = K + (ct + nt) * (Be << 1), Be >>= 1)), Ye === Ze) we += 4;
      else {
        var bt = w[rt + 3 * Ye], xt = w[rt + 3 * Ye + 1], kt = w[rt + 3 * Ye + 2];
        Ie[we++] = kt, Ie[we++] = xt, Ie[we++] = bt, Ie[we++] = 255;
      }
      --wt;
    }
  }, this.decodeAndBlitFrameRGBA = function(he, Ie) {
    var Se = this.frameInfo(he), et = Se.width * Se.height, Qe = new Uint8Array(et);
    Zp(w, Se.data_offset, Qe, et);
    var rt = Se.palette_offset, Ze = Se.transparent_index;
    Ze === null && (Ze = 256);
    var ct = Se.width, nt = _ - ct, wt = ct, K = 4 * (Se.y * _ + Se.x), ge = 4 * ((Se.y + Se.height) * _ + Se.x), we = K, Ee = 4 * nt;
    Se.interlaced === !0 && (Ee += 4 * _ * 7);
    for (var Be = 8, Ve = 0, We = Qe.length; Ve < We; ++Ve) {
      var Ye = Qe[Ve];
      if (wt === 0 && (wt = ct, (we += Ee) >= ge && (Ee = 4 * nt + 4 * _ * (Be - 1), we = K + (ct + nt) * (Be << 1), Be >>= 1)), Ye === Ze) we += 4;
      else {
        var bt = w[rt + 3 * Ye], xt = w[rt + 3 * Ye + 1], kt = w[rt + 3 * Ye + 2];
        Ie[we++] = bt, Ie[we++] = xt, Ie[we++] = kt, Ie[we++] = 255;
      }
      --wt;
    }
  };
}
function Zp(w, g, _, x) {
  for (var I = w[g++], A = 1 << I, v = A + 1, o = v + 1, D = I + 1, j = (1 << D) - 1, V = 0, q = 0, U = 0, B = w[g++], ye = new Int32Array(4096), oe = null; ; ) {
    for (; V < 16 && B !== 0; ) q |= w[g++] << V, V += 8, B === 1 ? B = w[g++] : --B;
    if (V < D) break;
    var xe = q & j;
    if (q >>= D, V -= D, xe !== A) {
      if (xe === v) break;
      for (var se = xe < o ? xe : oe, ve = 0, Fe = se; Fe > A; ) Fe = ye[Fe] >> 8, ++ve;
      var it = Fe;
      if (U + ve + (se !== xe ? 1 : 0) > x) return void mr.log("Warning, gif stream longer than expected.");
      _[U++] = it;
      var Ke = U += ve;
      for (se !== xe && (_[U++] = it), Fe = se; ve--; ) Fe = ye[Fe], _[--Ke] = 255 & Fe, Fe >>= 8;
      oe !== null && o < 4096 && (ye[o++] = oe << 8 | it, o >= j + 1 && D < 12 && (++D, j = j << 1 | 1)), oe = xe;
    } else o = v + 1, j = (1 << (D = I + 1)) - 1, oe = null;
  }
  return U !== x && mr.log("Warning, gif stream shorter than expected."), _;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Ou(w) {
  var g, _, x, I, A, v = Math.floor, o = new Array(64), D = new Array(64), j = new Array(64), V = new Array(64), q = new Array(65535), U = new Array(65535), B = new Array(64), ye = new Array(64), oe = [], xe = 0, se = 7, ve = new Array(64), Fe = new Array(64), it = new Array(64), Ke = new Array(256), gt = new Array(2048), $e = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], Le = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], dt = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], at = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], ae = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], he = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], Ie = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Se = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], et = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function Qe(K, ge) {
    for (var we = 0, Ee = 0, Be = new Array(), Ve = 1; Ve <= 16; Ve++) {
      for (var We = 1; We <= K[Ve]; We++) Be[ge[Ee]] = [], Be[ge[Ee]][0] = we, Be[ge[Ee]][1] = Ve, Ee++, we++;
      we *= 2;
    }
    return Be;
  }
  function rt(K) {
    for (var ge = K[0], we = K[1] - 1; we >= 0; ) ge & 1 << we && (xe |= 1 << se), we--, --se < 0 && (xe == 255 ? (Ze(255), Ze(0)) : Ze(xe), se = 7, xe = 0);
  }
  function Ze(K) {
    oe.push(K);
  }
  function ct(K) {
    Ze(K >> 8 & 255), Ze(255 & K);
  }
  function nt(K, ge, we, Ee, Be) {
    for (var Ve, We = Be[0], Ye = Be[240], bt = function(ut, _t) {
      var Lt, Ct, ei, pi, fi, wi, Ci, pt, Jt, ui, Dt = 0;
      for (Jt = 0; Jt < 8; ++Jt) {
        Lt = ut[Dt], Ct = ut[Dt + 1], ei = ut[Dt + 2], pi = ut[Dt + 3], fi = ut[Dt + 4], wi = ut[Dt + 5], Ci = ut[Dt + 6];
        var gr = Lt + (pt = ut[Dt + 7]), lt = Lt - pt, li = Ct + Ci, Bt = Ct - Ci, ki = ei + wi, lr = ei - wi, Ft = pi + fi, nn = pi - fi, Oi = gr + Ft, $i = gr - Ft, de = li + ki, Z = li - ki;
        ut[Dt] = Oi + de, ut[Dt + 4] = Oi - de;
        var W = 0.707106781 * (Z + $i);
        ut[Dt + 2] = $i + W, ut[Dt + 6] = $i - W;
        var J = 0.382683433 * ((Oi = nn + lr) - (Z = Bt + lt)), fe = 0.5411961 * Oi + J, Ae = 1.306562965 * Z + J, Ce = 0.707106781 * (de = lr + Bt), Me = lt + Ce, pe = lt - Ce;
        ut[Dt + 5] = pe + fe, ut[Dt + 3] = pe - fe, ut[Dt + 1] = Me + Ae, ut[Dt + 7] = Me - Ae, Dt += 8;
      }
      for (Dt = 0, Jt = 0; Jt < 8; ++Jt) {
        Lt = ut[Dt], Ct = ut[Dt + 8], ei = ut[Dt + 16], pi = ut[Dt + 24], fi = ut[Dt + 32], wi = ut[Dt + 40], Ci = ut[Dt + 48];
        var Oe = Lt + (pt = ut[Dt + 56]), ot = Lt - pt, Je = Ct + Ci, Ge = Ct - Ci, It = ei + wi, Nt = ei - wi, gi = pi + fi, ti = pi - fi, mi = Oe + gi, Ii = Oe - gi, Ei = Je + It, Ui = Je - It;
        ut[Dt] = mi + Ei, ut[Dt + 32] = mi - Ei;
        var ai = 0.707106781 * (Ui + Ii);
        ut[Dt + 16] = Ii + ai, ut[Dt + 48] = Ii - ai;
        var Fi = 0.382683433 * ((mi = ti + Nt) - (Ui = Ge + ot)), er = 0.5411961 * mi + Fi, Mr = 1.306562965 * Ui + Fi, Nr = 0.707106781 * (Ei = Nt + Ge), cr = ot + Nr, Jn = ot - Nr;
        ut[Dt + 40] = Jn + er, ut[Dt + 24] = Jn - er, ut[Dt + 8] = cr + Mr, ut[Dt + 56] = cr - Mr, Dt++;
      }
      for (Jt = 0; Jt < 64; ++Jt) ui = ut[Jt] * _t[Jt], B[Jt] = ui > 0 ? ui + 0.5 | 0 : ui - 0.5 | 0;
      return B;
    }(K, ge), xt = 0; xt < 64; ++xt) ye[$e[xt]] = bt[xt];
    var kt = ye[0] - we;
    we = ye[0], kt == 0 ? rt(Ee[0]) : (rt(Ee[U[Ve = 32767 + kt]]), rt(q[Ve]));
    for (var zt = 63; zt > 0 && ye[zt] == 0; ) zt--;
    if (zt == 0) return rt(We), we;
    for (var Ut, st = 1; st <= zt; ) {
      for (var te = st; ye[st] == 0 && st <= zt; ) ++st;
      var hi = st - te;
      if (hi >= 16) {
        Ut = hi >> 4;
        for (var Ht = 1; Ht <= Ut; ++Ht) rt(Ye);
        hi &= 15;
      }
      Ve = 32767 + ye[st], rt(Be[(hi << 4) + U[Ve]]), rt(q[Ve]), st++;
    }
    return zt != 63 && rt(We), we;
  }
  function wt(K) {
    K = Math.min(Math.max(K, 1), 100), A != K && (function(ge) {
      for (var we = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Ee = 0; Ee < 64; Ee++) {
        var Be = v((we[Ee] * ge + 50) / 100);
        Be = Math.min(Math.max(Be, 1), 255), o[$e[Ee]] = Be;
      }
      for (var Ve = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], We = 0; We < 64; We++) {
        var Ye = v((Ve[We] * ge + 50) / 100);
        Ye = Math.min(Math.max(Ye, 1), 255), D[$e[We]] = Ye;
      }
      for (var bt = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], xt = 0, kt = 0; kt < 8; kt++) for (var zt = 0; zt < 8; zt++) j[xt] = 1 / (o[$e[xt]] * bt[kt] * bt[zt] * 8), V[xt] = 1 / (D[$e[xt]] * bt[kt] * bt[zt] * 8), xt++;
    }(K < 50 ? Math.floor(5e3 / K) : Math.floor(200 - 2 * K)), A = K);
  }
  this.encode = function(K, ge) {
    ge && wt(ge), oe = new Array(), xe = 0, se = 7, ct(65496), ct(65504), ct(16), Ze(74), Ze(70), Ze(73), Ze(70), Ze(0), Ze(1), Ze(1), Ze(0), ct(1), ct(1), Ze(0), Ze(0), function() {
      ct(65499), ct(132), Ze(0);
      for (var Ct = 0; Ct < 64; Ct++) Ze(o[Ct]);
      Ze(1);
      for (var ei = 0; ei < 64; ei++) Ze(D[ei]);
    }(), function(Ct, ei) {
      ct(65472), ct(17), Ze(8), ct(ei), ct(Ct), Ze(3), Ze(1), Ze(17), Ze(0), Ze(2), Ze(17), Ze(1), Ze(3), Ze(17), Ze(1);
    }(K.width, K.height), function() {
      ct(65476), ct(418), Ze(0);
      for (var Ct = 0; Ct < 16; Ct++) Ze(Le[Ct + 1]);
      for (var ei = 0; ei <= 11; ei++) Ze(dt[ei]);
      Ze(16);
      for (var pi = 0; pi < 16; pi++) Ze(at[pi + 1]);
      for (var fi = 0; fi <= 161; fi++) Ze(ae[fi]);
      Ze(1);
      for (var wi = 0; wi < 16; wi++) Ze(he[wi + 1]);
      for (var Ci = 0; Ci <= 11; Ci++) Ze(Ie[Ci]);
      Ze(17);
      for (var pt = 0; pt < 16; pt++) Ze(Se[pt + 1]);
      for (var Jt = 0; Jt <= 161; Jt++) Ze(et[Jt]);
    }(), ct(65498), ct(12), Ze(3), Ze(1), Ze(0), Ze(2), Ze(17), Ze(3), Ze(17), Ze(0), Ze(63), Ze(0);
    var we = 0, Ee = 0, Be = 0;
    xe = 0, se = 7, this.encode.displayName = "_encode_";
    for (var Ve, We, Ye, bt, xt, kt, zt, Ut, st, te = K.data, hi = K.width, Ht = K.height, ut = 4 * hi, _t = 0; _t < Ht; ) {
      for (Ve = 0; Ve < ut; ) {
        for (xt = ut * _t + Ve, zt = -1, Ut = 0, st = 0; st < 64; st++) kt = xt + (Ut = st >> 3) * ut + (zt = 4 * (7 & st)), _t + Ut >= Ht && (kt -= ut * (_t + 1 + Ut - Ht)), Ve + zt >= ut && (kt -= Ve + zt - ut + 4), We = te[kt++], Ye = te[kt++], bt = te[kt++], ve[st] = (gt[We] + gt[Ye + 256 >> 0] + gt[bt + 512 >> 0] >> 16) - 128, Fe[st] = (gt[We + 768 >> 0] + gt[Ye + 1024 >> 0] + gt[bt + 1280 >> 0] >> 16) - 128, it[st] = (gt[We + 1280 >> 0] + gt[Ye + 1536 >> 0] + gt[bt + 1792 >> 0] >> 16) - 128;
        we = nt(ve, j, we, g, x), Ee = nt(Fe, V, Ee, _, I), Be = nt(it, V, Be, _, I), Ve += 32;
      }
      _t += 8;
    }
    if (se >= 0) {
      var Lt = [];
      Lt[1] = se + 1, Lt[0] = (1 << se + 1) - 1, rt(Lt);
    }
    return ct(65497), new Uint8Array(oe);
  }, w = w || 50, function() {
    for (var K = String.fromCharCode, ge = 0; ge < 256; ge++) Ke[ge] = K(ge);
  }(), g = Qe(Le, dt), _ = Qe(he, Ie), x = Qe(at, ae), I = Qe(Se, et), function() {
    for (var K = 1, ge = 2, we = 1; we <= 15; we++) {
      for (var Ee = K; Ee < ge; Ee++) U[32767 + Ee] = we, q[32767 + Ee] = [], q[32767 + Ee][1] = we, q[32767 + Ee][0] = Ee;
      for (var Be = -(ge - 1); Be <= -K; Be++) U[32767 + Be] = we, q[32767 + Be] = [], q[32767 + Be][1] = we, q[32767 + Be][0] = ge - 1 + Be;
      K <<= 1, ge <<= 1;
    }
  }(), function() {
    for (var K = 0; K < 256; K++) gt[K] = 19595 * K, gt[K + 256 >> 0] = 38470 * K, gt[K + 512 >> 0] = 7471 * K + 32768, gt[K + 768 >> 0] = -11059 * K, gt[K + 1024 >> 0] = -21709 * K, gt[K + 1280 >> 0] = 32768 * K + 8421375, gt[K + 1536 >> 0] = -27439 * K, gt[K + 1792 >> 0] = -5329 * K;
  }(), wt(w);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function $a(w, g) {
  if (this.pos = 0, this.buffer = w, this.datav = new DataView(w.buffer), this.is_with_alpha = !!g, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function Wp(w) {
  function g(Le) {
    if (!Le) throw Error("assert :P");
  }
  function _(Le, dt, at) {
    for (var ae = 0; 4 > ae; ae++) if (Le[dt + ae] != at.charCodeAt(ae)) return !0;
    return !1;
  }
  function x(Le, dt, at, ae, he) {
    for (var Ie = 0; Ie < he; Ie++) Le[dt + Ie] = at[ae + Ie];
  }
  function I(Le, dt, at, ae) {
    for (var he = 0; he < ae; he++) Le[dt + he] = at;
  }
  function A(Le) {
    return new Int32Array(Le);
  }
  function v(Le, dt) {
    for (var at = [], ae = 0; ae < Le; ae++) at.push(new dt());
    return at;
  }
  function o(Le, dt) {
    var at = [];
    return function ae(he, Ie, Se) {
      for (var et = Se[Ie], Qe = 0; Qe < et && (he.push(Se.length > Ie + 1 ? [] : new dt()), !(Se.length < Ie + 1)); Qe++) ae(he[Qe], Ie + 1, Se);
    }(at, 0, Le), at;
  }
  var D = function() {
    var Le = this;
    function dt(s, l) {
      for (var p = 1 << l - 1 >>> 0; s & p; ) p >>>= 1;
      return p ? (s & p - 1) + p : s;
    }
    function at(s, l, p, b, P) {
      g(!(b % p));
      do
        s[l + (b -= p)] = P;
      while (0 < b);
    }
    function ae(s, l, p, b, P) {
      if (g(2328 >= P), 512 >= P) var C = A(512);
      else if ((C = A(P)) == null) return 0;
      return function(E, z, N, R, G, ie) {
        var H, Q, ue = z, ce = 1 << N, ne = A(16), le = A(16);
        for (g(G != 0), g(R != null), g(E != null), g(0 < N), Q = 0; Q < G; ++Q) {
          if (15 < R[Q]) return 0;
          ++ne[R[Q]];
        }
        if (ne[0] == G) return 0;
        for (le[1] = 0, H = 1; 15 > H; ++H) {
          if (ne[H] > 1 << H) return 0;
          le[H + 1] = le[H] + ne[H];
        }
        for (Q = 0; Q < G; ++Q) H = R[Q], 0 < R[Q] && (ie[le[H]++] = Q);
        if (le[15] == 1) return (R = new he()).g = 0, R.value = ie[0], at(E, ue, 1, ce, R), ce;
        var De, Ne = -1, Te = ce - 1, qe = 0, He = 1, vt = 1, Ue = 1 << N;
        for (Q = 0, H = 1, G = 2; H <= N; ++H, G <<= 1) {
          if (He += vt <<= 1, 0 > (vt -= ne[H])) return 0;
          for (; 0 < ne[H]; --ne[H]) (R = new he()).g = H, R.value = ie[Q++], at(E, ue + qe, G, Ue, R), qe = dt(qe, H);
        }
        for (H = N + 1, G = 2; 15 >= H; ++H, G <<= 1) {
          if (He += vt <<= 1, 0 > (vt -= ne[H])) return 0;
          for (; 0 < ne[H]; --ne[H]) {
            if (R = new he(), (qe & Te) != Ne) {
              for (ue += Ue, De = 1 << (Ne = H) - N; 15 > Ne && !(0 >= (De -= ne[Ne])); ) ++Ne, De <<= 1;
              ce += Ue = 1 << (De = Ne - N), E[z + (Ne = qe & Te)].g = De + N, E[z + Ne].value = ue - z - Ne;
            }
            R.g = H - N, R.value = ie[Q++], at(E, ue + (qe >> N), G, Ue, R), qe = dt(qe, H);
          }
        }
        return He != 2 * le[15] - 1 ? 0 : ce;
      }(s, l, p, b, P, C);
    }
    function he() {
      this.value = this.g = 0;
    }
    function Ie() {
      this.value = this.g = 0;
    }
    function Se() {
      this.G = v(5, he), this.H = A(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = v(Hi, Ie);
    }
    function et(s, l, p, b) {
      g(s != null), g(l != null), g(2147483648 > b), s.Ca = 254, s.I = 0, s.b = -8, s.Ka = 0, s.oa = l, s.pa = p, s.Jd = l, s.Yc = p + b, s.Zc = 4 <= b ? p + b - 4 + 1 : p, Ve(s);
    }
    function Qe(s, l) {
      for (var p = 0; 0 < l--; ) p |= Ye(s, 128) << l;
      return p;
    }
    function rt(s, l) {
      var p = Qe(s, l);
      return We(s) ? -p : p;
    }
    function Ze(s, l, p, b) {
      var P, C = 0;
      for (g(s != null), g(l != null), g(4294967288 > b), s.Sb = b, s.Ra = 0, s.u = 0, s.h = 0, 4 < b && (b = 4), P = 0; P < b; ++P) C += l[p + P] << 8 * P;
      s.Ra = C, s.bb = b, s.oa = l, s.pa = p;
    }
    function ct(s) {
      for (; 8 <= s.u && s.bb < s.Sb; ) s.Ra >>>= 8, s.Ra += s.oa[s.pa + s.bb] << fa - 8 >>> 0, ++s.bb, s.u -= 8;
      we(s) && (s.h = 1, s.u = 0);
    }
    function nt(s, l) {
      if (g(0 <= l), !s.h && l <= Da) {
        var p = ge(s) & Ma[l];
        return s.u += l, ct(s), p;
      }
      return s.h = 1, s.u = 0;
    }
    function wt() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function K() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function ge(s) {
      return s.Ra >>> (s.u & fa - 1) >>> 0;
    }
    function we(s) {
      return g(s.bb <= s.Sb), s.h || s.bb == s.Sb && s.u > fa;
    }
    function Ee(s, l) {
      s.u = l, s.h = we(s);
    }
    function Be(s) {
      s.u >= es && (g(s.u >= es), ct(s));
    }
    function Ve(s) {
      g(s != null && s.oa != null), s.pa < s.Zc ? (s.I = (s.oa[s.pa++] | s.I << 8) >>> 0, s.b += 8) : (g(s != null && s.oa != null), s.pa < s.Yc ? (s.b += 8, s.I = s.oa[s.pa++] | s.I << 8) : s.Ka ? s.b = 0 : (s.I <<= 8, s.b += 8, s.Ka = 1));
    }
    function We(s) {
      return Qe(s, 1);
    }
    function Ye(s, l) {
      var p = s.Ca;
      0 > s.b && Ve(s);
      var b = s.b, P = p * l >>> 8, C = (s.I >>> b > P) + 0;
      for (C ? (p -= P, s.I -= P + 1 << b >>> 0) : p = P + 1, b = p, P = 0; 256 <= b; ) P += 8, b >>= 8;
      return b = 7 ^ P + $r[b], s.b -= b, s.Ca = (p << b) - 1, C;
    }
    function bt(s, l, p) {
      s[l + 0] = p >> 24 & 255, s[l + 1] = p >> 16 & 255, s[l + 2] = p >> 8 & 255, s[l + 3] = p >> 0 & 255;
    }
    function xt(s, l) {
      return s[l + 0] << 0 | s[l + 1] << 8;
    }
    function kt(s, l) {
      return xt(s, l) | s[l + 2] << 16;
    }
    function zt(s, l) {
      return xt(s, l) | xt(s, l + 2) << 16;
    }
    function Ut(s, l) {
      var p = 1 << l;
      return g(s != null), g(0 < l), s.X = A(p), s.X == null ? 0 : (s.Mb = 32 - l, s.Xa = l, 1);
    }
    function st(s, l) {
      g(s != null), g(l != null), g(s.Xa == l.Xa), x(l.X, 0, s.X, 0, 1 << l.Xa);
    }
    function te() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function hi(s, l, p, b) {
      g(p != null), g(b != null);
      var P = p[0], C = b[0];
      return P == 0 && (P = (s * C + l / 2) / l), C == 0 && (C = (l * P + s / 2) / s), 0 >= P || 0 >= C ? 0 : (p[0] = P, b[0] = C, 1);
    }
    function Ht(s, l) {
      return s + (1 << l) - 1 >>> l;
    }
    function ut(s, l) {
      return ((4278255360 & s) + (4278255360 & l) >>> 0 & 4278255360) + ((16711935 & s) + (16711935 & l) >>> 0 & 16711935) >>> 0;
    }
    function _t(s, l) {
      Le[l] = function(p, b, P, C, E, z, N) {
        var R;
        for (R = 0; R < E; ++R) {
          var G = Le[s](z[N + R - 1], P, C + R);
          z[N + R] = ut(p[b + R], G);
        }
      };
    }
    function Lt() {
      this.ud = this.hd = this.jd = 0;
    }
    function Ct(s, l) {
      return ((4278124286 & (s ^ l)) >>> 1) + (s & l) >>> 0;
    }
    function ei(s) {
      return 0 <= s && 256 > s ? s : 0 > s ? 0 : 255 < s ? 255 : void 0;
    }
    function pi(s, l) {
      return ei(s + (s - l + 0.5 >> 1));
    }
    function fi(s, l, p) {
      return Math.abs(l - p) - Math.abs(s - p);
    }
    function wi(s, l, p, b, P, C, E) {
      for (b = C[E - 1], p = 0; p < P; ++p) C[E + p] = b = ut(s[l + p], b);
    }
    function Ci(s, l, p, b, P) {
      var C;
      for (C = 0; C < p; ++C) {
        var E = s[l + C], z = E >> 8 & 255, N = 16711935 & (N = (N = 16711935 & E) + ((z << 16) + z));
        b[P + C] = (4278255360 & E) + N >>> 0;
      }
    }
    function pt(s, l) {
      l.jd = s >> 0 & 255, l.hd = s >> 8 & 255, l.ud = s >> 16 & 255;
    }
    function Jt(s, l, p, b, P, C) {
      var E;
      for (E = 0; E < b; ++E) {
        var z = l[p + E], N = z >>> 8, R = z, G = 255 & (G = (G = z >>> 16) + ((s.jd << 24 >> 24) * (N << 24 >> 24) >>> 5));
        R = 255 & (R = (R = R + ((s.hd << 24 >> 24) * (N << 24 >> 24) >>> 5)) + ((s.ud << 24 >> 24) * (G << 24 >> 24) >>> 5)), P[C + E] = (4278255360 & z) + (G << 16) + R;
      }
    }
    function ui(s, l, p, b, P) {
      Le[l] = function(C, E, z, N, R, G, ie, H, Q) {
        for (N = ie; N < H; ++N) for (ie = 0; ie < Q; ++ie) R[G++] = P(z[b(C[E++])]);
      }, Le[s] = function(C, E, z, N, R, G, ie) {
        var H = 8 >> C.b, Q = C.Ea, ue = C.K[0], ce = C.w;
        if (8 > H) for (C = (1 << C.b) - 1, ce = (1 << H) - 1; E < z; ++E) {
          var ne, le = 0;
          for (ne = 0; ne < Q; ++ne) ne & C || (le = b(N[R++])), G[ie++] = P(ue[le & ce]), le >>= H;
        }
        else Le["VP8LMapColor" + p](N, R, ue, ce, G, ie, E, z, Q);
      };
    }
    function Dt(s, l, p, b, P) {
      for (p = l + p; l < p; ) {
        var C = s[l++];
        b[P++] = C >> 16 & 255, b[P++] = C >> 8 & 255, b[P++] = C >> 0 & 255;
      }
    }
    function gr(s, l, p, b, P) {
      for (p = l + p; l < p; ) {
        var C = s[l++];
        b[P++] = C >> 16 & 255, b[P++] = C >> 8 & 255, b[P++] = C >> 0 & 255, b[P++] = C >> 24 & 255;
      }
    }
    function lt(s, l, p, b, P) {
      for (p = l + p; l < p; ) {
        var C = (E = s[l++]) >> 16 & 240 | E >> 12 & 15, E = E >> 0 & 240 | E >> 28 & 15;
        b[P++] = C, b[P++] = E;
      }
    }
    function li(s, l, p, b, P) {
      for (p = l + p; l < p; ) {
        var C = (E = s[l++]) >> 16 & 248 | E >> 13 & 7, E = E >> 5 & 224 | E >> 3 & 31;
        b[P++] = C, b[P++] = E;
      }
    }
    function Bt(s, l, p, b, P) {
      for (p = l + p; l < p; ) {
        var C = s[l++];
        b[P++] = C >> 0 & 255, b[P++] = C >> 8 & 255, b[P++] = C >> 16 & 255;
      }
    }
    function ki(s, l, p, b, P, C) {
      if (C == 0) for (p = l + p; l < p; ) bt(b, ((C = s[l++])[0] >> 24 | C[1] >> 8 & 65280 | C[2] << 8 & 16711680 | C[3] << 24) >>> 0), P += 32;
      else x(b, P, s, l, p);
    }
    function lr(s, l) {
      Le[l][0] = Le[s + "0"], Le[l][1] = Le[s + "1"], Le[l][2] = Le[s + "2"], Le[l][3] = Le[s + "3"], Le[l][4] = Le[s + "4"], Le[l][5] = Le[s + "5"], Le[l][6] = Le[s + "6"], Le[l][7] = Le[s + "7"], Le[l][8] = Le[s + "8"], Le[l][9] = Le[s + "9"], Le[l][10] = Le[s + "10"], Le[l][11] = Le[s + "11"], Le[l][12] = Le[s + "12"], Le[l][13] = Le[s + "13"], Le[l][14] = Le[s + "0"], Le[l][15] = Le[s + "0"];
    }
    function Ft(s) {
      return s == xs || s == ll || s == fo || s == qo;
    }
    function nn() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function Oi() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function $i() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new nn(), this.f.kb = new Oi(), this.sd = null;
    }
    function de() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function Z() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function W(s) {
      return alert("todo:WebPSamplerProcessPlane"), s.T;
    }
    function J(s, l) {
      var p = s.T, b = l.ba.f.RGBA, P = b.eb, C = b.fb + s.ka * b.A, E = On[l.ba.S], z = s.y, N = s.O, R = s.f, G = s.N, ie = s.ea, H = s.W, Q = l.cc, ue = l.dc, ce = l.Mc, ne = l.Nc, le = s.ka, De = s.ka + s.T, Ne = s.U, Te = Ne + 1 >> 1;
      for (le == 0 ? E(z, N, null, null, R, G, ie, H, R, G, ie, H, P, C, null, null, Ne) : (E(l.ec, l.fc, z, N, Q, ue, ce, ne, R, G, ie, H, P, C - b.A, P, C, Ne), ++p); le + 2 < De; le += 2) Q = R, ue = G, ce = ie, ne = H, G += s.Rc, H += s.Rc, C += 2 * b.A, E(z, (N += 2 * s.fa) - s.fa, z, N, Q, ue, ce, ne, R, G, ie, H, P, C - b.A, P, C, Ne);
      return N += s.fa, s.j + De < s.o ? (x(l.ec, l.fc, z, N, Ne), x(l.cc, l.dc, R, G, Te), x(l.Mc, l.Nc, ie, H, Te), p--) : 1 & De || E(z, N, null, null, R, G, ie, H, R, G, ie, H, P, C + b.A, null, null, Ne), p;
    }
    function fe(s, l, p) {
      var b = s.F, P = [s.J];
      if (b != null) {
        var C = s.U, E = l.ba.S, z = E == Ra || E == fo;
        l = l.ba.f.RGBA;
        var N = [0], R = s.ka;
        N[0] = s.T, s.Kb && (R == 0 ? --N[0] : (--R, P[0] -= s.width), s.j + s.ka + s.T == s.o && (N[0] = s.o - s.j - R));
        var G = l.eb;
        R = l.fb + R * l.A, s = Fa(b, P[0], s.width, C, N, G, R + (z ? 0 : 3), l.A), g(p == N), s && Ft(E) && Os(G, R, z, C, N, l.A);
      }
      return 0;
    }
    function Ae(s) {
      var l = s.ma, p = l.ba.S, b = 11 > p, P = p == Na || p == po || p == Ra || p == jo || p == 12 || Ft(p);
      if (l.memory = null, l.Ib = null, l.Jb = null, l.Nd = null, !pa(l.Oa, s, P ? 11 : 12)) return 0;
      if (P && Ft(p) && yt(), s.da) alert("todo:use_scaling");
      else {
        if (b) {
          if (l.Ib = W, s.Kb) {
            if (p = s.U + 1 >> 1, l.memory = A(s.U + 2 * p), l.memory == null) return 0;
            l.ec = l.memory, l.fc = 0, l.cc = l.ec, l.dc = l.fc + s.U, l.Mc = l.cc, l.Nc = l.dc + p, l.Ib = J, yt();
          }
        } else alert("todo:EmitYUV");
        P && (l.Jb = fe, b && je());
      }
      if (b && !go) {
        for (s = 0; 256 > s; ++s) Ss[s] = 89858 * (s - 128) + Ba >> ji, ni[s] = -22014 * (s - 128) + Ba, Vt[s] = -45773 * (s - 128), ul[s] = 113618 * (s - 128) + Ba >> ji;
        for (s = ws; s < wa; ++s) l = 76283 * (s - 16) + Ba >> ji, f[s - ws] = hn(l, 255), t[s - ws] = hn(l + 8 >> 4, 15);
        go = 1;
      }
      return 1;
    }
    function Ce(s) {
      var l = s.ma, p = s.U, b = s.T;
      return g(!(1 & s.ka)), 0 >= p || 0 >= b ? 0 : (p = l.Ib(s, l), l.Jb != null && l.Jb(s, l, p), l.Dc += p, 1);
    }
    function Me(s) {
      s.ma.memory = null;
    }
    function pe(s, l, p, b) {
      return nt(s, 8) != 47 ? 0 : (l[0] = nt(s, 14) + 1, p[0] = nt(s, 14) + 1, b[0] = nt(s, 1), nt(s, 3) != 0 ? 0 : !s.h);
    }
    function Oe(s, l) {
      if (4 > s) return s + 1;
      var p = s - 2 >> 1;
      return (2 + (1 & s) << p) + nt(l, p) + 1;
    }
    function ot(s, l) {
      return 120 < l ? l - 120 : 1 <= (p = ((p = Fl[l - 1]) >> 4) * s + (8 - (15 & p))) ? p : 1;
      var p;
    }
    function Je(s, l, p) {
      var b = ge(p), P = s[l += 255 & b].g - 8;
      return 0 < P && (Ee(p, p.u + 8), b = ge(p), l += s[l].value, l += b & (1 << P) - 1), Ee(p, p.u + s[l].g), s[l].value;
    }
    function Ge(s, l, p) {
      return p.g += s.g, p.value += s.value << l >>> 0, g(8 >= p.g), s.g;
    }
    function It(s, l, p) {
      var b = s.xc;
      return g((l = b == 0 ? 0 : s.vc[s.md * (p >> b) + (l >> b)]) < s.Wb), s.Ya[l];
    }
    function Nt(s, l, p, b) {
      var P = s.ab, C = s.c * l, E = s.C;
      l = E + l;
      var z = p, N = b;
      for (b = s.Ta, p = s.Ua; 0 < P--; ) {
        var R = s.gc[P], G = E, ie = l, H = z, Q = N, ue = (N = b, z = p, R.Ea);
        switch (g(G < ie), g(ie <= R.nc), R.hc) {
          case 2:
            za(H, Q, (ie - G) * ue, N, z);
            break;
          case 0:
            var ce = G, ne = ie, le = N, De = z, Ne = (Ue = R).Ea;
            ce == 0 && (co(H, Q, null, null, 1, le, De), wi(H, Q + 1, 0, 0, Ne - 1, le, De + 1), Q += Ne, De += Ne, ++ce);
            for (var Te = 1 << Ue.b, qe = Te - 1, He = Ht(Ne, Ue.b), vt = Ue.K, Ue = Ue.w + (ce >> Ue.b) * He; ce < ne; ) {
              var ft = vt, Tt = Ue, ii = 1;
              for (Rs(H, Q, le, De - Ne, 1, le, De); ii < Ne; ) {
                var Mt = (ii & ~qe) + Te;
                Mt > Ne && (Mt = Ne), (0, rs[ft[Tt++] >> 8 & 15])(H, Q + +ii, le, De + ii - Ne, Mt - ii, le, De + ii), ii = Mt;
              }
              Q += Ne, De += Ne, ++ce & qe || (Ue += He);
            }
            ie != R.nc && x(N, z - ue, N, z + (ie - G - 1) * ue, ue);
            break;
          case 1:
            for (ue = H, ne = Q, Ne = (H = R.Ea) - (De = H & ~(le = (Q = 1 << R.b) - 1)), ce = Ht(H, R.b), Te = R.K, R = R.w + (G >> R.b) * ce; G < ie; ) {
              for (qe = Te, He = R, vt = new Lt(), Ue = ne + De, ft = ne + H; ne < Ue; ) pt(qe[He++], vt), _i(vt, ue, ne, Q, N, z), ne += Q, z += Q;
              ne < ft && (pt(qe[He++], vt), _i(vt, ue, ne, Ne, N, z), ne += Ne, z += Ne), ++G & le || (R += ce);
            }
            break;
          case 3:
            if (H == N && Q == z && 0 < R.b) {
              for (ne = N, H = ue = z + (ie - G) * ue - (De = (ie - G) * Ht(R.Ea, R.b)), Q = N, le = z, ce = [], De = (Ne = De) - 1; 0 <= De; --De) ce[De] = Q[le + De];
              for (De = Ne - 1; 0 <= De; --De) ne[H + De] = ce[De];
              Sn(R, G, ie, N, ue, N, z);
            } else Sn(R, G, ie, H, Q, N, z);
        }
        z = b, N = p;
      }
      N != p && x(b, p, z, N, C);
    }
    function gi(s, l) {
      var p = s.V, b = s.Ba + s.c * s.C, P = l - s.C;
      if (g(l <= s.l.o), g(16 >= P), 0 < P) {
        var C = s.l, E = s.Ta, z = s.Ua, N = C.width;
        if (Nt(s, P, p, b), P = z = [z], g((p = s.C) < (b = l)), g(C.v < C.va), b > C.o && (b = C.o), p < C.j) {
          var R = C.j - p;
          p = C.j, P[0] += R * N;
        }
        if (p >= b ? p = 0 : (P[0] += 4 * C.v, C.ka = p - C.j, C.U = C.va - C.v, C.T = b - p, p = 1), p) {
          if (z = z[0], 11 > (p = s.ca).S) {
            var G = p.f.RGBA, ie = (b = p.S, P = C.U, C = C.T, R = G.eb, G.A), H = C;
            for (G = G.fb + s.Ma * G.A; 0 < H--; ) {
              var Q = E, ue = z, ce = P, ne = R, le = G;
              switch (b) {
                case qs:
                  Qr(Q, ue, ce, ne, le);
                  break;
                case Na:
                  ns(Q, ue, ce, ne, le);
                  break;
                case xs:
                  ns(Q, ue, ce, ne, le), Os(ne, le, 0, ce, 1, 0);
                  break;
                case ol:
                  ma(Q, ue, ce, ne, le);
                  break;
                case po:
                  ki(Q, ue, ce, ne, le, 1);
                  break;
                case ll:
                  ki(Q, ue, ce, ne, le, 1), Os(ne, le, 0, ce, 1, 0);
                  break;
                case Ra:
                  ki(Q, ue, ce, ne, le, 0);
                  break;
                case fo:
                  ki(Q, ue, ce, ne, le, 0), Os(ne, le, 1, ce, 1, 0);
                  break;
                case jo:
                  un(Q, ue, ce, ne, le);
                  break;
                case qo:
                  un(Q, ue, ce, ne, le), js(ne, le, ce, 1, 0);
                  break;
                case El:
                  dn(Q, ue, ce, ne, le);
                  break;
                default:
                  g(0);
              }
              z += N, G += ie;
            }
            s.Ma += C;
          } else alert("todo:EmitRescaledRowsYUVA");
          g(s.Ma <= p.height);
        }
      }
      s.C = l, g(s.C <= s.i);
    }
    function ti(s) {
      var l;
      if (0 < s.ua) return 0;
      for (l = 0; l < s.Wb; ++l) {
        var p = s.Ya[l].G, b = s.Ya[l].H;
        if (0 < p[1][b[1] + 0].g || 0 < p[2][b[2] + 0].g || 0 < p[3][b[3] + 0].g) return 0;
      }
      return 1;
    }
    function mi(s, l, p, b, P, C) {
      if (s.Z != 0) {
        var E = s.qd, z = s.rd;
        for (g(bs[s.Z] != null); l < p; ++l) bs[s.Z](E, z, b, P, b, P, C), E = b, z = P, P += C;
        s.qd = E, s.rd = z;
      }
    }
    function Ii(s, l) {
      var p = s.l.ma, b = p.Z == 0 || p.Z == 1 ? s.l.j : s.C;
      if (b = s.C < b ? b : s.C, g(l <= s.l.o), l > b) {
        var P = s.l.width, C = p.ca, E = p.tb + P * b, z = s.V, N = s.Ba + s.c * b, R = s.gc;
        g(s.ab == 1), g(R[0].hc == 3), is(R[0], b, l, z, N, C, E), mi(p, b, l, C, E, P);
      }
      s.C = s.Ma = l;
    }
    function Ei(s, l, p, b, P, C, E) {
      var z = s.$ / b, N = s.$ % b, R = s.m, G = s.s, ie = p + s.$, H = ie;
      P = p + b * P;
      var Q = p + b * C, ue = 280 + G.ua, ce = s.Pb ? z : 16777216, ne = 0 < G.ua ? G.Wa : null, le = G.wc, De = ie < Q ? It(G, N, z) : null;
      g(s.C < C), g(Q <= P);
      var Ne = !1;
      e: for (; ; ) {
        for (; Ne || ie < Q; ) {
          var Te = 0;
          if (z >= ce) {
            var qe = ie - p;
            g((ce = s).Pb), ce.wd = ce.m, ce.xd = qe, 0 < ce.s.ua && st(ce.s.Wa, ce.s.vb), ce = z + Pn;
          }
          if (N & le || (De = It(G, N, z)), g(De != null), De.Qb && (l[ie] = De.qb, Ne = !0), !Ne) if (Be(R), De.jc) {
            Te = R, qe = l;
            var He = ie, vt = De.pd[ge(Te) & Hi - 1];
            g(De.jc), 256 > vt.g ? (Ee(Te, Te.u + vt.g), qe[He] = vt.value, Te = 0) : (Ee(Te, Te.u + vt.g - 256), g(256 <= vt.value), Te = vt.value), Te == 0 && (Ne = !0);
          } else Te = Je(De.G[0], De.H[0], R);
          if (R.h) break;
          if (Ne || 256 > Te) {
            if (!Ne) if (De.nd) l[ie] = (De.qb | Te << 8) >>> 0;
            else {
              if (Be(R), Ne = Je(De.G[1], De.H[1], R), Be(R), qe = Je(De.G[2], De.H[2], R), He = Je(De.G[3], De.H[3], R), R.h) break;
              l[ie] = (He << 24 | Ne << 16 | Te << 8 | qe) >>> 0;
            }
            if (Ne = !1, ++ie, ++N >= b && (N = 0, ++z, E != null && z <= C && !(z % 16) && E(s, z), ne != null)) for (; H < ie; ) Te = l[H++], ne.X[(506832829 * Te & 4294967295) >>> ne.Mb] = Te;
          } else if (280 > Te) {
            if (Te = Oe(Te - 256, R), qe = Je(De.G[4], De.H[4], R), Be(R), qe = ot(b, qe = Oe(qe, R)), R.h) break;
            if (ie - p < qe || P - ie < Te) break e;
            for (He = 0; He < Te; ++He) l[ie + He] = l[ie + He - qe];
            for (ie += Te, N += Te; N >= b; ) N -= b, ++z, E != null && z <= C && !(z % 16) && E(s, z);
            if (g(ie <= P), N & le && (De = It(G, N, z)), ne != null) for (; H < ie; ) Te = l[H++], ne.X[(506832829 * Te & 4294967295) >>> ne.Mb] = Te;
          } else {
            if (!(Te < ue)) break e;
            for (Ne = Te - 280, g(ne != null); H < ie; ) Te = l[H++], ne.X[(506832829 * Te & 4294967295) >>> ne.Mb] = Te;
            Te = ie, g(!(Ne >>> (qe = ne).Xa)), l[Te] = qe.X[Ne], Ne = !0;
          }
          Ne || g(R.h == we(R));
        }
        if (s.Pb && R.h && ie < P) g(s.m.h), s.a = 5, s.m = s.wd, s.$ = s.xd, 0 < s.s.ua && st(s.s.vb, s.s.Wa);
        else {
          if (R.h) break e;
          E != null && E(s, z > C ? C : z), s.a = 0, s.$ = ie - p;
        }
        return 1;
      }
      return s.a = 3, 0;
    }
    function Ui(s) {
      g(s != null), s.vc = null, s.yc = null, s.Ya = null;
      var l = s.Wa;
      l != null && (l.X = null), s.vb = null, g(s != null);
    }
    function ai() {
      var s = new sl();
      return s == null ? null : (s.a = 0, s.xb = Pt, lr("Predictor", "VP8LPredictors"), lr("Predictor", "VP8LPredictors_C"), lr("PredictorAdd", "VP8LPredictorsAdd"), lr("PredictorAdd", "VP8LPredictorsAdd_C"), za = Ci, _i = Jt, Qr = Dt, ns = gr, un = lt, dn = li, ma = Bt, Le.VP8LMapColor32b = ts, Le.VP8LMapColor8b = al, s);
    }
    function Fi(s, l, p, b, P) {
      var C = 1, E = [s], z = [l], N = b.m, R = b.s, G = null, ie = 0;
      e: for (; ; ) {
        if (p) for (; C && nt(N, 1); ) {
          var H = E, Q = z, ue = b, ce = 1, ne = ue.m, le = ue.gc[ue.ab], De = nt(ne, 2);
          if (ue.Oc & 1 << De) C = 0;
          else {
            switch (ue.Oc |= 1 << De, le.hc = De, le.Ea = H[0], le.nc = Q[0], le.K = [null], ++ue.ab, g(4 >= ue.ab), De) {
              case 0:
              case 1:
                le.b = nt(ne, 3) + 2, ce = Fi(Ht(le.Ea, le.b), Ht(le.nc, le.b), 0, ue, le.K), le.K = le.K[0];
                break;
              case 3:
                var Ne, Te = nt(ne, 8) + 1, qe = 16 < Te ? 0 : 4 < Te ? 1 : 2 < Te ? 2 : 3;
                if (H[0] = Ht(le.Ea, qe), le.b = qe, Ne = ce = Fi(Te, 1, 0, ue, le.K)) {
                  var He, vt = Te, Ue = le, ft = 1 << (8 >> Ue.b), Tt = A(ft);
                  if (Tt == null) Ne = 0;
                  else {
                    var ii = Ue.K[0], Mt = Ue.w;
                    for (Tt[0] = Ue.K[0][0], He = 1; He < 1 * vt; ++He) Tt[He] = ut(ii[Mt + He], Tt[He - 1]);
                    for (; He < 4 * ft; ++He) Tt[He] = 0;
                    Ue.K[0] = null, Ue.K[0] = Tt, Ne = 1;
                  }
                }
                ce = Ne;
                break;
              case 2:
                break;
              default:
                g(0);
            }
            C = ce;
          }
        }
        if (E = E[0], z = z[0], C && nt(N, 1) && !(C = 1 <= (ie = nt(N, 4)) && 11 >= ie)) {
          b.a = 3;
          break e;
        }
        var Wt;
        if (Wt = C) t: {
          var ci, si, qi, Ti = b, Ni = E, Wi = z, bi = ie, Gi = p, fr = Ti.m, ur = Ti.s, Tr = [null], kr = 1, qr = 0, In = Bn[bi];
          i: for (; ; ) {
            if (Gi && nt(fr, 1)) {
              var Lr = nt(fr, 3) + 2, nr = Ht(Ni, Lr), Zr = Ht(Wi, Lr), Tn = nr * Zr;
              if (!Fi(nr, Zr, 0, Ti, Tr)) break i;
              for (Tr = Tr[0], ur.xc = Lr, ci = 0; ci < Tn; ++ci) {
                var kn = Tr[ci] >> 8 & 65535;
                Tr[ci] = kn, kn >= kr && (kr = kn + 1);
              }
            }
            if (fr.h) break i;
            for (si = 0; 5 > si; ++si) {
              var Li = Dl[si];
              !si && 0 < bi && (Li += 1 << bi), qr < Li && (qr = Li);
            }
            var Ur = v(kr * In, he), zr = kr, sr = v(zr, Se);
            if (sr == null) var Zs = null;
            else g(65536 >= zr), Zs = sr;
            var Oa = A(qr);
            if (Zs == null || Oa == null || Ur == null) {
              Ti.a = 1;
              break i;
            }
            var vr = Ur;
            for (ci = qi = 0; ci < kr; ++ci) {
              var jn = Zs[ci], Ws = jn.G, Gs = jn.H, Hs = 0, Vo = 1, dl = 0;
              for (si = 0; 5 > si; ++si) {
                Li = Dl[si], Ws[si] = vr, Gs[si] = qi, !si && 0 < bi && (Li += 1 << bi);
                n: {
                  var yo, $o = Li, ja = Ti, As = Oa, sh = vr, Ec = qi, pl = 0, qn = ja.m, lc = nt(qn, 1);
                  if (I(As, 0, 0, $o), lc) {
                    var ah = nt(qn, 1) + 1, oh = nt(qn, 1), lh = nt(qn, oh == 0 ? 1 : 8);
                    As[lh] = 1, ah == 2 && (As[lh = nt(qn, 8)] = 1);
                    var fl = 1;
                  } else {
                    var ml = A(19), Zo = nt(qn, 4) + 4;
                    if (19 < Zo) {
                      ja.a = 3;
                      var Ps = 0;
                      break n;
                    }
                    for (yo = 0; yo < Zo; ++yo) ml[mo[yo]] = nt(qn, 3);
                    var as = void 0, Is = void 0, Mc = ja, Wo = ml, cc = $o, Dc = As, xr = 0, Sa = Mc.m, zc = 8, _o = v(128, he);
                    r: for (; ae(_o, 0, 7, Wo, 19); ) {
                      if (nt(Sa, 1)) {
                        var Go = 2 + 2 * nt(Sa, 3);
                        if ((as = 2 + nt(Sa, Go)) > cc) break r;
                      } else as = cc;
                      for (Is = 0; Is < cc && as--; ) {
                        Be(Sa);
                        var Vl = _o[0 + (127 & ge(Sa))];
                        Ee(Sa, Sa.u + Vl.g);
                        var vo = Vl.value;
                        if (16 > vo) Dc[Is++] = vo, vo != 0 && (zc = vo);
                        else {
                          var ch = vo == 16, hh = vo - 16, uh = nc[hh], dh = nt(Sa, Ml[hh]) + uh;
                          if (Is + dh > cc) break r;
                          for (var Fc = ch ? zc : 0; 0 < dh--; ) Dc[Is++] = Fc;
                        }
                      }
                      xr = 1;
                      break r;
                    }
                    xr || (Mc.a = 3), fl = xr;
                  }
                  (fl = fl && !qn.h) && (pl = ae(sh, Ec, 8, As, $o)), fl && pl != 0 ? Ps = pl : (ja.a = 3, Ps = 0);
                }
                if (Ps == 0) break i;
                if (Vo && zl[si] == 1 && (Vo = vr[qi].g == 0), Hs += vr[qi].g, qi += Ps, 3 >= si) {
                  var $l, Zl = Oa[0];
                  for ($l = 1; $l < Li; ++$l) Oa[$l] > Zl && (Zl = Oa[$l]);
                  dl += Zl;
                }
              }
              if (jn.nd = Vo, jn.Qb = 0, Vo && (jn.qb = (Ws[3][Gs[3] + 0].value << 24 | Ws[1][Gs[1] + 0].value << 16 | Ws[2][Gs[2] + 0].value) >>> 0, Hs == 0 && 256 > Ws[0][Gs[0] + 0].value && (jn.Qb = 1, jn.qb += Ws[0][Gs[0] + 0].value << 8)), jn.jc = !jn.Qb && 6 > dl, jn.jc) {
                var Wl, Aa = jn;
                for (Wl = 0; Wl < Hi; ++Wl) {
                  var os = Wl, xo = Aa.pd[os], bo = Aa.G[0][Aa.H[0] + os];
                  256 <= bo.value ? (xo.g = bo.g + 256, xo.value = bo.value) : (xo.g = 0, xo.value = 0, os >>= Ge(bo, 8, xo), os >>= Ge(Aa.G[1][Aa.H[1] + os], 16, xo), os >>= Ge(Aa.G[2][Aa.H[2] + os], 0, xo), Ge(Aa.G[3][Aa.H[3] + os], 24, xo));
                }
              }
            }
            ur.vc = Tr, ur.Wb = kr, ur.Ya = Zs, ur.yc = Ur, Wt = 1;
            break t;
          }
          Wt = 0;
        }
        if (!(C = Wt)) {
          b.a = 3;
          break e;
        }
        if (0 < ie) {
          if (R.ua = 1 << ie, !Ut(R.Wa, ie)) {
            b.a = 1, C = 0;
            break e;
          }
        } else R.ua = 0;
        var gl = b, Gl = E, ph = z, hc = gl.s, Nc = hc.xc;
        if (gl.c = Gl, gl.i = ph, hc.md = Ht(Gl, Nc), hc.wc = Nc == 0 ? -1 : (1 << Nc) - 1, p) {
          b.xb = ac;
          break e;
        }
        if ((G = A(E * z)) == null) {
          b.a = 1, C = 0;
          break e;
        }
        C = (C = Ei(b, G, 0, E, z, z, null)) && !N.h;
        break e;
      }
      return C ? (P != null ? P[0] = G : (g(G == null), g(p)), b.$ = 0, p || Ui(R)) : Ui(R), C;
    }
    function er(s, l) {
      var p = s.c * s.i, b = p + l + 16 * l;
      return g(s.c <= l), s.V = A(b), s.V == null ? (s.Ta = null, s.Ua = 0, s.a = 1, 0) : (s.Ta = s.V, s.Ua = s.Ba + p + l, 1);
    }
    function Mr(s, l) {
      var p = s.C, b = l - p, P = s.V, C = s.Ba + s.c * p;
      for (g(l <= s.l.o); 0 < b; ) {
        var E = 16 < b ? 16 : b, z = s.l.ma, N = s.l.width, R = N * E, G = z.ca, ie = z.tb + N * p, H = s.Ta, Q = s.Ua;
        Nt(s, E, P, C), va(H, Q, G, ie, R), mi(z, p, p + E, G, ie, N), b -= E, P += E * s.c, p += E;
      }
      g(p == l), s.C = s.Ma = l;
    }
    function Nr() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function cr() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Jn() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = A(4), this.Lb = A(4);
    }
    function Qo() {
      this.Yb = function() {
        var s = [];
        return function l(p, b, P) {
          for (var C = P[b], E = 0; E < C && (p.push(P.length > b + 1 ? [] : 0), !(P.length < b + 1)); E++) l(p[E], b + 1, P);
        }(s, 0, [3, 11]), s;
      }();
    }
    function Ri() {
      this.jb = A(3), this.Wc = o([4, 8], Qo), this.Xc = o([4, 17], Qo);
    }
    function Co() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new A(4), this.od = new A(4);
    }
    function ea() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Yr() {
      this.Na = this.la = 0;
    }
    function Jr() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Cs() {
      this.ad = A(384), this.Za = 0, this.Ob = A(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Kr() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new ea()), this.Y = 0, this.ya = Array(new Cs()), this.aa = 0, this.l = new cn();
    }
    function sn() {
      this.y = A(16), this.f = A(8), this.ea = A(8);
    }
    function el() {
      this.cb = this.a = 0, this.sc = "", this.m = new wt(), this.Od = new Nr(), this.Kc = new cr(), this.ed = new Co(), this.Qa = new Jn(), this.Ic = this.$c = this.Aa = 0, this.D = new Kr(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = v(8, wt), this.ia = 0, this.pb = v(4, Jr), this.Pa = new Ri(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new sn()), this.Hd = 0, this.rb = Array(new Yr()), this.sb = 0, this.wa = Array(new ea()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Cs()), this.L = this.aa = 0, this.gd = o([4, 2], ea), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function cn() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function yr() {
      var s = new el();
      return s != null && (s.a = 0, s.sc = "OK", s.cb = 0, s.Xb = 0, Us || (Us = ds)), s;
    }
    function tr(s, l, p) {
      return s.a == 0 && (s.a = l, s.sc = p, s.cb = 0), 0;
    }
    function us(s, l, p) {
      return 3 <= p && s[l + 0] == 157 && s[l + 1] == 1 && s[l + 2] == 42;
    }
    function ir(s, l) {
      if (s == null) return 0;
      if (s.a = 0, s.sc = "OK", l == null) return tr(s, 2, "null VP8Io passed to VP8GetHeaders()");
      var p = l.data, b = l.w, P = l.ha;
      if (4 > P) return tr(s, 7, "Truncated header.");
      var C = p[b + 0] | p[b + 1] << 8 | p[b + 2] << 16, E = s.Od;
      if (E.Rb = !(1 & C), E.td = C >> 1 & 7, E.yd = C >> 4 & 1, E.ub = C >> 5, 3 < E.td) return tr(s, 3, "Incorrect keyframe parameters.");
      if (!E.yd) return tr(s, 4, "Frame not displayable.");
      b += 3, P -= 3;
      var z = s.Kc;
      if (E.Rb) {
        if (7 > P) return tr(s, 7, "cannot parse picture header");
        if (!us(p, b, P)) return tr(s, 3, "Bad code word");
        z.c = 16383 & (p[b + 4] << 8 | p[b + 3]), z.Td = p[b + 4] >> 6, z.i = 16383 & (p[b + 6] << 8 | p[b + 5]), z.Ud = p[b + 6] >> 6, b += 7, P -= 7, s.za = z.c + 15 >> 4, s.Ub = z.i + 15 >> 4, l.width = z.c, l.height = z.i, l.Da = 0, l.j = 0, l.v = 0, l.va = l.width, l.o = l.height, l.da = 0, l.ib = l.width, l.hb = l.height, l.U = l.width, l.T = l.height, I((C = s.Pa).jb, 0, 255, C.jb.length), g((C = s.Qa) != null), C.Cb = 0, C.Bb = 0, C.Fb = 1, I(C.Zb, 0, 0, C.Zb.length), I(C.Lb, 0, 0, C.Lb);
      }
      if (E.ub > P) return tr(s, 7, "bad partition length");
      et(C = s.m, p, b, E.ub), b += E.ub, P -= E.ub, E.Rb && (z.Ld = We(C), z.Kd = We(C)), z = s.Qa;
      var N, R = s.Pa;
      if (g(C != null), g(z != null), z.Cb = We(C), z.Cb) {
        if (z.Bb = We(C), We(C)) {
          for (z.Fb = We(C), N = 0; 4 > N; ++N) z.Zb[N] = We(C) ? rt(C, 7) : 0;
          for (N = 0; 4 > N; ++N) z.Lb[N] = We(C) ? rt(C, 6) : 0;
        }
        if (z.Bb) for (N = 0; 3 > N; ++N) R.jb[N] = We(C) ? Qe(C, 8) : 255;
      } else z.Bb = 0;
      if (C.Ka) return tr(s, 3, "cannot parse segment header");
      if ((z = s.ed).zd = We(C), z.Tb = Qe(C, 6), z.wb = Qe(C, 3), z.Pc = We(C), z.Pc && We(C)) {
        for (R = 0; 4 > R; ++R) We(C) && (z.vd[R] = rt(C, 6));
        for (R = 0; 4 > R; ++R) We(C) && (z.od[R] = rt(C, 6));
      }
      if (s.L = z.Tb == 0 ? 0 : z.zd ? 1 : 2, C.Ka) return tr(s, 3, "cannot parse filter header");
      var G = P;
      if (P = N = b, b = N + G, z = G, s.Xb = (1 << Qe(s.m, 2)) - 1, G < 3 * (R = s.Xb)) p = 7;
      else {
        for (N += 3 * R, z -= 3 * R, G = 0; G < R; ++G) {
          var ie = p[P + 0] | p[P + 1] << 8 | p[P + 2] << 16;
          ie > z && (ie = z), et(s.Jc[+G], p, N, ie), N += ie, z -= ie, P += 3;
        }
        et(s.Jc[+R], p, N, z), p = N < b ? 0 : 5;
      }
      if (p != 0) return tr(s, p, "cannot parse partitions");
      for (p = Qe(N = s.m, 7), P = We(N) ? rt(N, 4) : 0, b = We(N) ? rt(N, 4) : 0, z = We(N) ? rt(N, 4) : 0, R = We(N) ? rt(N, 4) : 0, N = We(N) ? rt(N, 4) : 0, G = s.Qa, ie = 0; 4 > ie; ++ie) {
        if (G.Cb) {
          var H = G.Zb[ie];
          G.Fb || (H += p);
        } else {
          if (0 < ie) {
            s.pb[ie] = s.pb[0];
            continue;
          }
          H = p;
        }
        var Q = s.pb[ie];
        Q.Sc[0] = cl[hn(H + P, 127)], Q.Sc[1] = gn[hn(H + 0, 127)], Q.Eb[0] = 2 * cl[hn(H + b, 127)], Q.Eb[1] = 101581 * gn[hn(H + z, 127)] >> 16, 8 > Q.Eb[1] && (Q.Eb[1] = 8), Q.Qc[0] = cl[hn(H + R, 117)], Q.Qc[1] = gn[hn(H + N, 127)], Q.lc = H + N;
      }
      if (!E.Rb) return tr(s, 4, "Not a key frame.");
      for (We(C), E = s.Pa, p = 0; 4 > p; ++p) {
        for (P = 0; 8 > P; ++P) for (b = 0; 3 > b; ++b) for (z = 0; 11 > z; ++z) R = Ye(C, xa[p][P][b][z]) ? Qe(C, 8) : Rl[p][P][b][z], E.Wc[p][P].Yb[b][z] = R;
        for (P = 0; 17 > P; ++P) E.Xc[p][P] = E.Wc[p][Rt[P]];
      }
      return s.kc = We(C), s.kc && (s.Bd = Qe(C, 8)), s.cb = 1;
    }
    function ds(s, l, p, b, P, C, E) {
      var z = l[P].Yb[p];
      for (p = 0; 16 > P; ++P) {
        if (!Ye(s, z[p + 0])) return P;
        for (; !Ye(s, z[p + 1]); ) if (z = l[++P].Yb[0], p = 0, P == 16) return 16;
        var N = l[P + 1].Yb;
        if (Ye(s, z[p + 2])) {
          var R = s, G = 0;
          if (Ye(R, (H = z)[(ie = p) + 3])) if (Ye(R, H[ie + 6])) {
            for (z = 0, ie = 2 * (G = Ye(R, H[ie + 8])) + (H = Ye(R, H[ie + 9 + G])), G = 0, H = Cc[ie]; H[z]; ++z) G += G + Ye(R, H[z]);
            G += 3 + (8 << ie);
          } else Ye(R, H[ie + 7]) ? (G = 7 + 2 * Ye(R, 165), G += Ye(R, 145)) : G = 5 + Ye(R, 159);
          else G = Ye(R, H[ie + 4]) ? 3 + Ye(R, H[ie + 5]) : 2;
          z = N[2];
        } else G = 1, z = N[1];
        N = E + sc[P], 0 > (R = s).b && Ve(R);
        var ie, H = R.b, Q = (ie = R.Ca >> 1) - (R.I >> H) >> 31;
        --R.b, R.Ca += Q, R.Ca |= 1, R.I -= (ie + 1 & Q) << H, C[N] = ((G ^ Q) - Q) * b[(0 < P) + 0];
      }
      return 16;
    }
    function an(s) {
      var l = s.rb[s.sb - 1];
      l.la = 0, l.Na = 0, I(s.zc, 0, 0, s.zc.length), s.ja = 0;
    }
    function Ga(s, l) {
      if (s == null) return 0;
      if (l == null) return tr(s, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!s.cb && !ir(s, l)) return 0;
      if (g(s.cb), l.ac == null || l.ac(l)) {
        l.ob && (s.L = 0);
        var p = c[s.L];
        if (s.L == 2 ? (s.yb = 0, s.zb = 0) : (s.yb = l.v - p >> 4, s.zb = l.j - p >> 4, 0 > s.yb && (s.yb = 0), 0 > s.zb && (s.zb = 0)), s.Va = l.o + 15 + p >> 4, s.Hb = l.va + 15 + p >> 4, s.Hb > s.za && (s.Hb = s.za), s.Va > s.Ub && (s.Va = s.Ub), 0 < s.L) {
          var b = s.ed;
          for (p = 0; 4 > p; ++p) {
            var P;
            if (s.Qa.Cb) {
              var C = s.Qa.Lb[p];
              s.Qa.Fb || (C += b.Tb);
            } else C = b.Tb;
            for (P = 0; 1 >= P; ++P) {
              var E = s.gd[p][P], z = C;
              if (b.Pc && (z += b.vd[0], P && (z += b.od[0])), 0 < (z = 0 > z ? 0 : 63 < z ? 63 : z)) {
                var N = z;
                0 < b.wb && (N = 4 < b.wb ? N >> 2 : N >> 1) > 9 - b.wb && (N = 9 - b.wb), 1 > N && (N = 1), E.dd = N, E.tc = 2 * z + N, E.ld = 40 <= z ? 2 : 15 <= z ? 1 : 0;
              } else E.tc = 0;
              E.La = P;
            }
          }
        }
        p = 0;
      } else tr(s, 6, "Frame setup failed"), p = s.a;
      if (p = p == 0) {
        if (p) {
          s.$c = 0, 0 < s.Aa || (s.Ic = m);
          e: {
            p = s.Ic, b = 4 * (N = s.za);
            var R = 32 * N, G = N + 1, ie = 0 < s.L ? N * (0 < s.Aa ? 2 : 1) : 0, H = (s.Aa == 2 ? 2 : 1) * N;
            if ((E = b + 832 + (P = 3 * (16 * p + c[s.L]) / 2 * R) + (C = s.Fa != null && 0 < s.Fa.length ? s.Kc.c * s.Kc.i : 0)) != E) p = 0;
            else {
              if (E > s.Vb) {
                if (s.Vb = 0, s.Ec = A(E), s.Fc = 0, s.Ec == null) {
                  p = tr(s, 1, "no memory during frame initialization.");
                  break e;
                }
                s.Vb = E;
              }
              E = s.Ec, z = s.Fc, s.Ac = E, s.Bc = z, z += b, s.Gd = v(R, sn), s.Hd = 0, s.rb = v(G + 1, Yr), s.sb = 1, s.wa = ie ? v(ie, ea) : null, s.Y = 0, s.D.Nb = 0, s.D.wa = s.wa, s.D.Y = s.Y, 0 < s.Aa && (s.D.Y += N), g(!0), s.oc = E, s.pc = z, z += 832, s.ya = v(H, Cs), s.aa = 0, s.D.ya = s.ya, s.D.aa = s.aa, s.Aa == 2 && (s.D.aa += N), s.R = 16 * N, s.B = 8 * N, N = (R = c[s.L]) * s.R, R = R / 2 * s.B, s.sa = E, s.ta = z + N, s.qa = s.sa, s.ra = s.ta + 16 * p * s.R + R, s.Ha = s.qa, s.Ia = s.ra + 8 * p * s.B + R, s.$c = 0, z += P, s.mb = C ? E : null, s.nb = C ? z : null, g(z + C <= s.Fc + s.Vb), an(s), I(s.Ac, s.Bc, 0, b), p = 1;
            }
          }
          if (p) {
            if (l.ka = 0, l.y = s.sa, l.O = s.ta, l.f = s.qa, l.N = s.ra, l.ea = s.Ha, l.Vd = s.Ia, l.fa = s.R, l.Rc = s.B, l.F = null, l.J = 0, !mn) {
              for (p = -255; 255 >= p; ++p) rc[255 + p] = 0 > p ? -p : p;
              for (p = -1020; 1020 >= p; ++p) Oo[1020 + p] = -128 > p ? -128 : 127 < p ? 127 : p;
              for (p = -112; 112 >= p; ++p) hr[112 + p] = -16 > p ? -16 : 15 < p ? 15 : p;
              for (p = -255; 510 >= p; ++p) vs[255 + p] = 0 > p ? 0 : 255 < p ? 255 : p;
              mn = 1;
            }
            Nn = Eo, ga = ia, ys = Ha, pn = Xa, Rn = ra, ya = Ta, Bs = so, _a = Ca, ss = rl, fn = ao, Pr = il, Or = la, _s = oo, Zi = Fo, Ji = oa, Ki = Fs, pr = Kn, An = Cl, on[0] = En, on[1] = ka, on[2] = Do, on[3] = Qa, on[4] = eo, on[5] = to, on[6] = Ms, on[7] = io, on[8] = kl, on[9] = tl, Vs[0] = Mo, Vs[1] = La, Vs[2] = Es, Vs[3] = Ja, Vs[4] = _r, Vs[5] = Ka, Vs[6] = Rr, jr[0] = fs, jr[1] = Ya, jr[2] = Ll, jr[3] = zo, jr[4] = Ds, jr[5] = ro, jr[6] = zs, p = 1;
          } else p = 0;
        }
        p && (p = function(Q, ue) {
          for (Q.M = 0; Q.M < Q.Va; ++Q.M) {
            var ce, ne = Q.Jc[Q.M & Q.Xb], le = Q.m, De = Q;
            for (ce = 0; ce < De.za; ++ce) {
              var Ne = le, Te = De, qe = Te.Ac, He = Te.Bc + 4 * ce, vt = Te.zc, Ue = Te.ya[Te.aa + ce];
              if (Te.Qa.Bb ? Ue.$b = Ye(Ne, Te.Pa.jb[0]) ? 2 + Ye(Ne, Te.Pa.jb[2]) : Ye(Ne, Te.Pa.jb[1]) : Ue.$b = 0, Te.kc && (Ue.Ad = Ye(Ne, Te.Bd)), Ue.Za = !Ye(Ne, 145) + 0, Ue.Za) {
                var ft = Ue.Ob, Tt = 0;
                for (Te = 0; 4 > Te; ++Te) {
                  var ii, Mt = vt[0 + Te];
                  for (ii = 0; 4 > ii; ++ii) {
                    Mt = Uo[qe[He + ii]][Mt];
                    for (var Wt = Nl[Ye(Ne, Mt[0])]; 0 < Wt; ) Wt = Nl[2 * Wt + Ye(Ne, Mt[Wt])];
                    Mt = -Wt, qe[He + ii] = Mt;
                  }
                  x(ft, Tt, qe, He, 4), Tt += 4, vt[0 + Te] = Mt;
                }
              } else Mt = Ye(Ne, 156) ? Ye(Ne, 128) ? 1 : 3 : Ye(Ne, 163) ? 2 : 0, Ue.Ob[0] = Mt, I(qe, He, Mt, 4), I(vt, 0, Mt, 4);
              Ue.Dd = Ye(Ne, 142) ? Ye(Ne, 114) ? Ye(Ne, 183) ? 1 : 3 : 2 : 0;
            }
            if (De.m.Ka) return tr(Q, 7, "Premature end-of-partition0 encountered.");
            for (; Q.ja < Q.za; ++Q.ja) {
              if (De = ne, Ne = (le = Q).rb[le.sb - 1], qe = le.rb[le.sb + le.ja], ce = le.ya[le.aa + le.ja], He = le.kc ? ce.Ad : 0) Ne.la = qe.la = 0, ce.Za || (Ne.Na = qe.Na = 0), ce.Hc = 0, ce.Gc = 0, ce.ia = 0;
              else {
                var ci, si;
                if (Ne = qe, qe = De, He = le.Pa.Xc, vt = le.ya[le.aa + le.ja], Ue = le.pb[vt.$b], Te = vt.ad, ft = 0, Tt = le.rb[le.sb - 1], Mt = ii = 0, I(Te, ft, 0, 384), vt.Za) var qi = 0, Ti = He[3];
                else {
                  Wt = A(16);
                  var Ni = Ne.Na + Tt.Na;
                  if (Ni = Us(qe, He[1], Ni, Ue.Eb, 0, Wt, 0), Ne.Na = Tt.Na = (0 < Ni) + 0, 1 < Ni) Nn(Wt, 0, Te, ft);
                  else {
                    var Wi = Wt[0] + 3 >> 3;
                    for (Wt = 0; 256 > Wt; Wt += 16) Te[ft + Wt] = Wi;
                  }
                  qi = 1, Ti = He[0];
                }
                var bi = 15 & Ne.la, Gi = 15 & Tt.la;
                for (Wt = 0; 4 > Wt; ++Wt) {
                  var fr = 1 & Gi;
                  for (Wi = si = 0; 4 > Wi; ++Wi) bi = bi >> 1 | (fr = (Ni = Us(qe, Ti, Ni = fr + (1 & bi), Ue.Sc, qi, Te, ft)) > qi) << 7, si = si << 2 | (3 < Ni ? 3 : 1 < Ni ? 2 : Te[ft + 0] != 0), ft += 16;
                  bi >>= 4, Gi = Gi >> 1 | fr << 7, ii = (ii << 8 | si) >>> 0;
                }
                for (Ti = bi, qi = Gi >> 4, ci = 0; 4 > ci; ci += 2) {
                  for (si = 0, bi = Ne.la >> 4 + ci, Gi = Tt.la >> 4 + ci, Wt = 0; 2 > Wt; ++Wt) {
                    for (fr = 1 & Gi, Wi = 0; 2 > Wi; ++Wi) Ni = fr + (1 & bi), bi = bi >> 1 | (fr = 0 < (Ni = Us(qe, He[2], Ni, Ue.Qc, 0, Te, ft))) << 3, si = si << 2 | (3 < Ni ? 3 : 1 < Ni ? 2 : Te[ft + 0] != 0), ft += 16;
                    bi >>= 2, Gi = Gi >> 1 | fr << 5;
                  }
                  Mt |= si << 4 * ci, Ti |= bi << 4 << ci, qi |= (240 & Gi) << ci;
                }
                Ne.la = Ti, Tt.la = qi, vt.Hc = ii, vt.Gc = Mt, vt.ia = 43690 & Mt ? 0 : Ue.ia, He = !(ii | Mt);
              }
              if (0 < le.L && (le.wa[le.Y + le.ja] = le.gd[ce.$b][ce.Za], le.wa[le.Y + le.ja].La |= !He), De.Ka) return tr(Q, 7, "Premature end-of-file encountered.");
            }
            if (an(Q), le = ue, De = 1, ce = (ne = Q).D, Ne = 0 < ne.L && ne.M >= ne.zb && ne.M <= ne.Va, ne.Aa == 0) e: {
              if (ce.M = ne.M, ce.uc = Ne, da(ne, ce), De = 1, ce = (si = ne.D).Nb, Ne = (Mt = c[ne.L]) * ne.R, qe = Mt / 2 * ne.B, Wt = 16 * ce * ne.R, Wi = 8 * ce * ne.B, He = ne.sa, vt = ne.ta - Ne + Wt, Ue = ne.qa, Te = ne.ra - qe + Wi, ft = ne.Ha, Tt = ne.Ia - qe + Wi, Gi = (bi = si.M) == 0, ii = bi >= ne.Va - 1, ne.Aa == 2 && da(ne, si), si.uc) for (fr = (Ni = ne).D.M, g(Ni.D.uc), si = Ni.yb; si < Ni.Hb; ++si) {
                qi = si, Ti = fr;
                var ur = (Tr = (Li = Ni).D).Nb;
                ci = Li.R;
                var Tr = Tr.wa[Tr.Y + qi], kr = Li.sa, qr = Li.ta + 16 * ur * ci + 16 * qi, In = Tr.dd, Lr = Tr.tc;
                if (Lr != 0) if (g(3 <= Lr), Li.L == 1) 0 < qi && Ki(kr, qr, ci, Lr + 4), Tr.La && An(kr, qr, ci, Lr), 0 < Ti && Ji(kr, qr, ci, Lr + 4), Tr.La && pr(kr, qr, ci, Lr);
                else {
                  var nr = Li.B, Zr = Li.qa, Tn = Li.ra + 8 * ur * nr + 8 * qi, kn = Li.Ha, Li = Li.Ia + 8 * ur * nr + 8 * qi;
                  ur = Tr.ld, 0 < qi && (_a(kr, qr, ci, Lr + 4, In, ur), fn(Zr, Tn, kn, Li, nr, Lr + 4, In, ur)), Tr.La && (Or(kr, qr, ci, Lr, In, ur), Zi(Zr, Tn, kn, Li, nr, Lr, In, ur)), 0 < Ti && (Bs(kr, qr, ci, Lr + 4, In, ur), ss(Zr, Tn, kn, Li, nr, Lr + 4, In, ur)), Tr.La && (Pr(kr, qr, ci, Lr, In, ur), _s(Zr, Tn, kn, Li, nr, Lr, In, ur));
                }
              }
              if (ne.ia && alert("todo:DitherRow"), le.put != null) {
                if (si = 16 * bi, bi = 16 * (bi + 1), Gi ? (le.y = ne.sa, le.O = ne.ta + Wt, le.f = ne.qa, le.N = ne.ra + Wi, le.ea = ne.Ha, le.W = ne.Ia + Wi) : (si -= Mt, le.y = He, le.O = vt, le.f = Ue, le.N = Te, le.ea = ft, le.W = Tt), ii || (bi -= Mt), bi > le.o && (bi = le.o), le.F = null, le.J = null, ne.Fa != null && 0 < ne.Fa.length && si < bi && (le.J = Ro(ne, le, si, bi - si), le.F = ne.mb, le.F == null && le.F.length == 0)) {
                  De = tr(ne, 3, "Could not decode alpha data.");
                  break e;
                }
                si < le.j && (Mt = le.j - si, si = le.j, g(!(1 & Mt)), le.O += ne.R * Mt, le.N += ne.B * (Mt >> 1), le.W += ne.B * (Mt >> 1), le.F != null && (le.J += le.width * Mt)), si < bi && (le.O += le.v, le.N += le.v >> 1, le.W += le.v >> 1, le.F != null && (le.J += le.v), le.ka = si - le.j, le.U = le.va - le.v, le.T = bi - si, De = le.put(le));
              }
              ce + 1 != ne.Ic || ii || (x(ne.sa, ne.ta - Ne, He, vt + 16 * ne.R, Ne), x(ne.qa, ne.ra - qe, Ue, Te + 8 * ne.B, qe), x(ne.Ha, ne.Ia - qe, ft, Tt + 8 * ne.B, qe));
            }
            if (!De) return tr(Q, 6, "Output aborted.");
          }
          return 1;
        }(s, l)), l.bc != null && l.bc(l), p &= 1;
      }
      return p ? (s.cb = 0, p) : 0;
    }
    function Ar(s, l, p, b, P) {
      P = s[l + p + 32 * b] + (P >> 3), s[l + p + 32 * b] = -256 & P ? 0 > P ? 0 : 255 : P;
    }
    function ta(s, l, p, b, P, C) {
      Ar(s, l, 0, p, b + P), Ar(s, l, 1, p, b + C), Ar(s, l, 2, p, b - C), Ar(s, l, 3, p, b - P);
    }
    function Dr(s) {
      return (20091 * s >> 16) + s;
    }
    function Mi(s, l, p, b) {
      var P, C = 0, E = A(16);
      for (P = 0; 4 > P; ++P) {
        var z = s[l + 0] + s[l + 8], N = s[l + 0] - s[l + 8], R = (35468 * s[l + 4] >> 16) - Dr(s[l + 12]), G = Dr(s[l + 4]) + (35468 * s[l + 12] >> 16);
        E[C + 0] = z + G, E[C + 1] = N + R, E[C + 2] = N - R, E[C + 3] = z - G, C += 4, l++;
      }
      for (P = C = 0; 4 > P; ++P) z = (s = E[C + 0] + 4) + E[C + 8], N = s - E[C + 8], R = (35468 * E[C + 4] >> 16) - Dr(E[C + 12]), Ar(p, b, 0, 0, z + (G = Dr(E[C + 4]) + (35468 * E[C + 12] >> 16))), Ar(p, b, 1, 0, N + R), Ar(p, b, 2, 0, N - R), Ar(p, b, 3, 0, z - G), C++, b += 32;
    }
    function Ta(s, l, p, b) {
      var P = s[l + 0] + 4, C = 35468 * s[l + 4] >> 16, E = Dr(s[l + 4]), z = 35468 * s[l + 1] >> 16;
      ta(p, b, 0, P + E, s = Dr(s[l + 1]), z), ta(p, b, 1, P + C, s, z), ta(p, b, 2, P - C, s, z), ta(p, b, 3, P - E, s, z);
    }
    function ia(s, l, p, b, P) {
      Mi(s, l, p, b), P && Mi(s, l + 16, p, b + 4);
    }
    function Ha(s, l, p, b) {
      ga(s, l + 0, p, b, 1), ga(s, l + 32, p, b + 128, 1);
    }
    function Xa(s, l, p, b) {
      var P;
      for (s = s[l + 0] + 4, P = 0; 4 > P; ++P) for (l = 0; 4 > l; ++l) Ar(p, b, l, P, s);
    }
    function ra(s, l, p, b) {
      s[l + 0] && pn(s, l + 0, p, b), s[l + 16] && pn(s, l + 16, p, b + 4), s[l + 32] && pn(s, l + 32, p, b + 128), s[l + 48] && pn(s, l + 48, p, b + 128 + 4);
    }
    function Eo(s, l, p, b) {
      var P, C = A(16);
      for (P = 0; 4 > P; ++P) {
        var E = s[l + 0 + P] + s[l + 12 + P], z = s[l + 4 + P] + s[l + 8 + P], N = s[l + 4 + P] - s[l + 8 + P], R = s[l + 0 + P] - s[l + 12 + P];
        C[0 + P] = E + z, C[8 + P] = E - z, C[4 + P] = R + N, C[12 + P] = R - N;
      }
      for (P = 0; 4 > P; ++P) E = (s = C[0 + 4 * P] + 3) + C[3 + 4 * P], z = C[1 + 4 * P] + C[2 + 4 * P], N = C[1 + 4 * P] - C[2 + 4 * P], R = s - C[3 + 4 * P], p[b + 0] = E + z >> 3, p[b + 16] = R + N >> 3, p[b + 32] = E - z >> 3, p[b + 48] = R - N >> 3, b += 64;
    }
    function na(s, l, p) {
      var b, P = l - 32, C = en, E = 255 - s[P - 1];
      for (b = 0; b < p; ++b) {
        var z, N = C, R = E + s[l - 1];
        for (z = 0; z < p; ++z) s[l + z] = N[R + s[P + z]];
        l += 32;
      }
    }
    function ka(s, l) {
      na(s, l, 4);
    }
    function Ya(s, l) {
      na(s, l, 8);
    }
    function La(s, l) {
      na(s, l, 16);
    }
    function Es(s, l) {
      var p;
      for (p = 0; 16 > p; ++p) x(s, l + 32 * p, s, l - 32, 16);
    }
    function Ja(s, l) {
      var p;
      for (p = 16; 0 < p; --p) I(s, l, s[l - 1], 16), l += 32;
    }
    function sa(s, l, p) {
      var b;
      for (b = 0; 16 > b; ++b) I(l, p + 32 * b, s, 16);
    }
    function Mo(s, l) {
      var p, b = 16;
      for (p = 0; 16 > p; ++p) b += s[l - 1 + 32 * p] + s[l + p - 32];
      sa(b >> 5, s, l);
    }
    function _r(s, l) {
      var p, b = 8;
      for (p = 0; 16 > p; ++p) b += s[l - 1 + 32 * p];
      sa(b >> 4, s, l);
    }
    function Ka(s, l) {
      var p, b = 8;
      for (p = 0; 16 > p; ++p) b += s[l + p - 32];
      sa(b >> 4, s, l);
    }
    function Rr(s, l) {
      sa(128, s, l);
    }
    function ri(s, l, p) {
      return s + 2 * l + p + 2 >> 2;
    }
    function Do(s, l) {
      var p, b = l - 32;
      for (b = new Uint8Array([ri(s[b - 1], s[b + 0], s[b + 1]), ri(s[b + 0], s[b + 1], s[b + 2]), ri(s[b + 1], s[b + 2], s[b + 3]), ri(s[b + 2], s[b + 3], s[b + 4])]), p = 0; 4 > p; ++p) x(s, l + 32 * p, b, 0, b.length);
    }
    function Qa(s, l) {
      var p = s[l - 1], b = s[l - 1 + 32], P = s[l - 1 + 64], C = s[l - 1 + 96];
      bt(s, l + 0, 16843009 * ri(s[l - 1 - 32], p, b)), bt(s, l + 32, 16843009 * ri(p, b, P)), bt(s, l + 64, 16843009 * ri(b, P, C)), bt(s, l + 96, 16843009 * ri(P, C, C));
    }
    function En(s, l) {
      var p, b = 4;
      for (p = 0; 4 > p; ++p) b += s[l + p - 32] + s[l - 1 + 32 * p];
      for (b >>= 3, p = 0; 4 > p; ++p) I(s, l + 32 * p, b, 4);
    }
    function eo(s, l) {
      var p = s[l - 1 + 0], b = s[l - 1 + 32], P = s[l - 1 + 64], C = s[l - 1 - 32], E = s[l + 0 - 32], z = s[l + 1 - 32], N = s[l + 2 - 32], R = s[l + 3 - 32];
      s[l + 0 + 96] = ri(b, P, s[l - 1 + 96]), s[l + 1 + 96] = s[l + 0 + 64] = ri(p, b, P), s[l + 2 + 96] = s[l + 1 + 64] = s[l + 0 + 32] = ri(C, p, b), s[l + 3 + 96] = s[l + 2 + 64] = s[l + 1 + 32] = s[l + 0 + 0] = ri(E, C, p), s[l + 3 + 64] = s[l + 2 + 32] = s[l + 1 + 0] = ri(z, E, C), s[l + 3 + 32] = s[l + 2 + 0] = ri(N, z, E), s[l + 3 + 0] = ri(R, N, z);
    }
    function Ms(s, l) {
      var p = s[l + 1 - 32], b = s[l + 2 - 32], P = s[l + 3 - 32], C = s[l + 4 - 32], E = s[l + 5 - 32], z = s[l + 6 - 32], N = s[l + 7 - 32];
      s[l + 0 + 0] = ri(s[l + 0 - 32], p, b), s[l + 1 + 0] = s[l + 0 + 32] = ri(p, b, P), s[l + 2 + 0] = s[l + 1 + 32] = s[l + 0 + 64] = ri(b, P, C), s[l + 3 + 0] = s[l + 2 + 32] = s[l + 1 + 64] = s[l + 0 + 96] = ri(P, C, E), s[l + 3 + 32] = s[l + 2 + 64] = s[l + 1 + 96] = ri(C, E, z), s[l + 3 + 64] = s[l + 2 + 96] = ri(E, z, N), s[l + 3 + 96] = ri(z, N, N);
    }
    function to(s, l) {
      var p = s[l - 1 + 0], b = s[l - 1 + 32], P = s[l - 1 + 64], C = s[l - 1 - 32], E = s[l + 0 - 32], z = s[l + 1 - 32], N = s[l + 2 - 32], R = s[l + 3 - 32];
      s[l + 0 + 0] = s[l + 1 + 64] = C + E + 1 >> 1, s[l + 1 + 0] = s[l + 2 + 64] = E + z + 1 >> 1, s[l + 2 + 0] = s[l + 3 + 64] = z + N + 1 >> 1, s[l + 3 + 0] = N + R + 1 >> 1, s[l + 0 + 96] = ri(P, b, p), s[l + 0 + 64] = ri(b, p, C), s[l + 0 + 32] = s[l + 1 + 96] = ri(p, C, E), s[l + 1 + 32] = s[l + 2 + 96] = ri(C, E, z), s[l + 2 + 32] = s[l + 3 + 96] = ri(E, z, N), s[l + 3 + 32] = ri(z, N, R);
    }
    function io(s, l) {
      var p = s[l + 0 - 32], b = s[l + 1 - 32], P = s[l + 2 - 32], C = s[l + 3 - 32], E = s[l + 4 - 32], z = s[l + 5 - 32], N = s[l + 6 - 32], R = s[l + 7 - 32];
      s[l + 0 + 0] = p + b + 1 >> 1, s[l + 1 + 0] = s[l + 0 + 64] = b + P + 1 >> 1, s[l + 2 + 0] = s[l + 1 + 64] = P + C + 1 >> 1, s[l + 3 + 0] = s[l + 2 + 64] = C + E + 1 >> 1, s[l + 0 + 32] = ri(p, b, P), s[l + 1 + 32] = s[l + 0 + 96] = ri(b, P, C), s[l + 2 + 32] = s[l + 1 + 96] = ri(P, C, E), s[l + 3 + 32] = s[l + 2 + 96] = ri(C, E, z), s[l + 3 + 64] = ri(E, z, N), s[l + 3 + 96] = ri(z, N, R);
    }
    function tl(s, l) {
      var p = s[l - 1 + 0], b = s[l - 1 + 32], P = s[l - 1 + 64], C = s[l - 1 + 96];
      s[l + 0 + 0] = p + b + 1 >> 1, s[l + 2 + 0] = s[l + 0 + 32] = b + P + 1 >> 1, s[l + 2 + 32] = s[l + 0 + 64] = P + C + 1 >> 1, s[l + 1 + 0] = ri(p, b, P), s[l + 3 + 0] = s[l + 1 + 32] = ri(b, P, C), s[l + 3 + 32] = s[l + 1 + 64] = ri(P, C, C), s[l + 3 + 64] = s[l + 2 + 64] = s[l + 0 + 96] = s[l + 1 + 96] = s[l + 2 + 96] = s[l + 3 + 96] = C;
    }
    function kl(s, l) {
      var p = s[l - 1 + 0], b = s[l - 1 + 32], P = s[l - 1 + 64], C = s[l - 1 + 96], E = s[l - 1 - 32], z = s[l + 0 - 32], N = s[l + 1 - 32], R = s[l + 2 - 32];
      s[l + 0 + 0] = s[l + 2 + 32] = p + E + 1 >> 1, s[l + 0 + 32] = s[l + 2 + 64] = b + p + 1 >> 1, s[l + 0 + 64] = s[l + 2 + 96] = P + b + 1 >> 1, s[l + 0 + 96] = C + P + 1 >> 1, s[l + 3 + 0] = ri(z, N, R), s[l + 2 + 0] = ri(E, z, N), s[l + 1 + 0] = s[l + 3 + 32] = ri(p, E, z), s[l + 1 + 32] = s[l + 3 + 64] = ri(b, p, E), s[l + 1 + 64] = s[l + 3 + 96] = ri(P, b, p), s[l + 1 + 96] = ri(C, P, b);
    }
    function Ll(s, l) {
      var p;
      for (p = 0; 8 > p; ++p) x(s, l + 32 * p, s, l - 32, 8);
    }
    function zo(s, l) {
      var p;
      for (p = 0; 8 > p; ++p) I(s, l, s[l - 1], 8), l += 32;
    }
    function ps(s, l, p) {
      var b;
      for (b = 0; 8 > b; ++b) I(l, p + 32 * b, s, 8);
    }
    function fs(s, l) {
      var p, b = 8;
      for (p = 0; 8 > p; ++p) b += s[l + p - 32] + s[l - 1 + 32 * p];
      ps(b >> 4, s, l);
    }
    function ro(s, l) {
      var p, b = 4;
      for (p = 0; 8 > p; ++p) b += s[l + p - 32];
      ps(b >> 3, s, l);
    }
    function Ds(s, l) {
      var p, b = 4;
      for (p = 0; 8 > p; ++p) b += s[l - 1 + 32 * p];
      ps(b >> 3, s, l);
    }
    function zs(s, l) {
      ps(128, s, l);
    }
    function Br(s, l, p) {
      var b = s[l - p], P = s[l + 0], C = 3 * (P - b) + ho[1020 + s[l - 2 * p] - s[l + p]], E = uo[112 + (C + 4 >> 3)];
      s[l - p] = en[255 + b + uo[112 + (C + 3 >> 3)]], s[l + 0] = en[255 + P - E];
    }
    function zi(s, l, p, b) {
      var P = s[l + 0], C = s[l + p];
      return Ir[255 + s[l - 2 * p] - s[l - p]] > b || Ir[255 + C - P] > b;
    }
    function no(s, l, p, b) {
      return 4 * Ir[255 + s[l - p] - s[l + 0]] + Ir[255 + s[l - 2 * p] - s[l + p]] <= b;
    }
    function aa(s, l, p, b, P) {
      var C = s[l - 3 * p], E = s[l - 2 * p], z = s[l - p], N = s[l + 0], R = s[l + p], G = s[l + 2 * p], ie = s[l + 3 * p];
      return 4 * Ir[255 + z - N] + Ir[255 + E - R] > b ? 0 : Ir[255 + s[l - 4 * p] - C] <= P && Ir[255 + C - E] <= P && Ir[255 + E - z] <= P && Ir[255 + ie - G] <= P && Ir[255 + G - R] <= P && Ir[255 + R - N] <= P;
    }
    function oa(s, l, p, b) {
      var P = 2 * b + 1;
      for (b = 0; 16 > b; ++b) no(s, l + b, p, P) && Br(s, l + b, p);
    }
    function Fs(s, l, p, b) {
      var P = 2 * b + 1;
      for (b = 0; 16 > b; ++b) no(s, l + b * p, 1, P) && Br(s, l + b * p, 1);
    }
    function Kn(s, l, p, b) {
      var P;
      for (P = 3; 0 < P; --P) oa(s, l += 4 * p, p, b);
    }
    function Cl(s, l, p, b) {
      var P;
      for (P = 3; 0 < P; --P) Fs(s, l += 4, p, b);
    }
    function wn(s, l, p, b, P, C, E, z) {
      for (C = 2 * C + 1; 0 < P--; ) {
        if (aa(s, l, p, C, E)) if (zi(s, l, p, z)) Br(s, l, p);
        else {
          var N = s, R = l, G = p, ie = N[R - 2 * G], H = N[R - G], Q = N[R + 0], ue = N[R + G], ce = N[R + 2 * G], ne = 27 * (De = ho[1020 + 3 * (Q - H) + ho[1020 + ie - ue]]) + 63 >> 7, le = 18 * De + 63 >> 7, De = 9 * De + 63 >> 7;
          N[R - 3 * G] = en[255 + N[R - 3 * G] + De], N[R - 2 * G] = en[255 + ie + le], N[R - G] = en[255 + H + ne], N[R + 0] = en[255 + Q - ne], N[R + G] = en[255 + ue - le], N[R + 2 * G] = en[255 + ce - De];
        }
        l += b;
      }
    }
    function Qn(s, l, p, b, P, C, E, z) {
      for (C = 2 * C + 1; 0 < P--; ) {
        if (aa(s, l, p, C, E)) if (zi(s, l, p, z)) Br(s, l, p);
        else {
          var N = s, R = l, G = p, ie = N[R - G], H = N[R + 0], Q = N[R + G], ue = uo[112 + ((ce = 3 * (H - ie)) + 4 >> 3)], ce = uo[112 + (ce + 3 >> 3)], ne = ue + 1 >> 1;
          N[R - 2 * G] = en[255 + N[R - 2 * G] + ne], N[R - G] = en[255 + ie + ce], N[R + 0] = en[255 + H - ue], N[R + G] = en[255 + Q - ne];
        }
        l += b;
      }
    }
    function so(s, l, p, b, P, C) {
      wn(s, l, p, 1, 16, b, P, C);
    }
    function Ca(s, l, p, b, P, C) {
      wn(s, l, 1, p, 16, b, P, C);
    }
    function il(s, l, p, b, P, C) {
      var E;
      for (E = 3; 0 < E; --E) Qn(s, l += 4 * p, p, 1, 16, b, P, C);
    }
    function la(s, l, p, b, P, C) {
      var E;
      for (E = 3; 0 < E; --E) Qn(s, l += 4, 1, p, 16, b, P, C);
    }
    function rl(s, l, p, b, P, C, E, z) {
      wn(s, l, P, 1, 8, C, E, z), wn(p, b, P, 1, 8, C, E, z);
    }
    function ao(s, l, p, b, P, C, E, z) {
      wn(s, l, 1, P, 8, C, E, z), wn(p, b, 1, P, 8, C, E, z);
    }
    function oo(s, l, p, b, P, C, E, z) {
      Qn(s, l + 4 * P, P, 1, 8, C, E, z), Qn(p, b + 4 * P, P, 1, 8, C, E, z);
    }
    function Fo(s, l, p, b, P, C, E, z) {
      Qn(s, l + 4, 1, P, 8, C, E, z), Qn(p, b + 4, 1, P, 8, C, E, z);
    }
    function Mn() {
      this.ba = new $i(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new Z(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function lo() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function No() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function nl() {
      this.ua = 0, this.Wa = new te(), this.vb = new te(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new Se(), this.yc = new he();
    }
    function sl() {
      this.xb = this.a = 0, this.l = new cn(), this.ca = new $i(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new K(), this.Pb = 0, this.wd = new K(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new nl(), this.ab = 0, this.gc = v(4, No), this.Oc = 0;
    }
    function ms() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new cn(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function Ea(s, l, p, b, P, C, E) {
      for (s = s == null ? 0 : s[l + 0], l = 0; l < E; ++l) P[C + l] = s + p[b + l] & 255, s = P[C + l];
    }
    function ca(s, l, p, b, P, C, E) {
      var z;
      if (s == null) Ea(null, null, p, b, P, C, E);
      else for (z = 0; z < E; ++z) P[C + z] = s[l + z] + p[b + z] & 255;
    }
    function ha(s, l, p, b, P, C, E) {
      if (s == null) Ea(null, null, p, b, P, C, E);
      else {
        var z, N = s[l + 0], R = N, G = N;
        for (z = 0; z < E; ++z) R = G + (N = s[l + z]) - R, G = p[b + z] + (-256 & R ? 0 > R ? 0 : 255 : R) & 255, R = N, P[C + z] = G;
      }
    }
    function Ro(s, l, p, b) {
      var P = l.width, C = l.o;
      if (g(s != null && l != null), 0 > p || 0 >= b || p + b > C) return null;
      if (!s.Cc) {
        if (s.ga == null) {
          var E;
          if (s.ga = new ms(), (E = s.ga == null) || (E = l.width * l.o, g(s.Gb.length == 0), s.Gb = A(E), s.Uc = 0, s.Gb == null ? E = 0 : (s.mb = s.Gb, s.nb = s.Uc, s.rc = null, E = 1), E = !E), !E) {
            E = s.ga;
            var z = s.Fa, N = s.P, R = s.qc, G = s.mb, ie = s.nb, H = N + 1, Q = R - 1, ue = E.l;
            if (g(z != null && G != null && l != null), bs[0] = null, bs[1] = Ea, bs[2] = ca, bs[3] = ha, E.ca = G, E.tb = ie, E.c = l.width, E.i = l.height, g(0 < E.c && 0 < E.i), 1 >= R) l = 0;
            else if (E.$a = z[N + 0] >> 0 & 3, E.Z = z[N + 0] >> 2 & 3, E.Lc = z[N + 0] >> 4 & 3, N = z[N + 0] >> 6 & 3, 0 > E.$a || 1 < E.$a || 4 <= E.Z || 1 < E.Lc || N) l = 0;
            else if (ue.put = Ce, ue.ac = Ae, ue.bc = Me, ue.ma = E, ue.width = l.width, ue.height = l.height, ue.Da = l.Da, ue.v = l.v, ue.va = l.va, ue.j = l.j, ue.o = l.o, E.$a) e: {
              g(E.$a == 1), l = ai();
              t: for (; ; ) {
                if (l == null) {
                  l = 0;
                  break e;
                }
                if (g(E != null), E.mc = l, l.c = E.c, l.i = E.i, l.l = E.l, l.l.ma = E, l.l.width = E.c, l.l.height = E.i, l.a = 0, Ze(l.m, z, H, Q), !Fi(E.c, E.i, 1, l, null) || (l.ab == 1 && l.gc[0].hc == 3 && ti(l.s) ? (E.ic = 1, z = l.c * l.i, l.Ta = null, l.Ua = 0, l.V = A(z), l.Ba = 0, l.V == null ? (l.a = 1, l = 0) : l = 1) : (E.ic = 0, l = er(l, E.c)), !l)) break t;
                l = 1;
                break e;
              }
              E.mc = null, l = 0;
            }
            else l = Q >= E.c * E.i;
            E = !l;
          }
          if (E) return null;
          s.ga.Lc != 1 ? s.Ga = 0 : b = C - p;
        }
        g(s.ga != null), g(p + b <= C);
        e: {
          if (l = (z = s.ga).c, C = z.l.o, z.$a == 0) {
            if (H = s.rc, Q = s.Vc, ue = s.Fa, N = s.P + 1 + p * l, R = s.mb, G = s.nb + p * l, g(N <= s.P + s.qc), z.Z != 0) for (g(bs[z.Z] != null), E = 0; E < b; ++E) bs[z.Z](H, Q, ue, N, R, G, l), H = R, Q = G, G += l, N += l;
            else for (E = 0; E < b; ++E) x(R, G, ue, N, l), H = R, Q = G, G += l, N += l;
            s.rc = H, s.Vc = Q;
          } else {
            if (g(z.mc != null), l = p + b, g((E = z.mc) != null), g(l <= E.i), E.C >= l) l = 1;
            else if (z.ic || je(), z.ic) {
              z = E.V, H = E.Ba, Q = E.c;
              var ce = E.i, ne = (ue = 1, N = E.$ / Q, R = E.$ % Q, G = E.m, ie = E.s, E.$), le = Q * ce, De = Q * l, Ne = ie.wc, Te = ne < De ? It(ie, R, N) : null;
              g(ne <= le), g(l <= ce), g(ti(ie));
              t: for (; ; ) {
                for (; !G.h && ne < De; ) {
                  if (R & Ne || (Te = It(ie, R, N)), g(Te != null), Be(G), 256 > (ce = Je(Te.G[0], Te.H[0], G))) z[H + ne] = ce, ++ne, ++R >= Q && (R = 0, ++N <= l && !(N % 16) && Ii(E, N));
                  else {
                    if (!(280 > ce)) {
                      ue = 0;
                      break t;
                    }
                    ce = Oe(ce - 256, G);
                    var qe, He = Je(Te.G[4], Te.H[4], G);
                    if (Be(G), !(ne >= (He = ot(Q, He = Oe(He, G))) && le - ne >= ce)) {
                      ue = 0;
                      break t;
                    }
                    for (qe = 0; qe < ce; ++qe) z[H + ne + qe] = z[H + ne + qe - He];
                    for (ne += ce, R += ce; R >= Q; ) R -= Q, ++N <= l && !(N % 16) && Ii(E, N);
                    ne < De && R & Ne && (Te = It(ie, R, N));
                  }
                  g(G.h == we(G));
                }
                Ii(E, N > l ? l : N);
                break t;
              }
              !ue || G.h && ne < le ? (ue = 0, E.a = G.h ? 5 : 3) : E.$ = ne, l = ue;
            } else l = Ei(E, E.V, E.Ba, E.c, E.i, l, Mr);
            if (!l) {
              b = 0;
              break e;
            }
          }
          p + b >= C && (s.Cc = 1), b = 1;
        }
        if (!b) return null;
        if (s.Cc && ((b = s.ga) != null && (b.mc = null), s.ga = null, 0 < s.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return s.nb + p * P;
    }
    function L(s, l, p, b, P, C) {
      for (; 0 < P--; ) {
        var E, z = s, N = l + (p ? 1 : 0), R = s, G = l + (p ? 0 : 3);
        for (E = 0; E < b; ++E) {
          var ie = R[G + 4 * E];
          ie != 255 && (ie *= 32897, z[N + 4 * E + 0] = z[N + 4 * E + 0] * ie >> 23, z[N + 4 * E + 1] = z[N + 4 * E + 1] * ie >> 23, z[N + 4 * E + 2] = z[N + 4 * E + 2] * ie >> 23);
        }
        l += C;
      }
    }
    function X(s, l, p, b, P) {
      for (; 0 < b--; ) {
        var C;
        for (C = 0; C < p; ++C) {
          var E = s[l + 2 * C + 0], z = 15 & (R = s[l + 2 * C + 1]), N = 4369 * z, R = (240 & R | R >> 4) * N >> 16;
          s[l + 2 * C + 0] = (240 & E | E >> 4) * N >> 16 & 240 | (15 & E | E << 4) * N >> 16 >> 4 & 15, s[l + 2 * C + 1] = 240 & R | z;
        }
        l += P;
      }
    }
    function _e(s, l, p, b, P, C, E, z) {
      var N, R, G = 255;
      for (R = 0; R < P; ++R) {
        for (N = 0; N < b; ++N) {
          var ie = s[l + N];
          C[E + 4 * N] = ie, G &= ie;
        }
        l += p, E += z;
      }
      return G != 255;
    }
    function ke(s, l, p, b, P) {
      var C;
      for (C = 0; C < P; ++C) p[b + C] = s[l + C] >> 8;
    }
    function je() {
      Os = L, js = X, Fa = _e, va = ke;
    }
    function tt(s, l, p) {
      Le[s] = function(b, P, C, E, z, N, R, G, ie, H, Q, ue, ce, ne, le, De, Ne) {
        var Te, qe = Ne - 1 >> 1, He = z[N + 0] | R[G + 0] << 16, vt = ie[H + 0] | Q[ue + 0] << 16;
        g(b != null);
        var Ue = 3 * He + vt + 131074 >> 2;
        for (l(b[P + 0], 255 & Ue, Ue >> 16, ce, ne), C != null && (Ue = 3 * vt + He + 131074 >> 2, l(C[E + 0], 255 & Ue, Ue >> 16, le, De)), Te = 1; Te <= qe; ++Te) {
          var ft = z[N + Te] | R[G + Te] << 16, Tt = ie[H + Te] | Q[ue + Te] << 16, ii = He + ft + vt + Tt + 524296, Mt = ii + 2 * (ft + vt) >> 3;
          Ue = Mt + He >> 1, He = (ii = ii + 2 * (He + Tt) >> 3) + ft >> 1, l(b[P + 2 * Te - 1], 255 & Ue, Ue >> 16, ce, ne + (2 * Te - 1) * p), l(b[P + 2 * Te - 0], 255 & He, He >> 16, ce, ne + (2 * Te - 0) * p), C != null && (Ue = ii + vt >> 1, He = Mt + Tt >> 1, l(C[E + 2 * Te - 1], 255 & Ue, Ue >> 16, le, De + (2 * Te - 1) * p), l(C[E + 2 * Te + 0], 255 & He, He >> 16, le, De + (2 * Te + 0) * p)), He = ft, vt = Tt;
        }
        1 & Ne || (Ue = 3 * He + vt + 131074 >> 2, l(b[P + Ne - 1], 255 & Ue, Ue >> 16, ce, ne + (Ne - 1) * p), C != null && (Ue = 3 * vt + He + 131074 >> 2, l(C[E + Ne - 1], 255 & Ue, Ue >> 16, le, De + (Ne - 1) * p)));
      };
    }
    function yt() {
      On[qs] = oc, On[Na] = Ol, On[ol] = Bl, On[po] = $s, On[Ra] = jl, On[jo] = hl, On[El] = ba, On[xs] = Ol, On[ll] = $s, On[fo] = jl, On[qo] = hl;
    }
    function jt(s) {
      return s & ~Ul ? 0 > s ? 0 : 255 : s >> ql;
    }
    function oi(s, l) {
      return jt((19077 * s >> 8) + (26149 * l >> 8) - 14234);
    }
    function yi(s, l, p) {
      return jt((19077 * s >> 8) - (6419 * l >> 8) - (13320 * p >> 8) + 8708);
    }
    function Yt(s, l) {
      return jt((19077 * s >> 8) + (33050 * l >> 8) - 17685);
    }
    function Di(s, l, p, b, P) {
      b[P + 0] = oi(s, p), b[P + 1] = yi(s, l, p), b[P + 2] = Yt(s, l);
    }
    function Zt(s, l, p, b, P) {
      b[P + 0] = Yt(s, l), b[P + 1] = yi(s, l, p), b[P + 2] = oi(s, p);
    }
    function rr(s, l, p, b, P) {
      var C = yi(s, l, p);
      l = C << 3 & 224 | Yt(s, l) >> 3, b[P + 0] = 248 & oi(s, p) | C >> 5, b[P + 1] = l;
    }
    function Si(s, l, p, b, P) {
      var C = 240 & Yt(s, l) | 15;
      b[P + 0] = 240 & oi(s, p) | yi(s, l, p) >> 4, b[P + 1] = C;
    }
    function Ai(s, l, p, b, P) {
      b[P + 0] = 255, Di(s, l, p, b, P + 1);
    }
    function br(s, l, p, b, P) {
      Zt(s, l, p, b, P), b[P + 3] = 255;
    }
    function Dn(s, l, p, b, P) {
      Di(s, l, p, b, P), b[P + 3] = 255;
    }
    function hn(s, l) {
      return 0 > s ? 0 : s > l ? l : s;
    }
    function Ns(s, l, p) {
      Le[s] = function(b, P, C, E, z, N, R, G, ie) {
        for (var H = G + (-2 & ie) * p; G != H; ) l(b[P + 0], C[E + 0], z[N + 0], R, G), l(b[P + 1], C[E + 0], z[N + 0], R, G + p), P += 2, ++E, ++N, G += 2 * p;
        1 & ie && l(b[P + 0], C[E + 0], z[N + 0], R, G);
      };
    }
    function Bo(s, l, p) {
      return p == 0 ? s == 0 ? l == 0 ? 6 : 5 : l == 0 ? 4 : 0 : p;
    }
    function ua(s, l, p, b, P) {
      switch (s >>> 30) {
        case 3:
          ga(l, p, b, P, 0);
          break;
        case 2:
          ya(l, p, b, P);
          break;
        case 1:
          pn(l, p, b, P);
      }
    }
    function da(s, l) {
      var p, b, P = l.M, C = l.Nb, E = s.oc, z = s.pc + 40, N = s.oc, R = s.pc + 584, G = s.oc, ie = s.pc + 600;
      for (p = 0; 16 > p; ++p) E[z + 32 * p - 1] = 129;
      for (p = 0; 8 > p; ++p) N[R + 32 * p - 1] = 129, G[ie + 32 * p - 1] = 129;
      for (0 < P ? E[z - 1 - 32] = N[R - 1 - 32] = G[ie - 1 - 32] = 129 : (I(E, z - 32 - 1, 127, 21), I(N, R - 32 - 1, 127, 9), I(G, ie - 32 - 1, 127, 9)), b = 0; b < s.za; ++b) {
        var H = l.ya[l.aa + b];
        if (0 < b) {
          for (p = -1; 16 > p; ++p) x(E, z + 32 * p - 4, E, z + 32 * p + 12, 4);
          for (p = -1; 8 > p; ++p) x(N, R + 32 * p - 4, N, R + 32 * p + 4, 4), x(G, ie + 32 * p - 4, G, ie + 32 * p + 4, 4);
        }
        var Q = s.Gd, ue = s.Hd + b, ce = H.ad, ne = H.Hc;
        if (0 < P && (x(E, z - 32, Q[ue].y, 0, 16), x(N, R - 32, Q[ue].f, 0, 8), x(G, ie - 32, Q[ue].ea, 0, 8)), H.Za) {
          var le = E, De = z - 32 + 16;
          for (0 < P && (b >= s.za - 1 ? I(le, De, Q[ue].y[15], 4) : x(le, De, Q[ue + 1].y, 0, 4)), p = 0; 4 > p; p++) le[De + 128 + p] = le[De + 256 + p] = le[De + 384 + p] = le[De + 0 + p];
          for (p = 0; 16 > p; ++p, ne <<= 2) le = E, De = z + n[p], on[H.Ob[p]](le, De), ua(ne, ce, 16 * +p, le, De);
        } else if (le = Bo(b, P, H.Ob[0]), Vs[le](E, z), ne != 0) for (p = 0; 16 > p; ++p, ne <<= 2) ua(ne, ce, 16 * +p, E, z + n[p]);
        for (p = H.Gc, le = Bo(b, P, H.Dd), jr[le](N, R), jr[le](G, ie), ne = ce, le = N, De = R, 255 & (H = p >> 0) && (170 & H ? ys(ne, 256, le, De) : Rn(ne, 256, le, De)), H = G, ne = ie, 255 & (p >>= 8) && (170 & p ? ys(ce, 320, H, ne) : Rn(ce, 320, H, ne)), P < s.Ub - 1 && (x(Q[ue].y, 0, E, z + 480, 16), x(Q[ue].f, 0, N, R + 224, 8), x(Q[ue].ea, 0, G, ie + 224, 8)), p = 8 * C * s.B, Q = s.sa, ue = s.ta + 16 * b + 16 * C * s.R, ce = s.qa, H = s.ra + 8 * b + p, ne = s.Ha, le = s.Ia + 8 * b + p, p = 0; 16 > p; ++p) x(Q, ue + p * s.R, E, z + 32 * p, 16);
        for (p = 0; 8 > p; ++p) x(ce, H + p * s.B, N, R + 32 * p, 8), x(ne, le + p * s.B, G, ie + 32 * p, 8);
      }
    }
    function gs(s, l, p, b, P, C, E, z, N) {
      var R = [0], G = [0], ie = 0, H = N != null ? N.kd : 0, Q = N ?? new lo();
      if (s == null || 12 > p) return 7;
      Q.data = s, Q.w = l, Q.ha = p, l = [l], p = [p], Q.gb = [Q.gb];
      e: {
        var ue = l, ce = p, ne = Q.gb;
        if (g(s != null), g(ce != null), g(ne != null), ne[0] = 0, 12 <= ce[0] && !_(s, ue[0], "RIFF")) {
          if (_(s, ue[0] + 8, "WEBP")) {
            ne = 3;
            break e;
          }
          var le = zt(s, ue[0] + 4);
          if (12 > le || 4294967286 < le) {
            ne = 3;
            break e;
          }
          if (H && le > ce[0] - 8) {
            ne = 7;
            break e;
          }
          ne[0] = le, ue[0] += 12, ce[0] -= 12;
        }
        ne = 0;
      }
      if (ne != 0) return ne;
      for (le = 0 < Q.gb[0], p = p[0]; ; ) {
        e: {
          var De = s;
          ce = l, ne = p;
          var Ne = R, Te = G, qe = ue = [0];
          if ((Ue = ie = [ie])[0] = 0, 8 > ne[0]) ne = 7;
          else {
            if (!_(De, ce[0], "VP8X")) {
              if (zt(De, ce[0] + 4) != 10) {
                ne = 3;
                break e;
              }
              if (18 > ne[0]) {
                ne = 7;
                break e;
              }
              var He = zt(De, ce[0] + 8), vt = 1 + kt(De, ce[0] + 12);
              if (2147483648 <= vt * (De = 1 + kt(De, ce[0] + 15))) {
                ne = 3;
                break e;
              }
              qe != null && (qe[0] = He), Ne != null && (Ne[0] = vt), Te != null && (Te[0] = De), ce[0] += 18, ne[0] -= 18, Ue[0] = 1;
            }
            ne = 0;
          }
        }
        if (ie = ie[0], ue = ue[0], ne != 0) return ne;
        if (ce = !!(2 & ue), !le && ie) return 3;
        if (C != null && (C[0] = !!(16 & ue)), E != null && (E[0] = ce), z != null && (z[0] = 0), E = R[0], ue = G[0], ie && ce && N == null) {
          ne = 0;
          break;
        }
        if (4 > p) {
          ne = 7;
          break;
        }
        if (le && ie || !le && !ie && !_(s, l[0], "ALPH")) {
          p = [p], Q.na = [Q.na], Q.P = [Q.P], Q.Sa = [Q.Sa];
          e: {
            He = s, ne = l, le = p;
            var Ue = Q.gb;
            Ne = Q.na, Te = Q.P, qe = Q.Sa, vt = 22, g(He != null), g(le != null), De = ne[0];
            var ft = le[0];
            for (g(Ne != null), g(qe != null), Ne[0] = null, Te[0] = null, qe[0] = 0; ; ) {
              if (ne[0] = De, le[0] = ft, 8 > ft) {
                ne = 7;
                break e;
              }
              var Tt = zt(He, De + 4);
              if (4294967286 < Tt) {
                ne = 3;
                break e;
              }
              var ii = 8 + Tt + 1 & -2;
              if (vt += ii, 0 < Ue && vt > Ue) {
                ne = 3;
                break e;
              }
              if (!_(He, De, "VP8 ") || !_(He, De, "VP8L")) {
                ne = 0;
                break e;
              }
              if (ft[0] < ii) {
                ne = 7;
                break e;
              }
              _(He, De, "ALPH") || (Ne[0] = He, Te[0] = De + 8, qe[0] = Tt), De += ii, ft -= ii;
            }
          }
          if (p = p[0], Q.na = Q.na[0], Q.P = Q.P[0], Q.Sa = Q.Sa[0], ne != 0) break;
        }
        p = [p], Q.Ja = [Q.Ja], Q.xa = [Q.xa];
        e: if (Ue = s, ne = l, le = p, Ne = Q.gb[0], Te = Q.Ja, qe = Q.xa, He = ne[0], De = !_(Ue, He, "VP8 "), vt = !_(Ue, He, "VP8L"), g(Ue != null), g(le != null), g(Te != null), g(qe != null), 8 > le[0]) ne = 7;
        else {
          if (De || vt) {
            if (Ue = zt(Ue, He + 4), 12 <= Ne && Ue > Ne - 12) {
              ne = 3;
              break e;
            }
            if (H && Ue > le[0] - 8) {
              ne = 7;
              break e;
            }
            Te[0] = Ue, ne[0] += 8, le[0] -= 8, qe[0] = vt;
          } else qe[0] = 5 <= le[0] && Ue[He + 0] == 47 && !(Ue[He + 4] >> 5), Te[0] = le[0];
          ne = 0;
        }
        if (p = p[0], Q.Ja = Q.Ja[0], Q.xa = Q.xa[0], l = l[0], ne != 0) break;
        if (4294967286 < Q.Ja) return 3;
        if (z == null || ce || (z[0] = Q.xa ? 2 : 1), E = [E], ue = [ue], Q.xa) {
          if (5 > p) {
            ne = 7;
            break;
          }
          z = E, H = ue, ce = C, s == null || 5 > p ? s = 0 : 5 <= p && s[l + 0] == 47 && !(s[l + 4] >> 5) ? (le = [0], Ue = [0], Ne = [0], Ze(Te = new K(), s, l, p), pe(Te, le, Ue, Ne) ? (z != null && (z[0] = le[0]), H != null && (H[0] = Ue[0]), ce != null && (ce[0] = Ne[0]), s = 1) : s = 0) : s = 0;
        } else {
          if (10 > p) {
            ne = 7;
            break;
          }
          z = ue, s == null || 10 > p || !us(s, l + 3, p - 3) ? s = 0 : (H = s[l + 0] | s[l + 1] << 8 | s[l + 2] << 16, ce = 16383 & (s[l + 7] << 8 | s[l + 6]), s = 16383 & (s[l + 9] << 8 | s[l + 8]), 1 & H || 3 < (H >> 1 & 7) || !(H >> 4 & 1) || H >> 5 >= Q.Ja || !ce || !s ? s = 0 : (E && (E[0] = ce), z && (z[0] = s), s = 1));
        }
        if (!s || (E = E[0], ue = ue[0], ie && (R[0] != E || G[0] != ue))) return 3;
        N != null && (N[0] = Q, N.offset = l - N.w, g(4294967286 > l - N.w), g(N.offset == N.ha - p));
        break;
      }
      return ne == 0 || ne == 7 && ie && N == null ? (C != null && (C[0] |= Q.na != null && 0 < Q.na.length), b != null && (b[0] = E), P != null && (P[0] = ue), 0) : ne;
    }
    function pa(s, l, p) {
      var b = l.width, P = l.height, C = 0, E = 0, z = b, N = P;
      if (l.Da = s != null && 0 < s.Da, l.Da && (z = s.cd, N = s.bd, C = s.v, E = s.j, 11 > p || (C &= -2, E &= -2), 0 > C || 0 > E || 0 >= z || 0 >= N || C + z > b || E + N > P)) return 0;
      if (l.v = C, l.j = E, l.va = C + z, l.o = E + N, l.U = z, l.T = N, l.da = s != null && 0 < s.da, l.da) {
        if (!hi(z, N, p = [s.ib], C = [s.hb])) return 0;
        l.ib = p[0], l.hb = C[0];
      }
      return l.ob = s != null && s.ob, l.Kb = s == null || !s.Sd, l.da && (l.ob = l.ib < 3 * b / 4 && l.hb < 3 * P / 4, l.Kb = 0), 1;
    }
    function zn(s) {
      if (s == null) return 2;
      if (11 > s.S) {
        var l = s.f.RGBA;
        l.fb += (s.height - 1) * l.A, l.A = -l.A;
      } else l = s.f.kb, s = s.height, l.O += (s - 1) * l.fa, l.fa = -l.fa, l.N += (s - 1 >> 1) * l.Ab, l.Ab = -l.Ab, l.W += (s - 1 >> 1) * l.Db, l.Db = -l.Db, l.F != null && (l.J += (s - 1) * l.lb, l.lb = -l.lb);
      return 0;
    }
    function Fn(s, l, p, b) {
      if (b == null || 0 >= s || 0 >= l) return 2;
      if (p != null) {
        if (p.Da) {
          var P = p.cd, C = p.bd, E = -2 & p.v, z = -2 & p.j;
          if (0 > E || 0 > z || 0 >= P || 0 >= C || E + P > s || z + C > l) return 2;
          s = P, l = C;
        }
        if (p.da) {
          if (!hi(s, l, P = [p.ib], C = [p.hb])) return 2;
          s = P[0], l = C[0];
        }
      }
      b.width = s, b.height = l;
      e: {
        var N = b.width, R = b.height;
        if (s = b.S, 0 >= N || 0 >= R || !(s >= qs && 13 > s)) s = 2;
        else {
          if (0 >= b.Rd && b.sd == null) {
            E = C = P = l = 0;
            var G = (z = N * T[s]) * R;
            if (11 > s || (C = (R + 1) / 2 * (l = (N + 1) / 2), s == 12 && (E = (P = N) * R)), (R = A(G + 2 * C + E)) == null) {
              s = 1;
              break e;
            }
            b.sd = R, 11 > s ? ((N = b.f.RGBA).eb = R, N.fb = 0, N.A = z, N.size = G) : ((N = b.f.kb).y = R, N.O = 0, N.fa = z, N.Fd = G, N.f = R, N.N = 0 + G, N.Ab = l, N.Cd = C, N.ea = R, N.W = 0 + G + C, N.Db = l, N.Ed = C, s == 12 && (N.F = R, N.J = 0 + G + 2 * C), N.Tc = E, N.lb = P);
          }
          if (l = 1, P = b.S, C = b.width, E = b.height, P >= qs && 13 > P) if (11 > P) s = b.f.RGBA, l &= (z = Math.abs(s.A)) * (E - 1) + C <= s.size, l &= z >= C * T[P], l &= s.eb != null;
          else {
            s = b.f.kb, z = (C + 1) / 2, G = (E + 1) / 2, N = Math.abs(s.fa), R = Math.abs(s.Ab);
            var ie = Math.abs(s.Db), H = Math.abs(s.lb), Q = H * (E - 1) + C;
            l &= N * (E - 1) + C <= s.Fd, l &= R * (G - 1) + z <= s.Cd, l = (l &= ie * (G - 1) + z <= s.Ed) & N >= C & R >= z & ie >= z, l &= s.y != null, l &= s.f != null, l &= s.ea != null, P == 12 && (l &= H >= C, l &= Q <= s.Tc, l &= s.F != null);
          }
          else l = 0;
          s = l ? 0 : 2;
        }
      }
      return s != 0 || p != null && p.fd && (s = zn(b)), s;
    }
    var Hi = 64, Ma = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Da = 24, fa = 32, es = 8, $r = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    _t("Predictor0", "PredictorAdd0"), Le.Predictor0 = function() {
      return 4278190080;
    }, Le.Predictor1 = function(s) {
      return s;
    }, Le.Predictor2 = function(s, l, p) {
      return l[p + 0];
    }, Le.Predictor3 = function(s, l, p) {
      return l[p + 1];
    }, Le.Predictor4 = function(s, l, p) {
      return l[p - 1];
    }, Le.Predictor5 = function(s, l, p) {
      return Ct(Ct(s, l[p + 1]), l[p + 0]);
    }, Le.Predictor6 = function(s, l, p) {
      return Ct(s, l[p - 1]);
    }, Le.Predictor7 = function(s, l, p) {
      return Ct(s, l[p + 0]);
    }, Le.Predictor8 = function(s, l, p) {
      return Ct(l[p - 1], l[p + 0]);
    }, Le.Predictor9 = function(s, l, p) {
      return Ct(l[p + 0], l[p + 1]);
    }, Le.Predictor10 = function(s, l, p) {
      return Ct(Ct(s, l[p - 1]), Ct(l[p + 0], l[p + 1]));
    }, Le.Predictor11 = function(s, l, p) {
      var b = l[p + 0];
      return 0 >= fi(b >> 24 & 255, s >> 24 & 255, (l = l[p - 1]) >> 24 & 255) + fi(b >> 16 & 255, s >> 16 & 255, l >> 16 & 255) + fi(b >> 8 & 255, s >> 8 & 255, l >> 8 & 255) + fi(255 & b, 255 & s, 255 & l) ? b : s;
    }, Le.Predictor12 = function(s, l, p) {
      var b = l[p + 0];
      return (ei((s >> 24 & 255) + (b >> 24 & 255) - ((l = l[p - 1]) >> 24 & 255)) << 24 | ei((s >> 16 & 255) + (b >> 16 & 255) - (l >> 16 & 255)) << 16 | ei((s >> 8 & 255) + (b >> 8 & 255) - (l >> 8 & 255)) << 8 | ei((255 & s) + (255 & b) - (255 & l))) >>> 0;
    }, Le.Predictor13 = function(s, l, p) {
      var b = l[p - 1];
      return (pi((s = Ct(s, l[p + 0])) >> 24 & 255, b >> 24 & 255) << 24 | pi(s >> 16 & 255, b >> 16 & 255) << 16 | pi(s >> 8 & 255, b >> 8 & 255) << 8 | pi(s >> 0 & 255, b >> 0 & 255)) >>> 0;
    };
    var co = Le.PredictorAdd0;
    Le.PredictorAdd1 = wi, _t("Predictor2", "PredictorAdd2"), _t("Predictor3", "PredictorAdd3"), _t("Predictor4", "PredictorAdd4"), _t("Predictor5", "PredictorAdd5"), _t("Predictor6", "PredictorAdd6"), _t("Predictor7", "PredictorAdd7"), _t("Predictor8", "PredictorAdd8"), _t("Predictor9", "PredictorAdd9"), _t("Predictor10", "PredictorAdd10"), _t("Predictor11", "PredictorAdd11"), _t("Predictor12", "PredictorAdd12"), _t("Predictor13", "PredictorAdd13");
    var Rs = Le.PredictorAdd2;
    ui("ColorIndexInverseTransform", "MapARGB", "32b", function(s) {
      return s >> 8 & 255;
    }, function(s) {
      return s;
    }), ui("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(s) {
      return s;
    }, function(s) {
      return s >> 8 & 255;
    });
    var za, Sn = Le.ColorIndexInverseTransform, ts = Le.MapARGB, is = Le.VP8LColorIndexInverseTransformAlpha, al = Le.MapAlpha, rs = Le.VP8LPredictorsAdd = [];
    rs.length = 16, (Le.VP8LPredictors = []).length = 16, (Le.VP8LPredictorsAdd_C = []).length = 16, (Le.VP8LPredictors_C = []).length = 16;
    var _i, Qr, ns, un, dn, ma, Nn, ga, ya, ys, pn, Rn, Bs, _a, ss, fn, Pr, Or, _s, Zi, Ji, Ki, pr, An, Os, js, Fa, va, rc = A(511), Oo = A(2041), hr = A(225), vs = A(767), mn = 0, ho = Oo, uo = hr, en = vs, Ir = rc, qs = 0, Na = 1, ol = 2, po = 3, Ra = 4, jo = 5, El = 6, xs = 7, ll = 8, fo = 9, qo = 10, Ml = [2, 3, 7], nc = [3, 3, 11], Dl = [280, 256, 256, 256, 40], zl = [0, 1, 1, 1, 0], mo = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Fl = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Bn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Pn = 8, cl = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], gn = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], Us = null, Cc = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], sc = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Nl = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Rl = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], Uo = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], xa = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Rt = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], Vs = [], on = [], jr = [], ac = 1, Pt = 2, bs = [], On = [];
    tt("UpsampleRgbLinePair", Di, 3), tt("UpsampleBgrLinePair", Zt, 3), tt("UpsampleRgbaLinePair", Dn, 4), tt("UpsampleBgraLinePair", br, 4), tt("UpsampleArgbLinePair", Ai, 4), tt("UpsampleRgba4444LinePair", Si, 2), tt("UpsampleRgb565LinePair", rr, 2);
    var oc = Le.UpsampleRgbLinePair, Bl = Le.UpsampleBgrLinePair, Ol = Le.UpsampleRgbaLinePair, $s = Le.UpsampleBgraLinePair, jl = Le.UpsampleArgbLinePair, hl = Le.UpsampleRgba4444LinePair, ba = Le.UpsampleRgb565LinePair, ji = 16, Ba = 1 << ji - 1, ws = -227, wa = 482, ql = 6, Ul = (256 << ql) - 1, go = 0, Ss = A(256), ul = A(256), Vt = A(256), ni = A(256), f = A(wa - ws), t = A(wa - ws);
    Ns("YuvToRgbRow", Di, 3), Ns("YuvToBgrRow", Zt, 3), Ns("YuvToRgbaRow", Dn, 4), Ns("YuvToBgraRow", br, 4), Ns("YuvToArgbRow", Ai, 4), Ns("YuvToRgba4444Row", Si, 2), Ns("YuvToRgb565Row", rr, 2);
    var n = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], c = [0, 2, 8], u = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], m = 1;
    this.WebPDecodeRGBA = function(s, l, p, b, P) {
      var C = Na, E = new Mn(), z = new $i();
      E.ba = z, z.S = C, z.width = [z.width], z.height = [z.height];
      var N = z.width, R = z.height, G = new de();
      if (G == null || s == null) var ie = 2;
      else g(G != null), ie = gs(s, l, p, G.width, G.height, G.Pd, G.Qd, G.format, null);
      if (ie != 0 ? N = 0 : (N != null && (N[0] = G.width[0]), R != null && (R[0] = G.height[0]), N = 1), N) {
        z.width = z.width[0], z.height = z.height[0], b != null && (b[0] = z.width), P != null && (P[0] = z.height);
        e: {
          if (b = new cn(), (P = new lo()).data = s, P.w = l, P.ha = p, P.kd = 1, l = [0], g(P != null), ((s = gs(P.data, P.w, P.ha, null, null, null, l, null, P)) == 0 || s == 7) && l[0] && (s = 4), (l = s) == 0) {
            if (g(E != null), b.data = P.data, b.w = P.w + P.offset, b.ha = P.ha - P.offset, b.put = Ce, b.ac = Ae, b.bc = Me, b.ma = E, P.xa) {
              if ((s = ai()) == null) {
                E = 1;
                break e;
              }
              if (function(H, Q) {
                var ue = [0], ce = [0], ne = [0];
                t: for (; ; ) {
                  if (H == null) return 0;
                  if (Q == null) return H.a = 2, 0;
                  if (H.l = Q, H.a = 0, Ze(H.m, Q.data, Q.w, Q.ha), !pe(H.m, ue, ce, ne)) {
                    H.a = 3;
                    break t;
                  }
                  if (H.xb = Pt, Q.width = ue[0], Q.height = ce[0], !Fi(ue[0], ce[0], 1, H, null)) break t;
                  return 1;
                }
                return g(H.a != 0), 0;
              }(s, b)) {
                if (b = (l = Fn(b.width, b.height, E.Oa, E.ba)) == 0) {
                  t: {
                    b = s;
                    i: for (; ; ) {
                      if (b == null) {
                        b = 0;
                        break t;
                      }
                      if (g(b.s.yc != null), g(b.s.Ya != null), g(0 < b.s.Wb), g((p = b.l) != null), g((P = p.ma) != null), b.xb != 0) {
                        if (b.ca = P.ba, b.tb = P.tb, g(b.ca != null), !pa(P.Oa, p, po)) {
                          b.a = 2;
                          break i;
                        }
                        if (!er(b, p.width) || p.da) break i;
                        if ((p.da || Ft(b.ca.S)) && je(), 11 > b.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), b.ca.f.kb.F != null && je()), b.Pb && 0 < b.s.ua && b.s.vb.X == null && !Ut(b.s.vb, b.s.Wa.Xa)) {
                          b.a = 1;
                          break i;
                        }
                        b.xb = 0;
                      }
                      if (!Ei(b, b.V, b.Ba, b.c, b.i, p.o, gi)) break i;
                      P.Dc = b.Ma, b = 1;
                      break t;
                    }
                    g(b.a != 0), b = 0;
                  }
                  b = !b;
                }
                b && (l = s.a);
              } else l = s.a;
            } else {
              if ((s = new yr()) == null) {
                E = 1;
                break e;
              }
              if (s.Fa = P.na, s.P = P.P, s.qc = P.Sa, ir(s, b)) {
                if ((l = Fn(b.width, b.height, E.Oa, E.ba)) == 0) {
                  if (s.Aa = 0, p = E.Oa, g((P = s) != null), p != null) {
                    if (0 < (N = 0 > (N = p.Md) ? 0 : 100 < N ? 255 : 255 * N / 100)) {
                      for (R = G = 0; 4 > R; ++R) 12 > (ie = P.pb[R]).lc && (ie.ia = N * u[0 > ie.lc ? 0 : ie.lc] >> 3), G |= ie.ia;
                      G && (alert("todo:VP8InitRandom"), P.ia = 1);
                    }
                    P.Ga = p.Id, 100 < P.Ga ? P.Ga = 100 : 0 > P.Ga && (P.Ga = 0);
                  }
                  Ga(s, b) || (l = s.a);
                }
              } else l = s.a;
            }
            l == 0 && E.Oa != null && E.Oa.fd && (l = zn(E.ba));
          }
          E = l;
        }
        C = E != 0 ? null : 11 > C ? z.f.RGBA.eb : z.f.kb.y;
      } else C = null;
      return C;
    };
    var T = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function j(Le, dt) {
    for (var at = "", ae = 0; ae < 4; ae++) at += String.fromCharCode(Le[dt++]);
    return at;
  }
  function V(Le, dt) {
    return (Le[dt + 0] << 0 | Le[dt + 1] << 8 | Le[dt + 2] << 16) >>> 0;
  }
  function q(Le, dt) {
    return (Le[dt + 0] << 0 | Le[dt + 1] << 8 | Le[dt + 2] << 16 | Le[dt + 3] << 24) >>> 0;
  }
  new D();
  var U = [0], B = [0], ye = [], oe = new D(), xe = w, se = function(Le, dt) {
    var at = {}, ae = 0, he = !1, Ie = 0, Se = 0;
    if (at.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(ge, we, Ee, Be) {
      for (var Ve = 0; Ve < Be; Ve++) if (ge[we + Ve] != Ee.charCodeAt(Ve)) return !0;
      return !1;
    }(Le, dt, "RIFF", 4)) {
      var et, Qe;
      for (q(Le, dt += 4), dt += 8; dt < Le.length; ) {
        var rt = j(Le, dt), Ze = q(Le, dt += 4);
        dt += 4;
        var ct = Ze + (1 & Ze);
        switch (rt) {
          case "VP8 ":
          case "VP8L":
            at.frames[ae] === void 0 && (at.frames[ae] = {}), (K = at.frames[ae]).src_off = he ? Se : dt - 8, K.src_size = Ie + Ze + 8, ae++, he && (he = !1, Ie = 0, Se = 0);
            break;
          case "VP8X":
            (K = at.header = {}).feature_flags = Le[dt];
            var nt = dt + 4;
            K.canvas_width = 1 + V(Le, nt), nt += 3, K.canvas_height = 1 + V(Le, nt), nt += 3;
            break;
          case "ALPH":
            he = !0, Ie = ct + 8, Se = dt - 8;
            break;
          case "ANIM":
            (K = at.header).bgcolor = q(Le, dt), nt = dt + 4, K.loop_count = (et = Le)[(Qe = nt) + 0] << 0 | et[Qe + 1] << 8, nt += 2;
            break;
          case "ANMF":
            var wt, K;
            (K = at.frames[ae] = {}).offset_x = 2 * V(Le, dt), dt += 3, K.offset_y = 2 * V(Le, dt), dt += 3, K.width = 1 + V(Le, dt), dt += 3, K.height = 1 + V(Le, dt), dt += 3, K.duration = V(Le, dt), dt += 3, wt = Le[dt++], K.dispose = 1 & wt, K.blend = wt >> 1 & 1;
        }
        rt != "ANMF" && (dt += ct);
      }
      return at;
    }
  }(xe, 0);
  se.response = xe, se.rgbaoutput = !0, se.dataurl = !1;
  var ve = se.header ? se.header : null, Fe = se.frames ? se.frames : null;
  if (ve) {
    ve.loop_counter = ve.loop_count, U = [ve.canvas_height], B = [ve.canvas_width];
    for (var it = 0; it < Fe.length && Fe[it].blend != 0; it++) ;
  }
  var Ke = Fe[0], gt = oe.WebPDecodeRGBA(xe, Ke.src_off, Ke.src_size, B, U);
  Ke.rgba = gt, Ke.imgwidth = B[0], Ke.imgheight = U[0];
  for (var $e = 0; $e < B[0] * U[0] * 4; $e++) ye[$e] = gt[$e];
  return this.width = B, this.height = U, this.data = ye, this;
}
(function(w) {
  var g = function() {
    return typeof Zu == "function";
  }, _ = function(U, B, ye, oe) {
    var xe = 4, se = v;
    switch (oe) {
      case w.image_compression.FAST:
        xe = 1, se = A;
        break;
      case w.image_compression.MEDIUM:
        xe = 6, se = o;
        break;
      case w.image_compression.SLOW:
        xe = 9, se = D;
    }
    U = x(U, B, ye, se);
    var ve = Zu(U, { level: xe });
    return w.__addimage__.arrayBufferToBinaryString(ve);
  }, x = function(U, B, ye, oe) {
    for (var xe, se, ve, Fe = U.length / B, it = new Uint8Array(U.length + Fe), Ke = V(), gt = 0; gt < Fe; gt += 1) {
      if (ve = gt * B, xe = U.subarray(ve, ve + B), oe) it.set(oe(xe, ye, se), ve + gt);
      else {
        for (var $e, Le = Ke.length, dt = []; $e < Le; $e += 1) dt[$e] = Ke[$e](xe, ye, se);
        var at = q(dt.concat());
        it.set(dt[at], ve + gt);
      }
      se = xe;
    }
    return it;
  }, I = function(U) {
    var B = Array.apply([], U);
    return B.unshift(0), B;
  }, A = function(U, B) {
    var ye, oe = [], xe = U.length;
    oe[0] = 1;
    for (var se = 0; se < xe; se += 1) ye = U[se - B] || 0, oe[se + 1] = U[se] - ye + 256 & 255;
    return oe;
  }, v = function(U, B, ye) {
    var oe, xe = [], se = U.length;
    xe[0] = 2;
    for (var ve = 0; ve < se; ve += 1) oe = ye && ye[ve] || 0, xe[ve + 1] = U[ve] - oe + 256 & 255;
    return xe;
  }, o = function(U, B, ye) {
    var oe, xe, se = [], ve = U.length;
    se[0] = 3;
    for (var Fe = 0; Fe < ve; Fe += 1) oe = U[Fe - B] || 0, xe = ye && ye[Fe] || 0, se[Fe + 1] = U[Fe] + 256 - (oe + xe >>> 1) & 255;
    return se;
  }, D = function(U, B, ye) {
    var oe, xe, se, ve, Fe = [], it = U.length;
    Fe[0] = 4;
    for (var Ke = 0; Ke < it; Ke += 1) oe = U[Ke - B] || 0, xe = ye && ye[Ke] || 0, se = ye && ye[Ke - B] || 0, ve = j(oe, xe, se), Fe[Ke + 1] = U[Ke] - ve + 256 & 255;
    return Fe;
  }, j = function(U, B, ye) {
    if (U === B && B === ye) return U;
    var oe = Math.abs(B - ye), xe = Math.abs(U - ye), se = Math.abs(U + B - ye - ye);
    return oe <= xe && oe <= se ? U : xe <= se ? B : ye;
  }, V = function() {
    return [I, A, v, o, D];
  }, q = function(U) {
    var B = U.map(function(ye) {
      return ye.reduce(function(oe, xe) {
        return oe + Math.abs(xe);
      }, 0);
    });
    return B.indexOf(Math.min.apply(null, B));
  };
  w.processPNG = function(U, B, ye, oe) {
    var xe, se, ve, Fe, it, Ke, gt, $e, Le, dt, at, ae, he, Ie, Se, et = this.decode.FLATE_DECODE, Qe = "";
    if (this.__addimage__.isArrayBuffer(U) && (U = new Uint8Array(U)), this.__addimage__.isArrayBufferView(U)) {
      if (U = (ve = new s0(U)).imgData, se = ve.bits, xe = ve.colorSpace, it = ve.colors, [4, 6].indexOf(ve.colorType) !== -1) {
        if (ve.bits === 8) {
          Le = ($e = ve.pixelBitlength == 32 ? new Uint32Array(ve.decodePixels().buffer) : ve.pixelBitlength == 16 ? new Uint16Array(ve.decodePixels().buffer) : new Uint8Array(ve.decodePixels().buffer)).length, at = new Uint8Array(Le * ve.colors), dt = new Uint8Array(Le);
          var rt, Ze = ve.pixelBitlength - ve.bits;
          for (Ie = 0, Se = 0; Ie < Le; Ie++) {
            for (he = $e[Ie], rt = 0; rt < Ze; ) at[Se++] = he >>> rt & 255, rt += ve.bits;
            dt[Ie] = he >>> rt & 255;
          }
        }
        if (ve.bits === 16) {
          Le = ($e = new Uint32Array(ve.decodePixels().buffer)).length, at = new Uint8Array(Le * (32 / ve.pixelBitlength) * ve.colors), dt = new Uint8Array(Le * (32 / ve.pixelBitlength)), ae = ve.colors > 1, Ie = 0, Se = 0;
          for (var ct = 0; Ie < Le; ) he = $e[Ie++], at[Se++] = he >>> 0 & 255, ae && (at[Se++] = he >>> 16 & 255, he = $e[Ie++], at[Se++] = he >>> 0 & 255), dt[ct++] = he >>> 16 & 255;
          se = 8;
        }
        oe !== w.image_compression.NONE && g() ? (U = _(at, ve.width * ve.colors, ve.colors, oe), gt = _(dt, ve.width, 1, oe)) : (U = at, gt = dt, et = void 0);
      }
      if (ve.colorType === 3 && (xe = this.color_spaces.INDEXED, Ke = ve.palette, ve.transparency.indexed)) {
        var nt = ve.transparency.indexed, wt = 0;
        for (Ie = 0, Le = nt.length; Ie < Le; ++Ie) wt += nt[Ie];
        if ((wt /= 255) === Le - 1 && nt.indexOf(0) !== -1) Fe = [nt.indexOf(0)];
        else if (wt !== Le) {
          for ($e = ve.decodePixels(), dt = new Uint8Array($e.length), Ie = 0, Le = $e.length; Ie < Le; Ie++) dt[Ie] = nt[$e[Ie]];
          gt = _(dt, ve.width, 1);
        }
      }
      var K = function(ge) {
        var we;
        switch (ge) {
          case w.image_compression.FAST:
            we = 11;
            break;
          case w.image_compression.MEDIUM:
            we = 13;
            break;
          case w.image_compression.SLOW:
            we = 14;
            break;
          default:
            we = 12;
        }
        return we;
      }(oe);
      return et === this.decode.FLATE_DECODE && (Qe = "/Predictor " + K + " "), Qe += "/Colors " + it + " /BitsPerComponent " + se + " /Columns " + ve.width, (this.__addimage__.isArrayBuffer(U) || this.__addimage__.isArrayBufferView(U)) && (U = this.__addimage__.arrayBufferToBinaryString(U)), (gt && this.__addimage__.isArrayBuffer(gt) || this.__addimage__.isArrayBufferView(gt)) && (gt = this.__addimage__.arrayBufferToBinaryString(gt)), { alias: ye, data: U, index: B, filter: et, decodeParameters: Qe, transparency: Fe, palette: Ke, sMask: gt, predictor: K, width: ve.width, height: ve.height, bitsPerComponent: se, colorSpace: xe };
    }
  };
})(vi.API), function(w) {
  w.processGIF89A = function(g, _, x, I) {
    var A = new a0(g), v = A.width, o = A.height, D = [];
    A.decodeAndBlitFrameRGBA(0, D);
    var j = { data: D, width: v, height: o }, V = new Ou(100).encode(j, 100);
    return w.processJPEG.call(this, V, _, x, I);
  }, w.processGIF87A = w.processGIF89A;
}(vi.API), $a.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var w = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(w);
    for (var g = 0; g < w; g++) {
      var _ = this.datav.getUint8(this.pos++, !0), x = this.datav.getUint8(this.pos++, !0), I = this.datav.getUint8(this.pos++, !0), A = this.datav.getUint8(this.pos++, !0);
      this.palette[g] = { red: I, green: x, blue: _, quad: A };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, $a.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var w = "bit" + this.bitPP, g = this.width * this.height * 4;
    this.data = new Uint8Array(g), this[w]();
  } catch (_) {
    mr.log("bit decode error:" + _);
  }
}, $a.prototype.bit1 = function() {
  var w, g = Math.ceil(this.width / 8), _ = g % 4;
  for (w = this.height - 1; w >= 0; w--) {
    for (var x = this.bottom_up ? w : this.height - 1 - w, I = 0; I < g; I++) for (var A = this.datav.getUint8(this.pos++, !0), v = x * this.width * 4 + 8 * I * 4, o = 0; o < 8 && 8 * I + o < this.width; o++) {
      var D = this.palette[A >> 7 - o & 1];
      this.data[v + 4 * o] = D.blue, this.data[v + 4 * o + 1] = D.green, this.data[v + 4 * o + 2] = D.red, this.data[v + 4 * o + 3] = 255;
    }
    _ !== 0 && (this.pos += 4 - _);
  }
}, $a.prototype.bit4 = function() {
  for (var w = Math.ceil(this.width / 2), g = w % 4, _ = this.height - 1; _ >= 0; _--) {
    for (var x = this.bottom_up ? _ : this.height - 1 - _, I = 0; I < w; I++) {
      var A = this.datav.getUint8(this.pos++, !0), v = x * this.width * 4 + 2 * I * 4, o = A >> 4, D = 15 & A, j = this.palette[o];
      if (this.data[v] = j.blue, this.data[v + 1] = j.green, this.data[v + 2] = j.red, this.data[v + 3] = 255, 2 * I + 1 >= this.width) break;
      j = this.palette[D], this.data[v + 4] = j.blue, this.data[v + 4 + 1] = j.green, this.data[v + 4 + 2] = j.red, this.data[v + 4 + 3] = 255;
    }
    g !== 0 && (this.pos += 4 - g);
  }
}, $a.prototype.bit8 = function() {
  for (var w = this.width % 4, g = this.height - 1; g >= 0; g--) {
    for (var _ = this.bottom_up ? g : this.height - 1 - g, x = 0; x < this.width; x++) {
      var I = this.datav.getUint8(this.pos++, !0), A = _ * this.width * 4 + 4 * x;
      if (I < this.palette.length) {
        var v = this.palette[I];
        this.data[A] = v.red, this.data[A + 1] = v.green, this.data[A + 2] = v.blue, this.data[A + 3] = 255;
      } else this.data[A] = 255, this.data[A + 1] = 255, this.data[A + 2] = 255, this.data[A + 3] = 255;
    }
    w !== 0 && (this.pos += 4 - w);
  }
}, $a.prototype.bit15 = function() {
  for (var w = this.width % 3, g = parseInt("11111", 2), _ = this.height - 1; _ >= 0; _--) {
    for (var x = this.bottom_up ? _ : this.height - 1 - _, I = 0; I < this.width; I++) {
      var A = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var v = (A & g) / g * 255 | 0, o = (A >> 5 & g) / g * 255 | 0, D = (A >> 10 & g) / g * 255 | 0, j = A >> 15 ? 255 : 0, V = x * this.width * 4 + 4 * I;
      this.data[V] = D, this.data[V + 1] = o, this.data[V + 2] = v, this.data[V + 3] = j;
    }
    this.pos += w;
  }
}, $a.prototype.bit16 = function() {
  for (var w = this.width % 3, g = parseInt("11111", 2), _ = parseInt("111111", 2), x = this.height - 1; x >= 0; x--) {
    for (var I = this.bottom_up ? x : this.height - 1 - x, A = 0; A < this.width; A++) {
      var v = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (v & g) / g * 255 | 0, D = (v >> 5 & _) / _ * 255 | 0, j = (v >> 11) / g * 255 | 0, V = I * this.width * 4 + 4 * A;
      this.data[V] = j, this.data[V + 1] = D, this.data[V + 2] = o, this.data[V + 3] = 255;
    }
    this.pos += w;
  }
}, $a.prototype.bit24 = function() {
  for (var w = this.height - 1; w >= 0; w--) {
    for (var g = this.bottom_up ? w : this.height - 1 - w, _ = 0; _ < this.width; _++) {
      var x = this.datav.getUint8(this.pos++, !0), I = this.datav.getUint8(this.pos++, !0), A = this.datav.getUint8(this.pos++, !0), v = g * this.width * 4 + 4 * _;
      this.data[v] = A, this.data[v + 1] = I, this.data[v + 2] = x, this.data[v + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, $a.prototype.bit32 = function() {
  for (var w = this.height - 1; w >= 0; w--) for (var g = this.bottom_up ? w : this.height - 1 - w, _ = 0; _ < this.width; _++) {
    var x = this.datav.getUint8(this.pos++, !0), I = this.datav.getUint8(this.pos++, !0), A = this.datav.getUint8(this.pos++, !0), v = this.datav.getUint8(this.pos++, !0), o = g * this.width * 4 + 4 * _;
    this.data[o] = A, this.data[o + 1] = I, this.data[o + 2] = x, this.data[o + 3] = v;
  }
}, $a.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  w.processBMP = function(g, _, x, I) {
    var A = new $a(g, !1), v = A.width, o = A.height, D = { data: A.getData(), width: v, height: o }, j = new Ou(100).encode(D, 100);
    return w.processJPEG.call(this, j, _, x, I);
  };
}(vi.API), Wp.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  w.processWEBP = function(g, _, x, I) {
    var A = new Wp(g), v = A.width, o = A.height, D = { data: A.getData(), width: v, height: o }, j = new Ou(100).encode(D, 100);
    return w.processJPEG.call(this, j, _, x, I);
  };
}(vi.API), vi.API.processRGBA = function(w, g, _) {
  for (var x = w.data, I = x.length, A = new Uint8Array(I / 4 * 3), v = new Uint8Array(I / 4), o = 0, D = 0, j = 0; j < I; j += 4) {
    var V = x[j], q = x[j + 1], U = x[j + 2], B = x[j + 3];
    A[o++] = V, A[o++] = q, A[o++] = U, v[D++] = B;
  }
  var ye = this.__addimage__.arrayBufferToBinaryString(A);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(v), data: ye, index: g, alias: _, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: w.width, height: w.height };
}, vi.API.setLanguage = function(w) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[w] !== void 0 && (this.internal.languageSettings.languageCode = w, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, wc = vi.API, Nh = wc.getCharWidthsArray = function(w, g) {
  var _, x, I = (g = g || {}).font || this.internal.getFont(), A = g.fontSize || this.internal.getFontSize(), v = g.charSpace || this.internal.getCharSpace(), o = g.widths ? g.widths : I.metadata.Unicode.widths, D = o.fof ? o.fof : 1, j = g.kerning ? g.kerning : I.metadata.Unicode.kerning, V = j.fof ? j.fof : 1, q = g.doKerning !== !1, U = 0, B = w.length, ye = 0, oe = o[0] || D, xe = [];
  for (_ = 0; _ < B; _++) x = w.charCodeAt(_), typeof I.metadata.widthOfString == "function" ? xe.push((I.metadata.widthOfGlyph(I.metadata.characterToGlyph(x)) + v * (1e3 / A) || 0) / 1e3) : (U = q && or(j[x]) === "object" && !isNaN(parseInt(j[x][ye], 10)) ? j[x][ye] / V : 0, xe.push((o[x] || oe) / D + U)), ye = x;
  return xe;
}, Up = wc.getStringUnitWidth = function(w, g) {
  var _ = (g = g || {}).fontSize || this.internal.getFontSize(), x = g.font || this.internal.getFont(), I = g.charSpace || this.internal.getCharSpace();
  return wc.processArabic && (w = wc.processArabic(w)), typeof x.metadata.widthOfString == "function" ? x.metadata.widthOfString(w, _, I) / _ : Nh.apply(this, arguments).reduce(function(A, v) {
    return A + v;
  }, 0);
}, Vp = function(w, g, _, x) {
  for (var I = [], A = 0, v = w.length, o = 0; A !== v && o + g[A] < _; ) o += g[A], A++;
  I.push(w.slice(0, A));
  var D = A;
  for (o = 0; A !== v; ) o + g[A] > x && (I.push(w.slice(D, A)), o = 0, D = A), o += g[A], A++;
  return D !== A && I.push(w.slice(D, A)), I;
}, $p = function(w, g, _) {
  _ || (_ = {});
  var x, I, A, v, o, D, j, V = [], q = [V], U = _.textIndent || 0, B = 0, ye = 0, oe = w.split(" "), xe = Nh.apply(this, [" ", _])[0];
  if (D = _.lineIndent === -1 ? oe[0].length + 2 : _.lineIndent || 0) {
    var se = Array(D).join(" "), ve = [];
    oe.map(function(it) {
      (it = it.split(/\s*\n/)).length > 1 ? ve = ve.concat(it.map(function(Ke, gt) {
        return (gt && Ke.length ? `
` : "") + Ke;
      })) : ve.push(it[0]);
    }), oe = ve, D = Up.apply(this, [se, _]);
  }
  for (A = 0, v = oe.length; A < v; A++) {
    var Fe = 0;
    if (x = oe[A], D && x[0] == `
` && (x = x.substr(1), Fe = 1), U + B + (ye = (I = Nh.apply(this, [x, _])).reduce(function(it, Ke) {
      return it + Ke;
    }, 0)) > g || Fe) {
      if (ye > g) {
        for (o = Vp.apply(this, [x, I, g - (U + B), g]), V.push(o.shift()), V = [o.pop()]; o.length; ) q.push([o.shift()]);
        ye = I.slice(x.length - (V[0] ? V[0].length : 0)).reduce(function(it, Ke) {
          return it + Ke;
        }, 0);
      } else V = [x];
      q.push(V), U = ye + D, B = xe;
    } else V.push(x), U += B + ye, B = xe;
  }
  return j = D ? function(it, Ke) {
    return (Ke ? se : "") + it.join(" ");
  } : function(it) {
    return it.join(" ");
  }, q.map(j);
}, wc.splitTextToSize = function(w, g, _) {
  var x, I = (_ = _ || {}).fontSize || this.internal.getFontSize(), A = (function(V) {
    if (V.widths && V.kerning) return { widths: V.widths, kerning: V.kerning };
    var q = this.internal.getFont(V.fontName, V.fontStyle);
    return q.metadata.Unicode ? { widths: q.metadata.Unicode.widths || { 0: 1 }, kerning: q.metadata.Unicode.kerning || {} } : { font: q.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, _);
  x = Array.isArray(w) ? w : String(w).split(/\r?\n/);
  var v = 1 * this.internal.scaleFactor * g / I;
  A.textIndent = _.textIndent ? 1 * _.textIndent * this.internal.scaleFactor / I : 0, A.lineIndent = _.lineIndent;
  var o, D, j = [];
  for (o = 0, D = x.length; o < D; o++) j = j.concat($p.apply(this, [x[o], v, A]));
  return j;
}, function(w) {
  w.__fontmetrics__ = w.__fontmetrics__ || {};
  for (var g = "klmnopqrstuvwxyz", _ = {}, x = {}, I = 0; I < g.length; I++) _[g[I]] = "0123456789abcdef"[I], x["0123456789abcdef"[I]] = g[I];
  var A = function(q) {
    return "0x" + parseInt(q, 10).toString(16);
  }, v = w.__fontmetrics__.compress = function(q) {
    var U, B, ye, oe, xe = ["{"];
    for (var se in q) {
      if (U = q[se], isNaN(parseInt(se, 10)) ? B = "'" + se + "'" : (se = parseInt(se, 10), B = (B = A(se).slice(2)).slice(0, -1) + x[B.slice(-1)]), typeof U == "number") U < 0 ? (ye = A(U).slice(3), oe = "-") : (ye = A(U).slice(2), oe = ""), ye = oe + ye.slice(0, -1) + x[ye.slice(-1)];
      else {
        if (or(U) !== "object") throw new Error("Don't know what to do with value type " + or(U) + ".");
        ye = v(U);
      }
      xe.push(B + ye);
    }
    return xe.push("}"), xe.join("");
  }, o = w.__fontmetrics__.uncompress = function(q) {
    if (typeof q != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var U, B, ye, oe, xe = {}, se = 1, ve = xe, Fe = [], it = "", Ke = "", gt = q.length - 1, $e = 1; $e < gt; $e += 1) (oe = q[$e]) == "'" ? U ? (ye = U.join(""), U = void 0) : U = [] : U ? U.push(oe) : oe == "{" ? (Fe.push([ve, ye]), ve = {}, ye = void 0) : oe == "}" ? ((B = Fe.pop())[0][B[1]] = ve, ye = void 0, ve = B[0]) : oe == "-" ? se = -1 : ye === void 0 ? _.hasOwnProperty(oe) ? (it += _[oe], ye = parseInt(it, 16) * se, se = 1, it = "") : it += oe : _.hasOwnProperty(oe) ? (Ke += _[oe], ve[ye] = parseInt(Ke, 16) * se, se = 1, ye = void 0, Ke = "") : Ke += oe;
    return xe;
  }, D = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: o("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, j = { Unicode: { Courier: D, "Courier-Bold": D, "Courier-BoldOblique": D, "Courier-Oblique": D, Helvetica: D, "Helvetica-Bold": D, "Helvetica-BoldOblique": D, "Helvetica-Oblique": D, "Times-Roman": D, "Times-Bold": D, "Times-BoldItalic": D, "Times-Italic": D } }, V = { Unicode: { "Courier-Oblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": o("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": o("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: o("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: o("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": o("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": o("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  w.events.push(["addFont", function(q) {
    var U = q.font, B = V.Unicode[U.postScriptName];
    B && (U.metadata.Unicode = {}, U.metadata.Unicode.widths = B.widths, U.metadata.Unicode.kerning = B.kerning);
    var ye = j.Unicode[U.postScriptName];
    ye && (U.metadata.Unicode.encoding = ye, U.encoding = ye.codePages[0]);
  }]);
}(vi.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  var g = function(_) {
    for (var x = _.length, I = new Uint8Array(x), A = 0; A < x; A++) I[A] = _.charCodeAt(A);
    return I;
  };
  w.API.events.push(["addFont", function(_) {
    var x = void 0, I = _.font, A = _.instance;
    if (!I.isStandardFont) {
      if (A === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + I.postScriptName + "').");
      if (typeof (x = A.existsFileInVFS(I.postScriptName) === !1 ? A.loadFile(I.postScriptName) : A.getFileFromVFS(I.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + I.postScriptName + "').");
      (function(v, o) {
        o = /^\x00\x01\x00\x00/.test(o) ? g(o) : g(eh(o)), v.metadata = w.API.TTFFont.open(o), v.metadata.Unicode = v.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, v.metadata.glyIdsUsed = [0];
      })(I, x);
    }
  }]);
}(vi), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(w) {
  function g() {
    return (xi.canvg ? Promise.resolve(xi.canvg) : import("./index.es-C9urqxwy-GJR2QxNc.mjs")).catch(function(_) {
      return Promise.reject(new Error("Could not load canvg: " + _));
    }).then(function(_) {
      return _.default ? _.default : _;
    });
  }
  vi.API.addSvgAsImage = function(_, x, I, A, v, o, D, j) {
    if (isNaN(x) || isNaN(I)) throw mr.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(A) || isNaN(v)) throw mr.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var V = document.createElement("canvas");
    V.width = A, V.height = v;
    var q = V.getContext("2d");
    q.fillStyle = "#fff", q.fillRect(0, 0, V.width, V.height);
    var U = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, B = this;
    return g().then(function(ye) {
      return ye.fromString(q, _, U);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(ye) {
      return ye.render(U);
    }).then(function() {
      B.addImage(V.toDataURL("image/jpeg", 1), x, I, A, v, D, j);
    });
  };
}(), vi.API.putTotalPages = function(w) {
  var g, _ = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (g = new RegExp(w, "g"), _ = this.internal.getNumberOfPages()) : (g = new RegExp(this.pdfEscape16(w, this.internal.getFont()), "g"), _ = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var x = 1; x <= this.internal.getNumberOfPages(); x++) for (var I = 0; I < this.internal.pages[x].length; I++) this.internal.pages[x][I] = this.internal.pages[x][I].replace(g, _);
  return this;
}, vi.API.viewerPreferences = function(w, g) {
  var _;
  w = w || {}, g = g || !1;
  var x, I, A, v = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, o = Object.keys(v), D = [], j = 0, V = 0, q = 0;
  function U(ye, oe) {
    var xe, se = !1;
    for (xe = 0; xe < ye.length; xe += 1) ye[xe] === oe && (se = !0);
    return se;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(v)), this.internal.viewerpreferences.isSubscribed = !1), _ = this.internal.viewerpreferences.configuration, w === "reset" || g === !0) {
    var B = o.length;
    for (q = 0; q < B; q += 1) _[o[q]].value = _[o[q]].defaultValue, _[o[q]].explicitSet = !1;
  }
  if (or(w) === "object") {
    for (I in w) if (A = w[I], U(o, I) && A !== void 0) {
      if (_[I].type === "boolean" && typeof A == "boolean") _[I].value = A;
      else if (_[I].type === "name" && U(_[I].valueSet, A)) _[I].value = A;
      else if (_[I].type === "integer" && Number.isInteger(A)) _[I].value = A;
      else if (_[I].type === "array") {
        for (j = 0; j < A.length; j += 1) if (x = !0, A[j].length === 1 && typeof A[j][0] == "number") D.push(String(A[j] - 1));
        else if (A[j].length > 1) {
          for (V = 0; V < A[j].length; V += 1) typeof A[j][V] != "number" && (x = !1);
          x === !0 && D.push([A[j][0] - 1, A[j][1] - 1].join(" "));
        }
        _[I].value = "[" + D.join(" ") + "]";
      } else _[I].value = _[I].defaultValue;
      _[I].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var ye, oe = [];
    for (ye in _) _[ye].explicitSet === !0 && (_[ye].type === "name" ? oe.push("/" + ye + " /" + _[ye].value) : oe.push("/" + ye + " " + _[ye].value));
    oe.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + oe.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = _, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(w) {
  var g = function() {
    var x = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', I = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), A = unescape(encodeURIComponent(x)), v = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), o = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), D = unescape(encodeURIComponent("</x:xmpmeta>")), j = A.length + v.length + o.length + I.length + D.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + j + " >>"), this.internal.write("stream"), this.internal.write(I + A + v + o + D), this.internal.write("endstream"), this.internal.write("endobj");
  }, _ = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  w.addMetadata = function(x, I) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: x, namespaceuri: I || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", _), this.internal.events.subscribe("postPutResources", g)), this;
  };
}(vi.API), function(w) {
  var g = w.API, _ = g.pdfEscape16 = function(A, v) {
    for (var o, D = v.metadata.Unicode.widths, j = ["", "0", "00", "000", "0000"], V = [""], q = 0, U = A.length; q < U; ++q) {
      if (o = v.metadata.characterToGlyph(A.charCodeAt(q)), v.metadata.glyIdsUsed.push(o), v.metadata.toUnicode[o] = A.charCodeAt(q), D.indexOf(o) == -1 && (D.push(o), D.push([parseInt(v.metadata.widthOfGlyph(o), 10)])), o == "0") return V.join("");
      o = o.toString(16), V.push(j[4 - o.length], o);
    }
    return V.join("");
  }, x = function(A) {
    var v, o, D, j, V, q, U;
    for (V = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, D = [], q = 0, U = (o = Object.keys(A).sort(function(B, ye) {
      return B - ye;
    })).length; q < U; q++) v = o[q], D.length >= 100 && (V += `
` + D.length + ` beginbfchar
` + D.join(`
`) + `
endbfchar`, D = []), A[v] !== void 0 && A[v] !== null && typeof A[v].toString == "function" && (j = ("0000" + A[v].toString(16)).slice(-4), v = ("0000" + (+v).toString(16)).slice(-4), D.push("<" + v + "><" + j + ">"));
    return D.length && (V += `
` + D.length + ` beginbfchar
` + D.join(`
`) + `
endbfchar
`), V += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  g.events.push(["putFont", function(A) {
    (function(v) {
      var o = v.font, D = v.out, j = v.newObject, V = v.putStream;
      if (o.metadata instanceof w.API.TTFFont && o.encoding === "Identity-H") {
        for (var q = o.metadata.Unicode.widths, U = o.metadata.subset.encode(o.metadata.glyIdsUsed, 1), B = "", ye = 0; ye < U.length; ye++) B += String.fromCharCode(U[ye]);
        var oe = j();
        V({ data: B, addLength1: !0, objectId: oe }), D("endobj");
        var xe = j();
        V({ data: x(o.metadata.toUnicode), addLength1: !0, objectId: xe }), D("endobj");
        var se = j();
        D("<<"), D("/Type /FontDescriptor"), D("/FontName /" + Ac(o.fontName)), D("/FontFile2 " + oe + " 0 R"), D("/FontBBox " + w.API.PDFObject.convert(o.metadata.bbox)), D("/Flags " + o.metadata.flags), D("/StemV " + o.metadata.stemV), D("/ItalicAngle " + o.metadata.italicAngle), D("/Ascent " + o.metadata.ascender), D("/Descent " + o.metadata.decender), D("/CapHeight " + o.metadata.capHeight), D(">>"), D("endobj");
        var ve = j();
        D("<<"), D("/Type /Font"), D("/BaseFont /" + Ac(o.fontName)), D("/FontDescriptor " + se + " 0 R"), D("/W " + w.API.PDFObject.convert(q)), D("/CIDToGIDMap /Identity"), D("/DW 1000"), D("/Subtype /CIDFontType2"), D("/CIDSystemInfo"), D("<<"), D("/Supplement 0"), D("/Registry (Adobe)"), D("/Ordering (" + o.encoding + ")"), D(">>"), D(">>"), D("endobj"), o.objectNumber = j(), D("<<"), D("/Type /Font"), D("/Subtype /Type0"), D("/ToUnicode " + xe + " 0 R"), D("/BaseFont /" + Ac(o.fontName)), D("/Encoding /" + o.encoding), D("/DescendantFonts [" + ve + " 0 R]"), D(">>"), D("endobj"), o.isAlreadyPutted = !0;
      }
    })(A);
  }]), g.events.push(["putFont", function(A) {
    (function(v) {
      var o = v.font, D = v.out, j = v.newObject, V = v.putStream;
      if (o.metadata instanceof w.API.TTFFont && o.encoding === "WinAnsiEncoding") {
        for (var q = o.metadata.rawData, U = "", B = 0; B < q.length; B++) U += String.fromCharCode(q[B]);
        var ye = j();
        V({ data: U, addLength1: !0, objectId: ye }), D("endobj");
        var oe = j();
        V({ data: x(o.metadata.toUnicode), addLength1: !0, objectId: oe }), D("endobj");
        var xe = j();
        D("<<"), D("/Descent " + o.metadata.decender), D("/CapHeight " + o.metadata.capHeight), D("/StemV " + o.metadata.stemV), D("/Type /FontDescriptor"), D("/FontFile2 " + ye + " 0 R"), D("/Flags 96"), D("/FontBBox " + w.API.PDFObject.convert(o.metadata.bbox)), D("/FontName /" + Ac(o.fontName)), D("/ItalicAngle " + o.metadata.italicAngle), D("/Ascent " + o.metadata.ascender), D(">>"), D("endobj"), o.objectNumber = j();
        for (var se = 0; se < o.metadata.hmtx.widths.length; se++) o.metadata.hmtx.widths[se] = parseInt(o.metadata.hmtx.widths[se] * (1e3 / o.metadata.head.unitsPerEm));
        D("<</Subtype/TrueType/Type/Font/ToUnicode " + oe + " 0 R/BaseFont/" + Ac(o.fontName) + "/FontDescriptor " + xe + " 0 R/Encoding/" + o.encoding + " /FirstChar 29 /LastChar 255 /Widths " + w.API.PDFObject.convert(o.metadata.hmtx.widths) + ">>"), D("endobj"), o.isAlreadyPutted = !0;
      }
    })(A);
  }]);
  var I = function(A) {
    var v, o = A.text || "", D = A.x, j = A.y, V = A.options || {}, q = A.mutex || {}, U = q.pdfEscape, B = q.activeFontKey, ye = q.fonts, oe = B, xe = "", se = 0, ve = "", Fe = ye[oe].encoding;
    if (ye[oe].encoding !== "Identity-H") return { text: o, x: D, y: j, options: V, mutex: q };
    for (ve = o, oe = B, Array.isArray(o) && (ve = o[0]), se = 0; se < ve.length; se += 1) ye[oe].metadata.hasOwnProperty("cmap") && (v = ye[oe].metadata.cmap.unicode.codeMap[ve[se].charCodeAt(0)]), v || ve[se].charCodeAt(0) < 256 && ye[oe].metadata.hasOwnProperty("Unicode") ? xe += ve[se] : xe += "";
    var it = "";
    return parseInt(oe.slice(1)) < 14 || Fe === "WinAnsiEncoding" ? it = U(xe, oe).split("").map(function(Ke) {
      return Ke.charCodeAt(0).toString(16);
    }).join("") : Fe === "Identity-H" && (it = _(xe, ye[oe])), q.isHex = !0, { text: it, x: D, y: j, options: V, mutex: q };
  };
  g.events.push(["postProcessText", function(A) {
    var v = A.text || "", o = [], D = { text: v, x: A.x, y: A.y, options: A.options, mutex: A.mutex };
    if (Array.isArray(v)) {
      var j = 0;
      for (j = 0; j < v.length; j += 1) Array.isArray(v[j]) && v[j].length === 3 ? o.push([I(Object.assign({}, D, { text: v[j][0] })).text, v[j][1], v[j][2]]) : o.push(I(Object.assign({}, D, { text: v[j] })).text);
      A.text = o;
    } else A.text = I(Object.assign({}, D, { text: v })).text;
  }]);
}(vi), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(w) {
  var g = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  w.existsFileInVFS = function(_) {
    return g.call(this), this.internal.vFS[_] !== void 0;
  }, w.addFileToVFS = function(_, x) {
    return g.call(this), this.internal.vFS[_] = x, this;
  }, w.getFileFromVFS = function(_) {
    return g.call(this), this.internal.vFS[_] !== void 0 ? this.internal.vFS[_] : null;
  };
}(vi.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(w) {
  w.__bidiEngine__ = w.prototype.__bidiEngine__ = function(x) {
    var I, A, v, o, D, j, V, q = g, U = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], B = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], ye = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, oe = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, xe = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], se = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), ve = !1, Fe = 0;
    this.__bidiEngine__ = {};
    var it = function(ae) {
      var he = ae.charCodeAt(), Ie = he >> 8, Se = oe[Ie];
      return Se !== void 0 ? q[256 * Se + (255 & he)] : Ie === 252 || Ie === 253 ? "AL" : se.test(Ie) ? "L" : Ie === 8 ? "R" : "N";
    }, Ke = function(ae) {
      for (var he, Ie = 0; Ie < ae.length; Ie++) {
        if ((he = it(ae.charAt(Ie))) === "L") return !1;
        if (he === "R") return !0;
      }
      return !1;
    }, gt = function(ae, he, Ie, Se) {
      var et, Qe, rt, Ze, ct = he[Se];
      switch (ct) {
        case "L":
        case "R":
          ve = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          ve && (ct = "AN");
          break;
        case "AL":
          ve = !0, ct = "R";
          break;
        case "WS":
          ct = "N";
          break;
        case "CS":
          Se < 1 || Se + 1 >= he.length || (et = Ie[Se - 1]) !== "EN" && et !== "AN" || (Qe = he[Se + 1]) !== "EN" && Qe !== "AN" ? ct = "N" : ve && (Qe = "AN"), ct = Qe === et ? Qe : "N";
          break;
        case "ES":
          ct = (et = Se > 0 ? Ie[Se - 1] : "B") === "EN" && Se + 1 < he.length && he[Se + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (Se > 0 && Ie[Se - 1] === "EN") {
            ct = "EN";
            break;
          }
          if (ve) {
            ct = "N";
            break;
          }
          for (rt = Se + 1, Ze = he.length; rt < Ze && he[rt] === "ET"; ) rt++;
          ct = rt < Ze && he[rt] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (v && !o) {
            for (Ze = he.length, rt = Se + 1; rt < Ze && he[rt] === "NSM"; ) rt++;
            if (rt < Ze) {
              var nt = ae[Se], wt = nt >= 1425 && nt <= 2303 || nt === 64286;
              if (et = he[rt], wt && (et === "R" || et === "AL")) {
                ct = "R";
                break;
              }
            }
          }
          ct = Se < 1 || (et = he[Se - 1]) === "B" ? "N" : Ie[Se - 1];
          break;
        case "B":
          ve = !1, I = !0, ct = Fe;
          break;
        case "S":
          A = !0, ct = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          ve = !1;
          break;
        case "BN":
          ct = "N";
      }
      return ct;
    }, $e = function(ae, he, Ie) {
      var Se = ae.split("");
      return Ie && Le(Se, Ie, { hiLevel: Fe }), Se.reverse(), he && he.reverse(), Se.join("");
    }, Le = function(ae, he, Ie) {
      var Se, et, Qe, rt, Ze, ct = -1, nt = ae.length, wt = 0, K = [], ge = Fe ? B : U, we = [];
      for (ve = !1, I = !1, A = !1, et = 0; et < nt; et++) we[et] = it(ae[et]);
      for (Qe = 0; Qe < nt; Qe++) {
        if (Ze = wt, K[Qe] = gt(ae, we, K, Qe), Se = 240 & (wt = ge[Ze][ye[K[Qe]]]), wt &= 15, he[Qe] = rt = ge[wt][5], Se > 0) if (Se === 16) {
          for (et = ct; et < Qe; et++) he[et] = 1;
          ct = -1;
        } else ct = -1;
        if (ge[wt][6]) ct === -1 && (ct = Qe);
        else if (ct > -1) {
          for (et = ct; et < Qe; et++) he[et] = rt;
          ct = -1;
        }
        we[Qe] === "B" && (he[Qe] = 0), Ie.hiLevel |= rt;
      }
      A && function(Ee, Be, Ve) {
        for (var We = 0; We < Ve; We++) if (Ee[We] === "S") {
          Be[We] = Fe;
          for (var Ye = We - 1; Ye >= 0 && Ee[Ye] === "WS"; Ye--) Be[Ye] = Fe;
        }
      }(we, he, nt);
    }, dt = function(ae, he, Ie, Se, et) {
      if (!(et.hiLevel < ae)) {
        if (ae === 1 && Fe === 1 && !I) return he.reverse(), void (Ie && Ie.reverse());
        for (var Qe, rt, Ze, ct, nt = he.length, wt = 0; wt < nt; ) {
          if (Se[wt] >= ae) {
            for (Ze = wt + 1; Ze < nt && Se[Ze] >= ae; ) Ze++;
            for (ct = wt, rt = Ze - 1; ct < rt; ct++, rt--) Qe = he[ct], he[ct] = he[rt], he[rt] = Qe, Ie && (Qe = Ie[ct], Ie[ct] = Ie[rt], Ie[rt] = Qe);
            wt = Ze;
          }
          wt++;
        }
      }
    }, at = function(ae, he, Ie) {
      var Se = ae.split(""), et = { hiLevel: Fe };
      return Ie || (Ie = []), Le(Se, Ie, et), function(Qe, rt, Ze) {
        if (Ze.hiLevel !== 0 && V) for (var ct, nt = 0; nt < Qe.length; nt++) rt[nt] === 1 && (ct = xe.indexOf(Qe[nt])) >= 0 && (Qe[nt] = xe[ct + 1]);
      }(Se, Ie, et), dt(2, Se, he, Ie, et), dt(1, Se, he, Ie, et), Se.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(ae, he, Ie) {
      if (function(et, Qe) {
        if (Qe) for (var rt = 0; rt < et.length; rt++) Qe[rt] = rt;
        o === void 0 && (o = Ke(et)), j === void 0 && (j = Ke(et));
      }(ae, he), v || !D || j) if (v && D && o ^ j) Fe = o ? 1 : 0, ae = $e(ae, he, Ie);
      else if (!v && D && j) Fe = o ? 1 : 0, ae = at(ae, he, Ie), ae = $e(ae, he);
      else if (!v || o || D || j) {
        if (v && !D && o ^ j) ae = $e(ae, he), o ? (Fe = 0, ae = at(ae, he, Ie)) : (Fe = 1, ae = at(ae, he, Ie), ae = $e(ae, he));
        else if (v && o && !D && j) Fe = 1, ae = at(ae, he, Ie), ae = $e(ae, he);
        else if (!v && !D && o ^ j) {
          var Se = V;
          o ? (Fe = 1, ae = at(ae, he, Ie), Fe = 0, V = !1, ae = at(ae, he, Ie), V = Se) : (Fe = 0, ae = at(ae, he, Ie), ae = $e(ae, he), Fe = 1, V = !1, ae = at(ae, he, Ie), V = Se, ae = $e(ae, he));
        }
      } else Fe = 0, ae = at(ae, he, Ie);
      else Fe = o ? 1 : 0, ae = at(ae, he, Ie);
      return ae;
    }, this.__bidiEngine__.setOptions = function(ae) {
      ae && (v = ae.isInputVisual, D = ae.isOutputVisual, o = ae.isInputRtl, j = ae.isOutputRtl, V = ae.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(x), this.__bidiEngine__;
  };
  var g = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], _ = new w.__bidiEngine__({ isInputVisual: !0 });
  w.API.events.push(["postProcessText", function(x) {
    var I = x.text, A = (x.x, x.y, x.options || {}), v = (x.mutex, A.lang, []);
    if (A.isInputVisual = typeof A.isInputVisual != "boolean" || A.isInputVisual, _.setOptions(A), Object.prototype.toString.call(I) === "[object Array]") {
      var o = 0;
      for (v = [], o = 0; o < I.length; o += 1) Object.prototype.toString.call(I[o]) === "[object Array]" ? v.push([_.doBidiReorder(I[o][0]), I[o][1], I[o][2]]) : v.push([_.doBidiReorder(I[o])]);
      x.text = v;
    } else x.text = _.doBidiReorder(I);
    _.setOptions({ isInputVisual: !0 });
  }]);
}(vi), vi.API.TTFFont = function() {
  function w(g) {
    var _;
    if (this.rawData = g, _ = this.contents = new Tl(g), this.contents.pos = 4, _.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    _.pos = 0, this.parse(), this.subset = new b0(this), this.registerTTF();
  }
  return w.open = function(g) {
    return new w(g);
  }, w.prototype.parse = function() {
    return this.directory = new o0(this.contents), this.head = new c0(this), this.name = new f0(this), this.cmap = new pf(this), this.toUnicode = {}, this.hhea = new h0(this), this.maxp = new m0(this), this.hmtx = new g0(this), this.post = new d0(this), this.os2 = new u0(this), this.loca = new x0(this), this.glyf = new y0(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, w.prototype.registerTTF = function() {
    var g, _, x, I, A;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var v, o, D, j;
      for (j = [], v = 0, o = (D = this.bbox).length; v < o; v++) g = D[v], j.push(Math.round(g * this.scaleFactor));
      return j;
    }).call(this), this.stemV = 0, this.post.exists ? (x = 255 & (I = this.post.italic_angle), 32768 & (_ = I >> 16) && (_ = -(1 + (65535 ^ _))), this.italicAngle = +(_ + "." + x)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (A = this.familyClass) === 1 || A === 2 || A === 3 || A === 4 || A === 5 || A === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, w.prototype.characterToGlyph = function(g) {
    var _;
    return ((_ = this.cmap.unicode) != null ? _.codeMap[g] : void 0) || 0;
  }, w.prototype.widthOfGlyph = function(g) {
    var _;
    return _ = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(g).advance * _;
  }, w.prototype.widthOfString = function(g, _, x) {
    var I, A, v, o;
    for (v = 0, A = 0, o = (g = "" + g).length; 0 <= o ? A < o : A > o; A = 0 <= o ? ++A : --A) I = g.charCodeAt(A), v += this.widthOfGlyph(this.characterToGlyph(I)) + x * (1e3 / _) || 0;
    return v * (_ / 1e3);
  }, w.prototype.lineHeight = function(g, _) {
    var x;
    return _ == null && (_ = !1), x = _ ? this.lineGap : 0, (this.ascender + x - this.decender) / 1e3 * g;
  }, w;
}();
var Wa, Tl = function() {
  function w(g) {
    this.data = g ?? [], this.pos = 0, this.length = this.data.length;
  }
  return w.prototype.readByte = function() {
    return this.data[this.pos++];
  }, w.prototype.writeByte = function(g) {
    return this.data[this.pos++] = g;
  }, w.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, w.prototype.writeUInt32 = function(g) {
    return this.writeByte(g >>> 24 & 255), this.writeByte(g >> 16 & 255), this.writeByte(g >> 8 & 255), this.writeByte(255 & g);
  }, w.prototype.readInt32 = function() {
    var g;
    return (g = this.readUInt32()) >= 2147483648 ? g - 4294967296 : g;
  }, w.prototype.writeInt32 = function(g) {
    return g < 0 && (g += 4294967296), this.writeUInt32(g);
  }, w.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, w.prototype.writeUInt16 = function(g) {
    return this.writeByte(g >> 8 & 255), this.writeByte(255 & g);
  }, w.prototype.readInt16 = function() {
    var g;
    return (g = this.readUInt16()) >= 32768 ? g - 65536 : g;
  }, w.prototype.writeInt16 = function(g) {
    return g < 0 && (g += 65536), this.writeUInt16(g);
  }, w.prototype.readString = function(g) {
    var _, x;
    for (x = [], _ = 0; 0 <= g ? _ < g : _ > g; _ = 0 <= g ? ++_ : --_) x[_] = String.fromCharCode(this.readByte());
    return x.join("");
  }, w.prototype.writeString = function(g) {
    var _, x, I;
    for (I = [], _ = 0, x = g.length; 0 <= x ? _ < x : _ > x; _ = 0 <= x ? ++_ : --_) I.push(this.writeByte(g.charCodeAt(_)));
    return I;
  }, w.prototype.readShort = function() {
    return this.readInt16();
  }, w.prototype.writeShort = function(g) {
    return this.writeInt16(g);
  }, w.prototype.readLongLong = function() {
    var g, _, x, I, A, v, o, D;
    return g = this.readByte(), _ = this.readByte(), x = this.readByte(), I = this.readByte(), A = this.readByte(), v = this.readByte(), o = this.readByte(), D = this.readByte(), 128 & g ? -1 * (72057594037927940 * (255 ^ g) + 281474976710656 * (255 ^ _) + 1099511627776 * (255 ^ x) + 4294967296 * (255 ^ I) + 16777216 * (255 ^ A) + 65536 * (255 ^ v) + 256 * (255 ^ o) + (255 ^ D) + 1) : 72057594037927940 * g + 281474976710656 * _ + 1099511627776 * x + 4294967296 * I + 16777216 * A + 65536 * v + 256 * o + D;
  }, w.prototype.writeLongLong = function(g) {
    var _, x;
    return _ = Math.floor(g / 4294967296), x = 4294967295 & g, this.writeByte(_ >> 24 & 255), this.writeByte(_ >> 16 & 255), this.writeByte(_ >> 8 & 255), this.writeByte(255 & _), this.writeByte(x >> 24 & 255), this.writeByte(x >> 16 & 255), this.writeByte(x >> 8 & 255), this.writeByte(255 & x);
  }, w.prototype.readInt = function() {
    return this.readInt32();
  }, w.prototype.writeInt = function(g) {
    return this.writeInt32(g);
  }, w.prototype.read = function(g) {
    var _, x;
    for (_ = [], x = 0; 0 <= g ? x < g : x > g; x = 0 <= g ? ++x : --x) _.push(this.readByte());
    return _;
  }, w.prototype.write = function(g) {
    var _, x, I, A;
    for (A = [], x = 0, I = g.length; x < I; x++) _ = g[x], A.push(this.writeByte(_));
    return A;
  }, w;
}(), o0 = function() {
  var w;
  function g(_) {
    var x, I, A;
    for (this.scalarType = _.readInt(), this.tableCount = _.readShort(), this.searchRange = _.readShort(), this.entrySelector = _.readShort(), this.rangeShift = _.readShort(), this.tables = {}, I = 0, A = this.tableCount; 0 <= A ? I < A : I > A; I = 0 <= A ? ++I : --I) x = { tag: _.readString(4), checksum: _.readInt(), offset: _.readInt(), length: _.readInt() }, this.tables[x.tag] = x;
  }
  return g.prototype.encode = function(_) {
    var x, I, A, v, o, D, j, V, q, U, B, ye, oe;
    for (oe in B = Object.keys(_).length, D = Math.log(2), q = 16 * Math.floor(Math.log(B) / D), v = Math.floor(q / D), V = 16 * B - q, (I = new Tl()).writeInt(this.scalarType), I.writeShort(B), I.writeShort(q), I.writeShort(v), I.writeShort(V), A = 16 * B, j = I.pos + A, o = null, ye = [], _) for (U = _[oe], I.writeString(oe), I.writeInt(w(U)), I.writeInt(j), I.writeInt(U.length), ye = ye.concat(U), oe === "head" && (o = j), j += U.length; j % 4; ) ye.push(0), j++;
    return I.write(ye), x = 2981146554 - w(I.data), I.pos = o + 8, I.writeUInt32(x), I.data;
  }, w = function(_) {
    var x, I, A, v;
    for (_ = ff.call(_); _.length % 4; ) _.push(0);
    for (A = new Tl(_), I = 0, x = 0, v = _.length; x < v; x = x += 4) I += A.readUInt32();
    return 4294967295 & I;
  }, g;
}(), l0 = {}.hasOwnProperty, Lo = function(w, g) {
  for (var _ in g) l0.call(g, _) && (w[_] = g[_]);
  function x() {
    this.constructor = w;
  }
  return x.prototype = g.prototype, w.prototype = new x(), w.__super__ = g.prototype, w;
};
Wa = function() {
  function w(g) {
    var _;
    this.file = g, _ = this.file.directory.tables[this.tag], this.exists = !!_, _ && (this.offset = _.offset, this.length = _.length, this.parse(this.file.contents));
  }
  return w.prototype.parse = function() {
  }, w.prototype.encode = function() {
  }, w.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, w;
}();
var c0 = function(w) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Lo(g, Wa), g.prototype.tag = "head", g.prototype.parse = function(_) {
    return _.pos = this.offset, this.version = _.readInt(), this.revision = _.readInt(), this.checkSumAdjustment = _.readInt(), this.magicNumber = _.readInt(), this.flags = _.readShort(), this.unitsPerEm = _.readShort(), this.created = _.readLongLong(), this.modified = _.readLongLong(), this.xMin = _.readShort(), this.yMin = _.readShort(), this.xMax = _.readShort(), this.yMax = _.readShort(), this.macStyle = _.readShort(), this.lowestRecPPEM = _.readShort(), this.fontDirectionHint = _.readShort(), this.indexToLocFormat = _.readShort(), this.glyphDataFormat = _.readShort();
  }, g.prototype.encode = function(_) {
    var x;
    return (x = new Tl()).writeInt(this.version), x.writeInt(this.revision), x.writeInt(this.checkSumAdjustment), x.writeInt(this.magicNumber), x.writeShort(this.flags), x.writeShort(this.unitsPerEm), x.writeLongLong(this.created), x.writeLongLong(this.modified), x.writeShort(this.xMin), x.writeShort(this.yMin), x.writeShort(this.xMax), x.writeShort(this.yMax), x.writeShort(this.macStyle), x.writeShort(this.lowestRecPPEM), x.writeShort(this.fontDirectionHint), x.writeShort(_), x.writeShort(this.glyphDataFormat), x.data;
  }, g;
}(), Gp = function() {
  function w(g, _) {
    var x, I, A, v, o, D, j, V, q, U, B, ye, oe, xe, se, ve, Fe;
    switch (this.platformID = g.readUInt16(), this.encodingID = g.readShort(), this.offset = _ + g.readInt(), q = g.pos, g.pos = this.offset, this.format = g.readUInt16(), this.length = g.readUInt16(), this.language = g.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (D = 0; D < 256; ++D) this.codeMap[D] = g.readByte();
        break;
      case 4:
        for (B = g.readUInt16(), U = B / 2, g.pos += 6, A = function() {
          var it, Ke;
          for (Ke = [], D = it = 0; 0 <= U ? it < U : it > U; D = 0 <= U ? ++it : --it) Ke.push(g.readUInt16());
          return Ke;
        }(), g.pos += 2, oe = function() {
          var it, Ke;
          for (Ke = [], D = it = 0; 0 <= U ? it < U : it > U; D = 0 <= U ? ++it : --it) Ke.push(g.readUInt16());
          return Ke;
        }(), j = function() {
          var it, Ke;
          for (Ke = [], D = it = 0; 0 <= U ? it < U : it > U; D = 0 <= U ? ++it : --it) Ke.push(g.readUInt16());
          return Ke;
        }(), V = function() {
          var it, Ke;
          for (Ke = [], D = it = 0; 0 <= U ? it < U : it > U; D = 0 <= U ? ++it : --it) Ke.push(g.readUInt16());
          return Ke;
        }(), I = (this.length - g.pos + this.offset) / 2, o = function() {
          var it, Ke;
          for (Ke = [], D = it = 0; 0 <= I ? it < I : it > I; D = 0 <= I ? ++it : --it) Ke.push(g.readUInt16());
          return Ke;
        }(), D = se = 0, Fe = A.length; se < Fe; D = ++se) for (xe = A[D], x = ve = ye = oe[D]; ye <= xe ? ve <= xe : ve >= xe; x = ye <= xe ? ++ve : --ve) V[D] === 0 ? v = x + j[D] : (v = o[V[D] / 2 + (x - ye) - (U - D)] || 0) !== 0 && (v += j[D]), this.codeMap[x] = 65535 & v;
    }
    g.pos = q;
  }
  return w.encode = function(g, _) {
    var x, I, A, v, o, D, j, V, q, U, B, ye, oe, xe, se, ve, Fe, it, Ke, gt, $e, Le, dt, at, ae, he, Ie, Se, et, Qe, rt, Ze, ct, nt, wt, K, ge, we, Ee, Be, Ve, We, Ye, bt, xt, kt;
    switch (Se = new Tl(), v = Object.keys(g).sort(function(zt, Ut) {
      return zt - Ut;
    }), _) {
      case "macroman":
        for (oe = 0, xe = function() {
          var zt = [];
          for (ye = 0; ye < 256; ++ye) zt.push(0);
          return zt;
        }(), ve = { 0: 0 }, A = {}, et = 0, ct = v.length; et < ct; et++) ve[Ye = g[I = v[et]]] == null && (ve[Ye] = ++oe), A[I] = { old: g[I], new: ve[g[I]] }, xe[I] = ve[g[I]];
        return Se.writeUInt16(1), Se.writeUInt16(0), Se.writeUInt32(12), Se.writeUInt16(0), Se.writeUInt16(262), Se.writeUInt16(0), Se.write(xe), { charMap: A, subtable: Se.data, maxGlyphID: oe + 1 };
      case "unicode":
        for (he = [], q = [], Fe = 0, ve = {}, x = {}, se = j = null, Qe = 0, nt = v.length; Qe < nt; Qe++) ve[Ke = g[I = v[Qe]]] == null && (ve[Ke] = ++Fe), x[I] = { old: Ke, new: ve[Ke] }, o = ve[Ke] - I, se != null && o === j || (se && q.push(se), he.push(I), j = o), se = I;
        for (se && q.push(se), q.push(65535), he.push(65535), at = 2 * (dt = he.length), Le = 2 * Math.pow(Math.log(dt) / Math.LN2, 2), U = Math.log(Le / 2) / Math.LN2, $e = 2 * dt - Le, D = [], gt = [], B = [], ye = rt = 0, wt = he.length; rt < wt; ye = ++rt) {
          if (ae = he[ye], V = q[ye], ae === 65535) {
            D.push(0), gt.push(0);
            break;
          }
          if (ae - (Ie = x[ae].new) >= 32768) for (D.push(0), gt.push(2 * (B.length + dt - ye)), I = Ze = ae; ae <= V ? Ze <= V : Ze >= V; I = ae <= V ? ++Ze : --Ze) B.push(x[I].new);
          else D.push(Ie - ae), gt.push(0);
        }
        for (Se.writeUInt16(3), Se.writeUInt16(1), Se.writeUInt32(12), Se.writeUInt16(4), Se.writeUInt16(16 + 8 * dt + 2 * B.length), Se.writeUInt16(0), Se.writeUInt16(at), Se.writeUInt16(Le), Se.writeUInt16(U), Se.writeUInt16($e), Ve = 0, K = q.length; Ve < K; Ve++) I = q[Ve], Se.writeUInt16(I);
        for (Se.writeUInt16(0), We = 0, ge = he.length; We < ge; We++) I = he[We], Se.writeUInt16(I);
        for (bt = 0, we = D.length; bt < we; bt++) o = D[bt], Se.writeUInt16(o);
        for (xt = 0, Ee = gt.length; xt < Ee; xt++) it = gt[xt], Se.writeUInt16(it);
        for (kt = 0, Be = B.length; kt < Be; kt++) oe = B[kt], Se.writeUInt16(oe);
        return { charMap: x, subtable: Se.data, maxGlyphID: Fe + 1 };
    }
  }, w;
}(), pf = function(w) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Lo(g, Wa), g.prototype.tag = "cmap", g.prototype.parse = function(_) {
    var x, I, A;
    for (_.pos = this.offset, this.version = _.readUInt16(), A = _.readUInt16(), this.tables = [], this.unicode = null, I = 0; 0 <= A ? I < A : I > A; I = 0 <= A ? ++I : --I) x = new Gp(_, this.offset), this.tables.push(x), x.isUnicode && this.unicode == null && (this.unicode = x);
    return !0;
  }, g.encode = function(_, x) {
    var I, A;
    return x == null && (x = "macroman"), I = Gp.encode(_, x), (A = new Tl()).writeUInt16(0), A.writeUInt16(1), I.table = A.data.concat(I.subtable), I;
  }, g;
}(), h0 = function(w) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Lo(g, Wa), g.prototype.tag = "hhea", g.prototype.parse = function(_) {
    return _.pos = this.offset, this.version = _.readInt(), this.ascender = _.readShort(), this.decender = _.readShort(), this.lineGap = _.readShort(), this.advanceWidthMax = _.readShort(), this.minLeftSideBearing = _.readShort(), this.minRightSideBearing = _.readShort(), this.xMaxExtent = _.readShort(), this.caretSlopeRise = _.readShort(), this.caretSlopeRun = _.readShort(), this.caretOffset = _.readShort(), _.pos += 8, this.metricDataFormat = _.readShort(), this.numberOfMetrics = _.readUInt16();
  }, g;
}(), u0 = function(w) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Lo(g, Wa), g.prototype.tag = "OS/2", g.prototype.parse = function(_) {
    if (_.pos = this.offset, this.version = _.readUInt16(), this.averageCharWidth = _.readShort(), this.weightClass = _.readUInt16(), this.widthClass = _.readUInt16(), this.type = _.readShort(), this.ySubscriptXSize = _.readShort(), this.ySubscriptYSize = _.readShort(), this.ySubscriptXOffset = _.readShort(), this.ySubscriptYOffset = _.readShort(), this.ySuperscriptXSize = _.readShort(), this.ySuperscriptYSize = _.readShort(), this.ySuperscriptXOffset = _.readShort(), this.ySuperscriptYOffset = _.readShort(), this.yStrikeoutSize = _.readShort(), this.yStrikeoutPosition = _.readShort(), this.familyClass = _.readShort(), this.panose = function() {
      var x, I;
      for (I = [], x = 0; x < 10; ++x) I.push(_.readByte());
      return I;
    }(), this.charRange = function() {
      var x, I;
      for (I = [], x = 0; x < 4; ++x) I.push(_.readInt());
      return I;
    }(), this.vendorID = _.readString(4), this.selection = _.readShort(), this.firstCharIndex = _.readShort(), this.lastCharIndex = _.readShort(), this.version > 0 && (this.ascent = _.readShort(), this.descent = _.readShort(), this.lineGap = _.readShort(), this.winAscent = _.readShort(), this.winDescent = _.readShort(), this.codePageRange = function() {
      var x, I;
      for (I = [], x = 0; x < 2; x = ++x) I.push(_.readInt());
      return I;
    }(), this.version > 1)) return this.xHeight = _.readShort(), this.capHeight = _.readShort(), this.defaultChar = _.readShort(), this.breakChar = _.readShort(), this.maxContext = _.readShort();
  }, g;
}(), d0 = function(w) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Lo(g, Wa), g.prototype.tag = "post", g.prototype.parse = function(_) {
    var x, I, A;
    switch (_.pos = this.offset, this.format = _.readInt(), this.italicAngle = _.readInt(), this.underlinePosition = _.readShort(), this.underlineThickness = _.readShort(), this.isFixedPitch = _.readInt(), this.minMemType42 = _.readInt(), this.maxMemType42 = _.readInt(), this.minMemType1 = _.readInt(), this.maxMemType1 = _.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var v;
        for (I = _.readUInt16(), this.glyphNameIndex = [], v = 0; 0 <= I ? v < I : v > I; v = 0 <= I ? ++v : --v) this.glyphNameIndex.push(_.readUInt16());
        for (this.names = [], A = []; _.pos < this.offset + this.length; ) x = _.readByte(), A.push(this.names.push(_.readString(x)));
        return A;
      case 151552:
        return I = _.readUInt16(), this.offsets = _.read(I);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var o, D, j;
          for (j = [], v = o = 0, D = this.file.maxp.numGlyphs; 0 <= D ? o < D : o > D; v = 0 <= D ? ++o : --o) j.push(_.readUInt32());
          return j;
        }).call(this);
    }
  }, g;
}(), p0 = function(w, g) {
  this.raw = w, this.length = w.length, this.platformID = g.platformID, this.encodingID = g.encodingID, this.languageID = g.languageID;
}, f0 = function(w) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Lo(g, Wa), g.prototype.tag = "name", g.prototype.parse = function(_) {
    var x, I, A, v, o, D, j, V, q, U, B;
    for (_.pos = this.offset, _.readShort(), x = _.readShort(), D = _.readShort(), I = [], v = 0; 0 <= x ? v < x : v > x; v = 0 <= x ? ++v : --v) I.push({ platformID: _.readShort(), encodingID: _.readShort(), languageID: _.readShort(), nameID: _.readShort(), length: _.readShort(), offset: this.offset + D + _.readShort() });
    for (j = {}, v = q = 0, U = I.length; q < U; v = ++q) A = I[v], _.pos = A.offset, V = _.readString(A.length), o = new p0(V, A), j[B = A.nameID] == null && (j[B] = []), j[A.nameID].push(o);
    this.strings = j, this.copyright = j[0], this.fontFamily = j[1], this.fontSubfamily = j[2], this.uniqueSubfamily = j[3], this.fontName = j[4], this.version = j[5];
    try {
      this.postscriptName = j[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = j[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = j[7], this.manufacturer = j[8], this.designer = j[9], this.description = j[10], this.vendorUrl = j[11], this.designerUrl = j[12], this.license = j[13], this.licenseUrl = j[14], this.preferredFamily = j[15], this.preferredSubfamily = j[17], this.compatibleFull = j[18], this.sampleText = j[19];
  }, g;
}(), m0 = function(w) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Lo(g, Wa), g.prototype.tag = "maxp", g.prototype.parse = function(_) {
    return _.pos = this.offset, this.version = _.readInt(), this.numGlyphs = _.readUInt16(), this.maxPoints = _.readUInt16(), this.maxContours = _.readUInt16(), this.maxCompositePoints = _.readUInt16(), this.maxComponentContours = _.readUInt16(), this.maxZones = _.readUInt16(), this.maxTwilightPoints = _.readUInt16(), this.maxStorage = _.readUInt16(), this.maxFunctionDefs = _.readUInt16(), this.maxInstructionDefs = _.readUInt16(), this.maxStackElements = _.readUInt16(), this.maxSizeOfInstructions = _.readUInt16(), this.maxComponentElements = _.readUInt16(), this.maxComponentDepth = _.readUInt16();
  }, g;
}(), g0 = function(w) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Lo(g, Wa), g.prototype.tag = "hmtx", g.prototype.parse = function(_) {
    var x, I, A, v, o, D, j;
    for (_.pos = this.offset, this.metrics = [], x = 0, D = this.file.hhea.numberOfMetrics; 0 <= D ? x < D : x > D; x = 0 <= D ? ++x : --x) this.metrics.push({ advance: _.readUInt16(), lsb: _.readInt16() });
    for (A = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var V, q;
      for (q = [], x = V = 0; 0 <= A ? V < A : V > A; x = 0 <= A ? ++V : --V) q.push(_.readInt16());
      return q;
    }(), this.widths = (function() {
      var V, q, U, B;
      for (B = [], V = 0, q = (U = this.metrics).length; V < q; V++) v = U[V], B.push(v.advance);
      return B;
    }).call(this), I = this.widths[this.widths.length - 1], j = [], x = o = 0; 0 <= A ? o < A : o > A; x = 0 <= A ? ++o : --o) j.push(this.widths.push(I));
    return j;
  }, g.prototype.forGlyph = function(_) {
    return _ in this.metrics ? this.metrics[_] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[_ - this.metrics.length] };
  }, g;
}(), ff = [].slice, y0 = function(w) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Lo(g, Wa), g.prototype.tag = "glyf", g.prototype.parse = function() {
    return this.cache = {};
  }, g.prototype.glyphFor = function(_) {
    var x, I, A, v, o, D, j, V, q, U;
    return _ in this.cache ? this.cache[_] : (v = this.file.loca, x = this.file.contents, I = v.indexOf(_), (A = v.lengthOf(_)) === 0 ? this.cache[_] = null : (x.pos = this.offset + I, o = (D = new Tl(x.read(A))).readShort(), V = D.readShort(), U = D.readShort(), j = D.readShort(), q = D.readShort(), this.cache[_] = o === -1 ? new v0(D, V, U, j, q) : new _0(D, o, V, U, j, q), this.cache[_]));
  }, g.prototype.encode = function(_, x, I) {
    var A, v, o, D, j;
    for (o = [], v = [], D = 0, j = x.length; D < j; D++) A = _[x[D]], v.push(o.length), A && (o = o.concat(A.encode(I)));
    return v.push(o.length), { table: o, offsets: v };
  }, g;
}(), _0 = function() {
  function w(g, _, x, I, A, v) {
    this.raw = g, this.numberOfContours = _, this.xMin = x, this.yMin = I, this.xMax = A, this.yMax = v, this.compound = !1;
  }
  return w.prototype.encode = function() {
    return this.raw.data;
  }, w;
}(), v0 = function() {
  function w(g, _, x, I, A) {
    var v, o;
    for (this.raw = g, this.xMin = _, this.yMin = x, this.xMax = I, this.yMax = A, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], v = this.raw; o = v.readShort(), this.glyphOffsets.push(v.pos), this.glyphIDs.push(v.readUInt16()), 32 & o; ) v.pos += 1 & o ? 4 : 2, 128 & o ? v.pos += 8 : 64 & o ? v.pos += 4 : 8 & o && (v.pos += 2);
  }
  return w.prototype.encode = function() {
    var g, _, x;
    for (_ = new Tl(ff.call(this.raw.data)), g = 0, x = this.glyphIDs.length; g < x; ++g) _.pos = this.glyphOffsets[g];
    return _.data;
  }, w;
}(), x0 = function(w) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Lo(g, Wa), g.prototype.tag = "loca", g.prototype.parse = function(_) {
    var x, I;
    return _.pos = this.offset, x = this.file.head.indexToLocFormat, this.offsets = x === 0 ? (function() {
      var A, v;
      for (v = [], I = 0, A = this.length; I < A; I += 2) v.push(2 * _.readUInt16());
      return v;
    }).call(this) : (function() {
      var A, v;
      for (v = [], I = 0, A = this.length; I < A; I += 4) v.push(_.readUInt32());
      return v;
    }).call(this);
  }, g.prototype.indexOf = function(_) {
    return this.offsets[_];
  }, g.prototype.lengthOf = function(_) {
    return this.offsets[_ + 1] - this.offsets[_];
  }, g.prototype.encode = function(_, x) {
    for (var I = new Uint32Array(this.offsets.length), A = 0, v = 0, o = 0; o < I.length; ++o) if (I[o] = A, v < x.length && x[v] == o) {
      ++v, I[o] = A;
      var D = this.offsets[o], j = this.offsets[o + 1] - D;
      j > 0 && (A += j);
    }
    for (var V = new Array(4 * I.length), q = 0; q < I.length; ++q) V[4 * q + 3] = 255 & I[q], V[4 * q + 2] = (65280 & I[q]) >> 8, V[4 * q + 1] = (16711680 & I[q]) >> 16, V[4 * q] = (4278190080 & I[q]) >> 24;
    return V;
  }, g;
}(), b0 = function() {
  function w(g) {
    this.font = g, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return w.prototype.generateCmap = function() {
    var g, _, x, I, A;
    for (_ in I = this.font.cmap.tables[0].codeMap, g = {}, A = this.subset) x = A[_], g[_] = I[x];
    return g;
  }, w.prototype.glyphsFor = function(g) {
    var _, x, I, A, v, o, D;
    for (I = {}, v = 0, o = g.length; v < o; v++) I[A = g[v]] = this.font.glyf.glyphFor(A);
    for (A in _ = [], I) (x = I[A]) != null && x.compound && _.push.apply(_, x.glyphIDs);
    if (_.length > 0) for (A in D = this.glyphsFor(_)) x = D[A], I[A] = x;
    return I;
  }, w.prototype.encode = function(g, _) {
    var x, I, A, v, o, D, j, V, q, U, B, ye, oe, xe, se;
    for (I in x = pf.encode(this.generateCmap(), "unicode"), v = this.glyphsFor(g), B = { 0: 0 }, se = x.charMap) B[(D = se[I]).old] = D.new;
    for (ye in U = x.maxGlyphID, v) ye in B || (B[ye] = U++);
    return V = function(ve) {
      var Fe, it;
      for (Fe in it = {}, ve) it[ve[Fe]] = Fe;
      return it;
    }(B), q = Object.keys(V).sort(function(ve, Fe) {
      return ve - Fe;
    }), oe = function() {
      var ve, Fe, it;
      for (it = [], ve = 0, Fe = q.length; ve < Fe; ve++) o = q[ve], it.push(V[o]);
      return it;
    }(), A = this.font.glyf.encode(v, oe, B), j = this.font.loca.encode(A.offsets, oe), xe = { cmap: this.font.cmap.raw(), glyf: A.table, loca: j, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(_) }, this.font.os2.exists && (xe["OS/2"] = this.font.os2.raw()), this.font.directory.encode(xe);
  }, w;
}();
vi.API.PDFObject = function() {
  var w;
  function g() {
  }
  return w = function(_, x) {
    return (Array(x + 1).join("0") + _).slice(-x);
  }, g.convert = function(_) {
    var x, I, A, v;
    if (Array.isArray(_)) return "[" + function() {
      var o, D, j;
      for (j = [], o = 0, D = _.length; o < D; o++) x = _[o], j.push(g.convert(x));
      return j;
    }().join(" ") + "]";
    if (typeof _ == "string") return "/" + _;
    if (_ != null && _.isString) return "(" + _ + ")";
    if (_ instanceof Date) return "(D:" + w(_.getUTCFullYear(), 4) + w(_.getUTCMonth(), 2) + w(_.getUTCDate(), 2) + w(_.getUTCHours(), 2) + w(_.getUTCMinutes(), 2) + w(_.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(_) === "[object Object]") {
      for (I in A = ["<<"], _) v = _[I], A.push("/" + I + " " + g.convert(v));
      return A.push(">>"), A.join(`
`);
    }
    return "" + _;
  }, g;
}();
const Wh = {
  "circle-radius": 8,
  "circle-color": "red",
  "circle-stroke-width": 1,
  "circle-stroke-color": "black"
}, rh = {
  style: {
    textSize: 16,
    textHaloColor: "#FFFFFF",
    textHaloWidth: 0.8,
    textColor: "#000000",
    fallbackTextFont: ["Open Sans Regular"]
  },
  visibility: "visible",
  position: "bottom-right"
}, nh = {
  image: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="none" stroke="white" stroke-width="1.5"/><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="#000000" fill-rule="evenodd"></path></svg>',
  imageName: "gl-export-north-icon",
  imageSizeFraction: 0.05,
  visibility: "visible",
  position: "top-right"
};
class mf {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(g, _ = Ql.A4, x = 300, I = Ko.PNG, A = tc.mm, v = "map", o = "maplibregl-marker", D = Wh, j = "maplibregl-ctrl-attrib-inner", V = rh, q = nh) {
    Vi(this, "map"), Vi(this, "width"), Vi(this, "height"), Vi(this, "dpi"), Vi(this, "format"), Vi(this, "unit"), Vi(this, "fileName"), Vi(this, "markerClassName"), Vi(this, "markerCirclePaint"), Vi(this, "attributionClassName"), Vi(this, "attributionOptions"), Vi(this, "northIconOptions"), this.map = g, this.width = _[0], this.height = _[1], this.dpi = x, this.format = I, this.unit = A, this.fileName = v, this.markerClassName = o, this.markerCirclePaint = D, this.attributionClassName = j, this.attributionOptions = V, this.northIconOptions = q;
  }
  renderMapPost(g) {
    return g;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(g) {
    const _ = this.getMarkers();
    for (let x = 0; x < _.length; x++) {
      const I = _.item(x);
      if (!I) continue;
      const A = I.getAttribute("style");
      if (!A) continue;
      const v = /translate\(([^,]+)px,\s*([^,]+)px\)/, o = A.match(v);
      if (!o) continue;
      const D = parseInt(o[1]), j = parseInt(o[2]), V = this.map.unproject([D, j]), q = `point${x}`;
      g.addSource(q, {
        type: "geojson",
        data: {
          type: "Point",
          coordinates: [V.lng, V.lat]
        }
      }), g.addLayer({
        id: q,
        source: q,
        type: "circle",
        paint: this.markerCirclePaint
      });
    }
    return g;
  }
  /**
   * Generate and download Map image
   */
  generate() {
    const g = this;
    JsLoadingOverlay.show({
      overlayBackgroundColor: "#5D5959",
      overlayOpacity: "0.6",
      spinnerIcon: "ball-spin",
      spinnerColor: "#2400FD",
      spinnerSize: "2x",
      overlayIDName: "overlay",
      spinnerIDName: "spinner",
      offsetX: 0,
      offsetY: 0,
      containerID: null,
      lockScroll: !1,
      overlayZIndex: 9998,
      spinnerZIndex: 9999
    });
    const _ = global.window.devicePixelRatio;
    Object.defineProperty(global.window, "devicePixelRatio", {
      get() {
        return g.dpi / 96;
      }
    });
    const x = document.createElement("div");
    x.className = "hidden-map", document.body.appendChild(x);
    const I = document.createElement("div");
    I.style.width = this.toPixels(this.width), I.style.height = this.toPixels(this.height), x.appendChild(I);
    const A = this.map.getStyle();
    if (A && A.sources) {
      const o = A.sources;
      Object.keys(o).forEach((D) => {
        const j = o[D];
        Object.keys(j).forEach((V) => {
          j[V] || delete j[V];
        });
      });
    }
    let v = this.getRenderedMap(I, A);
    this.addNorthIconToMap(v).then(() => {
      v.once("idle", () => {
        this.addAttributions(v) ? v.once("idle", () => {
          v = this.renderMapPost(v), this.getMarkers().length === 0 ? this.exportImage(v, x, _) : (v = this.renderMarkers(v), v.once("idle", () => {
            this.exportImage(v, x, _);
          }));
        }) : (v = this.renderMapPost(v), this.getMarkers().length === 0 ? this.exportImage(v, x, _) : (v = this.renderMarkers(v), v.once("idle", () => {
          this.exportImage(v, x, _);
        })));
      });
    });
  }
  stripHtml(g) {
    const _ = document.createElement("div");
    return _.innerHTML = g, _.textContent || _.innerText || "";
  }
  /**
   * Get icon width against exported map size by using fraction rate
   * @param renderMap Map object
   * @param fraction adjust icon size by using this fraction rate. Default is 8%
   * @returns Icon width calculated
   */
  getIconWidth(g, _) {
    const x = g.getContainer(), I = parseInt(x.style.width.replace("px", ""));
    return parseInt(`${I * _}`);
  }
  /**
   * Get element position's pixel values based on selected position setting
   * @param renderMap Map object
   * @param position Position of element inserted
   * @param offset Offset value to adjust position
   * @returns Pixels [width, height]
   */
  getElementPosition(g, _, x = 0) {
    const I = g.getContainer();
    let A = 0, v = 0;
    switch (_) {
      case "top-left":
        A = 0 + x, v = 0 + x;
        break;
      case "top-right":
        A = parseInt(I.style.width.replace("px", "")) - x, v = 0 + x;
        break;
      case "bottom-left":
        A = 0 + x, v = parseInt(I.style.height.replace("px", "")) - x;
        break;
      case "bottom-right":
        A = parseInt(I.style.width.replace("px", "")) - x, v = parseInt(I.style.height.replace("px", "")) - x;
        break;
    }
    return [A, v];
  }
  /**
   * Add North Icon SVG to map object
   * @param renderMap Map object
   * @returns void
   */
  addNorthIconImage(g) {
    const _ = this.getIconWidth(g, this.northIconOptions.imageSizeFraction ?? 0.08);
    return new Promise((x) => {
      const I = new Image(_, _);
      I.onload = () => {
        this.northIconOptions.imageName && g.addImage(this.northIconOptions.imageName, I), x();
      };
      function A(v) {
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(v);
      }
      this.northIconOptions.image && (I.src = A(this.northIconOptions.image));
    });
  }
  /**
   * Add North Icon Symbol layer to renderMap object
   * @param renderMap Map object
   * @returns
   */
  addNorthIconToMap(g) {
    let _ = this.northIconOptions.visibility ?? "visible";
    return g.getZoom() < 2 && this.width > this.height && (_ = "none"), new Promise((x) => {
      this.addNorthIconImage(g).then(() => {
        const I = this.getIconWidth(
          g,
          this.northIconOptions.imageSizeFraction ?? 0.08
        ) * 0.8, A = this.getElementPosition(
          g,
          this.northIconOptions.position ?? "top-right",
          I
        ), v = g.unproject(A), o = this.northIconOptions.imageName ?? "gl-export-north-icon";
        g.addSource(o, {
          type: "geojson",
          data: {
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: [v.lng, v.lat]
            },
            properties: {}
          }
        }), g.addLayer({
          id: o,
          source: o,
          type: "symbol",
          layout: {
            "icon-image": o,
            "icon-size": 1,
            "icon-rotate": g.getBearing() * -1,
            "icon-allow-overlap": !0,
            "icon-ignore-placement": !0,
            visibility: _
          },
          paint: {}
        }), x();
      });
    });
  }
  addAttributions(g) {
    var _;
    if (!this.map.getStyle().glyphs) return !1;
    const x = g.getContainer(), I = this.attributionOptions.position ?? "bottom-right", A = this.getElementPosition(g, I, 5), v = A[0], o = g.unproject(A), D = x.getElementsByClassName(this.attributionClassName), j = [];
    if ((D == null ? void 0 : D.length) > 0) {
      const xe = D.item(0);
      if (xe)
        for (let se = 0; se < xe.children.length; se++) {
          const ve = xe.children.item(se);
          ve && j.push(this.stripHtml(ve.outerHTML));
        }
    } else {
      const xe = this.map.getStyle().sources;
      Object.keys(xe).forEach((se) => {
        const ve = xe[se];
        if ("attribution" in ve) {
          const Fe = ve.attribution;
          j.push(this.stripHtml(Fe));
        }
      });
    }
    if (j.length === 0) return !1;
    const V = j.join(" | "), q = "attribution";
    g.addSource(q, {
      type: "geojson",
      data: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [o.lng, o.lat]
        },
        properties: {
          attribution: V
        }
      }
    });
    const U = this.map.getStyle().layers.filter(
      (xe) => xe.type === "symbol" && xe.layout && "text-font" in xe.layout
    ), B = U.length > 0 && U[0].layout ? U[0].layout["text-font"] : (_ = this.attributionOptions.style) == null ? void 0 : _.fallbackTextFont;
    let ye = this.attributionOptions.visibility ?? "visible";
    g.getZoom() < 2 && this.width > this.height && (ye = "none");
    const oe = this.attributionOptions.style;
    return g.addLayer({
      id: q,
      source: q,
      type: "symbol",
      layout: {
        "text-field": ["get", "attribution"],
        "text-font": B,
        "text-max-width": parseInt(`${v / oe.textSize}`),
        "text-anchor": I,
        "text-justify": ["top-right", "bottom-right"].includes(I) ? "right" : "left",
        "text-size": oe.textSize,
        "text-allow-overlap": !0,
        visibility: ye
      },
      paint: {
        "text-halo-color": oe.textHaloColor,
        "text-halo-width": oe.textHaloWidth,
        "text-color": oe.textColor
      }
    }), !0;
  }
  exportImage(g, _, x) {
    var I;
    const A = g.getCanvas(), v = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case Ko.PNG:
        this.toPNG(A, v);
        break;
      case Ko.JPEG:
        this.toJPEG(A, v);
        break;
      case Ko.PDF:
        this.toPDF(g, v);
        break;
      case Ko.SVG:
        this.toSVG(A, v);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    g.remove(), (I = _.parentNode) == null || I.removeChild(_), Object.defineProperty(global.window, "devicePixelRatio", {
      get() {
        return x;
      }
    }), _.remove(), JsLoadingOverlay.hide();
  }
  /**
   * Convert canvas to PNG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toPNG(g, _) {
    const x = document.createElement("a");
    x.href = g.toDataURL(), x.download = _, x.click(), x.remove();
  }
  /**
   * Convert canvas to JPEG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toJPEG(g, _) {
    const x = g.toDataURL("image/jpeg", 0.85), I = document.createElement("a");
    I.href = x, I.download = _, I.click(), I.remove();
  }
  /**
   * Convert Map object to PDF
   * @param map Map object
   * @param fileName file name
   */
  toPDF(g, _) {
    const x = g.getCanvas(), I = new vi({
      orientation: this.width > this.height ? "l" : "p",
      unit: this.unit,
      compress: !0,
      format: [this.width, this.height]
    });
    I.addImage(
      x.toDataURL("image/png"),
      "png",
      0,
      0,
      this.width,
      this.height,
      void 0,
      "FAST"
    );
    const { lng: A, lat: v } = g.getCenter();
    I.setProperties({
      title: g.getStyle().name,
      subject: `center: [${A}, ${v}], zoom: ${g.getZoom()}`,
      creator: "Mapbox GL Export Plugin",
      author: "(c)Mapbox, (c)OpenStreetMap"
    }), I.save(_);
  }
  /**
   * Convert canvas to SVG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toSVG(g, _) {
    const x = g.toDataURL("image/png"), I = Number(this.toPixels(this.width, this.dpi).replace("px", "")), A = Number(this.toPixels(this.height, this.dpi).replace("px", "")), v = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${I}" 
      height="${A}" 
      viewBox="0 0 ${I} ${A}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${x}" width="${I}" height="${A}"></image>
    </svg>`, o = document.createElement("a");
    o.href = `data:application/xml,${encodeURIComponent(v)}`, o.download = _, o.click(), o.remove();
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(g, _ = 96) {
    return this.unit === tc.mm && (_ /= 25.4), `${_ * g}px`;
  }
}
class w0 extends mf {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(g, _ = Ql.A4, x = 300, I = Ko.PNG, A = tc.mm, v = "map", o = Wh, D = rh, j = nh) {
    super(
      g,
      _,
      x,
      I,
      A,
      v,
      "maplibregl-marker",
      o,
      "maplibregl-ctrl-attrib-inner",
      D,
      j
    );
  }
  getRenderedMap(g, _) {
    const x = new og.Map({
      container: g,
      style: _,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transfrom request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (x.setMaxPitch(85), x.setPitch(this.map.getPitch()));
    const I = (this.map.style.imageManager || {}).images || [];
    return Object.keys(I).forEach((A) => {
      I[A].data && x.addImage(A, I[A].data);
    }), x;
  }
  renderMapPost(g) {
    const _ = this.map.getTerrain();
    return _ && g.setTerrain({
      source: _.source,
      exaggeration: _.exaggeration
    }), g;
  }
}
class S0 {
  constructor(g) {
    Vi(this, "controlContainer"), Vi(this, "exportContainer"), Vi(this, "crosshair"), Vi(this, "printableArea"), Vi(this, "map"), Vi(this, "exportButton"), Vi(this, "options", {
      PageSize: Ql.A4,
      PageOrientation: Mh.Landscape,
      Format: Ko.PDF,
      DPI: Ip[300],
      Crosshair: !1,
      PrintableArea: !1,
      Local: "en",
      AllowedSizes: Object.keys(Ql),
      Filename: "map",
      markerCirclePaint: Wh,
      attributionOptions: rh,
      northIconOptions: nh
    }), Vi(this, "MAPLIB_CSS_PREFIX", "maplibregl"), g && (g.attributionOptions = Object.assign(
      rh,
      g.attributionOptions
    ), g.northIconOptions = Object.assign(nh, g.northIconOptions), this.options = Object.assign(this.options, g)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const g = this.options.Local ?? "en";
    return Pg(g);
  }
  onAdd(g) {
    var _;
    this.map = g, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const x = document.createElement("TABLE");
    x.className = "print-table";
    const I = {};
    (_ = this.options.AllowedSizes) == null || _.forEach((V) => {
      Ql[V] && (I[V] = Ql[V]);
    });
    const A = this.createSelection(
      I,
      this.getTranslation().PageSize,
      "page-size",
      this.options.PageSize,
      (V, q) => JSON.stringify(V[q])
    );
    x.appendChild(A);
    const v = this.createSelection(
      Mh,
      this.getTranslation().PageOrientation,
      "page-orientation",
      this.options.PageOrientation,
      (V, q) => V[q]
    );
    x.appendChild(v);
    const o = this.createSelection(
      Ko,
      this.getTranslation().Format,
      "format-type",
      this.options.Format,
      (V, q) => V[q]
    );
    x.appendChild(o);
    const D = this.createSelection(
      Ip,
      this.getTranslation().DPI,
      "dpi-type",
      this.options.DPI,
      (V, q) => V[q]
    );
    x.appendChild(D), this.exportContainer.appendChild(x);
    const j = document.createElement("button");
    return j.type = "button", j.textContent = this.getTranslation().Generate, j.classList.add("generate-button"), j.addEventListener("click", () => {
      const V = document.getElementById("mapbox-gl-export-page-size"), q = document.getElementById("mapbox-gl-export-page-orientation"), U = document.getElementById("mapbox-gl-export-format-type"), B = document.getElementById("mapbox-gl-export-dpi-type"), ye = q.value;
      let oe = JSON.parse(V.value);
      ye === Mh.Portrait && (oe = oe.reverse()), this.generateMap(
        g,
        oe,
        Number(B.value),
        U.value,
        tc.mm,
        this.options.Filename
      );
    }), this.exportContainer.appendChild(j), this.controlContainer;
  }
  generateMap(g, _, x, I, A, v) {
    new w0(
      g,
      _,
      x,
      I,
      A,
      v,
      this.options.markerCirclePaint,
      this.options.attributionOptions,
      this.options.northIconOptions
    ).generate();
  }
  createSelection(g, _, x, I, A) {
    const v = document.createElement("label");
    v.textContent = _;
    const o = document.createElement("select");
    o.setAttribute("id", `mapbox-gl-export-${x}`), o.style.width = "100%", Object.keys(g).forEach((q) => {
      const U = document.createElement("option");
      U.setAttribute("value", A(g, q)), U.appendChild(document.createTextNode(q)), U.setAttribute("name", x), I === g[q] && (U.selected = !0), o.appendChild(U);
    }), o.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const D = document.createElement("TR"), j = document.createElement("TD"), V = document.createElement("TD");
    return j.appendChild(v), V.appendChild(o), D.appendChild(j), D.appendChild(V), D;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(g) {
    this.controlContainer && !this.controlContainer.contains(g.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(g) {
    this.options.Crosshair === !0 && (g === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new hg(this.map), this.crosshair.create()));
  }
  togglePrintableArea(g) {
    this.options.PrintableArea === !0 && (g === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new ug(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0)
      return;
    const g = document.getElementById("mapbox-gl-export-page-size"), _ = document.getElementById("mapbox-gl-export-page-orientation").value;
    let x = JSON.parse(g.value);
    _ === Mh.Portrait && (x = x.reverse()), this.printableArea.updateArea(x[0], x[1]);
  }
}
(function(w) {
  var g = {};
  function _(x) {
    if (g[x]) return g[x].exports;
    var I = g[x] = { i: x, l: !1, exports: {} };
    return w[x].call(I.exports, I, I.exports, _), I.l = !0, I.exports;
  }
  _.m = w, _.c = g, _.d = function(x, I, A) {
    _.o(x, I) || Object.defineProperty(x, I, { enumerable: !0, get: A });
  }, _.r = function(x) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(x, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(x, "__esModule", { value: !0 });
  }, _.t = function(x, I) {
    if (1 & I && (x = _(x)), 8 & I || 4 & I && typeof x == "object" && x && x.__esModule) return x;
    var A = /* @__PURE__ */ Object.create(null);
    if (_.r(A), Object.defineProperty(A, "default", { enumerable: !0, value: x }), 2 & I && typeof x != "string") for (var v in x) _.d(A, v, (function(o) {
      return x[o];
    }).bind(null, v));
    return A;
  }, _.n = function(x) {
    var I = x && x.__esModule ? function() {
      return x.default;
    } : function() {
      return x;
    };
    return _.d(I, "a", I), I;
  }, _.o = function(x, I) {
    return Object.prototype.hasOwnProperty.call(x, I);
  }, _.p = "", _(_.s = 0);
})([function(w, g, _) {
  w.exports = _(1);
}, function(w, g) {
  function _(I, A) {
    for (var v = 0; v < A.length; v++) {
      var o = A[v];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(I, o.key, o);
    }
  }
  var x = function() {
    function I() {
      (function(o, D) {
        if (!(o instanceof D)) throw new TypeError("Cannot call a class as a function");
      })(this, I), this.options = { overlayBackgroundColor: "#666666", overlayOpacity: 0.6, spinnerIcon: "ball-circus", spinnerColor: "#000", spinnerSize: "3x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetY: 0, offsetX: 0, lockScroll: !1, containerID: null, spinnerZIndex: 99999, overlayZIndex: 99998 }, this.stylesheetBaseURL = "https://cdn.jsdelivr.net/npm/load-awesome@1.1.0/css/", this.spinner = null, this.spinnerStylesheetURL = null, this.numberOfEmptyDivForSpinner = { "ball-8bits": 16, "ball-atom": 4, "ball-beat": 3, "ball-circus": 5, "ball-climbing-dot": 1, "ball-clip-rotate": 1, "ball-clip-rotate-multiple": 2, "ball-clip-rotate-pulse": 2, "ball-elastic-dots": 5, "ball-fall": 3, "ball-fussion": 4, "ball-grid-beat": 9, "ball-grid-pulse": 9, "ball-newton-cradle": 4, "ball-pulse": 3, "ball-pulse-rise": 5, "ball-pulse-sync": 3, "ball-rotate": 1, "ball-running-dots": 5, "ball-scale": 1, "ball-scale-multiple": 3, "ball-scale-pulse": 2, "ball-scale-ripple": 1, "ball-scale-ripple-multiple": 3, "ball-spin": 8, "ball-spin-clockwise": 8, "ball-spin-clockwise-fade": 8, "ball-spin-clockwise-fade-rotating": 8, "ball-spin-fade": 8, "ball-spin-fade-rotating": 8, "ball-spin-rotate": 2, "ball-square-clockwise-spin": 8, "ball-square-spin": 8, "ball-triangle-path": 3, "ball-zig-zag": 2, "ball-zig-zag-deflect": 2, cog: 1, "cube-transition": 2, fire: 3, "line-scale": 5, "line-scale-party": 5, "line-scale-pulse-out": 5, "line-scale-pulse-out-rapid": 5, "line-spin-clockwise-fade": 8, "line-spin-clockwise-fade-rotating": 8, "line-spin-fade": 8, "line-spin-fade-rotating": 8, pacman: 6, "square-jelly-box": 2, "square-loader": 1, "square-spin": 1, timer: 1, "triangle-skew-spin": 1 };
    }
    var A, v;
    return A = I, (v = [{ key: "show", value: function(o) {
      this.setOptions(o), this.addSpinnerStylesheet(), this.generateSpinnerElement(), this.options.lockScroll && (document.body.style.overflow = "hidden", document.documentElement.style.overflow = "hidden"), this.generateAndAddOverlayElement();
    } }, { key: "hide", value: function() {
      this.options.lockScroll && (document.body.style.overflow = "", document.documentElement.style.overflow = "");
      var o = document.getElementById("loading-overlay-stylesheet");
      o && (o.disabled = !0, o.parentNode.removeChild(o), document.getElementById(this.options.overlayIDName).remove(), document.getElementById(this.options.spinnerIDName).remove());
    } }, { key: "setOptions", value: function(o) {
      if (o !== void 0) for (var D in o) this.options[D] = o[D];
    } }, { key: "generateAndAddOverlayElement", value: function() {
      var o = "50%";
      this.options.offsetX !== 0 && (o = "calc(50% + " + this.options.offsetX + ")");
      var D = "50%";
      if (this.options.offsetY !== 0 && (D = "calc(50% + " + this.options.offsetY + ")"), this.options.containerID && document.body.contains(document.getElementById(this.options.containerID))) {
        var j = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: absolute; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, '; z-index: 50; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: absolute; top: ').concat(D, "; left: ").concat(o, '; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: 9999;">').concat(this.spinner, "</div>"), V = document.getElementById(this.options.containerID);
        return V.style.position = "relative", void V.insertAdjacentHTML("beforeend", j);
      }
      var q = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: fixed; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, "; z-index: ").concat(this.options.overlayZIndex, '; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: fixed; top: ').concat(D, "; left: ").concat(o, "; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: ").concat(this.options.spinnerZIndex, ';">').concat(this.spinner, "</div>");
      document.body.insertAdjacentHTML("beforeend", q);
    } }, { key: "generateSpinnerElement", value: function() {
      var o = this, D = Object.keys(this.numberOfEmptyDivForSpinner).find(function(V) {
        return V === o.options.spinnerIcon;
      }), j = this.generateEmptyDivElement(this.numberOfEmptyDivForSpinner[D]);
      this.spinner = '<div style="color: '.concat(this.options.spinnerColor, '" class="la-').concat(this.options.spinnerIcon, " la-").concat(this.options.spinnerSize, '">').concat(j, "</div>");
    } }, { key: "addSpinnerStylesheet", value: function() {
      this.setSpinnerStylesheetURL();
      var o = document.createElement("link");
      o.setAttribute("id", "loading-overlay-stylesheet"), o.setAttribute("rel", "stylesheet"), o.setAttribute("type", "text/css"), o.setAttribute("href", this.spinnerStylesheetURL), document.getElementsByTagName("head")[0].appendChild(o);
    } }, { key: "setSpinnerStylesheetURL", value: function() {
      this.spinnerStylesheetURL = this.stylesheetBaseURL + this.options.spinnerIcon + ".min.css";
    } }, { key: "generateEmptyDivElement", value: function(o) {
      for (var D = "", j = 1; j <= o; j++) D += "<div></div>";
      return D;
    } }]) && _(A.prototype, v), I;
  }();
  window.JsLoadingOverlay = new x(), w.exports = JsLoadingOverlay;
}]);
class A0 extends mf {
  /**
   * Constructor
   * @param map MapboxMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(_, x = Ql.A4, I = 300, A = Ko.PNG, v = tc.mm, o = "map", D = Wh, j = rh, V = nh, q) {
    super(
      _,
      x,
      I,
      A,
      v,
      o,
      "mapboxgl-marker",
      D,
      "mapboxgl-ctrl-attrib-inner",
      j,
      V
    );
    Eu(this, "accesstoken");
    this.accesstoken = q;
  }
  getRenderedMap(_, x) {
    var v;
    const I = new ng({
      accessToken: this.accesstoken || sg,
      container: _,
      style: x,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transfrom request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    }), A = (this.map.style.imageManager || {}).images || [];
    return A && ((v = Object.keys(A)) == null ? void 0 : v.length) > 0 && Object.keys(A).forEach((o) => {
      o && A[o].data && I.addImage(o, A[o].data);
    }), I;
  }
}
class T0 extends S0 {
  constructor(_) {
    super(_);
    Eu(this, "accessToken");
    this.MAPLIB_CSS_PREFIX = "mapboxgl", this.accessToken = _.accessToken;
  }
  generateMap(_, x, I, A, v, o) {
    new A0(
      _,
      x,
      I,
      A,
      v,
      o,
      this.options.markerCirclePaint,
      this.options.attributionOptions,
      this.options.northIconOptions,
      this.accessToken
    ).generate();
  }
}
export {
  Ko as C,
  T0 as M,
  Ql as _,
  or as p,
  Mh as t,
  Ip as u
};
//# sourceMappingURL=index-D5puivqF.mjs.map
