var ng = Object.defineProperty;
var sg = (b, g, y) => g in b ? ng(b, g, { enumerable: !0, configurable: !0, writable: !0, value: y }) : b[g] = y;
var Eu = (b, g, y) => sg(b, typeof g != "symbol" ? g + "" : g, y);
import { Map as ag, accessToken as og } from "mapbox-gl";
var lg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Yp = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.6.0/LICENSE.txt
 */
(function(b, g) {
  (function(y, x) {
    b.exports = x();
  })(lg, function() {
    var y = {}, x = {};
    function P(v, l, M) {
      if (x[v] = M, v === "index") {
        var B = "var sharedModule = {}; (" + x.shared + ")(sharedModule); (" + x.worker + ")(sharedModule);", $ = {};
        return x.shared($), x.index(y, $), typeof window < "u" && y.setWorkerUrl(window.URL.createObjectURL(new Blob([B], { type: "text/javascript" }))), y;
      }
    }
    P("shared", ["exports"], function(v) {
      function l(i, e, n, o) {
        return new (n || (n = Promise))(function(u, f) {
          function m(E) {
            try {
              I(o.next(E));
            } catch (D) {
              f(D);
            }
          }
          function S(E) {
            try {
              I(o.throw(E));
            } catch (D) {
              f(D);
            }
          }
          function I(E) {
            var D;
            E.done ? u(E.value) : (D = E.value, D instanceof n ? D : new n(function(N) {
              N(D);
            })).then(m, S);
          }
          I((o = o.apply(i, e || [])).next());
        });
      }
      function M(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var B = $;
      function $(i, e) {
        this.x = i, this.y = e;
      }
      $.prototype = { clone: function() {
        return new $(this.x, this.y);
      }, add: function(i) {
        return this.clone()._add(i);
      }, sub: function(i) {
        return this.clone()._sub(i);
      }, multByPoint: function(i) {
        return this.clone()._multByPoint(i);
      }, divByPoint: function(i) {
        return this.clone()._divByPoint(i);
      }, mult: function(i) {
        return this.clone()._mult(i);
      }, div: function(i) {
        return this.clone()._div(i);
      }, rotate: function(i) {
        return this.clone()._rotate(i);
      }, rotateAround: function(i, e) {
        return this.clone()._rotateAround(i, e);
      }, matMult: function(i) {
        return this.clone()._matMult(i);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(i) {
        return this.x === i.x && this.y === i.y;
      }, dist: function(i) {
        return Math.sqrt(this.distSqr(i));
      }, distSqr: function(i) {
        var e = i.x - this.x, n = i.y - this.y;
        return e * e + n * n;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(i) {
        return Math.atan2(this.y - i.y, this.x - i.x);
      }, angleWith: function(i) {
        return this.angleWithSep(i.x, i.y);
      }, angleWithSep: function(i, e) {
        return Math.atan2(this.x * e - this.y * i, this.x * i + this.y * e);
      }, _matMult: function(i) {
        var e = i[2] * this.x + i[3] * this.y;
        return this.x = i[0] * this.x + i[1] * this.y, this.y = e, this;
      }, _add: function(i) {
        return this.x += i.x, this.y += i.y, this;
      }, _sub: function(i) {
        return this.x -= i.x, this.y -= i.y, this;
      }, _mult: function(i) {
        return this.x *= i, this.y *= i, this;
      }, _div: function(i) {
        return this.x /= i, this.y /= i, this;
      }, _multByPoint: function(i) {
        return this.x *= i.x, this.y *= i.y, this;
      }, _divByPoint: function(i) {
        return this.x /= i.x, this.y /= i.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var i = this.y;
        return this.y = this.x, this.x = -i, this;
      }, _rotate: function(i) {
        var e = Math.cos(i), n = Math.sin(i), o = n * this.x + e * this.y;
        return this.x = e * this.x - n * this.y, this.y = o, this;
      }, _rotateAround: function(i, e) {
        var n = Math.cos(i), o = Math.sin(i), u = e.y + o * (this.x - e.x) + n * (this.y - e.y);
        return this.x = e.x + n * (this.x - e.x) - o * (this.y - e.y), this.y = u, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, $.convert = function(i) {
        return i instanceof $ ? i : Array.isArray(i) ? new $(i[0], i[1]) : i;
      };
      var q = M(B), U = F;
      function F(i, e, n, o) {
        this.cx = 3 * i, this.bx = 3 * (n - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (o - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = e, this.p2x = n, this.p2y = o;
      }
      F.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, e) {
        if (e === void 0 && (e = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var n = i, o = 0; o < 8; o++) {
          var u = this.sampleCurveX(n) - i;
          if (Math.abs(u) < e) return n;
          var f = this.sampleCurveDerivativeX(n);
          if (Math.abs(f) < 1e-6) break;
          n -= u / f;
        }
        var m = 0, S = 1;
        for (n = i, o = 0; o < 20 && (u = this.sampleCurveX(n), !(Math.abs(u - i) < e)); o++) i > u ? m = n : S = n, n = 0.5 * (S - m) + m;
        return n;
      }, solve: function(i, e) {
        return this.sampleCurveY(this.solveCurveX(i, e));
      } };
      var mt = M(U);
      let ot, yt;
      function st() {
        return ot == null && (ot = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), ot;
      }
      function gt() {
        if (yt == null && (yt = !1, st())) {
          const e = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
          if (e) {
            for (let o = 0; o < 5 * 5; o++) {
              const u = 4 * o;
              e.fillStyle = `rgb(${u},${u + 1},${u + 2})`, e.fillRect(o % 5, Math.floor(o / 5), 1, 1);
            }
            const n = e.getImageData(0, 0, 5, 5).data;
            for (let o = 0; o < 5 * 5 * 4; o++) if (o % 4 != 3 && n[o] !== o) {
              yt = !0;
              break;
            }
          }
        }
        return yt || !1;
      }
      function Mt(i, e, n, o) {
        const u = new mt(i, e, n, o);
        return (f) => u.solve(f);
      }
      const Qt = Mt(0.25, 0.1, 0.25, 1);
      function Ht(i, e, n) {
        return Math.min(n, Math.max(e, i));
      }
      function pe(i, e, n) {
        const o = n - e, u = ((i - e) % o + o) % o + e;
        return u === e ? n : u;
      }
      function jt(i, ...e) {
        for (const n of e) for (const o in n) i[o] = n[o];
        return i;
      }
      let Tt = 1;
      function le(i, e, n) {
        const o = {};
        for (const u in i) o[u] = e.call(this, i[u], u, i);
        return o;
      }
      function ne(i, e, n) {
        const o = {};
        for (const u in i) e.call(this, i[u], u, i) && (o[u] = i[u]);
        return o;
      }
      function at(i) {
        return Array.isArray(i) ? i.map(at) : typeof i == "object" && i ? le(i, at) : i;
      }
      const lt = {};
      function Pt(i) {
        lt[i] || (typeof console < "u" && console.warn(i), lt[i] = !0);
      }
      function bt(i, e, n) {
        return (n.y - i.y) * (e.x - i.x) > (e.y - i.y) * (n.x - i.x);
      }
      function Jt(i) {
        return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope;
      }
      let Yt = null;
      function te(i) {
        return typeof ImageBitmap < "u" && i instanceof ImageBitmap;
      }
      const Ut = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function se(i, e, n, o, u) {
        return l(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
          const f = new VideoFrame(i, { timestamp: 0 });
          try {
            const m = f == null ? void 0 : f.format;
            if (!m || !m.startsWith("BGR") && !m.startsWith("RGB")) throw new Error(`Unrecognized format ${m}`);
            const S = m.startsWith("BGR"), I = new Uint8ClampedArray(o * u * 4);
            if (yield f.copyTo(I, function(E, D, N, j, H) {
              const et = 4 * Math.max(-D, 0), rt = (Math.max(0, N) - N) * j * 4 + et, dt = 4 * j, vt = Math.max(0, D), Nt = Math.max(0, N);
              return { rect: { x: vt, y: Nt, width: Math.min(E.width, D + j) - vt, height: Math.min(E.height, N + H) - Nt }, layout: [{ offset: rt, stride: dt }] };
            }(i, e, n, o, u)), S) for (let E = 0; E < I.length; E += 4) {
              const D = I[E];
              I[E] = I[E + 2], I[E + 2] = D;
            }
            return I;
          } finally {
            f.close();
          }
        });
      }
      let ee, be;
      const Q = "AbortError";
      function pt() {
        return new Error(Q);
      }
      const _t = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function Ct(i) {
        return _t.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))];
      }
      const Dt = "global-dispatcher";
      class Ot extends Error {
        constructor(e, n, o, u) {
          super(`AJAXError: ${n} (${e}): ${o}`), this.status = e, this.statusText = n, this.url = o, this.body = u;
        }
      }
      const Vt = () => Jt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Wt = function(i, e) {
        if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
          const o = Ct(i.url);
          if (o) return o(i, e);
          if (Jt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, targetMapId: Dt }, e);
        }
        if (!(/^file:/.test(n = i.url) || /^file:/.test(Vt()) && !/^\w+:/.test(n))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(o, u) {
            return l(this, void 0, void 0, function* () {
              const f = new Request(o.url, { method: o.method || "GET", body: o.body, credentials: o.credentials, headers: o.headers, cache: o.cache, referrer: Vt(), signal: u.signal });
              o.type !== "json" || f.headers.has("Accept") || f.headers.set("Accept", "application/json");
              const m = yield fetch(f);
              if (!m.ok) {
                const E = yield m.blob();
                throw new Ot(m.status, m.statusText, o.url, E);
              }
              let S;
              S = o.type === "arrayBuffer" || o.type === "image" ? m.arrayBuffer() : o.type === "json" ? m.json() : m.text();
              const I = yield S;
              if (u.signal.aborted) throw pt();
              return { data: I, cacheControl: m.headers.get("Cache-Control"), expires: m.headers.get("Expires") };
            });
          }(i, e);
          if (Jt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, mustQueue: !0, targetMapId: Dt }, e);
        }
        var n;
        return function(o, u) {
          return new Promise((f, m) => {
            var S;
            const I = new XMLHttpRequest();
            I.open(o.method || "GET", o.url, !0), o.type !== "arrayBuffer" && o.type !== "image" || (I.responseType = "arraybuffer");
            for (const E in o.headers) I.setRequestHeader(E, o.headers[E]);
            o.type === "json" && (I.responseType = "text", !((S = o.headers) === null || S === void 0) && S.Accept || I.setRequestHeader("Accept", "application/json")), I.withCredentials = o.credentials === "include", I.onerror = () => {
              m(new Error(I.statusText));
            }, I.onload = () => {
              if (!u.signal.aborted) if ((I.status >= 200 && I.status < 300 || I.status === 0) && I.response !== null) {
                let E = I.response;
                if (o.type === "json") try {
                  E = JSON.parse(I.response);
                } catch (D) {
                  return void m(D);
                }
                f({ data: E, cacheControl: I.getResponseHeader("Cache-Control"), expires: I.getResponseHeader("Expires") });
              } else {
                const E = new Blob([I.response], { type: I.getResponseHeader("Content-Type") });
                m(new Ot(I.status, I.statusText, o.url, E));
              }
            }, u.signal.addEventListener("abort", () => {
              I.abort(), m(pt());
            }), I.send(o.body);
          });
        }(i, e);
      };
      function xe(i) {
        if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
        const e = new URL(i), n = window.location;
        return e.protocol === n.protocol && e.host === n.host;
      }
      function ve(i, e, n) {
        n[i] && n[i].indexOf(e) !== -1 || (n[i] = n[i] || [], n[i].push(e));
      }
      function ke(i, e, n) {
        if (n && n[i]) {
          const o = n[i].indexOf(e);
          o !== -1 && n[i].splice(o, 1);
        }
      }
      class ze {
        constructor(e, n = {}) {
          jt(this, n), this.type = e;
        }
      }
      class Je extends ze {
        constructor(e, n = {}) {
          super("error", jt({ error: e }, n));
        }
      }
      class ie {
        on(e, n) {
          return this._listeners = this._listeners || {}, ve(e, n, this._listeners), this;
        }
        off(e, n) {
          return ke(e, n, this._listeners), ke(e, n, this._oneTimeListeners), this;
        }
        once(e, n) {
          return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, ve(e, n, this._oneTimeListeners), this) : new Promise((o) => this.once(e, o));
        }
        fire(e, n) {
          typeof e == "string" && (e = new ze(e, n || {}));
          const o = e.type;
          if (this.listens(o)) {
            e.target = this;
            const u = this._listeners && this._listeners[o] ? this._listeners[o].slice() : [];
            for (const S of u) S.call(this, e);
            const f = this._oneTimeListeners && this._oneTimeListeners[o] ? this._oneTimeListeners[o].slice() : [];
            for (const S of f) ke(o, S, this._oneTimeListeners), S.call(this, e);
            const m = this._eventedParent;
            m && (jt(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), m.fire(e));
          } else e instanceof Je && console.error(e.error);
          return this;
        }
        listens(e) {
          return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
        }
        setEventedParent(e, n) {
          return this._eventedParent = e, this._eventedParentData = n, this;
        }
      }
      var K = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const ci = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function Ue(i, e) {
        const n = {};
        for (const o in i) o !== "ref" && (n[o] = i[o]);
        return ci.forEach((o) => {
          o in e && (n[o] = e[o]);
        }), n;
      }
      function oe(i, e) {
        if (Array.isArray(i)) {
          if (!Array.isArray(e) || i.length !== e.length) return !1;
          for (let n = 0; n < i.length; n++) if (!oe(i[n], e[n])) return !1;
          return !0;
        }
        if (typeof i == "object" && i !== null && e !== null) {
          if (typeof e != "object" || Object.keys(i).length !== Object.keys(e).length) return !1;
          for (const n in i) if (!oe(i[n], e[n])) return !1;
          return !0;
        }
        return i === e;
      }
      function ye(i, e) {
        i.push(e);
      }
      function De(i, e, n) {
        ye(n, { command: "addSource", args: [i, e[i]] });
      }
      function Ae(i, e, n) {
        ye(e, { command: "removeSource", args: [i] }), n[i] = !0;
      }
      function $e(i, e, n, o) {
        Ae(i, n, o), De(i, e, n);
      }
      function hi(i, e, n) {
        let o;
        for (o in i[n]) if (Object.prototype.hasOwnProperty.call(i[n], o) && o !== "data" && !oe(i[n][o], e[n][o])) return !1;
        for (o in e[n]) if (Object.prototype.hasOwnProperty.call(e[n], o) && o !== "data" && !oe(i[n][o], e[n][o])) return !1;
        return !0;
      }
      function si(i, e, n, o, u, f) {
        i = i || {}, e = e || {};
        for (const m in i) Object.prototype.hasOwnProperty.call(i, m) && (oe(i[m], e[m]) || n.push({ command: f, args: [o, m, e[m], u] }));
        for (const m in e) Object.prototype.hasOwnProperty.call(e, m) && !Object.prototype.hasOwnProperty.call(i, m) && (oe(i[m], e[m]) || n.push({ command: f, args: [o, m, e[m], u] }));
      }
      function _i(i) {
        return i.id;
      }
      function Ii(i, e) {
        return i[e.id] = e, i;
      }
      class he {
        constructor(e, n, o, u) {
          this.message = (e ? `${e}: ` : "") + o, u && (this.identifier = u), n != null && n.__line__ && (this.line = n.__line__);
        }
      }
      function Ke(i, ...e) {
        for (const n of e) for (const o in n) i[o] = n[o];
        return i;
      }
      class ai extends Error {
        constructor(e, n) {
          super(n), this.message = n, this.key = e;
        }
      }
      class Pe {
        constructor(e, n = []) {
          this.parent = e, this.bindings = {};
          for (const [o, u] of n) this.bindings[o] = u;
        }
        concat(e) {
          return new Pe(this, e);
        }
        get(e) {
          if (this.bindings[e]) return this.bindings[e];
          if (this.parent) return this.parent.get(e);
          throw new Error(`${e} not found in scope.`);
        }
        has(e) {
          return !!this.bindings[e] || !!this.parent && this.parent.has(e);
        }
      }
      const lr = { kind: "null" }, ue = { kind: "number" }, ni = { kind: "string" }, Te = { kind: "boolean" }, ki = { kind: "color" }, vr = { kind: "object" }, Me = { kind: "value" }, Ur = { kind: "collator" }, qi = { kind: "formatted" }, Ir = { kind: "padding" }, kr = { kind: "resolvedImage" }, ht = { kind: "variableAnchorOffsetCollection" };
      function O(i, e) {
        return { kind: "array", itemType: i, N: e };
      }
      function V(i) {
        if (i.kind === "array") {
          const e = V(i.itemType);
          return typeof i.N == "number" ? `array<${e}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${e}>`;
        }
        return i.kind;
      }
      const it = [lr, ue, ni, Te, ki, qi, vr, O(Me), Ir, kr, ht];
      function ct(i, e) {
        if (e.kind === "error") return null;
        if (i.kind === "array") {
          if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !ct(i.itemType, e.itemType)) && (typeof i.N != "number" || i.N === e.N)) return null;
        } else {
          if (i.kind === e.kind) return null;
          if (i.kind === "value") {
            for (const n of it) if (!ct(n, e)) return null;
          }
        }
        return `Expected ${V(i)} but found ${V(e)} instead.`;
      }
      function At(i, e) {
        return e.some((n) => n.kind === i.kind);
      }
      function Et(i, e) {
        return e.some((n) => n === "null" ? i === null : n === "array" ? Array.isArray(i) : n === "object" ? i && !Array.isArray(i) && typeof i == "object" : n === typeof i);
      }
      function wt(i, e) {
        return i.kind === "array" && e.kind === "array" ? i.itemType.kind === e.itemType.kind && typeof i.N == "number" : i.kind === e.kind;
      }
      const xt = 0.96422, $t = 0.82521, re = 4 / 29, Rt = 6 / 29, fe = 3 * Rt * Rt, Ne = Rt * Rt * Rt, Ve = Math.PI / 180, ei = 180 / Math.PI;
      function mi(i) {
        return (i %= 360) < 0 && (i += 360), i;
      }
      function He([i, e, n, o]) {
        let u, f;
        const m = Di((0.2225045 * (i = Ti(i)) + 0.7168786 * (e = Ti(e)) + 0.0606169 * (n = Ti(n))) / 1);
        i === e && e === n ? u = f = m : (u = Di((0.4360747 * i + 0.3850649 * e + 0.1430804 * n) / xt), f = Di((0.0139322 * i + 0.0971045 * e + 0.7141733 * n) / $t));
        const S = 116 * m - 16;
        return [S < 0 ? 0 : S, 500 * (u - m), 200 * (m - f), o];
      }
      function Ti(i) {
        return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
      }
      function Di(i) {
        return i > Ne ? Math.pow(i, 1 / 3) : i / fe + re;
      }
      function Oi([i, e, n, o]) {
        let u = (i + 16) / 116, f = isNaN(e) ? u : u + e / 500, m = isNaN(n) ? u : u - n / 200;
        return u = 1 * Ci(u), f = xt * Ci(f), m = $t * Ci(m), [oi(3.1338561 * f - 1.6168667 * u - 0.4906146 * m), oi(-0.9787684 * f + 1.9161415 * u + 0.033454 * m), oi(0.0719453 * f - 0.2289914 * u + 1.4052427 * m), o];
      }
      function oi(i) {
        return (i = i <= 304e-5 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055) < 0 ? 0 : i > 1 ? 1 : i;
      }
      function Ci(i) {
        return i > Rt ? i * i * i : fe * (i - re);
      }
      function Ui(i) {
        return parseInt(i.padEnd(2, i), 16) / 255;
      }
      function rr(i, e) {
        return pr(e ? i / 100 : i, 0, 1);
      }
      function pr(i, e, n) {
        return Math.min(Math.max(e, i), n);
      }
      function fr(i) {
        return !i.some(Number.isNaN);
      }
      const $s = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      class Ni {
        constructor(e, n, o, u = 1, f = !0) {
          this.r = e, this.g = n, this.b = o, this.a = u, f || (this.r *= u, this.g *= u, this.b *= u, u || this.overwriteGetter("rgb", [e, n, o, u]));
        }
        static parse(e) {
          if (e instanceof Ni) return e;
          if (typeof e != "string") return;
          const n = function(o) {
            if ((o = o.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
            const u = $s[o];
            if (u) {
              const [m, S, I] = u;
              return [m / 255, S / 255, I / 255, 1];
            }
            if (o.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(o)) {
              const m = o.length < 6 ? 1 : 2;
              let S = 1;
              return [Ui(o.slice(S, S += m)), Ui(o.slice(S, S += m)), Ui(o.slice(S, S += m)), Ui(o.slice(S, S + m) || "ff")];
            }
            if (o.startsWith("rgb")) {
              const m = o.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (m) {
                const [S, I, E, D, N, j, H, et, rt, dt, vt, Nt] = m, kt = [D || " ", H || " ", dt].join("");
                if (kt === "  " || kt === "  /" || kt === ",," || kt === ",,,") {
                  const zt = [E, j, rt].join(""), Xt = zt === "%%%" ? 100 : zt === "" ? 255 : 0;
                  if (Xt) {
                    const me = [pr(+I / Xt, 0, 1), pr(+N / Xt, 0, 1), pr(+et / Xt, 0, 1), vt ? rr(+vt, Nt) : 1];
                    if (fr(me)) return me;
                  }
                }
                return;
              }
            }
            const f = o.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (f) {
              const [m, S, I, E, D, N, j, H, et] = f, rt = [I || " ", D || " ", j].join("");
              if (rt === "  " || rt === "  /" || rt === ",," || rt === ",,,") {
                const dt = [+S, pr(+E, 0, 100), pr(+N, 0, 100), H ? rr(+H, et) : 1];
                if (fr(dt)) return function([vt, Nt, kt, zt]) {
                  function Xt(me) {
                    const Ee = (me + vt / 30) % 12, ti = Nt * Math.min(kt, 1 - kt);
                    return kt - ti * Math.max(-1, Math.min(Ee - 3, 9 - Ee, 1));
                  }
                  return vt = mi(vt), Nt /= 100, kt /= 100, [Xt(0), Xt(8), Xt(4), zt];
                }(dt);
              }
            }
          }(e);
          return n ? new Ni(...n, !1) : void 0;
        }
        get rgb() {
          const { r: e, g: n, b: o, a: u } = this, f = u || 1 / 0;
          return this.overwriteGetter("rgb", [e / f, n / f, o / f, u]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(e) {
            const [n, o, u, f] = He(e), m = Math.sqrt(o * o + u * u);
            return [Math.round(1e4 * m) ? mi(Math.atan2(u, o) * ei) : NaN, m, n, f];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", He(this.rgb));
        }
        overwriteGetter(e, n) {
          return Object.defineProperty(this, e, { value: n }), n;
        }
        toString() {
          const [e, n, o, u] = this.rgb;
          return `rgba(${[e, n, o].map((f) => Math.round(255 * f)).join(",")},${u})`;
        }
      }
      Ni.black = new Ni(0, 0, 0, 1), Ni.white = new Ni(1, 1, 1, 1), Ni.transparent = new Ni(0, 0, 0, 0), Ni.red = new Ni(1, 0, 0, 1);
      class zo {
        constructor(e, n, o) {
          this.sensitivity = e ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = o, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(e, n) {
          return this.collator.compare(e, n);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class Zs {
        constructor(e, n, o, u, f) {
          this.text = e, this.image = n, this.scale = o, this.fontStack = u, this.textColor = f;
        }
      }
      class Vr {
        constructor(e) {
          this.sections = e;
        }
        static fromString(e) {
          return new Vr([new Zs(e, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
        }
        static factory(e) {
          return e instanceof Vr ? e : Vr.fromString(e);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
        }
      }
      class tn {
        constructor(e) {
          this.values = e.slice();
        }
        static parse(e) {
          if (e instanceof tn) return e;
          if (typeof e == "number") return new tn([e, e, e, e]);
          if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
            for (const n of e) if (typeof n != "number") return;
            switch (e.length) {
              case 1:
                e = [e[0], e[0], e[0], e[0]];
                break;
              case 2:
                e = [e[0], e[1], e[0], e[1]];
                break;
              case 3:
                e = [e[0], e[1], e[2], e[1]];
            }
            return new tn(e);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const Do = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class en {
        constructor(e) {
          this.values = e.slice();
        }
        static parse(e) {
          if (e instanceof en) return e;
          if (Array.isArray(e) && !(e.length < 1) && e.length % 2 == 0) {
            for (let n = 0; n < e.length; n += 2) {
              const o = e[n], u = e[n + 1];
              if (typeof o != "string" || !Do.has(o) || !Array.isArray(u) || u.length !== 2 || typeof u[0] != "number" || typeof u[1] != "number") return;
            }
            return new en(e);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class br {
        constructor(e) {
          this.name = e.name, this.available = e.available;
        }
        toString() {
          return this.name;
        }
        static fromString(e) {
          return e ? new br({ name: e, available: !1 }) : null;
        }
      }
      function Ua(i, e, n, o) {
        return typeof i == "number" && i >= 0 && i <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? o === void 0 || typeof o == "number" && o >= 0 && o <= 1 ? null : `Invalid rgba value [${[i, e, n, o].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof o == "number" ? [i, e, n, o] : [i, e, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function os(i) {
        if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof Ni || i instanceof zo || i instanceof Vr || i instanceof tn || i instanceof en || i instanceof br) return !0;
        if (Array.isArray(i)) {
          for (const e of i) if (!os(e)) return !1;
          return !0;
        }
        if (typeof i == "object") {
          for (const e in i) if (!os(i[e])) return !1;
          return !0;
        }
        return !1;
      }
      function dr(i) {
        if (i === null) return lr;
        if (typeof i == "string") return ni;
        if (typeof i == "boolean") return Te;
        if (typeof i == "number") return ue;
        if (i instanceof Ni) return ki;
        if (i instanceof zo) return Ur;
        if (i instanceof Vr) return qi;
        if (i instanceof tn) return Ir;
        if (i instanceof en) return ht;
        if (i instanceof br) return kr;
        if (Array.isArray(i)) {
          const e = i.length;
          let n;
          for (const o of i) {
            const u = dr(o);
            if (n) {
              if (n === u) continue;
              n = Me;
              break;
            }
            n = u;
          }
          return O(n || Me, e);
        }
        return vr;
      }
      function $i(i) {
        const e = typeof i;
        return i === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(i) : i instanceof Ni || i instanceof Vr || i instanceof tn || i instanceof en || i instanceof br ? i.toString() : JSON.stringify(i);
      }
      class ls {
        constructor(e, n) {
          this.type = e, this.value = n;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (!os(e[1])) return n.error("invalid value");
          const o = e[1];
          let u = dr(o);
          const f = n.expectedType;
          return u.kind !== "array" || u.N !== 0 || !f || f.kind !== "array" || typeof f.N == "number" && f.N !== 0 || (u = f), new ls(u, o);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      class nr {
        constructor(e) {
          this.name = "ExpressionEvaluationError", this.message = e;
        }
        toJSON() {
          return this.message;
        }
      }
      const fa = { string: ni, number: ue, boolean: Te, object: vr };
      class $r {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2) return n.error("Expected at least one argument.");
          let o, u = 1;
          const f = e[0];
          if (f === "array") {
            let S, I;
            if (e.length > 2) {
              const E = e[1];
              if (typeof E != "string" || !(E in fa) || E === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
              S = fa[E], u++;
            } else S = Me;
            if (e.length > 3) {
              if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
              I = e[2], u++;
            }
            o = O(S, I);
          } else {
            if (!fa[f]) throw new Error(`Types doesn't contain name = ${f}`);
            o = fa[f];
          }
          const m = [];
          for (; u < e.length; u++) {
            const S = n.parse(e[u], u, Me);
            if (!S) return null;
            m.push(S);
          }
          return new $r(o, m);
        }
        evaluate(e) {
          for (let n = 0; n < this.args.length; n++) {
            const o = this.args[n].evaluate(e);
            if (!ct(this.type, dr(o))) return o;
            if (n === this.args.length - 1) throw new nr(`Expected value to be of type ${V(this.type)}, but found ${V(dr(o))} instead.`);
          }
          throw new Error();
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      }
      const ma = { "to-boolean": Te, "to-color": ki, "to-number": ue, "to-string": ni };
      class Tr {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2) return n.error("Expected at least one argument.");
          const o = e[0];
          if (!ma[o]) throw new Error(`Can't parse ${o} as it is not part of the known types`);
          if ((o === "to-boolean" || o === "to-string") && e.length !== 2) return n.error("Expected one argument.");
          const u = ma[o], f = [];
          for (let m = 1; m < e.length; m++) {
            const S = n.parse(e[m], m, Me);
            if (!S) return null;
            f.push(S);
          }
          return new Tr(u, f);
        }
        evaluate(e) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(e);
            case "color": {
              let n, o;
              for (const u of this.args) {
                if (n = u.evaluate(e), o = null, n instanceof Ni) return n;
                if (typeof n == "string") {
                  const f = e.parseColor(n);
                  if (f) return f;
                } else if (Array.isArray(n) && (o = n.length < 3 || n.length > 4 ? `Invalid rbga value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : Ua(n[0], n[1], n[2], n[3]), !o)) return new Ni(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
              }
              throw new nr(o || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "padding": {
              let n;
              for (const o of this.args) {
                n = o.evaluate(e);
                const u = tn.parse(n);
                if (u) return u;
              }
              throw new nr(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let n;
              for (const o of this.args) {
                n = o.evaluate(e);
                const u = en.parse(n);
                if (u) return u;
              }
              throw new nr(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "number": {
              let n = null;
              for (const o of this.args) {
                if (n = o.evaluate(e), n === null) return 0;
                const u = Number(n);
                if (!isNaN(u)) return u;
              }
              throw new nr(`Could not convert ${JSON.stringify(n)} to number.`);
            }
            case "formatted":
              return Vr.fromString($i(this.args[0].evaluate(e)));
            case "resolvedImage":
              return br.fromString($i(this.args[0].evaluate(e)));
            default:
              return $i(this.args[0].evaluate(e));
          }
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      }
      const Gs = ["Unknown", "Point", "LineString", "Polygon"];
      class Lr {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Gs[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(e) {
          let n = this._parseColorCache[e];
          return n || (n = this._parseColorCache[e] = Ni.parse(e)), n;
        }
      }
      class Ln {
        constructor(e, n, o = [], u, f = new Pe(), m = []) {
          this.registry = e, this.path = o, this.key = o.map((S) => `[${S}]`).join(""), this.scope = f, this.errors = m, this.expectedType = u, this._isConstant = n;
        }
        parse(e, n, o, u, f = {}) {
          return n ? this.concat(n, o, u)._parse(e, f) : this._parse(e, f);
        }
        _parse(e, n) {
          function o(u, f, m) {
            return m === "assert" ? new $r(f, [u]) : m === "coerce" ? new Tr(f, [u]) : u;
          }
          if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
            if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const u = e[0];
            if (typeof u != "string") return this.error(`Expression name must be a string, but found ${typeof u} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const f = this.registry[u];
            if (f) {
              let m = f.parse(e, this);
              if (!m) return null;
              if (this.expectedType) {
                const S = this.expectedType, I = m.type;
                if (S.kind !== "string" && S.kind !== "number" && S.kind !== "boolean" && S.kind !== "object" && S.kind !== "array" || I.kind !== "value") if (S.kind !== "color" && S.kind !== "formatted" && S.kind !== "resolvedImage" || I.kind !== "value" && I.kind !== "string") if (S.kind !== "padding" || I.kind !== "value" && I.kind !== "number" && I.kind !== "array") if (S.kind !== "variableAnchorOffsetCollection" || I.kind !== "value" && I.kind !== "array") {
                  if (this.checkSubtype(S, I)) return null;
                } else m = o(m, S, n.typeAnnotation || "coerce");
                else m = o(m, S, n.typeAnnotation || "coerce");
                else m = o(m, S, n.typeAnnotation || "coerce");
                else m = o(m, S, n.typeAnnotation || "assert");
              }
              if (!(m instanceof ls) && m.type.kind !== "resolvedImage" && this._isConstant(m)) {
                const S = new Lr();
                try {
                  m = new ls(m.type, m.evaluate(S));
                } catch (I) {
                  return this.error(I.message), null;
                }
              }
              return m;
            }
            return this.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
        }
        concat(e, n, o) {
          const u = typeof e == "number" ? this.path.concat(e) : this.path, f = o ? this.scope.concat(o) : this.scope;
          return new Ln(this.registry, this._isConstant, u, n || null, f, this.errors);
        }
        error(e, ...n) {
          const o = `${this.key}${n.map((u) => `[${u}]`).join("")}`;
          this.errors.push(new ai(o, e));
        }
        checkSubtype(e, n) {
          const o = ct(e, n);
          return o && this.error(o), o;
        }
      }
      class Ei {
        constructor(e, n) {
          this.type = n.type, this.bindings = [].concat(e), this.result = n;
        }
        evaluate(e) {
          return this.result.evaluate(e);
        }
        eachChild(e) {
          for (const n of this.bindings) e(n[1]);
          e(this.result);
        }
        static parse(e, n) {
          if (e.length < 4) return n.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
          const o = [];
          for (let f = 1; f < e.length - 1; f += 2) {
            const m = e[f];
            if (typeof m != "string") return n.error(`Expected string, but found ${typeof m} instead.`, f);
            if (/[^a-zA-Z0-9_]/.test(m)) return n.error("Variable names must contain only alphanumeric characters or '_'.", f);
            const S = n.parse(e[f + 1], f + 1);
            if (!S) return null;
            o.push([m, S]);
          }
          const u = n.parse(e[e.length - 1], e.length - 1, n.expectedType, o);
          return u ? new Ei(o, u) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Va {
        constructor(e, n) {
          this.type = n.type, this.name = e, this.boundExpression = n;
        }
        static parse(e, n) {
          if (e.length !== 2 || typeof e[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
          const o = e[1];
          return n.scope.has(o) ? new Va(o, n.scope.get(o)) : n.error(`Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(e) {
          return this.boundExpression.evaluate(e);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class $a {
        constructor(e, n, o) {
          this.type = e, this.index = n, this.input = o;
        }
        static parse(e, n) {
          if (e.length !== 3) return n.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, ue), u = n.parse(e[2], 2, O(n.expectedType || Me));
          return o && u ? new $a(u.type.itemType, o, u) : null;
        }
        evaluate(e) {
          const n = this.index.evaluate(e), o = this.input.evaluate(e);
          if (n < 0) throw new nr(`Array index out of bounds: ${n} < 0.`);
          if (n >= o.length) throw new nr(`Array index out of bounds: ${n} > ${o.length - 1}.`);
          if (n !== Math.floor(n)) throw new nr(`Array index must be an integer, but found ${n} instead.`);
          return o[n];
        }
        eachChild(e) {
          e(this.index), e(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class ga {
        constructor(e, n) {
          this.type = Te, this.needle = e, this.haystack = n;
        }
        static parse(e, n) {
          if (e.length !== 3) return n.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Me), u = n.parse(e[2], 2, Me);
          return o && u ? At(o.type, [Te, ni, ue, lr, Me]) ? new ga(o, u) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${V(o.type)} instead`) : null;
        }
        evaluate(e) {
          const n = this.needle.evaluate(e), o = this.haystack.evaluate(e);
          if (!o) return !1;
          if (!Et(n, ["boolean", "string", "number", "null"])) throw new nr(`Expected first argument to be of type boolean, string, number or null, but found ${V(dr(n))} instead.`);
          if (!Et(o, ["string", "array"])) throw new nr(`Expected second argument to be of type array or string, but found ${V(dr(o))} instead.`);
          return o.indexOf(n) >= 0;
        }
        eachChild(e) {
          e(this.needle), e(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class ya {
        constructor(e, n, o) {
          this.type = ue, this.needle = e, this.haystack = n, this.fromIndex = o;
        }
        static parse(e, n) {
          if (e.length <= 2 || e.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Me), u = n.parse(e[2], 2, Me);
          if (!o || !u) return null;
          if (!At(o.type, [Te, ni, ue, lr, Me])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${V(o.type)} instead`);
          if (e.length === 4) {
            const f = n.parse(e[3], 3, ue);
            return f ? new ya(o, u, f) : null;
          }
          return new ya(o, u);
        }
        evaluate(e) {
          const n = this.needle.evaluate(e), o = this.haystack.evaluate(e);
          if (!Et(n, ["boolean", "string", "number", "null"])) throw new nr(`Expected first argument to be of type boolean, string, number or null, but found ${V(dr(n))} instead.`);
          let u;
          if (this.fromIndex && (u = this.fromIndex.evaluate(e)), Et(o, ["string"])) {
            const f = o.indexOf(n, u);
            return f === -1 ? -1 : [...o.slice(0, f)].length;
          }
          if (Et(o, ["array"])) return o.indexOf(n, u);
          throw new nr(`Expected second argument to be of type array or string, but found ${V(dr(o))} instead.`);
        }
        eachChild(e) {
          e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class Za {
        constructor(e, n, o, u, f, m) {
          this.inputType = e, this.type = n, this.input = o, this.cases = u, this.outputs = f, this.otherwise = m;
        }
        static parse(e, n) {
          if (e.length < 5) return n.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 1) return n.error("Expected an even number of arguments.");
          let o, u;
          n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
          const f = {}, m = [];
          for (let E = 2; E < e.length - 1; E += 2) {
            let D = e[E];
            const N = e[E + 1];
            Array.isArray(D) || (D = [D]);
            const j = n.concat(E);
            if (D.length === 0) return j.error("Expected at least one branch label.");
            for (const et of D) {
              if (typeof et != "number" && typeof et != "string") return j.error("Branch labels must be numbers or strings.");
              if (typeof et == "number" && Math.abs(et) > Number.MAX_SAFE_INTEGER) return j.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof et == "number" && Math.floor(et) !== et) return j.error("Numeric branch labels must be integer values.");
              if (o) {
                if (j.checkSubtype(o, dr(et))) return null;
              } else o = dr(et);
              if (f[String(et)] !== void 0) return j.error("Branch labels must be unique.");
              f[String(et)] = m.length;
            }
            const H = n.parse(N, E, u);
            if (!H) return null;
            u = u || H.type, m.push(H);
          }
          const S = n.parse(e[1], 1, Me);
          if (!S) return null;
          const I = n.parse(e[e.length - 1], e.length - 1, u);
          return I ? S.type.kind !== "value" && n.concat(1).checkSubtype(o, S.type) ? null : new Za(o, u, S, f, m, I) : null;
        }
        evaluate(e) {
          const n = this.input.evaluate(e);
          return (dr(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(e);
        }
        eachChild(e) {
          e(this.input), this.outputs.forEach(e), e(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class Ws {
        constructor(e, n, o) {
          this.type = e, this.branches = n, this.otherwise = o;
        }
        static parse(e, n) {
          if (e.length < 4) return n.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 0) return n.error("Expected an odd number of arguments.");
          let o;
          n.expectedType && n.expectedType.kind !== "value" && (o = n.expectedType);
          const u = [];
          for (let m = 1; m < e.length - 1; m += 2) {
            const S = n.parse(e[m], m, Te);
            if (!S) return null;
            const I = n.parse(e[m + 1], m + 1, o);
            if (!I) return null;
            u.push([S, I]), o = o || I.type;
          }
          const f = n.parse(e[e.length - 1], e.length - 1, o);
          if (!f) return null;
          if (!o) throw new Error("Can't infer output type");
          return new Ws(o, u, f);
        }
        evaluate(e) {
          for (const [n, o] of this.branches) if (n.evaluate(e)) return o.evaluate(e);
          return this.otherwise.evaluate(e);
        }
        eachChild(e) {
          for (const [n, o] of this.branches) e(n), e(o);
          e(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([e, n]) => n.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class Ga {
        constructor(e, n, o, u) {
          this.type = e, this.input = n, this.beginIndex = o, this.endIndex = u;
        }
        static parse(e, n) {
          if (e.length <= 2 || e.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Me), u = n.parse(e[2], 2, ue);
          if (!o || !u) return null;
          if (!At(o.type, [O(Me), ni, Me])) return n.error(`Expected first argument to be of type array or string, but found ${V(o.type)} instead`);
          if (e.length === 4) {
            const f = n.parse(e[3], 3, ue);
            return f ? new Ga(o.type, o, u, f) : null;
          }
          return new Ga(o.type, o, u);
        }
        evaluate(e) {
          const n = this.input.evaluate(e), o = this.beginIndex.evaluate(e);
          let u;
          if (this.endIndex && (u = this.endIndex.evaluate(e)), Et(n, ["string"])) return [...n].slice(o, u).join("");
          if (Et(n, ["array"])) return n.slice(o, u);
          throw new nr(`Expected first argument to be of type array or string, but found ${V(dr(n))} instead.`);
        }
        eachChild(e) {
          e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function _a(i, e) {
        const n = i.length - 1;
        let o, u, f = 0, m = n, S = 0;
        for (; f <= m; ) if (S = Math.floor((f + m) / 2), o = i[S], u = i[S + 1], o <= e) {
          if (S === n || e < u) return S;
          f = S + 1;
        } else {
          if (!(o > e)) throw new nr("Input is not a number.");
          m = S - 1;
        }
        return 0;
      }
      class Hs {
        constructor(e, n, o) {
          this.type = e, this.input = n, this.labels = [], this.outputs = [];
          for (const [u, f] of o) this.labels.push(u), this.outputs.push(f);
        }
        static parse(e, n) {
          if (e.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
          const o = n.parse(e[1], 1, ue);
          if (!o) return null;
          const u = [];
          let f = null;
          n.expectedType && n.expectedType.kind !== "value" && (f = n.expectedType);
          for (let m = 1; m < e.length; m += 2) {
            const S = m === 1 ? -1 / 0 : e[m], I = e[m + 1], E = m, D = m + 1;
            if (typeof S != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', E);
            if (u.length && u[u.length - 1][0] >= S) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', E);
            const N = n.parse(I, D, f);
            if (!N) return null;
            f = f || N.type, u.push([S, N]);
          }
          return new Hs(f, o, u);
        }
        evaluate(e) {
          const n = this.labels, o = this.outputs;
          if (n.length === 1) return o[0].evaluate(e);
          const u = this.input.evaluate(e);
          if (u <= n[0]) return o[0].evaluate(e);
          const f = n.length;
          return u >= n[f - 1] ? o[f - 1].evaluate(e) : o[_a(n, u)].evaluate(e);
        }
        eachChild(e) {
          e(this.input);
          for (const n of this.outputs) e(n);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
      }
      function Ts(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      var Wa = va;
      function va(i, e, n, o) {
        this.cx = 3 * i, this.bx = 3 * (n - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (o - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = e, this.p2x = n, this.p2y = o;
      }
      va.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, e) {
        if (e === void 0 && (e = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var n = i, o = 0; o < 8; o++) {
          var u = this.sampleCurveX(n) - i;
          if (Math.abs(u) < e) return n;
          var f = this.sampleCurveDerivativeX(n);
          if (Math.abs(f) < 1e-6) break;
          n -= u / f;
        }
        var m = 0, S = 1;
        for (n = i, o = 0; o < 20 && (u = this.sampleCurveX(n), !(Math.abs(u - i) < e)); o++) i > u ? m = n : S = n, n = 0.5 * (S - m) + m;
        return n;
      }, solve: function(i, e) {
        return this.sampleCurveY(this.solveCurveX(i, e));
      } };
      var sl = Ts(Wa);
      function cr(i, e, n) {
        return i + n * (e - i);
      }
      function xa(i, e, n) {
        return i.map((o, u) => cr(o, e[u], n));
      }
      const Zr = { number: cr, color: function(i, e, n, o = "rgb") {
        switch (o) {
          case "rgb": {
            const [u, f, m, S] = xa(i.rgb, e.rgb, n);
            return new Ni(u, f, m, S, !1);
          }
          case "hcl": {
            const [u, f, m, S] = i.hcl, [I, E, D, N] = e.hcl;
            let j, H;
            if (isNaN(u) || isNaN(I)) isNaN(u) ? isNaN(I) ? j = NaN : (j = I, m !== 1 && m !== 0 || (H = E)) : (j = u, D !== 1 && D !== 0 || (H = f));
            else {
              let Nt = I - u;
              I > u && Nt > 180 ? Nt -= 360 : I < u && u - I > 180 && (Nt += 360), j = u + n * Nt;
            }
            const [et, rt, dt, vt] = function([Nt, kt, zt, Xt]) {
              return Nt = isNaN(Nt) ? 0 : Nt * Ve, Oi([zt, Math.cos(Nt) * kt, Math.sin(Nt) * kt, Xt]);
            }([j, H ?? cr(f, E, n), cr(m, D, n), cr(S, N, n)]);
            return new Ni(et, rt, dt, vt, !1);
          }
          case "lab": {
            const [u, f, m, S] = Oi(xa(i.lab, e.lab, n));
            return new Ni(u, f, m, S, !1);
          }
        }
      }, array: xa, padding: function(i, e, n) {
        return new tn(xa(i.values, e.values, n));
      }, variableAnchorOffsetCollection: function(i, e, n) {
        const o = i.values, u = e.values;
        if (o.length !== u.length) throw new nr(`Cannot interpolate values of different length. from: ${i.toString()}, to: ${e.toString()}`);
        const f = [];
        for (let m = 0; m < o.length; m += 2) {
          if (o[m] !== u[m]) throw new nr(`Cannot interpolate values containing mismatched anchors. from[${m}]: ${o[m]}, to[${m}]: ${u[m]}`);
          f.push(o[m]);
          const [S, I] = o[m + 1], [E, D] = u[m + 1];
          f.push([cr(S, E, n), cr(I, D, n)]);
        }
        return new en(f);
      } };
      class Ye {
        constructor(e, n, o, u, f) {
          this.type = e, this.operator = n, this.interpolation = o, this.input = u, this.labels = [], this.outputs = [];
          for (const [m, S] of f) this.labels.push(m), this.outputs.push(S);
        }
        static interpolationFactor(e, n, o, u) {
          let f = 0;
          if (e.name === "exponential") f = ba(n, e.base, o, u);
          else if (e.name === "linear") f = ba(n, 1, o, u);
          else if (e.name === "cubic-bezier") {
            const m = e.controlPoints;
            f = new sl(m[0], m[1], m[2], m[3]).solve(ba(n, 1, o, u));
          }
          return f;
        }
        static parse(e, n) {
          let [o, u, f, ...m] = e;
          if (!Array.isArray(u) || u.length === 0) return n.error("Expected an interpolation type expression.", 1);
          if (u[0] === "linear") u = { name: "linear" };
          else if (u[0] === "exponential") {
            const E = u[1];
            if (typeof E != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
            u = { name: "exponential", base: E };
          } else {
            if (u[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(u[0])}`, 1, 0);
            {
              const E = u.slice(1);
              if (E.length !== 4 || E.some((D) => typeof D != "number" || D < 0 || D > 1)) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              u = { name: "cubic-bezier", controlPoints: E };
            }
          }
          if (e.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
          if (f = n.parse(f, 2, ue), !f) return null;
          const S = [];
          let I = null;
          o === "interpolate-hcl" || o === "interpolate-lab" ? I = ki : n.expectedType && n.expectedType.kind !== "value" && (I = n.expectedType);
          for (let E = 0; E < m.length; E += 2) {
            const D = m[E], N = m[E + 1], j = E + 3, H = E + 4;
            if (typeof D != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', j);
            if (S.length && S[S.length - 1][0] >= D) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', j);
            const et = n.parse(N, H, I);
            if (!et) return null;
            I = I || et.type, S.push([D, et]);
          }
          return wt(I, ue) || wt(I, ki) || wt(I, Ir) || wt(I, ht) || wt(I, O(ue)) ? new Ye(I, o, u, f, S) : n.error(`Type ${V(I)} is not interpolatable.`);
        }
        evaluate(e) {
          const n = this.labels, o = this.outputs;
          if (n.length === 1) return o[0].evaluate(e);
          const u = this.input.evaluate(e);
          if (u <= n[0]) return o[0].evaluate(e);
          const f = n.length;
          if (u >= n[f - 1]) return o[f - 1].evaluate(e);
          const m = _a(n, u), S = Ye.interpolationFactor(this.interpolation, u, n[m], n[m + 1]), I = o[m].evaluate(e), E = o[m + 1].evaluate(e);
          switch (this.operator) {
            case "interpolate":
              return Zr[this.type.kind](I, E, S);
            case "interpolate-hcl":
              return Zr.color(I, E, S, "hcl");
            case "interpolate-lab":
              return Zr.color(I, E, S, "lab");
          }
        }
        eachChild(e) {
          e(this.input);
          for (const n of this.outputs) e(n);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
      }
      function ba(i, e, n, o) {
        const u = o - n, f = i - n;
        return u === 0 ? 0 : e === 1 ? f / u : (Math.pow(e, f) - 1) / (Math.pow(e, u) - 1);
      }
      class Ha {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2) return n.error("Expectected at least one argument.");
          let o = null;
          const u = n.expectedType;
          u && u.kind !== "value" && (o = u);
          const f = [];
          for (const S of e.slice(1)) {
            const I = n.parse(S, 1 + f.length, o, void 0, { typeAnnotation: "omit" });
            if (!I) return null;
            o = o || I.type, f.push(I);
          }
          if (!o) throw new Error("No output type");
          const m = u && f.some((S) => ct(u, S.type));
          return new Ha(m ? Me : o, f);
        }
        evaluate(e) {
          let n, o = null, u = 0;
          for (const f of this.args) if (u++, o = f.evaluate(e), o && o instanceof br && !o.available && (n || (n = o.name), o = null, u === this.args.length && (o = n)), o !== null) break;
          return o;
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      }
      function Zn(i, e) {
        return i === "==" || i === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
      }
      function No(i, e, n, o) {
        return o.compare(e, n) === 0;
      }
      function cs(i, e, n) {
        const o = i !== "==" && i !== "!=";
        return class Jp {
          constructor(f, m, S) {
            this.type = Te, this.lhs = f, this.rhs = m, this.collator = S, this.hasUntypedArgument = f.type.kind === "value" || m.type.kind === "value";
          }
          static parse(f, m) {
            if (f.length !== 3 && f.length !== 4) return m.error("Expected two or three arguments.");
            const S = f[0];
            let I = m.parse(f[1], 1, Me);
            if (!I) return null;
            if (!Zn(S, I.type)) return m.concat(1).error(`"${S}" comparisons are not supported for type '${V(I.type)}'.`);
            let E = m.parse(f[2], 2, Me);
            if (!E) return null;
            if (!Zn(S, E.type)) return m.concat(2).error(`"${S}" comparisons are not supported for type '${V(E.type)}'.`);
            if (I.type.kind !== E.type.kind && I.type.kind !== "value" && E.type.kind !== "value") return m.error(`Cannot compare types '${V(I.type)}' and '${V(E.type)}'.`);
            o && (I.type.kind === "value" && E.type.kind !== "value" ? I = new $r(E.type, [I]) : I.type.kind !== "value" && E.type.kind === "value" && (E = new $r(I.type, [E])));
            let D = null;
            if (f.length === 4) {
              if (I.type.kind !== "string" && E.type.kind !== "string" && I.type.kind !== "value" && E.type.kind !== "value") return m.error("Cannot use collator to compare non-string types.");
              if (D = m.parse(f[3], 3, Ur), !D) return null;
            }
            return new Jp(I, E, D);
          }
          evaluate(f) {
            const m = this.lhs.evaluate(f), S = this.rhs.evaluate(f);
            if (o && this.hasUntypedArgument) {
              const I = dr(m), E = dr(S);
              if (I.kind !== E.kind || I.kind !== "string" && I.kind !== "number") throw new nr(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${I.kind}, ${E.kind}) instead.`);
            }
            if (this.collator && !o && this.hasUntypedArgument) {
              const I = dr(m), E = dr(S);
              if (I.kind !== "string" || E.kind !== "string") return e(f, m, S);
            }
            return this.collator ? n(f, m, S, this.collator.evaluate(f)) : e(f, m, S);
          }
          eachChild(f) {
            f(this.lhs), f(this.rhs), this.collator && f(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const wa = cs("==", function(i, e, n) {
        return e === n;
      }, No), Fo = cs("!=", function(i, e, n) {
        return e !== n;
      }, function(i, e, n, o) {
        return !No(0, e, n, o);
      }), Il = cs("<", function(i, e, n) {
        return e < n;
      }, function(i, e, n, o) {
        return o.compare(e, n) < 0;
      }), al = cs(">", function(i, e, n) {
        return e > n;
      }, function(i, e, n, o) {
        return o.compare(e, n) > 0;
      }), ol = cs("<=", function(i, e, n) {
        return e <= n;
      }, function(i, e, n, o) {
        return o.compare(e, n) <= 0;
      }), Ro = cs(">=", function(i, e, n) {
        return e >= n;
      }, function(i, e, n, o) {
        return o.compare(e, n) >= 0;
      });
      class hs {
        constructor(e, n, o) {
          this.type = Ur, this.locale = o, this.caseSensitive = e, this.diacriticSensitive = n;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error("Expected one argument.");
          const o = e[1];
          if (typeof o != "object" || Array.isArray(o)) return n.error("Collator options argument must be an object.");
          const u = n.parse(o["case-sensitive"] !== void 0 && o["case-sensitive"], 1, Te);
          if (!u) return null;
          const f = n.parse(o["diacritic-sensitive"] !== void 0 && o["diacritic-sensitive"], 1, Te);
          if (!f) return null;
          let m = null;
          return o.locale && (m = n.parse(o.locale, 1, ni), !m) ? null : new hs(u, f, m);
        }
        evaluate(e) {
          return new zo(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
        }
        eachChild(e) {
          e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class us {
        constructor(e, n, o, u, f) {
          this.type = ni, this.number = e, this.locale = n, this.currency = o, this.minFractionDigits = u, this.maxFractionDigits = f;
        }
        static parse(e, n) {
          if (e.length !== 3) return n.error("Expected two arguments.");
          const o = n.parse(e[1], 1, ue);
          if (!o) return null;
          const u = e[2];
          if (typeof u != "object" || Array.isArray(u)) return n.error("NumberFormat options argument must be an object.");
          let f = null;
          if (u.locale && (f = n.parse(u.locale, 1, ni), !f)) return null;
          let m = null;
          if (u.currency && (m = n.parse(u.currency, 1, ni), !m)) return null;
          let S = null;
          if (u["min-fraction-digits"] && (S = n.parse(u["min-fraction-digits"], 1, ue), !S)) return null;
          let I = null;
          return u["max-fraction-digits"] && (I = n.parse(u["max-fraction-digits"], 1, ue), !I) ? null : new us(o, f, m, S, I);
        }
        evaluate(e) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
        }
        eachChild(e) {
          e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class Xa {
        constructor(e) {
          this.type = qi, this.sections = e;
        }
        static parse(e, n) {
          if (e.length < 2) return n.error("Expected at least one argument.");
          const o = e[1];
          if (!Array.isArray(o) && typeof o == "object") return n.error("First argument must be an image or text section.");
          const u = [];
          let f = !1;
          for (let m = 1; m <= e.length - 1; ++m) {
            const S = e[m];
            if (f && typeof S == "object" && !Array.isArray(S)) {
              f = !1;
              let I = null;
              if (S["font-scale"] && (I = n.parse(S["font-scale"], 1, ue), !I)) return null;
              let E = null;
              if (S["text-font"] && (E = n.parse(S["text-font"], 1, O(ni)), !E)) return null;
              let D = null;
              if (S["text-color"] && (D = n.parse(S["text-color"], 1, ki), !D)) return null;
              const N = u[u.length - 1];
              N.scale = I, N.font = E, N.textColor = D;
            } else {
              const I = n.parse(e[m], 1, Me);
              if (!I) return null;
              const E = I.type.kind;
              if (E !== "string" && E !== "value" && E !== "null" && E !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              f = !0, u.push({ content: I, scale: null, font: null, textColor: null });
            }
          }
          return new Xa(u);
        }
        evaluate(e) {
          return new Vr(this.sections.map((n) => {
            const o = n.content.evaluate(e);
            return dr(o) === kr ? new Zs("", o, null, null, null) : new Zs($i(o), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null);
          }));
        }
        eachChild(e) {
          for (const n of this.sections) e(n.content), n.scale && e(n.scale), n.font && e(n.font), n.textColor && e(n.textColor);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ls {
        constructor(e) {
          this.type = kr, this.input = e;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error("Expected two arguments.");
          const o = n.parse(e[1], 1, ni);
          return o ? new Ls(o) : n.error("No image name provided.");
        }
        evaluate(e) {
          const n = this.input.evaluate(e), o = br.fromString(n);
          return o && e.availableImages && (o.available = e.availableImages.indexOf(n) > -1), o;
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Sa {
        constructor(e) {
          this.type = ue, this.input = e;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1);
          return o ? o.type.kind !== "array" && o.type.kind !== "string" && o.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${V(o.type)} instead.`) : new Sa(o) : null;
        }
        evaluate(e) {
          const n = this.input.evaluate(e);
          if (typeof n == "string") return [...n].length;
          if (Array.isArray(n)) return n.length;
          throw new nr(`Expected value to be of type string or array, but found ${V(dr(n))} instead.`);
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const rn = 8192;
      function Ya(i, e) {
        const n = (180 + i[0]) / 360, o = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360, u = Math.pow(2, e.z);
        return [Math.round(n * u * rn), Math.round(o * u * rn)];
      }
      function Cs(i, e) {
        const n = Math.pow(2, e.z);
        return [(u = (i[0] / rn + e.x) / n, 360 * u - 180), (o = (i[1] / rn + e.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90)];
        var o, u;
      }
      function Si(i, e) {
        i[0] = Math.min(i[0], e[0]), i[1] = Math.min(i[1], e[1]), i[2] = Math.max(i[2], e[0]), i[3] = Math.max(i[3], e[1]);
      }
      function Xs(i, e) {
        return !(i[0] <= e[0] || i[2] >= e[2] || i[1] <= e[1] || i[3] >= e[3]);
      }
      function Es(i, e, n) {
        const o = i[0] - e[0], u = i[1] - e[1], f = i[0] - n[0], m = i[1] - n[1];
        return o * m - f * u == 0 && o * f <= 0 && u * m <= 0;
      }
      function Gn(i, e, n, o) {
        return (u = [o[0] - n[0], o[1] - n[1]])[0] * (f = [e[0] - i[0], e[1] - i[1]])[1] - u[1] * f[0] != 0 && !(!ll(i, e, n, o) || !ll(n, o, i, e));
        var u, f;
      }
      function kl(i, e, n) {
        for (const o of n) for (let u = 0; u < o.length - 1; ++u) if (Gn(i, e, o[u], o[u + 1])) return !0;
        return !1;
      }
      function xn(i, e, n = !1) {
        let o = !1;
        for (const S of e) for (let I = 0; I < S.length - 1; I++) {
          if (Es(i, S[I], S[I + 1])) return n;
          (f = S[I])[1] > (u = i)[1] != (m = S[I + 1])[1] > u[1] && u[0] < (m[0] - f[0]) * (u[1] - f[1]) / (m[1] - f[1]) + f[0] && (o = !o);
        }
        var u, f, m;
        return o;
      }
      function Wn(i, e) {
        for (const n of e) if (xn(i, n)) return !0;
        return !1;
      }
      function Ja(i, e) {
        for (const n of i) if (!xn(n, e)) return !1;
        for (let n = 0; n < i.length - 1; ++n) if (kl(i[n], i[n + 1], e)) return !1;
        return !0;
      }
      function Aa(i, e) {
        for (const n of e) if (Ja(i, n)) return !0;
        return !1;
      }
      function ll(i, e, n, o) {
        const u = o[0] - n[0], f = o[1] - n[1], m = (i[0] - n[0]) * f - u * (i[1] - n[1]), S = (e[0] - n[0]) * f - u * (e[1] - n[1]);
        return m > 0 && S < 0 || m < 0 && S > 0;
      }
      function Ys(i, e, n) {
        const o = [];
        for (let u = 0; u < i.length; u++) {
          const f = [];
          for (let m = 0; m < i[u].length; m++) {
            const S = Ya(i[u][m], n);
            Si(e, S), f.push(S);
          }
          o.push(f);
        }
        return o;
      }
      function cl(i, e, n) {
        const o = [];
        for (let u = 0; u < i.length; u++) {
          const f = Ys(i[u], e, n);
          o.push(f);
        }
        return o;
      }
      function Ka(i, e, n, o) {
        if (i[0] < n[0] || i[0] > n[2]) {
          const u = 0.5 * o;
          let f = i[0] - n[0] > u ? -o : n[0] - i[0] > u ? o : 0;
          f === 0 && (f = i[0] - n[2] > u ? -o : n[2] - i[0] > u ? o : 0), i[0] += f;
        }
        Si(e, i);
      }
      function Qa(i, e, n, o) {
        const u = Math.pow(2, o.z) * rn, f = [o.x * rn, o.y * rn], m = [];
        for (const S of i) for (const I of S) {
          const E = [I.x + f[0], I.y + f[1]];
          Ka(E, e, n, u), m.push(E);
        }
        return m;
      }
      function Bo(i, e, n, o) {
        const u = Math.pow(2, o.z) * rn, f = [o.x * rn, o.y * rn], m = [];
        for (const I of i) {
          const E = [];
          for (const D of I) {
            const N = [D.x + f[0], D.y + f[1]];
            Si(e, N), E.push(N);
          }
          m.push(E);
        }
        if (e[2] - e[0] <= u / 2) {
          (S = e)[0] = S[1] = 1 / 0, S[2] = S[3] = -1 / 0;
          for (const I of m) for (const E of I) Ka(E, e, n, u);
        }
        var S;
        return m;
      }
      class Cn {
        constructor(e, n) {
          this.type = Te, this.geojson = e, this.geometries = n;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (os(e[1])) {
            const o = e[1];
            if (o.type === "FeatureCollection") {
              const u = [];
              for (const f of o.features) {
                const { type: m, coordinates: S } = f.geometry;
                m === "Polygon" && u.push(S), m === "MultiPolygon" && u.push(...S);
              }
              if (u.length) return new Cn(o, { type: "MultiPolygon", coordinates: u });
            } else if (o.type === "Feature") {
              const u = o.geometry.type;
              if (u === "Polygon" || u === "MultiPolygon") return new Cn(o, o.geometry);
            } else if (o.type === "Polygon" || o.type === "MultiPolygon") return new Cn(o, o);
          }
          return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point") return function(n, o) {
              const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = n.canonicalID();
              if (o.type === "Polygon") {
                const S = Ys(o.coordinates, f, m), I = Qa(n.geometry(), u, f, m);
                if (!Xs(u, f)) return !1;
                for (const E of I) if (!xn(E, S)) return !1;
              }
              if (o.type === "MultiPolygon") {
                const S = cl(o.coordinates, f, m), I = Qa(n.geometry(), u, f, m);
                if (!Xs(u, f)) return !1;
                for (const E of I) if (!Wn(E, S)) return !1;
              }
              return !0;
            }(e, this.geometries);
            if (e.geometryType() === "LineString") return function(n, o) {
              const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = n.canonicalID();
              if (o.type === "Polygon") {
                const S = Ys(o.coordinates, f, m), I = Bo(n.geometry(), u, f, m);
                if (!Xs(u, f)) return !1;
                for (const E of I) if (!Ja(E, S)) return !1;
              }
              if (o.type === "MultiPolygon") {
                const S = cl(o.coordinates, f, m), I = Bo(n.geometry(), u, f, m);
                if (!Xs(u, f)) return !1;
                for (const E of I) if (!Aa(E, S)) return !1;
              }
              return !0;
            }(e, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      let to = class {
        constructor(i = [], e = (n, o) => n < o ? -1 : n > o ? 1 : 0) {
          if (this.data = i, this.length = this.data.length, this.compare = e, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
        }
        push(i) {
          this.data.push(i), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const i = this.data[0], e = this.data.pop();
          return --this.length > 0 && (this.data[0] = e, this._down(0)), i;
        }
        peek() {
          return this.data[0];
        }
        _up(i) {
          const { data: e, compare: n } = this, o = e[i];
          for (; i > 0; ) {
            const u = i - 1 >> 1, f = e[u];
            if (n(o, f) >= 0) break;
            e[i] = f, i = u;
          }
          e[i] = o;
        }
        _down(i) {
          const { data: e, compare: n } = this, o = this.length >> 1, u = e[i];
          for (; i < o; ) {
            let f = 1 + (i << 1);
            const m = f + 1;
            if (m < this.length && n(e[m], e[f]) < 0 && (f = m), n(e[f], u) >= 0) break;
            e[i] = e[f], i = f;
          }
          e[i] = u;
        }
      };
      function Oo(i, e, n, o, u) {
        jo(i, e, n, o || i.length - 1, u || eo);
      }
      function jo(i, e, n, o, u) {
        for (; o > n; ) {
          if (o - n > 600) {
            var f = o - n + 1, m = e - n + 1, S = Math.log(f), I = 0.5 * Math.exp(2 * S / 3), E = 0.5 * Math.sqrt(S * I * (f - I) / f) * (m - f / 2 < 0 ? -1 : 1);
            jo(i, e, Math.max(n, Math.floor(e - m * I / f + E)), Math.min(o, Math.floor(e + (f - m) * I / f + E)), u);
          }
          var D = i[e], N = n, j = o;
          for (Pa(i, n, e), u(i[o], D) > 0 && Pa(i, n, o); N < j; ) {
            for (Pa(i, N, j), N++, j--; u(i[N], D) < 0; ) N++;
            for (; u(i[j], D) > 0; ) j--;
          }
          u(i[n], D) === 0 ? Pa(i, n, j) : Pa(i, ++j, o), j <= e && (n = j + 1), e <= j && (o = j - 1);
        }
      }
      function Pa(i, e, n) {
        var o = i[e];
        i[e] = i[n], i[n] = o;
      }
      function eo(i, e) {
        return i < e ? -1 : i > e ? 1 : 0;
      }
      function ds(i, e) {
        if (i.length <= 1) return [i];
        const n = [];
        let o, u;
        for (const f of i) {
          const m = Js(f);
          m !== 0 && (f.area = Math.abs(m), u === void 0 && (u = m < 0), u === m < 0 ? (o && n.push(o), o = [f]) : o.push(f));
        }
        if (o && n.push(o), e > 1) for (let f = 0; f < n.length; f++) n[f].length <= e || (Oo(n[f], e, 1, n[f].length - 1, qo), n[f] = n[f].slice(0, e));
        return n;
      }
      function qo(i, e) {
        return e.area - i.area;
      }
      function Js(i) {
        let e = 0;
        for (let n, o, u = 0, f = i.length, m = f - 1; u < f; m = u++) n = i[u], o = i[m], e += (o.x - n.x) * (n.y + o.y);
        return e;
      }
      const io = 1 / 298.257223563, L = io * (2 - io), X = Math.PI / 180;
      class ft {
        constructor(e) {
          const n = 6378.137 * X * 1e3, o = Math.cos(e * X), u = 1 / (1 - L * (1 - o * o)), f = Math.sqrt(u);
          this.kx = n * f * o, this.ky = n * f * u * (1 - L);
        }
        distance(e, n) {
          const o = this.wrap(e[0] - n[0]) * this.kx, u = (e[1] - n[1]) * this.ky;
          return Math.sqrt(o * o + u * u);
        }
        pointOnLine(e, n) {
          let o, u, f, m, S = 1 / 0;
          for (let I = 0; I < e.length - 1; I++) {
            let E = e[I][0], D = e[I][1], N = this.wrap(e[I + 1][0] - E) * this.kx, j = (e[I + 1][1] - D) * this.ky, H = 0;
            N === 0 && j === 0 || (H = (this.wrap(n[0] - E) * this.kx * N + (n[1] - D) * this.ky * j) / (N * N + j * j), H > 1 ? (E = e[I + 1][0], D = e[I + 1][1]) : H > 0 && (E += N / this.kx * H, D += j / this.ky * H)), N = this.wrap(n[0] - E) * this.kx, j = (n[1] - D) * this.ky;
            const et = N * N + j * j;
            et < S && (S = et, o = E, u = D, f = I, m = H);
          }
          return { point: [o, u], index: f, t: Math.max(0, Math.min(1, m)) };
        }
        wrap(e) {
          for (; e < -180; ) e += 360;
          for (; e > 180; ) e -= 360;
          return e;
        }
      }
      function Lt(i, e) {
        return e[0] - i[0];
      }
      function Ft(i) {
        return i[1] - i[0] + 1;
      }
      function Kt(i, e) {
        return i[1] >= i[0] && i[1] < e;
      }
      function _e(i, e) {
        if (i[0] > i[1]) return [null, null];
        const n = Ft(i);
        if (e) {
          if (n === 2) return [i, null];
          const u = Math.floor(n / 2);
          return [[i[0], i[0] + u], [i[0] + u, i[1]]];
        }
        if (n === 1) return [i, null];
        const o = Math.floor(n / 2) - 1;
        return [[i[0], i[0] + o], [i[0] + o + 1, i[1]]];
      }
      function Re(i, e) {
        if (!Kt(e, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let o = e[0]; o <= e[1]; ++o) Si(n, i[o]);
        return n;
      }
      function Qe(i) {
        const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const n of i) for (const o of n) Si(e, o);
        return e;
      }
      function gi(i) {
        return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0;
      }
      function vi(i, e, n) {
        if (!gi(i) || !gi(e)) return NaN;
        let o = 0, u = 0;
        return i[2] < e[0] && (o = e[0] - i[2]), i[0] > e[2] && (o = i[0] - e[2]), i[1] > e[3] && (u = i[1] - e[3]), i[3] < e[1] && (u = e[1] - i[3]), n.distance([0, 0], [o, u]);
      }
      function bi(i, e, n) {
        const o = n.pointOnLine(e, i);
        return n.distance(i, o.point);
      }
      function di(i, e, n, o, u) {
        const f = Math.min(bi(i, [n, o], u), bi(e, [n, o], u)), m = Math.min(bi(n, [i, e], u), bi(o, [i, e], u));
        return Math.min(f, m);
      }
      function mr(i, e, n, o, u) {
        if (!Kt(e, i.length) || !Kt(o, n.length)) return 1 / 0;
        let f = 1 / 0;
        for (let m = e[0]; m < e[1]; ++m) {
          const S = i[m], I = i[m + 1];
          for (let E = o[0]; E < o[1]; ++E) {
            const D = n[E], N = n[E + 1];
            if (Gn(S, I, D, N)) return 0;
            f = Math.min(f, di(S, I, D, N, u));
          }
        }
        return f;
      }
      function Xe(i, e, n, o, u) {
        if (!Kt(e, i.length) || !Kt(o, n.length)) return NaN;
        let f = 1 / 0;
        for (let m = e[0]; m <= e[1]; ++m) for (let S = o[0]; S <= o[1]; ++S) if (f = Math.min(f, u.distance(i[m], n[S])), f === 0) return f;
        return f;
      }
      function Cr(i, e, n) {
        if (xn(i, e, !0)) return 0;
        let o = 1 / 0;
        for (const u of e) {
          const f = u[0], m = u[u.length - 1];
          if (f !== m && (o = Math.min(o, bi(i, [m, f], n)), o === 0)) return o;
          const S = n.pointOnLine(u, i);
          if (o = Math.min(o, n.distance(i, S.point)), o === 0) return o;
        }
        return o;
      }
      function xi(i, e, n, o) {
        if (!Kt(e, i.length)) return NaN;
        for (let f = e[0]; f <= e[1]; ++f) if (xn(i[f], n, !0)) return 0;
        let u = 1 / 0;
        for (let f = e[0]; f < e[1]; ++f) {
          const m = i[f], S = i[f + 1];
          for (const I of n) for (let E = 0, D = I.length, N = D - 1; E < D; N = E++) {
            const j = I[N], H = I[E];
            if (Gn(m, S, j, H)) return 0;
            u = Math.min(u, di(m, S, j, H, o));
          }
        }
        return u;
      }
      function Li(i, e) {
        for (const n of i) for (const o of n) if (xn(o, e, !0)) return !0;
        return !1;
      }
      function nn(i, e, n, o = 1 / 0) {
        const u = Qe(i), f = Qe(e);
        if (o !== 1 / 0 && vi(u, f, n) >= o) return o;
        if (Xs(u, f)) {
          if (Li(i, e)) return 0;
        } else if (Li(e, i)) return 0;
        let m = 1 / 0;
        for (const S of i) for (let I = 0, E = S.length, D = E - 1; I < E; D = I++) {
          const N = S[D], j = S[I];
          for (const H of e) for (let et = 0, rt = H.length, dt = rt - 1; et < rt; dt = et++) {
            const vt = H[dt], Nt = H[et];
            if (Gn(N, j, vt, Nt)) return 0;
            m = Math.min(m, di(N, j, vt, Nt, n));
          }
        }
        return m;
      }
      function Hn(i, e, n, o, u, f) {
        if (!f) return;
        const m = vi(Re(o, f), u, n);
        m < e && i.push([m, f, [0, 0]]);
      }
      function Ks(i, e, n, o, u, f, m) {
        if (!f || !m) return;
        const S = vi(Re(o, f), Re(u, m), n);
        S < e && i.push([S, f, m]);
      }
      function Qs(i, e, n, o, u = 1 / 0) {
        let f = Math.min(o.distance(i[0], n[0][0]), u);
        if (f === 0) return f;
        const m = new to([[0, [0, i.length - 1], [0, 0]]], Lt), S = Qe(n);
        for (; m.length > 0; ) {
          const I = m.pop();
          if (I[0] >= f) continue;
          const E = I[1], D = e ? 50 : 100;
          if (Ft(E) <= D) {
            if (!Kt(E, i.length)) return NaN;
            if (e) {
              const N = xi(i, E, n, o);
              if (isNaN(N) || N === 0) return N;
              f = Math.min(f, N);
            } else for (let N = E[0]; N <= E[1]; ++N) {
              const j = Cr(i[N], n, o);
              if (f = Math.min(f, j), f === 0) return 0;
            }
          } else {
            const N = _e(E, e);
            Hn(m, f, o, i, S, N[0]), Hn(m, f, o, i, S, N[1]);
          }
        }
        return f;
      }
      function ta(i, e, n, o, u, f = 1 / 0) {
        let m = Math.min(f, u.distance(i[0], n[0]));
        if (m === 0) return m;
        const S = new to([[0, [0, i.length - 1], [0, n.length - 1]]], Lt);
        for (; S.length > 0; ) {
          const I = S.pop();
          if (I[0] >= m) continue;
          const E = I[1], D = I[2], N = e ? 50 : 100, j = o ? 50 : 100;
          if (Ft(E) <= N && Ft(D) <= j) {
            if (!Kt(E, i.length) && Kt(D, n.length)) return NaN;
            let H;
            if (e && o) H = mr(i, E, n, D, u), m = Math.min(m, H);
            else if (e && !o) {
              const et = i.slice(E[0], E[1] + 1);
              for (let rt = D[0]; rt <= D[1]; ++rt) if (H = bi(n[rt], et, u), m = Math.min(m, H), m === 0) return m;
            } else if (!e && o) {
              const et = n.slice(D[0], D[1] + 1);
              for (let rt = E[0]; rt <= E[1]; ++rt) if (H = bi(i[rt], et, u), m = Math.min(m, H), m === 0) return m;
            } else H = Xe(i, E, n, D, u), m = Math.min(m, H);
          } else {
            const H = _e(E, e), et = _e(D, o);
            Ks(S, m, u, i, n, H[0], et[0]), Ks(S, m, u, i, n, H[0], et[1]), Ks(S, m, u, i, n, H[1], et[0]), Ks(S, m, u, i, n, H[1], et[1]);
          }
        }
        return m;
      }
      function ea(i) {
        return i.type === "MultiPolygon" ? i.coordinates.map((e) => ({ type: "Polygon", coordinates: e })) : i.type === "MultiLineString" ? i.coordinates.map((e) => ({ type: "LineString", coordinates: e })) : i.type === "MultiPoint" ? i.coordinates.map((e) => ({ type: "Point", coordinates: e })) : [i];
      }
      class Xn {
        constructor(e, n) {
          this.type = ue, this.geojson = e, this.geometries = n;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (os(e[1])) {
            const o = e[1];
            if (o.type === "FeatureCollection") return new Xn(o, o.features.map((u) => ea(u.geometry)).flat());
            if (o.type === "Feature") return new Xn(o, ea(o.geometry));
            if ("type" in o && "coordinates" in o) return new Xn(o, ea(o));
          }
          return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point") return function(n, o) {
              const u = n.geometry(), f = u.flat().map((I) => Cs([I.x, I.y], n.canonical));
              if (u.length === 0) return NaN;
              const m = new ft(f[0][1]);
              let S = 1 / 0;
              for (const I of o) {
                switch (I.type) {
                  case "Point":
                    S = Math.min(S, ta(f, !1, [I.coordinates], !1, m, S));
                    break;
                  case "LineString":
                    S = Math.min(S, ta(f, !1, I.coordinates, !0, m, S));
                    break;
                  case "Polygon":
                    S = Math.min(S, Qs(f, !1, I.coordinates, m, S));
                }
                if (S === 0) return S;
              }
              return S;
            }(e, this.geometries);
            if (e.geometryType() === "LineString") return function(n, o) {
              const u = n.geometry(), f = u.flat().map((I) => Cs([I.x, I.y], n.canonical));
              if (u.length === 0) return NaN;
              const m = new ft(f[0][1]);
              let S = 1 / 0;
              for (const I of o) {
                switch (I.type) {
                  case "Point":
                    S = Math.min(S, ta(f, !0, [I.coordinates], !1, m, S));
                    break;
                  case "LineString":
                    S = Math.min(S, ta(f, !0, I.coordinates, !0, m, S));
                    break;
                  case "Polygon":
                    S = Math.min(S, Qs(f, !0, I.coordinates, m, S));
                }
                if (S === 0) return S;
              }
              return S;
            }(e, this.geometries);
            if (e.geometryType() === "Polygon") return function(n, o) {
              const u = n.geometry();
              if (u.length === 0 || u[0].length === 0) return NaN;
              const f = ds(u, 0).map((I) => I.map((E) => E.map((D) => Cs([D.x, D.y], n.canonical)))), m = new ft(f[0][0][0][1]);
              let S = 1 / 0;
              for (const I of o) for (const E of f) {
                switch (I.type) {
                  case "Point":
                    S = Math.min(S, Qs([I.coordinates], !1, E, m, S));
                    break;
                  case "LineString":
                    S = Math.min(S, Qs(I.coordinates, !0, E, m, S));
                    break;
                  case "Polygon":
                    S = Math.min(S, nn(E, I.coordinates, m, S));
                }
                if (S === 0) return S;
              }
              return S;
            }(e, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const Yn = { "==": wa, "!=": Fo, ">": al, "<": Il, ">=": Ro, "<=": ol, array: $r, at: $a, boolean: $r, case: Ws, coalesce: Ha, collator: hs, format: Xa, image: Ls, in: ga, "index-of": ya, interpolate: Ye, "interpolate-hcl": Ye, "interpolate-lab": Ye, length: Sa, let: Ei, literal: ls, match: Za, number: $r, "number-format": us, object: $r, slice: Ga, step: Hs, string: $r, "to-boolean": Tr, "to-color": Tr, "to-number": Tr, "to-string": Tr, var: Va, within: Cn, distance: Xn };
      class Er {
        constructor(e, n, o, u) {
          this.name = e, this.type = n, this._evaluate = o, this.args = u;
        }
        evaluate(e) {
          return this._evaluate(e, this.args);
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return !1;
        }
        static parse(e, n) {
          const o = e[0], u = Er.definitions[o];
          if (!u) return n.error(`Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const f = Array.isArray(u) ? u[0] : u.type, m = Array.isArray(u) ? [[u[1], u[2]]] : u.overloads, S = m.filter(([E]) => !Array.isArray(E) || E.length === e.length - 1);
          let I = null;
          for (const [E, D] of S) {
            I = new Ln(n.registry, ra, n.path, null, n.scope);
            const N = [];
            let j = !1;
            for (let H = 1; H < e.length; H++) {
              const et = e[H], rt = Array.isArray(E) ? E[H - 1] : E.type, dt = I.parse(et, 1 + N.length, rt);
              if (!dt) {
                j = !0;
                break;
              }
              N.push(dt);
            }
            if (!j) if (Array.isArray(E) && E.length !== N.length) I.error(`Expected ${E.length} arguments, but found ${N.length} instead.`);
            else {
              for (let H = 0; H < N.length; H++) {
                const et = Array.isArray(E) ? E[H] : E.type, rt = N[H];
                I.concat(H + 1).checkSubtype(et, rt.type);
              }
              if (I.errors.length === 0) return new Er(o, f, D, N);
            }
          }
          if (S.length === 1) n.errors.push(...I.errors);
          else {
            const E = (S.length ? S : m).map(([N]) => {
              return j = N, Array.isArray(j) ? `(${j.map(V).join(", ")})` : `(${V(j.type)}...)`;
              var j;
            }).join(" | "), D = [];
            for (let N = 1; N < e.length; N++) {
              const j = n.parse(e[N], 1 + D.length);
              if (!j) return null;
              D.push(V(j.type));
            }
            n.error(`Expected arguments of type ${E}, but found (${D.join(", ")}) instead.`);
          }
          return null;
        }
        static register(e, n) {
          Er.definitions = n;
          for (const o in n) e[o] = Er;
        }
      }
      function Gr(i, [e, n, o, u]) {
        e = e.evaluate(i), n = n.evaluate(i), o = o.evaluate(i);
        const f = u ? u.evaluate(i) : 1, m = Ua(e, n, o, f);
        if (m) throw new nr(m);
        return new Ni(e / 255, n / 255, o / 255, f, !1);
      }
      function ia(i, e) {
        return i in e;
      }
      function ps(i, e) {
        const n = e[i];
        return n === void 0 ? null : n;
      }
      function En(i) {
        return { type: i };
      }
      function ra(i) {
        if (i instanceof Va) return ra(i.boundExpression);
        if (i instanceof Er && i.name === "error" || i instanceof hs || i instanceof Cn || i instanceof Xn) return !1;
        const e = i instanceof Tr || i instanceof $r;
        let n = !0;
        return i.eachChild((o) => {
          n = e ? n && ra(o) : n && o instanceof ls;
        }), !!n && Nr(i) && na(i, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function Nr(i) {
        if (i instanceof Er && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof Cn || i instanceof Xn) return !1;
        let e = !0;
        return i.eachChild((n) => {
          e && !Nr(n) && (e = !1);
        }), e;
      }
      function Ia(i) {
        if (i instanceof Er && i.name === "feature-state") return !1;
        let e = !0;
        return i.eachChild((n) => {
          e && !Ia(n) && (e = !1);
        }), e;
      }
      function na(i, e) {
        if (i instanceof Er && e.indexOf(i.name) >= 0) return !1;
        let n = !0;
        return i.eachChild((o) => {
          n && !na(o, e) && (n = !1);
        }), n;
      }
      function Uo(i) {
        return { result: "success", value: i };
      }
      function Wr(i) {
        return { result: "error", value: i };
      }
      function fs(i) {
        return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven";
      }
      function Vo(i) {
        return !!i.expression && i.expression.parameters.indexOf("zoom") > -1;
      }
      function ro(i) {
        return !!i.expression && i.expression.interpolated;
      }
      function yi(i) {
        return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i;
      }
      function sn(i) {
        return typeof i == "object" && i !== null && !Array.isArray(i);
      }
      function Mn(i) {
        return i;
      }
      function ms(i, e) {
        const n = e.type === "color", o = i.stops && typeof i.stops[0][0] == "object", u = o || !(o || i.property !== void 0), f = i.type || (ro(e) ? "exponential" : "interval");
        if (n || e.type === "padding") {
          const D = n ? Ni.parse : tn.parse;
          (i = Ke({}, i)).stops && (i.stops = i.stops.map((N) => [N[0], D(N[1])])), i.default = D(i.default ? i.default : e.default);
        }
        if (i.colorSpace && (m = i.colorSpace) !== "rgb" && m !== "hcl" && m !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
        var m;
        let S, I, E;
        if (f === "exponential") S = an;
        else if (f === "interval") S = Ms;
        else if (f === "categorical") {
          S = Jn, I = /* @__PURE__ */ Object.create(null);
          for (const D of i.stops) I[D[0]] = D[1];
          E = typeof i.stops[0][0];
        } else {
          if (f !== "identity") throw new Error(`Unknown function type "${f}"`);
          S = ka;
        }
        if (o) {
          const D = {}, N = [];
          for (let et = 0; et < i.stops.length; et++) {
            const rt = i.stops[et], dt = rt[0].zoom;
            D[dt] === void 0 && (D[dt] = { zoom: dt, type: i.type, property: i.property, default: i.default, stops: [] }, N.push(dt)), D[dt].stops.push([rt[0].value, rt[1]]);
          }
          const j = [];
          for (const et of N) j.push([D[et].zoom, ms(D[et], e)]);
          const H = { name: "linear" };
          return { kind: "composite", interpolationType: H, interpolationFactor: Ye.interpolationFactor.bind(void 0, H), zoomStops: j.map((et) => et[0]), evaluate: ({ zoom: et }, rt) => an({ stops: j, base: i.base }, e, et).evaluate(et, rt) };
        }
        if (u) {
          const D = f === "exponential" ? { name: "exponential", base: i.base !== void 0 ? i.base : 1 } : null;
          return { kind: "camera", interpolationType: D, interpolationFactor: Ye.interpolationFactor.bind(void 0, D), zoomStops: i.stops.map((N) => N[0]), evaluate: ({ zoom: N }) => S(i, e, N, I, E) };
        }
        return { kind: "source", evaluate(D, N) {
          const j = N && N.properties ? N.properties[i.property] : void 0;
          return j === void 0 ? hn(i.default, e.default) : S(i, e, j, I, E);
        } };
      }
      function hn(i, e, n) {
        return i !== void 0 ? i : e !== void 0 ? e : n !== void 0 ? n : void 0;
      }
      function Jn(i, e, n, o, u) {
        return hn(typeof n === u ? o[n] : void 0, i.default, e.default);
      }
      function Ms(i, e, n) {
        if (yi(n) !== "number") return hn(i.default, e.default);
        const o = i.stops.length;
        if (o === 1 || n <= i.stops[0][0]) return i.stops[0][1];
        if (n >= i.stops[o - 1][0]) return i.stops[o - 1][1];
        const u = _a(i.stops.map((f) => f[0]), n);
        return i.stops[u][1];
      }
      function an(i, e, n) {
        const o = i.base !== void 0 ? i.base : 1;
        if (yi(n) !== "number") return hn(i.default, e.default);
        const u = i.stops.length;
        if (u === 1 || n <= i.stops[0][0]) return i.stops[0][1];
        if (n >= i.stops[u - 1][0]) return i.stops[u - 1][1];
        const f = _a(i.stops.map((D) => D[0]), n), m = function(D, N, j, H) {
          const et = H - j, rt = D - j;
          return et === 0 ? 0 : N === 1 ? rt / et : (Math.pow(N, rt) - 1) / (Math.pow(N, et) - 1);
        }(n, o, i.stops[f][0], i.stops[f + 1][0]), S = i.stops[f][1], I = i.stops[f + 1][1], E = Zr[e.type] || Mn;
        return typeof S.evaluate == "function" ? { evaluate(...D) {
          const N = S.evaluate.apply(void 0, D), j = I.evaluate.apply(void 0, D);
          if (N !== void 0 && j !== void 0) return E(N, j, m, i.colorSpace);
        } } : E(S, I, m, i.colorSpace);
      }
      function ka(i, e, n) {
        switch (e.type) {
          case "color":
            n = Ni.parse(n);
            break;
          case "formatted":
            n = Vr.fromString(n.toString());
            break;
          case "resolvedImage":
            n = br.fromString(n.toString());
            break;
          case "padding":
            n = tn.parse(n);
            break;
          default:
            yi(n) === e.type || e.type === "enum" && e.values[n] || (n = void 0);
        }
        return hn(n, i.default, e.default);
      }
      Er.register(Yn, { error: [{ kind: "error" }, [ni], (i, [e]) => {
        throw new nr(e.evaluate(i));
      }], typeof: [ni, [Me], (i, [e]) => V(dr(e.evaluate(i)))], "to-rgba": [O(ue, 4), [ki], (i, [e]) => {
        const [n, o, u, f] = e.evaluate(i).rgb;
        return [255 * n, 255 * o, 255 * u, f];
      }], rgb: [ki, [ue, ue, ue], Gr], rgba: [ki, [ue, ue, ue, ue], Gr], has: { type: Te, overloads: [[[ni], (i, [e]) => ia(e.evaluate(i), i.properties())], [[ni, vr], (i, [e, n]) => ia(e.evaluate(i), n.evaluate(i))]] }, get: { type: Me, overloads: [[[ni], (i, [e]) => ps(e.evaluate(i), i.properties())], [[ni, vr], (i, [e, n]) => ps(e.evaluate(i), n.evaluate(i))]] }, "feature-state": [Me, [ni], (i, [e]) => ps(e.evaluate(i), i.featureState || {})], properties: [vr, [], (i) => i.properties()], "geometry-type": [ni, [], (i) => i.geometryType()], id: [Me, [], (i) => i.id()], zoom: [ue, [], (i) => i.globals.zoom], "heatmap-density": [ue, [], (i) => i.globals.heatmapDensity || 0], "line-progress": [ue, [], (i) => i.globals.lineProgress || 0], accumulated: [Me, [], (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated], "+": [ue, En(ue), (i, e) => {
        let n = 0;
        for (const o of e) n += o.evaluate(i);
        return n;
      }], "*": [ue, En(ue), (i, e) => {
        let n = 1;
        for (const o of e) n *= o.evaluate(i);
        return n;
      }], "-": { type: ue, overloads: [[[ue, ue], (i, [e, n]) => e.evaluate(i) - n.evaluate(i)], [[ue], (i, [e]) => -e.evaluate(i)]] }, "/": [ue, [ue, ue], (i, [e, n]) => e.evaluate(i) / n.evaluate(i)], "%": [ue, [ue, ue], (i, [e, n]) => e.evaluate(i) % n.evaluate(i)], ln2: [ue, [], () => Math.LN2], pi: [ue, [], () => Math.PI], e: [ue, [], () => Math.E], "^": [ue, [ue, ue], (i, [e, n]) => Math.pow(e.evaluate(i), n.evaluate(i))], sqrt: [ue, [ue], (i, [e]) => Math.sqrt(e.evaluate(i))], log10: [ue, [ue], (i, [e]) => Math.log(e.evaluate(i)) / Math.LN10], ln: [ue, [ue], (i, [e]) => Math.log(e.evaluate(i))], log2: [ue, [ue], (i, [e]) => Math.log(e.evaluate(i)) / Math.LN2], sin: [ue, [ue], (i, [e]) => Math.sin(e.evaluate(i))], cos: [ue, [ue], (i, [e]) => Math.cos(e.evaluate(i))], tan: [ue, [ue], (i, [e]) => Math.tan(e.evaluate(i))], asin: [ue, [ue], (i, [e]) => Math.asin(e.evaluate(i))], acos: [ue, [ue], (i, [e]) => Math.acos(e.evaluate(i))], atan: [ue, [ue], (i, [e]) => Math.atan(e.evaluate(i))], min: [ue, En(ue), (i, e) => Math.min(...e.map((n) => n.evaluate(i)))], max: [ue, En(ue), (i, e) => Math.max(...e.map((n) => n.evaluate(i)))], abs: [ue, [ue], (i, [e]) => Math.abs(e.evaluate(i))], round: [ue, [ue], (i, [e]) => {
        const n = e.evaluate(i);
        return n < 0 ? -Math.round(-n) : Math.round(n);
      }], floor: [ue, [ue], (i, [e]) => Math.floor(e.evaluate(i))], ceil: [ue, [ue], (i, [e]) => Math.ceil(e.evaluate(i))], "filter-==": [Te, [ni, Me], (i, [e, n]) => i.properties()[e.value] === n.value], "filter-id-==": [Te, [Me], (i, [e]) => i.id() === e.value], "filter-type-==": [Te, [ni], (i, [e]) => i.geometryType() === e.value], "filter-<": [Te, [ni, Me], (i, [e, n]) => {
        const o = i.properties()[e.value], u = n.value;
        return typeof o == typeof u && o < u;
      }], "filter-id-<": [Te, [Me], (i, [e]) => {
        const n = i.id(), o = e.value;
        return typeof n == typeof o && n < o;
      }], "filter->": [Te, [ni, Me], (i, [e, n]) => {
        const o = i.properties()[e.value], u = n.value;
        return typeof o == typeof u && o > u;
      }], "filter-id->": [Te, [Me], (i, [e]) => {
        const n = i.id(), o = e.value;
        return typeof n == typeof o && n > o;
      }], "filter-<=": [Te, [ni, Me], (i, [e, n]) => {
        const o = i.properties()[e.value], u = n.value;
        return typeof o == typeof u && o <= u;
      }], "filter-id-<=": [Te, [Me], (i, [e]) => {
        const n = i.id(), o = e.value;
        return typeof n == typeof o && n <= o;
      }], "filter->=": [Te, [ni, Me], (i, [e, n]) => {
        const o = i.properties()[e.value], u = n.value;
        return typeof o == typeof u && o >= u;
      }], "filter-id->=": [Te, [Me], (i, [e]) => {
        const n = i.id(), o = e.value;
        return typeof n == typeof o && n >= o;
      }], "filter-has": [Te, [Me], (i, [e]) => e.value in i.properties()], "filter-has-id": [Te, [], (i) => i.id() !== null && i.id() !== void 0], "filter-type-in": [Te, [O(ni)], (i, [e]) => e.value.indexOf(i.geometryType()) >= 0], "filter-id-in": [Te, [O(Me)], (i, [e]) => e.value.indexOf(i.id()) >= 0], "filter-in-small": [Te, [ni, O(Me)], (i, [e, n]) => n.value.indexOf(i.properties()[e.value]) >= 0], "filter-in-large": [Te, [ni, O(Me)], (i, [e, n]) => function(o, u, f, m) {
        for (; f <= m; ) {
          const S = f + m >> 1;
          if (u[S] === o) return !0;
          u[S] > o ? m = S - 1 : f = S + 1;
        }
        return !1;
      }(i.properties()[e.value], n.value, 0, n.value.length - 1)], all: { type: Te, overloads: [[[Te, Te], (i, [e, n]) => e.evaluate(i) && n.evaluate(i)], [En(Te), (i, e) => {
        for (const n of e) if (!n.evaluate(i)) return !1;
        return !0;
      }]] }, any: { type: Te, overloads: [[[Te, Te], (i, [e, n]) => e.evaluate(i) || n.evaluate(i)], [En(Te), (i, e) => {
        for (const n of e) if (n.evaluate(i)) return !0;
        return !1;
      }]] }, "!": [Te, [Te], (i, [e]) => !e.evaluate(i)], "is-supported-script": [Te, [ni], (i, [e]) => {
        const n = i.globals && i.globals.isSupportedScript;
        return !n || n(e.evaluate(i));
      }], upcase: [ni, [ni], (i, [e]) => e.evaluate(i).toUpperCase()], downcase: [ni, [ni], (i, [e]) => e.evaluate(i).toLowerCase()], concat: [ni, En(Me), (i, e) => e.map((n) => $i(n.evaluate(i))).join("")], "resolved-locale": [ni, [Ur], (i, [e]) => e.evaluate(i).resolvedLocale()] });
      class zs {
        constructor(e, n) {
          var o;
          this.expression = e, this._warningHistory = {}, this._evaluator = new Lr(), this._defaultValue = n ? (o = n).type === "color" && sn(o.default) ? new Ni(0, 0, 0, 0) : o.type === "color" ? Ni.parse(o.default) || null : o.type === "padding" ? tn.parse(o.default) || null : o.type === "variableAnchorOffsetCollection" ? en.parse(o.default) || null : o.default === void 0 ? null : o.default : null, this._enumValues = n && n.type === "enum" ? n.values : null;
        }
        evaluateWithoutErrorHandling(e, n, o, u, f, m) {
          return this._evaluator.globals = e, this._evaluator.feature = n, this._evaluator.featureState = o, this._evaluator.canonical = u, this._evaluator.availableImages = f || null, this._evaluator.formattedSection = m, this.expression.evaluate(this._evaluator);
        }
        evaluate(e, n, o, u, f, m) {
          this._evaluator.globals = e, this._evaluator.feature = n || null, this._evaluator.featureState = o || null, this._evaluator.canonical = u, this._evaluator.availableImages = f || null, this._evaluator.formattedSection = m || null;
          try {
            const S = this.expression.evaluate(this._evaluator);
            if (S == null || typeof S == "number" && S != S) return this._defaultValue;
            if (this._enumValues && !(S in this._enumValues)) throw new nr(`Expected value to be one of ${Object.keys(this._enumValues).map((I) => JSON.stringify(I)).join(", ")}, but found ${JSON.stringify(S)} instead.`);
            return S;
          } catch (S) {
            return this._warningHistory[S.message] || (this._warningHistory[S.message] = !0, typeof console < "u" && console.warn(S.message)), this._defaultValue;
          }
        }
      }
      function zn(i) {
        return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in Yn;
      }
      function on(i, e) {
        const n = new Ln(Yn, ra, [], e ? function(u) {
          const f = { color: ki, string: ni, number: ue, enum: ni, boolean: Te, formatted: qi, padding: Ir, resolvedImage: kr, variableAnchorOffsetCollection: ht };
          return u.type === "array" ? O(f[u.value] || Me, u.length) : f[u.type];
        }(e) : void 0), o = n.parse(i, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return o ? Uo(new zs(o, e)) : Wr(n.errors);
      }
      class un {
        constructor(e, n) {
          this.kind = e, this._styleExpression = n, this.isStateDependent = e !== "constant" && !Ia(n.expression);
        }
        evaluateWithoutErrorHandling(e, n, o, u, f, m) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, n, o, u, f, m);
        }
        evaluate(e, n, o, u, f, m) {
          return this._styleExpression.evaluate(e, n, o, u, f, m);
        }
      }
      class Ds {
        constructor(e, n, o, u) {
          this.kind = e, this.zoomStops = o, this._styleExpression = n, this.isStateDependent = e !== "camera" && !Ia(n.expression), this.interpolationType = u;
        }
        evaluateWithoutErrorHandling(e, n, o, u, f, m) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, n, o, u, f, m);
        }
        evaluate(e, n, o, u, f, m) {
          return this._styleExpression.evaluate(e, n, o, u, f, m);
        }
        interpolationFactor(e, n, o) {
          return this.interpolationType ? Ye.interpolationFactor(this.interpolationType, e, n, o) : 0;
        }
      }
      function Ta(i, e) {
        const n = on(i, e);
        if (n.result === "error") return n;
        const o = n.value.expression, u = Nr(o);
        if (!u && !fs(e)) return Wr([new ai("", "data expressions not supported")]);
        const f = na(o, ["zoom"]);
        if (!f && !Vo(e)) return Wr([new ai("", "zoom expressions not supported")]);
        const m = Kn(o);
        return m || f ? m instanceof ai ? Wr([m]) : m instanceof Ye && !ro(e) ? Wr([new ai("", '"interpolate" expressions cannot be used with this property')]) : Uo(m ? new Ds(u ? "camera" : "composite", n.value, m.labels, m instanceof Ye ? m.interpolation : void 0) : new un(u ? "constant" : "source", n.value)) : Wr([new ai("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class gs {
        constructor(e, n) {
          this._parameters = e, this._specification = n, Ke(this, ms(this._parameters, this._specification));
        }
        static deserialize(e) {
          return new gs(e._parameters, e._specification);
        }
        static serialize(e) {
          return { _parameters: e._parameters, _specification: e._specification };
        }
      }
      function Kn(i) {
        let e = null;
        if (i instanceof Ei) e = Kn(i.result);
        else if (i instanceof Ha) {
          for (const n of i.args) if (e = Kn(n), e) break;
        } else (i instanceof Hs || i instanceof Ye) && i.input instanceof Er && i.input.name === "zoom" && (e = i);
        return e instanceof ai || i.eachChild((n) => {
          const o = Kn(n);
          o instanceof ai ? e = o : !e && o ? e = new ai("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && o && e !== o && (e = new ai("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e;
      }
      function La(i) {
        if (i === !0 || i === !1) return !0;
        if (!Array.isArray(i) || i.length === 0) return !1;
        switch (i[0]) {
          case "has":
            return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
          case "in":
            return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
          case "any":
          case "all":
            for (const e of i.slice(1)) if (!La(e) && typeof e != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      const ln = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function dn(i) {
        if (i == null) return { filter: () => !0, needGeometry: !1 };
        La(i) || (i = Ki(i));
        const e = on(i, ln);
        if (e.result === "error") throw new Error(e.value.map((n) => `${n.key}: ${n.message}`).join(", "));
        return { filter: (n, o, u) => e.value.evaluate(n, o, {}, u), needGeometry: ji(i) };
      }
      function Pi(i, e) {
        return i < e ? -1 : i > e ? 1 : 0;
      }
      function ji(i) {
        if (!Array.isArray(i)) return !1;
        if (i[0] === "within" || i[0] === "distance") return !0;
        for (let e = 1; e < i.length; e++) if (ji(i[e])) return !0;
        return !1;
      }
      function Ki(i) {
        if (!i) return !0;
        const e = i[0];
        return i.length <= 1 ? e !== "any" : e === "==" ? gr(i[1], i[2], "==") : e === "!=" ? _s(gr(i[1], i[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? gr(i[1], i[2], e) : e === "any" ? (n = i.slice(1), ["any"].concat(n.map(Ki))) : e === "all" ? ["all"].concat(i.slice(1).map(Ki)) : e === "none" ? ["all"].concat(i.slice(1).map(Ki).map(_s)) : e === "in" ? ys(i[1], i.slice(2)) : e === "!in" ? _s(ys(i[1], i.slice(2))) : e === "has" ? bn(i[1]) : e !== "!has" || _s(bn(i[1]));
        var n;
      }
      function gr(i, e, n) {
        switch (i) {
          case "$type":
            return [`filter-type-${n}`, e];
          case "$id":
            return [`filter-id-${n}`, e];
          default:
            return [`filter-${n}`, i, e];
        }
      }
      function ys(i, e) {
        if (e.length === 0) return !1;
        switch (i) {
          case "$type":
            return ["filter-type-in", ["literal", e]];
          case "$id":
            return ["filter-id-in", ["literal", e]];
          default:
            return e.length > 200 && !e.some((n) => typeof n != typeof e[0]) ? ["filter-in-large", i, ["literal", e.sort(Pi)]] : ["filter-in-small", i, ["literal", e]];
        }
      }
      function bn(i) {
        switch (i) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", i];
        }
      }
      function _s(i) {
        return ["!", i];
      }
      function sa(i) {
        const e = typeof i;
        if (e === "number" || e === "boolean" || e === "string" || i == null) return JSON.stringify(i);
        if (Array.isArray(i)) {
          let u = "[";
          for (const f of i) u += `${sa(f)},`;
          return `${u}]`;
        }
        const n = Object.keys(i).sort();
        let o = "{";
        for (let u = 0; u < n.length; u++) o += `${JSON.stringify(n[u])}:${sa(i[n[u]])},`;
        return `${o}}`;
      }
      function Yl(i) {
        let e = "";
        for (const n of ci) e += `/${sa(i[n])}`;
        return e;
      }
      function $o(i) {
        const e = i.value;
        return e ? [new he(i.key, e, "constants have been deprecated as of v8")] : [];
      }
      function hr(i) {
        return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i;
      }
      function Dn(i) {
        if (Array.isArray(i)) return i.map(Dn);
        if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
          const e = {};
          for (const n in i) e[n] = Dn(i[n]);
          return e;
        }
        return hr(i);
      }
      function wn(i) {
        const e = i.key, n = i.value, o = i.valueSpec || {}, u = i.objectElementValidators || {}, f = i.style, m = i.styleSpec, S = i.validateSpec;
        let I = [];
        const E = yi(n);
        if (E !== "object") return [new he(e, n, `object expected, ${E} found`)];
        for (const D in n) {
          const N = D.split(".")[0], j = o[N] || o["*"];
          let H;
          if (u[N]) H = u[N];
          else if (o[N]) H = S;
          else if (u["*"]) H = u["*"];
          else {
            if (!o["*"]) {
              I.push(new he(e, n[D], `unknown property "${D}"`));
              continue;
            }
            H = S;
          }
          I = I.concat(H({ key: (e && `${e}.`) + D, value: n[D], valueSpec: j, style: f, styleSpec: m, object: n, objectKey: D, validateSpec: S }, n));
        }
        for (const D in o) u[D] || o[D].required && o[D].default === void 0 && n[D] === void 0 && I.push(new he(e, n, `missing required property "${D}"`));
        return I;
      }
      function no(i) {
        const e = i.value, n = i.valueSpec, o = i.style, u = i.styleSpec, f = i.key, m = i.arrayElementValidator || i.validateSpec;
        if (yi(e) !== "array") return [new he(f, e, `array expected, ${yi(e)} found`)];
        if (n.length && e.length !== n.length) return [new he(f, e, `array length ${n.length} expected, length ${e.length} found`)];
        if (n["min-length"] && e.length < n["min-length"]) return [new he(f, e, `array length at least ${n["min-length"]} expected, length ${e.length} found`)];
        let S = { type: n.value, values: n.values };
        u.$version < 7 && (S.function = n.function), yi(n.value) === "object" && (S = n.value);
        let I = [];
        for (let E = 0; E < e.length; E++) I = I.concat(m({ array: e, arrayIndex: E, value: e[E], valueSpec: S, validateSpec: i.validateSpec, style: o, styleSpec: u, key: `${f}[${E}]` }));
        return I;
      }
      function so(i) {
        const e = i.key, n = i.value, o = i.valueSpec;
        let u = yi(n);
        return u === "number" && n != n && (u = "NaN"), u !== "number" ? [new he(e, n, `number expected, ${u} found`)] : "minimum" in o && n < o.minimum ? [new he(e, n, `${n} is less than the minimum value ${o.minimum}`)] : "maximum" in o && n > o.maximum ? [new he(e, n, `${n} is greater than the maximum value ${o.maximum}`)] : [];
      }
      function Ca(i) {
        const e = i.valueSpec, n = hr(i.value.type);
        let o, u, f, m = {};
        const S = n !== "categorical" && i.value.property === void 0, I = !S, E = yi(i.value.stops) === "array" && yi(i.value.stops[0]) === "array" && yi(i.value.stops[0][0]) === "object", D = wn({ key: i.key, value: i.value, valueSpec: i.styleSpec.function, validateSpec: i.validateSpec, style: i.style, styleSpec: i.styleSpec, objectElementValidators: { stops: function(H) {
          if (n === "identity") return [new he(H.key, H.value, 'identity function may not have a "stops" property')];
          let et = [];
          const rt = H.value;
          return et = et.concat(no({ key: H.key, value: rt, valueSpec: H.valueSpec, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec, arrayElementValidator: N })), yi(rt) === "array" && rt.length === 0 && et.push(new he(H.key, rt, "array must have at least one stop")), et;
        }, default: function(H) {
          return H.validateSpec({ key: H.key, value: H.value, valueSpec: e, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec });
        } } });
        return n === "identity" && S && D.push(new he(i.key, i.value, 'missing required property "property"')), n === "identity" || i.value.stops || D.push(new he(i.key, i.value, 'missing required property "stops"')), n === "exponential" && i.valueSpec.expression && !ro(i.valueSpec) && D.push(new he(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (I && !fs(i.valueSpec) ? D.push(new he(i.key, i.value, "property functions not supported")) : S && !Vo(i.valueSpec) && D.push(new he(i.key, i.value, "zoom functions not supported"))), n !== "categorical" && !E || i.value.property !== void 0 || D.push(new he(i.key, i.value, '"property" property is required')), D;
        function N(H) {
          let et = [];
          const rt = H.value, dt = H.key;
          if (yi(rt) !== "array") return [new he(dt, rt, `array expected, ${yi(rt)} found`)];
          if (rt.length !== 2) return [new he(dt, rt, `array length 2 expected, length ${rt.length} found`)];
          if (E) {
            if (yi(rt[0]) !== "object") return [new he(dt, rt, `object expected, ${yi(rt[0])} found`)];
            if (rt[0].zoom === void 0) return [new he(dt, rt, "object stop key must have zoom")];
            if (rt[0].value === void 0) return [new he(dt, rt, "object stop key must have value")];
            if (f && f > hr(rt[0].zoom)) return [new he(dt, rt[0].zoom, "stop zoom values must appear in ascending order")];
            hr(rt[0].zoom) !== f && (f = hr(rt[0].zoom), u = void 0, m = {}), et = et.concat(wn({ key: `${dt}[0]`, value: rt[0], valueSpec: { zoom: {} }, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec, objectElementValidators: { zoom: so, value: j } }));
          } else et = et.concat(j({ key: `${dt}[0]`, value: rt[0], valueSpec: {}, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec }, rt));
          return zn(Dn(rt[1])) ? et.concat([new he(`${dt}[1]`, rt[1], "expressions are not allowed in function stops.")]) : et.concat(H.validateSpec({ key: `${dt}[1]`, value: rt[1], valueSpec: e, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec }));
        }
        function j(H, et) {
          const rt = yi(H.value), dt = hr(H.value), vt = H.value !== null ? H.value : et;
          if (o) {
            if (rt !== o) return [new he(H.key, vt, `${rt} stop domain type must match previous stop domain type ${o}`)];
          } else o = rt;
          if (rt !== "number" && rt !== "string" && rt !== "boolean") return [new he(H.key, vt, "stop domain value must be a number, string, or boolean")];
          if (rt !== "number" && n !== "categorical") {
            let Nt = `number expected, ${rt} found`;
            return fs(e) && n === void 0 && (Nt += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new he(H.key, vt, Nt)];
          }
          return n !== "categorical" || rt !== "number" || isFinite(dt) && Math.floor(dt) === dt ? n !== "categorical" && rt === "number" && u !== void 0 && dt < u ? [new he(H.key, vt, "stop domain values must appear in ascending order")] : (u = dt, n === "categorical" && dt in m ? [new he(H.key, vt, "stop domain values must be unique")] : (m[dt] = !0, [])) : [new he(H.key, vt, `integer expected, found ${dt}`)];
        }
      }
      function wr(i) {
        const e = (i.expressionContext === "property" ? Ta : on)(Dn(i.value), i.valueSpec);
        if (e.result === "error") return e.value.map((o) => new he(`${i.key}${o.key}`, i.value, o.message));
        const n = e.value.expression || e.value._styleExpression.expression;
        if (i.expressionContext === "property" && i.propertyKey === "text-font" && !n.outputDefined()) return [new he(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (i.expressionContext === "property" && i.propertyType === "layout" && !Ia(n)) return [new he(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (i.expressionContext === "filter" && !Ia(n)) return [new he(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
        if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
          if (!na(n, ["zoom", "feature-state"])) return [new he(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (i.expressionContext === "cluster-initial" && !Nr(n)) return [new he(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Fr(i) {
        const e = i.key, n = i.value, o = i.valueSpec, u = [];
        return Array.isArray(o.values) ? o.values.indexOf(hr(n)) === -1 && u.push(new he(e, n, `expected one of [${o.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(o.values).indexOf(hr(n)) === -1 && u.push(new he(e, n, `expected one of [${Object.keys(o.values).join(", ")}], ${JSON.stringify(n)} found`)), u;
      }
      function ao(i) {
        return La(Dn(i.value)) ? wr(Ke({}, i, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Ea(i);
      }
      function Ea(i) {
        const e = i.value, n = i.key;
        if (yi(e) !== "array") return [new he(n, e, `array expected, ${yi(e)} found`)];
        const o = i.styleSpec;
        let u, f = [];
        if (e.length < 1) return [new he(n, e, "filter array must have at least 1 element")];
        switch (f = f.concat(Fr({ key: `${n}[0]`, value: e[0], valueSpec: o.filter_operator, style: i.style, styleSpec: i.styleSpec })), hr(e[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e.length >= 2 && hr(e[1]) === "$type" && f.push(new he(n, e, `"$type" cannot be use with operator "${e[0]}"`));
          case "==":
          case "!=":
            e.length !== 3 && f.push(new he(n, e, `filter array for operator "${e[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e.length >= 2 && (u = yi(e[1]), u !== "string" && f.push(new he(`${n}[1]`, e[1], `string expected, ${u} found`)));
            for (let m = 2; m < e.length; m++) u = yi(e[m]), hr(e[1]) === "$type" ? f = f.concat(Fr({ key: `${n}[${m}]`, value: e[m], valueSpec: o.geometry_type, style: i.style, styleSpec: i.styleSpec })) : u !== "string" && u !== "number" && u !== "boolean" && f.push(new he(`${n}[${m}]`, e[m], `string, number, or boolean expected, ${u} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let m = 1; m < e.length; m++) f = f.concat(Ea({ key: `${n}[${m}]`, value: e[m], style: i.style, styleSpec: i.styleSpec }));
            break;
          case "has":
          case "!has":
            u = yi(e[1]), e.length !== 2 ? f.push(new he(n, e, `filter array for "${e[0]}" operator must have 2 elements`)) : u !== "string" && f.push(new he(`${n}[1]`, e[1], `string expected, ${u} found`));
        }
        return f;
      }
      function oo(i, e) {
        const n = i.key, o = i.validateSpec, u = i.style, f = i.styleSpec, m = i.value, S = i.objectKey, I = f[`${e}_${i.layerType}`];
        if (!I) return [];
        const E = S.match(/^(.*)-transition$/);
        if (e === "paint" && E && I[E[1]] && I[E[1]].transition) return o({ key: n, value: m, valueSpec: f.transition, style: u, styleSpec: f });
        const D = i.valueSpec || I[S];
        if (!D) return [new he(n, m, `unknown property "${S}"`)];
        let N;
        if (yi(m) === "string" && fs(D) && !D.tokens && (N = /^{([^}]+)}$/.exec(m))) return [new he(n, m, `"${S}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(N[1])} }\`.`)];
        const j = [];
        return i.layerType === "symbol" && (S === "text-field" && u && !u.glyphs && j.push(new he(n, m, 'use of "text-field" requires a style "glyphs" property')), S === "text-font" && sn(Dn(m)) && hr(m.type) === "identity" && j.push(new he(n, m, '"text-font" does not support identity functions'))), j.concat(o({ key: i.key, value: m, valueSpec: D, style: u, styleSpec: f, expressionContext: "property", propertyType: e, propertyKey: S }));
      }
      function lo(i) {
        return oo(i, "paint");
      }
      function co(i) {
        return oo(i, "layout");
      }
      function Zo(i) {
        let e = [];
        const n = i.value, o = i.key, u = i.style, f = i.styleSpec;
        n.type || n.ref || e.push(new he(o, n, 'either "type" or "ref" is required'));
        let m = hr(n.type);
        const S = hr(n.ref);
        if (n.id) {
          const I = hr(n.id);
          for (let E = 0; E < i.arrayIndex; E++) {
            const D = u.layers[E];
            hr(D.id) === I && e.push(new he(o, n.id, `duplicate layer id "${n.id}", previously used at line ${D.id.__line__}`));
          }
        }
        if ("ref" in n) {
          let I;
          ["type", "source", "source-layer", "filter", "layout"].forEach((E) => {
            E in n && e.push(new he(o, n[E], `"${E}" is prohibited for ref layers`));
          }), u.layers.forEach((E) => {
            hr(E.id) === S && (I = E);
          }), I ? I.ref ? e.push(new he(o, n.ref, "ref cannot reference another ref layer")) : m = hr(I.type) : e.push(new he(o, n.ref, `ref layer "${S}" not found`));
        } else if (m !== "background") if (n.source) {
          const I = u.sources && u.sources[n.source], E = I && hr(I.type);
          I ? E === "vector" && m === "raster" ? e.push(new he(o, n.source, `layer "${n.id}" requires a raster source`)) : E !== "raster-dem" && m === "hillshade" ? e.push(new he(o, n.source, `layer "${n.id}" requires a raster-dem source`)) : E === "raster" && m !== "raster" ? e.push(new he(o, n.source, `layer "${n.id}" requires a vector source`)) : E !== "vector" || n["source-layer"] ? E === "raster-dem" && m !== "hillshade" ? e.push(new he(o, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : m !== "line" || !n.paint || !n.paint["line-gradient"] || E === "geojson" && I.lineMetrics || e.push(new he(o, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new he(o, n, `layer "${n.id}" must specify a "source-layer"`)) : e.push(new he(o, n.source, `source "${n.source}" not found`));
        } else e.push(new he(o, n, 'missing required property "source"'));
        return e = e.concat(wn({ key: o, value: n, valueSpec: f.layer, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, objectElementValidators: { "*": () => [], type: () => i.validateSpec({ key: `${o}.type`, value: n.type, valueSpec: f.layer.type, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, object: n, objectKey: "type" }), filter: ao, layout: (I) => wn({ layer: n, key: I.key, value: I.value, style: I.style, styleSpec: I.styleSpec, validateSpec: I.validateSpec, objectElementValidators: { "*": (E) => co(Ke({ layerType: m }, E)) } }), paint: (I) => wn({ layer: n, key: I.key, value: I.value, style: I.style, styleSpec: I.styleSpec, validateSpec: I.validateSpec, objectElementValidators: { "*": (E) => lo(Ke({ layerType: m }, E)) } }) } })), e;
      }
      function Ns(i) {
        const e = i.value, n = i.key, o = yi(e);
        return o !== "string" ? [new he(n, e, `string expected, ${o} found`)] : [];
      }
      const ho = { promoteId: function({ key: i, value: e }) {
        if (yi(e) === "string") return Ns({ key: i, value: e });
        {
          const n = [];
          for (const o in e) n.push(...Ns({ key: `${i}.${o}`, value: e[o] }));
          return n;
        }
      } };
      function Go(i) {
        const e = i.value, n = i.key, o = i.styleSpec, u = i.style, f = i.validateSpec;
        if (!e.type) return [new he(n, e, '"type" is required')];
        const m = hr(e.type);
        let S;
        switch (m) {
          case "vector":
          case "raster":
            return S = wn({ key: n, value: e, valueSpec: o[`source_${m.replace("-", "_")}`], style: i.style, styleSpec: o, objectElementValidators: ho, validateSpec: f }), S;
          case "raster-dem":
            return S = function(I) {
              var E;
              const D = (E = I.sourceName) !== null && E !== void 0 ? E : "", N = I.value, j = I.styleSpec, H = j.source_raster_dem, et = I.style;
              let rt = [];
              const dt = yi(N);
              if (N === void 0) return rt;
              if (dt !== "object") return rt.push(new he("source_raster_dem", N, `object expected, ${dt} found`)), rt;
              const vt = hr(N.encoding) === "custom", Nt = ["redFactor", "greenFactor", "blueFactor", "baseShift"], kt = I.value.encoding ? `"${I.value.encoding}"` : "Default";
              for (const zt in N) !vt && Nt.includes(zt) ? rt.push(new he(zt, N[zt], `In "${D}": "${zt}" is only valid when "encoding" is set to "custom". ${kt} encoding found`)) : H[zt] ? rt = rt.concat(I.validateSpec({ key: zt, value: N[zt], valueSpec: H[zt], validateSpec: I.validateSpec, style: et, styleSpec: j })) : rt.push(new he(zt, N[zt], `unknown property "${zt}"`));
              return rt;
            }({ sourceName: n, value: e, style: i.style, styleSpec: o, validateSpec: f }), S;
          case "geojson":
            if (S = wn({ key: n, value: e, valueSpec: o.source_geojson, style: u, styleSpec: o, validateSpec: f, objectElementValidators: ho }), e.cluster) for (const I in e.clusterProperties) {
              const [E, D] = e.clusterProperties[I], N = typeof E == "string" ? [E, ["accumulated"], ["get", I]] : E;
              S.push(...wr({ key: `${n}.${I}.map`, value: D, validateSpec: f, expressionContext: "cluster-map" })), S.push(...wr({ key: `${n}.${I}.reduce`, value: N, validateSpec: f, expressionContext: "cluster-reduce" }));
            }
            return S;
          case "video":
            return wn({ key: n, value: e, valueSpec: o.source_video, style: u, validateSpec: f, styleSpec: o });
          case "image":
            return wn({ key: n, value: e, valueSpec: o.source_image, style: u, validateSpec: f, styleSpec: o });
          case "canvas":
            return [new he(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Fr({ key: `${n}.type`, value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: u, validateSpec: f, styleSpec: o });
        }
      }
      function Wo(i) {
        const e = i.value, n = i.styleSpec, o = n.light, u = i.style;
        let f = [];
        const m = yi(e);
        if (e === void 0) return f;
        if (m !== "object") return f = f.concat([new he("light", e, `object expected, ${m} found`)]), f;
        for (const S in e) {
          const I = S.match(/^(.*)-transition$/);
          f = f.concat(I && o[I[1]] && o[I[1]].transition ? i.validateSpec({ key: S, value: e[S], valueSpec: n.transition, validateSpec: i.validateSpec, style: u, styleSpec: n }) : o[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: o[S], validateSpec: i.validateSpec, style: u, styleSpec: n }) : [new he(S, e[S], `unknown property "${S}"`)]);
        }
        return f;
      }
      function Ho(i) {
        const e = i.value, n = i.styleSpec, o = n.sky, u = i.style, f = yi(e);
        if (e === void 0) return [];
        if (f !== "object") return [new he("sky", e, `object expected, ${f} found`)];
        let m = [];
        for (const S in e) m = m.concat(o[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: o[S], style: u, styleSpec: n }) : [new he(S, e[S], `unknown property "${S}"`)]);
        return m;
      }
      function Jl(i) {
        const e = i.value, n = i.styleSpec, o = n.terrain, u = i.style;
        let f = [];
        const m = yi(e);
        if (e === void 0) return f;
        if (m !== "object") return f = f.concat([new he("terrain", e, `object expected, ${m} found`)]), f;
        for (const S in e) f = f.concat(o[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: o[S], validateSpec: i.validateSpec, style: u, styleSpec: n }) : [new he(S, e[S], `unknown property "${S}"`)]);
        return f;
      }
      function Tl(i) {
        let e = [];
        const n = i.value, o = i.key;
        if (Array.isArray(n)) {
          const u = [], f = [];
          for (const m in n) n[m].id && u.includes(n[m].id) && e.push(new he(o, n, `all the sprites' ids must be unique, but ${n[m].id} is duplicated`)), u.push(n[m].id), n[m].url && f.includes(n[m].url) && e.push(new he(o, n, `all the sprites' URLs must be unique, but ${n[m].url} is duplicated`)), f.push(n[m].url), e = e.concat(wn({ key: `${o}[${m}]`, value: n[m], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: i.validateSpec }));
          return e;
        }
        return Ns({ key: o, value: n });
      }
      const hl = { "*": () => [], array: no, boolean: function(i) {
        const e = i.value, n = i.key, o = yi(e);
        return o !== "boolean" ? [new he(n, e, `boolean expected, ${o} found`)] : [];
      }, number: so, color: function(i) {
        const e = i.key, n = i.value, o = yi(n);
        return o !== "string" ? [new he(e, n, `color expected, ${o} found`)] : Ni.parse(String(n)) ? [] : [new he(e, n, `color expected, "${n}" found`)];
      }, constants: $o, enum: Fr, filter: ao, function: Ca, layer: Zo, object: wn, source: Go, light: Wo, sky: Ho, terrain: Jl, projection: function(i) {
        const e = i.value, n = i.styleSpec, o = n.projection, u = i.style, f = yi(e);
        if (e === void 0) return [];
        if (f !== "object") return [new he("projection", e, `object expected, ${f} found`)];
        let m = [];
        for (const S in e) m = m.concat(o[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: o[S], style: u, styleSpec: n }) : [new he(S, e[S], `unknown property "${S}"`)]);
        return m;
      }, string: Ns, formatted: function(i) {
        return Ns(i).length === 0 ? [] : wr(i);
      }, resolvedImage: function(i) {
        return Ns(i).length === 0 ? [] : wr(i);
      }, padding: function(i) {
        const e = i.key, n = i.value;
        if (yi(n) === "array") {
          if (n.length < 1 || n.length > 4) return [new he(e, n, `padding requires 1 to 4 values; ${n.length} values found`)];
          const o = { type: "number" };
          let u = [];
          for (let f = 0; f < n.length; f++) u = u.concat(i.validateSpec({ key: `${e}[${f}]`, value: n[f], validateSpec: i.validateSpec, valueSpec: o }));
          return u;
        }
        return so({ key: e, value: n, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(i) {
        const e = i.key, n = i.value, o = yi(n), u = i.styleSpec;
        if (o !== "array" || n.length < 1 || n.length % 2 != 0) return [new he(e, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let f = [];
        for (let m = 0; m < n.length; m += 2) f = f.concat(Fr({ key: `${e}[${m}]`, value: n[m], valueSpec: u.layout_symbol["text-anchor"] })), f = f.concat(no({ key: `${e}[${m + 1}]`, value: n[m + 1], valueSpec: { length: 2, value: "number" }, validateSpec: i.validateSpec, style: i.style, styleSpec: u }));
        return f;
      }, sprite: Tl };
      function uo(i) {
        const e = i.value, n = i.valueSpec, o = i.styleSpec;
        return i.validateSpec = uo, n.expression && sn(hr(e)) ? Ca(i) : n.expression && zn(Dn(e)) ? wr(i) : n.type && hl[n.type] ? hl[n.type](i) : wn(Ke({}, i, { valueSpec: n.type ? o[n.type] : n }));
      }
      function Kl(i) {
        const e = i.value, n = i.key, o = Ns(i);
        return o.length || (e.indexOf("{fontstack}") === -1 && o.push(new he(n, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && o.push(new he(n, e, '"glyphs" url must include a "{range}" token'))), o;
      }
      function Qn(i, e = K) {
        let n = [];
        return n = n.concat(uo({ key: "", value: i, valueSpec: e.$root, styleSpec: e, style: i, validateSpec: uo, objectElementValidators: { glyphs: Kl, "*": () => [] } })), i.constants && (n = n.concat($o({ key: "constants", value: i.constants, style: i, styleSpec: e, validateSpec: uo }))), Ll(n);
      }
      function ts(i) {
        return function(e) {
          return i({ ...e, validateSpec: uo });
        };
      }
      function Ll(i) {
        return [].concat(i).sort((e, n) => e.line - n.line);
      }
      function Sn(i) {
        return function(...e) {
          return Ll(i.apply(this, e));
        };
      }
      Qn.source = Sn(ts(Go)), Qn.sprite = Sn(ts(Tl)), Qn.glyphs = Sn(ts(Kl)), Qn.light = Sn(ts(Wo)), Qn.sky = Sn(ts(Ho)), Qn.terrain = Sn(ts(Jl)), Qn.layer = Sn(ts(Zo)), Qn.filter = Sn(ts(ao)), Qn.paintProperty = Sn(ts(lo)), Qn.layoutProperty = Sn(ts(co));
      const Fs = Qn, aa = Fs.light, Dc = Fs.sky, Cl = Fs.paintProperty, Ql = Fs.layoutProperty;
      function tc(i, e) {
        let n = !1;
        if (e && e.length) for (const o of e) i.fire(new Je(new Error(o.message))), n = !0;
        return n;
      }
      class po {
        constructor(e, n, o) {
          const u = this.cells = [];
          if (e instanceof ArrayBuffer) {
            this.arrayBuffer = e;
            const m = new Int32Array(this.arrayBuffer);
            e = m[0], this.d = (n = m[1]) + 2 * (o = m[2]);
            for (let I = 0; I < this.d * this.d; I++) {
              const E = m[3 + I], D = m[3 + I + 1];
              u.push(E === D ? null : m.subarray(E, D));
            }
            const S = m[3 + u.length + 1];
            this.keys = m.subarray(m[3 + u.length], S), this.bboxes = m.subarray(S), this.insert = this._insertReadonly;
          } else {
            this.d = n + 2 * o;
            for (let m = 0; m < this.d * this.d; m++) u.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = n, this.extent = e, this.padding = o, this.scale = n / e, this.uid = 0;
          const f = o / n * e;
          this.min = -f, this.max = e + f;
        }
        insert(e, n, o, u, f) {
          this._forEachCell(n, o, u, f, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(n), this.bboxes.push(o), this.bboxes.push(u), this.bboxes.push(f);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(e, n, o, u, f, m) {
          this.cells[f].push(m);
        }
        query(e, n, o, u, f) {
          const m = this.min, S = this.max;
          if (e <= m && n <= m && S <= o && S <= u && !f) return Array.prototype.slice.call(this.keys);
          {
            const I = [];
            return this._forEachCell(e, n, o, u, this._queryCell, I, {}, f), I;
          }
        }
        _queryCell(e, n, o, u, f, m, S, I) {
          const E = this.cells[f];
          if (E !== null) {
            const D = this.keys, N = this.bboxes;
            for (let j = 0; j < E.length; j++) {
              const H = E[j];
              if (S[H] === void 0) {
                const et = 4 * H;
                (I ? I(N[et + 0], N[et + 1], N[et + 2], N[et + 3]) : e <= N[et + 2] && n <= N[et + 3] && o >= N[et + 0] && u >= N[et + 1]) ? (S[H] = !0, m.push(D[H])) : S[H] = !1;
              }
            }
          }
        }
        _forEachCell(e, n, o, u, f, m, S, I) {
          const E = this._convertToCellCoord(e), D = this._convertToCellCoord(n), N = this._convertToCellCoord(o), j = this._convertToCellCoord(u);
          for (let H = E; H <= N; H++) for (let et = D; et <= j; et++) {
            const rt = this.d * et + H;
            if ((!I || I(this._convertFromCellCoord(H), this._convertFromCellCoord(et), this._convertFromCellCoord(H + 1), this._convertFromCellCoord(et + 1))) && f.call(this, e, n, o, u, rt, m, S, I)) return;
          }
        }
        _convertFromCellCoord(e) {
          return (e - this.padding) / this.scale;
        }
        _convertToCellCoord(e) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const e = this.cells, n = 3 + this.cells.length + 1 + 1;
          let o = 0;
          for (let m = 0; m < this.cells.length; m++) o += this.cells[m].length;
          const u = new Int32Array(n + o + this.keys.length + this.bboxes.length);
          u[0] = this.extent, u[1] = this.n, u[2] = this.padding;
          let f = n;
          for (let m = 0; m < e.length; m++) {
            const S = e[m];
            u[3 + m] = f, u.set(S, f), f += S.length;
          }
          return u[3 + e.length] = f, u.set(this.keys, f), f += this.keys.length, u[3 + e.length + 1] = f, u.set(this.bboxes, f), f += this.bboxes.length, u.buffer;
        }
        static serialize(e, n) {
          const o = e.toArrayBuffer();
          return n && n.push(o), { buffer: o };
        }
        static deserialize(e) {
          return new po(e.buffer);
        }
      }
      const vs = {};
      function Fe(i, e, n = {}) {
        if (vs[i]) throw new Error(`${i} is already registered.`);
        Object.defineProperty(e, "_classRegistryKey", { value: i, writeable: !1 }), vs[i] = { klass: e, omit: n.omit || [], shallow: n.shallow || [] };
      }
      Fe("Object", Object), Fe("TransferableGridIndex", po), Fe("Color", Ni), Fe("Error", Error), Fe("AJAXError", Ot), Fe("ResolvedImage", br), Fe("StylePropertyFunction", gs), Fe("StyleExpression", zs, { omit: ["_evaluator"] }), Fe("ZoomDependentExpression", Ds), Fe("ZoomConstantExpression", un), Fe("CompoundExpression", Er, { omit: ["_evaluate"] });
      for (const i in Yn) Yn[i]._classRegistryKey || Fe(`Expression_${i}`, Yn[i]);
      function Rs(i) {
        return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer");
      }
      function An(i) {
        return i.$name || i.constructor._classRegistryKey;
      }
      function xs(i) {
        return !function(e) {
          if (e === null || typeof e != "object") return !1;
          const n = An(e);
          return !(!n || n === "Object");
        }(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || Rs(i) || te(i) || ArrayBuffer.isView(i) || i instanceof ImageData);
      }
      function Xo(i, e) {
        if (xs(i)) return (Rs(i) || te(i)) && e && e.push(i), ArrayBuffer.isView(i) && e && e.push(i.buffer), i instanceof ImageData && e && e.push(i.data.buffer), i;
        if (Array.isArray(i)) {
          const f = [];
          for (const m of i) f.push(Xo(m, e));
          return f;
        }
        if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
        const n = An(i);
        if (!n) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
        if (!vs[n]) throw new Error(`${n} is not registered.`);
        const { klass: o } = vs[n], u = o.serialize ? o.serialize(i, e) : {};
        if (o.serialize) {
          if (e && u === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const f in i) {
            if (!i.hasOwnProperty(f) || vs[n].omit.indexOf(f) >= 0) continue;
            const m = i[f];
            u[f] = vs[n].shallow.indexOf(f) >= 0 ? m : Xo(m, e);
          }
          i instanceof Error && (u.message = i.message);
        }
        if (u.$name) throw new Error("$name property is reserved for worker serialization logic.");
        return n !== "Object" && (u.$name = n), u;
      }
      function fo(i) {
        if (xs(i)) return i;
        if (Array.isArray(i)) return i.map(fo);
        if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
        const e = An(i) || "Object";
        if (!vs[e]) throw new Error(`can't deserialize unregistered class ${e}`);
        const { klass: n } = vs[e];
        if (!n) throw new Error(`can't deserialize unregistered class ${e}`);
        if (n.deserialize) return n.deserialize(i);
        const o = Object.create(n.prototype);
        for (const u of Object.keys(i)) {
          if (u === "$name") continue;
          const f = i[u];
          o[u] = vs[e].shallow.indexOf(u) >= 0 ? f : fo(f);
        }
        return o;
      }
      class pn {
        constructor() {
          this.first = !0;
        }
        update(e, n) {
          const o = Math.floor(e);
          return this.first ? (this.first = !1, this.lastIntegerZoom = o, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = o, !0) : (this.lastFloorZoom > o ? (this.lastIntegerZoom = o + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < o && (this.lastIntegerZoom = o, this.lastIntegerZoomTime = n), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = o, !0));
        }
      }
      const ui = { "Latin-1 Supplement": (i) => i >= 128 && i <= 255, "Hangul Jamo": (i) => i >= 4352 && i <= 4607, Khmer: (i) => i >= 6016 && i <= 6143, "General Punctuation": (i) => i >= 8192 && i <= 8303, "Letterlike Symbols": (i) => i >= 8448 && i <= 8527, "Number Forms": (i) => i >= 8528 && i <= 8591, "Miscellaneous Technical": (i) => i >= 8960 && i <= 9215, "Control Pictures": (i) => i >= 9216 && i <= 9279, "Optical Character Recognition": (i) => i >= 9280 && i <= 9311, "Enclosed Alphanumerics": (i) => i >= 9312 && i <= 9471, "Geometric Shapes": (i) => i >= 9632 && i <= 9727, "Miscellaneous Symbols": (i) => i >= 9728 && i <= 9983, "Miscellaneous Symbols and Arrows": (i) => i >= 11008 && i <= 11263, "Ideographic Description Characters": (i) => i >= 12272 && i <= 12287, "CJK Symbols and Punctuation": (i) => i >= 12288 && i <= 12351, Katakana: (i) => i >= 12448 && i <= 12543, Kanbun: (i) => i >= 12688 && i <= 12703, "CJK Strokes": (i) => i >= 12736 && i <= 12783, "Enclosed CJK Letters and Months": (i) => i >= 12800 && i <= 13055, "CJK Compatibility": (i) => i >= 13056 && i <= 13311, "Yijing Hexagram Symbols": (i) => i >= 19904 && i <= 19967, "Private Use Area": (i) => i >= 57344 && i <= 63743, "Vertical Forms": (i) => i >= 65040 && i <= 65055, "CJK Compatibility Forms": (i) => i >= 65072 && i <= 65103, "Small Form Variants": (i) => i >= 65104 && i <= 65135, "Halfwidth and Fullwidth Forms": (i) => i >= 65280 && i <= 65519 };
      function El(i) {
        for (const e of i) if (Bs(e.charCodeAt(0))) return !0;
        return !1;
      }
      function Nc(i) {
        for (const e of i) if (!ec(e.charCodeAt(0))) return !1;
        return !0;
      }
      function ul(i) {
        const e = i.map((n) => {
          try {
            return new RegExp(`\\p{sc=${n}}`, "u").source;
          } catch {
            return null;
          }
        }).filter((n) => n);
        return new RegExp(e.join("|"), "u");
      }
      const Ml = ul(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function ec(i) {
        return !Ml.test(String.fromCodePoint(i));
      }
      const zl = ul(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
      function Bs(i) {
        return !(i !== 746 && i !== 747 && (i < 4352 || !(ui["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || ui["CJK Compatibility"](i) || ui["CJK Strokes"](i) || !(!ui["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || ui["Enclosed CJK Letters and Months"](i) || ui["Ideographic Description Characters"](i) || ui.Kanbun(i) || ui.Katakana(i) && i !== 12540 || !(!ui["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!ui["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || ui["Vertical Forms"](i) || ui["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || zl.test(String.fromCodePoint(i)))));
      }
      function mo(i) {
        return !(Bs(i) || function(e) {
          return !!(ui["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || ui["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || ui["Letterlike Symbols"](e) || ui["Number Forms"](e) || ui["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || ui["Control Pictures"](e) && e !== 9251 || ui["Optical Character Recognition"](e) || ui["Enclosed Alphanumerics"](e) || ui["Geometric Shapes"](e) || ui["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || ui["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || ui["CJK Symbols and Punctuation"](e) || ui.Katakana(e) || ui["Private Use Area"](e) || ui["CJK Compatibility Forms"](e) || ui["Small Form Variants"](e) || ui["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533);
        }(i));
      }
      const go = ul(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
      function Ma(i) {
        return go.test(String.fromCodePoint(i));
      }
      function Yo(i, e) {
        return !(!e && Ma(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || ui.Khmer(i));
      }
      function ic(i) {
        for (const e of i) if (Ma(e.charCodeAt(0))) return !0;
        return !1;
      }
      const bs = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(i) {
          this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(i) {
          this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      }();
      class Vi {
        constructor(e, n) {
          this.zoom = e, n ? (this.now = n.now, this.fadeDuration = n.fadeDuration, this.zoomHistory = n.zoomHistory, this.transition = n.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new pn(), this.transition = {});
        }
        isSupportedScript(e) {
          return function(n, o) {
            for (const u of n) if (!Yo(u.charCodeAt(0), o)) return !1;
            return !0;
          }(e, bs.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const e = this.zoom, n = e - Math.floor(e), o = this.crossFadingFactor();
          return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * o } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - o) * n };
        }
      }
      class dl {
        constructor(e, n) {
          this.property = e, this.value = n, this.expression = function(o, u) {
            if (sn(o)) return new gs(o, u);
            if (zn(o)) {
              const f = Ta(o, u);
              if (f.result === "error") throw new Error(f.value.map((m) => `${m.key}: ${m.message}`).join(", "));
              return f.value;
            }
            {
              let f = o;
              return u.type === "color" && typeof o == "string" ? f = Ni.parse(o) : u.type !== "padding" || typeof o != "number" && !Array.isArray(o) ? u.type === "variableAnchorOffsetCollection" && Array.isArray(o) && (f = en.parse(o)) : f = tn.parse(o), { kind: "constant", evaluate: () => f };
            }
          }(n === void 0 ? e.specification.default : n, e.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(e, n, o) {
          return this.property.possiblyEvaluate(this, e, n, o);
        }
      }
      class pl {
        constructor(e) {
          this.property = e, this.value = new dl(e, void 0);
        }
        transitioned(e, n) {
          return new rc(this.property, this.value, n, jt({}, e.transition, this.transition), e.now);
        }
        untransitioned() {
          return new rc(this.property, this.value, null, {}, 0);
        }
      }
      class yo {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues);
        }
        getValue(e) {
          return at(this._values[e].value.value);
        }
        setValue(e, n) {
          Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new pl(this._values[e].property)), this._values[e].value = new dl(this._values[e].property, n === null ? void 0 : at(n));
        }
        getTransition(e) {
          return at(this._values[e].transition);
        }
        setTransition(e, n) {
          Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new pl(this._values[e].property)), this._values[e].transition = at(n) || void 0;
        }
        serialize() {
          const e = {};
          for (const n of Object.keys(this._values)) {
            const o = this.getValue(n);
            o !== void 0 && (e[n] = o);
            const u = this.getTransition(n);
            u !== void 0 && (e[`${n}-transition`] = u);
          }
          return e;
        }
        transitioned(e, n) {
          const o = new nc(this._properties);
          for (const u of Object.keys(this._values)) o._values[u] = this._values[u].transitioned(e, n._values[u]);
          return o;
        }
        untransitioned() {
          const e = new nc(this._properties);
          for (const n of Object.keys(this._values)) e._values[n] = this._values[n].untransitioned();
          return e;
        }
      }
      class rc {
        constructor(e, n, o, u, f) {
          this.property = e, this.value = n, this.begin = f + u.delay || 0, this.end = this.begin + u.duration || 0, e.specification.transition && (u.delay || u.duration) && (this.prior = o);
        }
        possiblyEvaluate(e, n, o) {
          const u = e.now || 0, f = this.value.possiblyEvaluate(e, n, o), m = this.prior;
          if (m) {
            if (u > this.end) return this.prior = null, f;
            if (this.value.isDataDriven()) return this.prior = null, f;
            if (u < this.begin) return m.possiblyEvaluate(e, n, o);
            {
              const S = (u - this.begin) / (this.end - this.begin);
              return this.property.interpolate(m.possiblyEvaluate(e, n, o), f, function(I) {
                if (I <= 0) return 0;
                if (I >= 1) return 1;
                const E = I * I, D = E * I;
                return 4 * (I < 0.5 ? D : 3 * (I - E) + D - 0.75);
              }(S));
            }
          }
          return f;
        }
      }
      class nc {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(e, n, o) {
          const u = new p(this._properties);
          for (const f of Object.keys(this._values)) u._values[f] = this._values[f].possiblyEvaluate(e, n, o);
          return u;
        }
        hasTransition() {
          for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
          return !1;
        }
      }
      class sc {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultPropertyValues);
        }
        hasValue(e) {
          return this._values[e].value !== void 0;
        }
        getValue(e) {
          return at(this._values[e].value);
        }
        setValue(e, n) {
          this._values[e] = new dl(this._values[e].property, n === null ? void 0 : at(n));
        }
        serialize() {
          const e = {};
          for (const n of Object.keys(this._values)) {
            const o = this.getValue(n);
            o !== void 0 && (e[n] = o);
          }
          return e;
        }
        possiblyEvaluate(e, n, o) {
          const u = new p(this._properties);
          for (const f of Object.keys(this._values)) u._values[f] = this._values[f].possiblyEvaluate(e, n, o);
          return u;
        }
      }
      class es {
        constructor(e, n, o) {
          this.property = e, this.value = n, this.parameters = o;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(e) {
          return this.value.kind === "constant" ? this.value.value : e;
        }
        evaluate(e, n, o, u) {
          return this.property.evaluate(this.value, this.parameters, e, n, o, u);
        }
      }
      class p {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
        }
        get(e) {
          return this._values[e];
        }
      }
      class t {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, n) {
          if (e.isDataDriven()) throw new Error("Value should not be data driven");
          return e.expression.evaluate(n);
        }
        interpolate(e, n, o) {
          const u = Zr[this.specification.type];
          return u ? u(e, n, o) : e;
        }
      }
      class s {
        constructor(e, n) {
          this.specification = e, this.overrides = n;
        }
        possiblyEvaluate(e, n, o, u) {
          return new es(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(n, null, {}, o, u) } : e.expression, n);
        }
        interpolate(e, n, o) {
          if (e.value.kind !== "constant" || n.value.kind !== "constant") return e;
          if (e.value.value === void 0 || n.value.value === void 0) return new es(this, { kind: "constant", value: void 0 }, e.parameters);
          const u = Zr[this.specification.type];
          if (u) {
            const f = u(e.value.value, n.value.value, o);
            return new es(this, { kind: "constant", value: f }, e.parameters);
          }
          return e;
        }
        evaluate(e, n, o, u, f, m) {
          return e.kind === "constant" ? e.value : e.evaluate(n, o, u, f, m);
        }
      }
      class c extends s {
        possiblyEvaluate(e, n, o, u) {
          if (e.value === void 0) return new es(this, { kind: "constant", value: void 0 }, n);
          if (e.expression.kind === "constant") {
            const f = e.expression.evaluate(n, null, {}, o, u), m = e.property.specification.type === "resolvedImage" && typeof f != "string" ? f.name : f, S = this._calculate(m, m, m, n);
            return new es(this, { kind: "constant", value: S }, n);
          }
          if (e.expression.kind === "camera") {
            const f = this._calculate(e.expression.evaluate({ zoom: n.zoom - 1 }), e.expression.evaluate({ zoom: n.zoom }), e.expression.evaluate({ zoom: n.zoom + 1 }), n);
            return new es(this, { kind: "constant", value: f }, n);
          }
          return new es(this, e.expression, n);
        }
        evaluate(e, n, o, u, f, m) {
          if (e.kind === "source") {
            const S = e.evaluate(n, o, u, f, m);
            return this._calculate(S, S, S, n);
          }
          return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(n.zoom) - 1 }, o, u), e.evaluate({ zoom: Math.floor(n.zoom) }, o, u), e.evaluate({ zoom: Math.floor(n.zoom) + 1 }, o, u), n) : e.value;
        }
        _calculate(e, n, o, u) {
          return u.zoom > u.zoomHistory.lastIntegerZoom ? { from: e, to: n } : { from: o, to: n };
        }
        interpolate(e) {
          return e;
        }
      }
      class r {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, n, o, u) {
          if (e.value !== void 0) {
            if (e.expression.kind === "constant") {
              const f = e.expression.evaluate(n, null, {}, o, u);
              return this._calculate(f, f, f, n);
            }
            return this._calculate(e.expression.evaluate(new Vi(Math.floor(n.zoom - 1), n)), e.expression.evaluate(new Vi(Math.floor(n.zoom), n)), e.expression.evaluate(new Vi(Math.floor(n.zoom + 1), n)), n);
          }
        }
        _calculate(e, n, o, u) {
          return u.zoom > u.zoomHistory.lastIntegerZoom ? { from: e, to: n } : { from: o, to: n };
        }
        interpolate(e) {
          return e;
        }
      }
      class a {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, n, o, u) {
          return !!e.expression.evaluate(n, null, {}, o, u);
        }
        interpolate() {
          return !1;
        }
      }
      class h {
        constructor(e) {
          this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const n in e) {
            const o = e[n];
            o.specification.overridable && this.overridableProperties.push(n);
            const u = this.defaultPropertyValues[n] = new dl(o, void 0), f = this.defaultTransitionablePropertyValues[n] = new pl(o);
            this.defaultTransitioningPropertyValues[n] = f.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = u.possiblyEvaluate({});
          }
        }
      }
      Fe("DataDrivenProperty", s), Fe("DataConstantProperty", t), Fe("CrossFadedDataDrivenProperty", c), Fe("CrossFadedProperty", r), Fe("ColorRampProperty", a);
      const d = "-transition";
      class _ extends ie {
        constructor(e, n) {
          if (super(), this.id = e.id, this.type = e.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, e.type !== "custom" && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), n.layout && (this._unevaluatedLayout = new sc(n.layout)), n.paint)) {
            this._transitionablePaint = new yo(n.paint);
            for (const o in e.paint) this.setPaintProperty(o, e.paint[o], { validate: !1 });
            for (const o in e.layout) this.setLayoutProperty(o, e.layout[o], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new p(n.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(e) {
          return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
        }
        setLayoutProperty(e, n, o = {}) {
          n != null && this._validate(Ql, `layers.${this.id}.layout.${e}`, e, n, o) || (e !== "visibility" ? this._unevaluatedLayout.setValue(e, n) : this.visibility = n);
        }
        getPaintProperty(e) {
          return e.endsWith(d) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
        }
        setPaintProperty(e, n, o = {}) {
          if (n != null && this._validate(Cl, `layers.${this.id}.paint.${e}`, e, n, o)) return !1;
          if (e.endsWith(d)) return this._transitionablePaint.setTransition(e.slice(0, -11), n || void 0), !1;
          {
            const u = this._transitionablePaint._values[e], f = u.property.specification["property-type"] === "cross-faded-data-driven", m = u.value.isDataDriven(), S = u.value;
            this._transitionablePaint.setValue(e, n), this._handleSpecialPaintPropertyUpdate(e);
            const I = this._transitionablePaint._values[e].value;
            return I.isDataDriven() || m || f || this._handleOverridablePaintPropertyUpdate(e, S, I);
          }
        }
        _handleSpecialPaintPropertyUpdate(e) {
        }
        _handleOverridablePaintPropertyUpdate(e, n, o) {
          return !1;
        }
        isHidden(e) {
          return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(e) {
          this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(e, n) {
          e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, n);
        }
        serialize() {
          const e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), ne(e, (n, o) => !(n === void 0 || o === "layout" && !Object.keys(n).length || o === "paint" && !Object.keys(n).length));
        }
        _validate(e, n, o, u, f = {}) {
          return (!f || f.validate !== !1) && tc(this, e.call(Fs, { key: n, layerType: this.type, objectKey: o, value: u, styleSpec: K, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const e in this.paint._values) {
            const n = this.paint.get(e);
            if (n instanceof es && fs(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0;
          }
          return !1;
        }
      }
      const w = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class k {
        constructor(e, n) {
          this._structArray = e, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class T {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(e, n) {
          return e._trim(), n && (e.isTransferred = !0, n.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
        }
        static deserialize(e) {
          const n = Object.create(this.prototype);
          return n.arrayBuffer = e.arrayBuffer, n.length = e.length, n.capacity = e.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(e) {
          this.reserve(e), this.length = e;
        }
        reserve(e) {
          if (e > this.capacity) {
            this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const n = this.uint8;
            this._refreshViews(), n && this.uint8.set(n);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function C(i, e = 1) {
        let n = 0, o = 0;
        return { members: i.map((u) => {
          const f = w[u.type].BYTES_PER_ELEMENT, m = n = z(n, Math.max(e, f)), S = u.components || 1;
          return o = Math.max(o, f), n += f * S, { name: u.name, type: u.type, components: S, offset: m };
        }), size: z(n, Math.max(o, e)), alignment: e };
      }
      function z(i, e) {
        return Math.ceil(i / e) * e;
      }
      class R extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, e, n);
        }
        emplace(e, n, o) {
          const u = 2 * e;
          return this.int16[u + 0] = n, this.int16[u + 1] = o, e;
        }
      }
      R.prototype.bytesPerElement = 4, Fe("StructArrayLayout2i4", R);
      class W extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const f = 3 * e;
          return this.int16[f + 0] = n, this.int16[f + 1] = o, this.int16[f + 2] = u, e;
        }
      }
      W.prototype.bytesPerElement = 6, Fe("StructArrayLayout3i6", W);
      class Z extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, e, n, o, u);
        }
        emplace(e, n, o, u, f) {
          const m = 4 * e;
          return this.int16[m + 0] = n, this.int16[m + 1] = o, this.int16[m + 2] = u, this.int16[m + 3] = f, e;
        }
      }
      Z.prototype.bytesPerElement = 8, Fe("StructArrayLayout4i8", Z);
      class G extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, f, m) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, o, u, f, m);
        }
        emplace(e, n, o, u, f, m, S) {
          const I = 6 * e;
          return this.int16[I + 0] = n, this.int16[I + 1] = o, this.int16[I + 2] = u, this.int16[I + 3] = f, this.int16[I + 4] = m, this.int16[I + 5] = S, e;
        }
      }
      G.prototype.bytesPerElement = 12, Fe("StructArrayLayout2i4i12", G);
      class nt extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, f, m) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, o, u, f, m);
        }
        emplace(e, n, o, u, f, m, S) {
          const I = 4 * e, E = 8 * e;
          return this.int16[I + 0] = n, this.int16[I + 1] = o, this.uint8[E + 4] = u, this.uint8[E + 5] = f, this.uint8[E + 6] = m, this.uint8[E + 7] = S, e;
        }
      }
      nt.prototype.bytesPerElement = 8, Fe("StructArrayLayout2i4ub8", nt);
      class Y extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, e, n);
        }
        emplace(e, n, o) {
          const u = 2 * e;
          return this.float32[u + 0] = n, this.float32[u + 1] = o, e;
        }
      }
      Y.prototype.bytesPerElement = 8, Fe("StructArrayLayout2f8", Y);
      class J extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, f, m, S, I, E, D) {
          const N = this.length;
          return this.resize(N + 1), this.emplace(N, e, n, o, u, f, m, S, I, E, D);
        }
        emplace(e, n, o, u, f, m, S, I, E, D, N) {
          const j = 10 * e;
          return this.uint16[j + 0] = n, this.uint16[j + 1] = o, this.uint16[j + 2] = u, this.uint16[j + 3] = f, this.uint16[j + 4] = m, this.uint16[j + 5] = S, this.uint16[j + 6] = I, this.uint16[j + 7] = E, this.uint16[j + 8] = D, this.uint16[j + 9] = N, e;
        }
      }
      J.prototype.bytesPerElement = 20, Fe("StructArrayLayout10ui20", J);
      class tt extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, f, m, S, I, E, D, N, j) {
          const H = this.length;
          return this.resize(H + 1), this.emplace(H, e, n, o, u, f, m, S, I, E, D, N, j);
        }
        emplace(e, n, o, u, f, m, S, I, E, D, N, j, H) {
          const et = 12 * e;
          return this.int16[et + 0] = n, this.int16[et + 1] = o, this.int16[et + 2] = u, this.int16[et + 3] = f, this.uint16[et + 4] = m, this.uint16[et + 5] = S, this.uint16[et + 6] = I, this.uint16[et + 7] = E, this.int16[et + 8] = D, this.int16[et + 9] = N, this.int16[et + 10] = j, this.int16[et + 11] = H, e;
        }
      }
      tt.prototype.bytesPerElement = 24, Fe("StructArrayLayout4i4ui4i24", tt);
      class ut extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const f = 3 * e;
          return this.float32[f + 0] = n, this.float32[f + 1] = o, this.float32[f + 2] = u, e;
        }
      }
      ut.prototype.bytesPerElement = 12, Fe("StructArrayLayout3f12", ut);
      class St extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.uint32[1 * e + 0] = n, e;
        }
      }
      St.prototype.bytesPerElement = 4, Fe("StructArrayLayout1ul4", St);
      class It extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, f, m, S, I, E) {
          const D = this.length;
          return this.resize(D + 1), this.emplace(D, e, n, o, u, f, m, S, I, E);
        }
        emplace(e, n, o, u, f, m, S, I, E, D) {
          const N = 10 * e, j = 5 * e;
          return this.int16[N + 0] = n, this.int16[N + 1] = o, this.int16[N + 2] = u, this.int16[N + 3] = f, this.int16[N + 4] = m, this.int16[N + 5] = S, this.uint32[j + 3] = I, this.uint16[N + 8] = E, this.uint16[N + 9] = D, e;
        }
      }
      It.prototype.bytesPerElement = 20, Fe("StructArrayLayout6i1ul2ui20", It);
      class Gt extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, f, m) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, o, u, f, m);
        }
        emplace(e, n, o, u, f, m, S) {
          const I = 6 * e;
          return this.int16[I + 0] = n, this.int16[I + 1] = o, this.int16[I + 2] = u, this.int16[I + 3] = f, this.int16[I + 4] = m, this.int16[I + 5] = S, e;
        }
      }
      Gt.prototype.bytesPerElement = 12, Fe("StructArrayLayout2i2i2i12", Gt);
      class qt extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, f) {
          const m = this.length;
          return this.resize(m + 1), this.emplace(m, e, n, o, u, f);
        }
        emplace(e, n, o, u, f, m) {
          const S = 4 * e, I = 8 * e;
          return this.float32[S + 0] = n, this.float32[S + 1] = o, this.float32[S + 2] = u, this.int16[I + 6] = f, this.int16[I + 7] = m, e;
        }
      }
      qt.prototype.bytesPerElement = 16, Fe("StructArrayLayout2f1f2i16", qt);
      class Zt extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, f, m) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, o, u, f, m);
        }
        emplace(e, n, o, u, f, m, S) {
          const I = 16 * e, E = 4 * e, D = 8 * e;
          return this.uint8[I + 0] = n, this.uint8[I + 1] = o, this.float32[E + 1] = u, this.float32[E + 2] = f, this.int16[D + 6] = m, this.int16[D + 7] = S, e;
        }
      }
      Zt.prototype.bytesPerElement = 16, Fe("StructArrayLayout2ub2f2i16", Zt);
      class Bt extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const f = 3 * e;
          return this.uint16[f + 0] = n, this.uint16[f + 1] = o, this.uint16[f + 2] = u, e;
        }
      }
      Bt.prototype.bytesPerElement = 6, Fe("StructArrayLayout3ui6", Bt);
      class ge extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, f, m, S, I, E, D, N, j, H, et, rt, dt, vt) {
          const Nt = this.length;
          return this.resize(Nt + 1), this.emplace(Nt, e, n, o, u, f, m, S, I, E, D, N, j, H, et, rt, dt, vt);
        }
        emplace(e, n, o, u, f, m, S, I, E, D, N, j, H, et, rt, dt, vt, Nt) {
          const kt = 24 * e, zt = 12 * e, Xt = 48 * e;
          return this.int16[kt + 0] = n, this.int16[kt + 1] = o, this.uint16[kt + 2] = u, this.uint16[kt + 3] = f, this.uint32[zt + 2] = m, this.uint32[zt + 3] = S, this.uint32[zt + 4] = I, this.uint16[kt + 10] = E, this.uint16[kt + 11] = D, this.uint16[kt + 12] = N, this.float32[zt + 7] = j, this.float32[zt + 8] = H, this.uint8[Xt + 36] = et, this.uint8[Xt + 37] = rt, this.uint8[Xt + 38] = dt, this.uint32[zt + 10] = vt, this.int16[kt + 22] = Nt, e;
        }
      }
      ge.prototype.bytesPerElement = 48, Fe("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", ge);
      class Le extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, f, m, S, I, E, D, N, j, H, et, rt, dt, vt, Nt, kt, zt, Xt, me, Ee, ti, Ie, Se, qe, Oe) {
          const Be = this.length;
          return this.resize(Be + 1), this.emplace(Be, e, n, o, u, f, m, S, I, E, D, N, j, H, et, rt, dt, vt, Nt, kt, zt, Xt, me, Ee, ti, Ie, Se, qe, Oe);
        }
        emplace(e, n, o, u, f, m, S, I, E, D, N, j, H, et, rt, dt, vt, Nt, kt, zt, Xt, me, Ee, ti, Ie, Se, qe, Oe, Be) {
          const ae = 32 * e, Ze = 16 * e;
          return this.int16[ae + 0] = n, this.int16[ae + 1] = o, this.int16[ae + 2] = u, this.int16[ae + 3] = f, this.int16[ae + 4] = m, this.int16[ae + 5] = S, this.int16[ae + 6] = I, this.int16[ae + 7] = E, this.uint16[ae + 8] = D, this.uint16[ae + 9] = N, this.uint16[ae + 10] = j, this.uint16[ae + 11] = H, this.uint16[ae + 12] = et, this.uint16[ae + 13] = rt, this.uint16[ae + 14] = dt, this.uint16[ae + 15] = vt, this.uint16[ae + 16] = Nt, this.uint16[ae + 17] = kt, this.uint16[ae + 18] = zt, this.uint16[ae + 19] = Xt, this.uint16[ae + 20] = me, this.uint16[ae + 21] = Ee, this.uint16[ae + 22] = ti, this.uint32[Ze + 12] = Ie, this.float32[Ze + 13] = Se, this.float32[Ze + 14] = qe, this.uint16[ae + 30] = Oe, this.uint16[ae + 31] = Be, e;
        }
      }
      Le.prototype.bytesPerElement = 64, Fe("StructArrayLayout8i15ui1ul2f2ui64", Le);
      class ce extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.float32[1 * e + 0] = n, e;
        }
      }
      ce.prototype.bytesPerElement = 4, Fe("StructArrayLayout1f4", ce);
      class de extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const f = 3 * e;
          return this.uint16[6 * e + 0] = n, this.float32[f + 1] = o, this.float32[f + 2] = u, e;
        }
      }
      de.prototype.bytesPerElement = 12, Fe("StructArrayLayout1ui2f12", de);
      class Ce extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const f = 4 * e;
          return this.uint32[2 * e + 0] = n, this.uint16[f + 2] = o, this.uint16[f + 3] = u, e;
        }
      }
      Ce.prototype.bytesPerElement = 8, Fe("StructArrayLayout1ul2ui8", Ce);
      class ii extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, e, n);
        }
        emplace(e, n, o) {
          const u = 2 * e;
          return this.uint16[u + 0] = n, this.uint16[u + 1] = o, e;
        }
      }
      ii.prototype.bytesPerElement = 4, Fe("StructArrayLayout2ui4", ii);
      class we extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.uint16[1 * e + 0] = n, e;
        }
      }
      we.prototype.bytesPerElement = 2, Fe("StructArrayLayout1ui2", we);
      class We extends T {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, e, n, o, u);
        }
        emplace(e, n, o, u, f) {
          const m = 4 * e;
          return this.float32[m + 0] = n, this.float32[m + 1] = o, this.float32[m + 2] = u, this.float32[m + 3] = f, e;
        }
      }
      We.prototype.bytesPerElement = 16, Fe("StructArrayLayout4f16", We);
      class Ai extends k {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new q(this.anchorPointX, this.anchorPointY);
        }
      }
      Ai.prototype.size = 20;
      class Mi extends It {
        get(e) {
          return new Ai(this, e);
        }
      }
      Fe("CollisionBoxArray", Mi);
      class sr extends k {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(e) {
          this._structArray.uint8[this._pos1 + 37] = e;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(e) {
          this._structArray.uint8[this._pos1 + 38] = e;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 10] = e;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      sr.prototype.size = 48;
      class ri extends ge {
        get(e) {
          return new sr(this, e);
        }
      }
      Fe("PlacedSymbolArray", ri);
      class Xi extends k {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 12] = e;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      Xi.prototype.size = 64;
      class Gi extends Le {
        get(e) {
          return new Xi(this, e);
        }
      }
      Fe("SymbolInstanceArray", Gi);
      class zi extends ce {
        getoffsetX(e) {
          return this.float32[1 * e + 0];
        }
      }
      Fe("GlyphOffsetArray", zi);
      class Fi extends W {
        getx(e) {
          return this.int16[3 * e + 0];
        }
        gety(e) {
          return this.int16[3 * e + 1];
        }
        gettileUnitDistanceFromAnchor(e) {
          return this.int16[3 * e + 2];
        }
      }
      Fe("SymbolLineVertexArray", Fi);
      class Qi extends k {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      Qi.prototype.size = 12;
      class Mr extends de {
        get(e) {
          return new Qi(this, e);
        }
      }
      Fe("TextAnchorOffsetArray", Mr);
      class fn extends k {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      fn.prototype.size = 8;
      class ar extends Ce {
        get(e) {
          return new fn(this, e);
        }
      }
      Fe("FeatureIndexArray", ar);
      class Hr extends R {
      }
      class ws extends R {
      }
      class oa extends R {
      }
      class Sr extends G {
      }
      class Ri extends nt {
      }
      class Ss extends Y {
      }
      class Nn extends J {
      }
      class Xr extends tt {
      }
      class Ar extends ut {
      }
      class Rr extends St {
      }
      class Yi extends Gt {
      }
      class Yr extends Zt {
      }
      class Pn extends Bt {
      }
      class As extends ii {
      }
      const ac = C([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: fl } = ac;
      class zr {
        constructor(e = []) {
          this.segments = e;
        }
        prepareSegment(e, n, o, u) {
          let f = this.segments[this.segments.length - 1];
          return e > zr.MAX_VERTEX_ARRAY_LENGTH && Pt(`Max vertices per segment is ${zr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!f || f.vertexLength + e > zr.MAX_VERTEX_ARRAY_LENGTH || f.sortKey !== u) && (f = { vertexOffset: n.length, primitiveOffset: o.length, vertexLength: 0, primitiveLength: 0 }, u !== void 0 && (f.sortKey = u), this.segments.push(f)), f;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const e of this.segments) for (const n in e.vaos) e.vaos[n].destroy();
        }
        static simpleSegment(e, n, o, u) {
          return new zr([{ vertexOffset: e, primitiveOffset: n, vertexLength: o, primitiveLength: u, vaos: {}, sortKey: 0 }]);
        }
      }
      function is(i, e) {
        return 256 * (i = Ht(Math.floor(i), 0, 255)) + Ht(Math.floor(e), 0, 255);
      }
      zr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Fe("SegmentVector", zr);
      const za = C([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var la = { exports: {} }, Da = { exports: {} };
      Da.exports = function(i, e) {
        var n, o, u, f, m, S, I, E;
        for (o = i.length - (n = 3 & i.length), u = e, m = 3432918353, S = 461845907, E = 0; E < o; ) I = 255 & i.charCodeAt(E) | (255 & i.charCodeAt(++E)) << 8 | (255 & i.charCodeAt(++E)) << 16 | (255 & i.charCodeAt(++E)) << 24, ++E, u = 27492 + (65535 & (f = 5 * (65535 & (u = (u ^= I = (65535 & (I = (I = (65535 & I) * m + (((I >>> 16) * m & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295) << 13 | u >>> 19)) + ((5 * (u >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (f >>> 16) & 65535) << 16);
        switch (I = 0, n) {
          case 3:
            I ^= (255 & i.charCodeAt(E + 2)) << 16;
          case 2:
            I ^= (255 & i.charCodeAt(E + 1)) << 8;
          case 1:
            u ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & i.charCodeAt(E))) * m + (((I >>> 16) * m & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295;
        }
        return u ^= i.length, u = 2246822507 * (65535 & (u ^= u >>> 16)) + ((2246822507 * (u >>> 16) & 65535) << 16) & 4294967295, u = 3266489909 * (65535 & (u ^= u >>> 13)) + ((3266489909 * (u >>> 16) & 65535) << 16) & 4294967295, (u ^= u >>> 16) >>> 0;
      };
      var Dl = Da.exports, Nl = { exports: {} };
      Nl.exports = function(i, e) {
        for (var n, o = i.length, u = e ^ o, f = 0; o >= 4; ) n = 1540483477 * (65535 & (n = 255 & i.charCodeAt(f) | (255 & i.charCodeAt(++f)) << 8 | (255 & i.charCodeAt(++f)) << 16 | (255 & i.charCodeAt(++f)) << 24)) + ((1540483477 * (n >>> 16) & 65535) << 16), u = 1540483477 * (65535 & u) + ((1540483477 * (u >>> 16) & 65535) << 16) ^ (n = 1540483477 * (65535 & (n ^= n >>> 24)) + ((1540483477 * (n >>> 16) & 65535) << 16)), o -= 4, ++f;
        switch (o) {
          case 3:
            u ^= (255 & i.charCodeAt(f + 2)) << 16;
          case 2:
            u ^= (255 & i.charCodeAt(f + 1)) << 8;
          case 1:
            u = 1540483477 * (65535 & (u ^= 255 & i.charCodeAt(f))) + ((1540483477 * (u >>> 16) & 65535) << 16);
        }
        return u = 1540483477 * (65535 & (u ^= u >>> 13)) + ((1540483477 * (u >>> 16) & 65535) << 16), (u ^= u >>> 15) >>> 0;
      };
      var _o = Dl, vo = Nl.exports;
      la.exports = _o, la.exports.murmur3 = _o, la.exports.murmur2 = vo;
      var Fc = M(la.exports);
      class oc {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(e, n, o, u) {
          this.ids.push(ph(e)), this.positions.push(n, o, u);
        }
        getPositions(e) {
          if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
          const n = ph(e);
          let o = 0, u = this.ids.length - 1;
          for (; o < u; ) {
            const m = o + u >> 1;
            this.ids[m] >= n ? u = m : o = m + 1;
          }
          const f = [];
          for (; this.ids[o] === n; ) f.push({ index: this.positions[3 * o], start: this.positions[3 * o + 1], end: this.positions[3 * o + 2] }), o++;
          return f;
        }
        static serialize(e, n) {
          const o = new Float64Array(e.ids), u = new Uint32Array(e.positions);
          return lc(o, u, 0, o.length - 1), n && n.push(o.buffer, u.buffer), { ids: o, positions: u };
        }
        static deserialize(e) {
          const n = new oc();
          return n.ids = e.ids, n.positions = e.positions, n.indexed = !0, n;
        }
      }
      function ph(i) {
        const e = +i;
        return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : Fc(String(i));
      }
      function lc(i, e, n, o) {
        for (; n < o; ) {
          const u = i[n + o >> 1];
          let f = n - 1, m = o + 1;
          for (; ; ) {
            do
              f++;
            while (i[f] < u);
            do
              m--;
            while (i[m] > u);
            if (f >= m) break;
            Jo(i, f, m), Jo(e, 3 * f, 3 * m), Jo(e, 3 * f + 1, 3 * m + 1), Jo(e, 3 * f + 2, 3 * m + 2);
          }
          m - n < o - m ? (lc(i, e, n, m), n = m + 1) : (lc(i, e, m + 1, o), o = m);
        }
      }
      function Jo(i, e, n) {
        const o = i[e];
        i[e] = i[n], i[n] = o;
      }
      Fe("FeaturePositionMap", oc);
      class xo {
        constructor(e, n) {
          this.gl = e.gl, this.location = n;
        }
      }
      class Fl extends xo {
        constructor(e, n) {
          super(e, n), this.current = 0;
        }
        set(e) {
          this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
        }
      }
      class Rl extends xo {
        constructor(e, n) {
          super(e, n), this.current = [0, 0, 0, 0];
        }
        set(e) {
          e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] && e[3] === this.current[3] || (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
        }
      }
      class cc extends xo {
        constructor(e, n) {
          super(e, n), this.current = Ni.transparent;
        }
        set(e) {
          e.r === this.current.r && e.g === this.current.g && e.b === this.current.b && e.a === this.current.a || (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
        }
      }
      const Bl = new Float32Array(16);
      function hc(i) {
        return [is(255 * i.r, 255 * i.g), is(255 * i.b, 255 * i.a)];
      }
      class Ol {
        constructor(e, n, o) {
          this.value = e, this.uniformNames = n.map((u) => `u_${u}`), this.type = o;
        }
        setUniform(e, n, o) {
          e.set(o.constantOr(this.value));
        }
        getBinding(e, n, o) {
          return this.type === "color" ? new cc(e, n) : new Fl(e, n);
        }
      }
      class Na {
        constructor(e, n) {
          this.uniformNames = n.map((o) => `u_${o}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(e, n) {
          this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = e.tlbr;
        }
        setUniform(e, n, o, u) {
          const f = u === "u_pattern_to" ? this.patternTo : u === "u_pattern_from" ? this.patternFrom : u === "u_pixel_ratio_to" ? this.pixelRatioTo : u === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          f && e.set(f);
        }
        getBinding(e, n, o) {
          return o.substr(0, 9) === "u_pattern" ? new Rl(e, n) : new Fl(e, n);
        }
      }
      class ca {
        constructor(e, n, o, u) {
          this.expression = e, this.type = o, this.maxValue = 0, this.paintVertexAttributes = n.map((f) => ({ name: `a_${f}`, type: "Float32", components: o === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new u();
        }
        populatePaintArray(e, n, o, u, f) {
          const m = this.paintVertexArray.length, S = this.expression.evaluate(new Vi(0), n, {}, u, [], f);
          this.paintVertexArray.resize(e), this._setPaintValue(m, e, S);
        }
        updatePaintArray(e, n, o, u) {
          const f = this.expression.evaluate({ zoom: 0 }, o, u);
          this._setPaintValue(e, n, f);
        }
        _setPaintValue(e, n, o) {
          if (this.type === "color") {
            const u = hc(o);
            for (let f = e; f < n; f++) this.paintVertexArray.emplace(f, u[0], u[1]);
          } else {
            for (let u = e; u < n; u++) this.paintVertexArray.emplace(u, o);
            this.maxValue = Math.max(this.maxValue, Math.abs(o));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class rs {
        constructor(e, n, o, u, f, m) {
          this.expression = e, this.uniformNames = n.map((S) => `u_${S}_t`), this.type = o, this.useIntegerZoom = u, this.zoom = f, this.maxValue = 0, this.paintVertexAttributes = n.map((S) => ({ name: `a_${S}`, type: "Float32", components: o === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new m();
        }
        populatePaintArray(e, n, o, u, f) {
          const m = this.expression.evaluate(new Vi(this.zoom), n, {}, u, [], f), S = this.expression.evaluate(new Vi(this.zoom + 1), n, {}, u, [], f), I = this.paintVertexArray.length;
          this.paintVertexArray.resize(e), this._setPaintValue(I, e, m, S);
        }
        updatePaintArray(e, n, o, u) {
          const f = this.expression.evaluate({ zoom: this.zoom }, o, u), m = this.expression.evaluate({ zoom: this.zoom + 1 }, o, u);
          this._setPaintValue(e, n, f, m);
        }
        _setPaintValue(e, n, o, u) {
          if (this.type === "color") {
            const f = hc(o), m = hc(u);
            for (let S = e; S < n; S++) this.paintVertexArray.emplace(S, f[0], f[1], m[0], m[1]);
          } else {
            for (let f = e; f < n; f++) this.paintVertexArray.emplace(f, o, u);
            this.maxValue = Math.max(this.maxValue, Math.abs(o), Math.abs(u));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(e, n) {
          const o = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, u = Ht(this.expression.interpolationFactor(o, this.zoom, this.zoom + 1), 0, 1);
          e.set(u);
        }
        getBinding(e, n, o) {
          return new Fl(e, n);
        }
      }
      class In {
        constructor(e, n, o, u, f, m) {
          this.expression = e, this.type = n, this.useIntegerZoom = o, this.zoom = u, this.layerId = m, this.zoomInPaintVertexArray = new f(), this.zoomOutPaintVertexArray = new f();
        }
        populatePaintArray(e, n, o) {
          const u = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(u, e, n.patterns && n.patterns[this.layerId], o);
        }
        updatePaintArray(e, n, o, u, f) {
          this._setPaintValues(e, n, o.patterns && o.patterns[this.layerId], f);
        }
        _setPaintValues(e, n, o, u) {
          if (!u || !o) return;
          const { min: f, mid: m, max: S } = o, I = u[f], E = u[m], D = u[S];
          if (I && E && D) for (let N = e; N < n; N++) this.zoomInPaintVertexArray.emplace(N, E.tl[0], E.tl[1], E.br[0], E.br[1], I.tl[0], I.tl[1], I.br[0], I.br[1], E.pixelRatio, I.pixelRatio), this.zoomOutPaintVertexArray.emplace(N, E.tl[0], E.tl[1], E.br[0], E.br[1], D.tl[0], D.tl[1], D.br[0], D.br[1], E.pixelRatio, D.pixelRatio);
        }
        upload(e) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, za.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, za.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class Rc {
        constructor(e, n, o) {
          this.binders = {}, this._buffers = [];
          const u = [];
          for (const f in e.paint._values) {
            if (!o(f)) continue;
            const m = e.paint.get(f);
            if (!(m instanceof es && fs(m.property.specification))) continue;
            const S = Hh(f, e.type), I = m.value, E = m.property.specification.type, D = m.property.useIntegerZoom, N = m.property.specification["property-type"], j = N === "cross-faded" || N === "cross-faded-data-driven";
            if (I.kind === "constant") this.binders[f] = j ? new Na(I.value, S) : new Ol(I.value, S, E), u.push(`/u_${f}`);
            else if (I.kind === "source" || j) {
              const H = Bc(f, E, "source");
              this.binders[f] = j ? new In(I, E, D, n, H, e.id) : new ca(I, S, E, H), u.push(`/a_${f}`);
            } else {
              const H = Bc(f, E, "composite");
              this.binders[f] = new rs(I, S, E, D, n, H), u.push(`/z_${f}`);
            }
          }
          this.cacheKey = u.sort().join("");
        }
        getMaxValue(e) {
          const n = this.binders[e];
          return n instanceof ca || n instanceof rs ? n.maxValue : 0;
        }
        populatePaintArrays(e, n, o, u, f) {
          for (const m in this.binders) {
            const S = this.binders[m];
            (S instanceof ca || S instanceof rs || S instanceof In) && S.populatePaintArray(e, n, o, u, f);
          }
        }
        setConstantPatternPositions(e, n) {
          for (const o in this.binders) {
            const u = this.binders[o];
            u instanceof Na && u.setConstantPatternPositions(e, n);
          }
        }
        updatePaintArrays(e, n, o, u, f) {
          let m = !1;
          for (const S in e) {
            const I = n.getPositions(S);
            for (const E of I) {
              const D = o.feature(E.index);
              for (const N in this.binders) {
                const j = this.binders[N];
                if ((j instanceof ca || j instanceof rs || j instanceof In) && j.expression.isStateDependent === !0) {
                  const H = u.paint.get(N);
                  j.expression = H.value, j.updatePaintArray(E.start, E.end, D, e[S], f), m = !0;
                }
              }
            }
          }
          return m;
        }
        defines() {
          const e = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            (o instanceof Ol || o instanceof Na) && e.push(...o.uniformNames.map((u) => `#define HAS_UNIFORM_${u}`));
          }
          return e;
        }
        getBinderAttributes() {
          const e = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            if (o instanceof ca || o instanceof rs) for (let u = 0; u < o.paintVertexAttributes.length; u++) e.push(o.paintVertexAttributes[u].name);
            else if (o instanceof In) for (let u = 0; u < za.members.length; u++) e.push(za.members[u].name);
          }
          return e;
        }
        getBinderUniforms() {
          const e = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            if (o instanceof Ol || o instanceof Na || o instanceof rs) for (const u of o.uniformNames) e.push(u);
          }
          return e;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(e, n) {
          const o = [];
          for (const u in this.binders) {
            const f = this.binders[u];
            if (f instanceof Ol || f instanceof Na || f instanceof rs) {
              for (const m of f.uniformNames) if (n[m]) {
                const S = f.getBinding(e, n[m], m);
                o.push({ name: m, property: u, binding: S });
              }
            }
          }
          return o;
        }
        setUniforms(e, n, o, u) {
          for (const { name: f, property: m, binding: S } of n) this.binders[m].setUniform(S, u, o.get(m), f);
        }
        updatePaintBuffers(e) {
          this._buffers = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            if (e && o instanceof In) {
              const u = e.fromScale === 2 ? o.zoomInPaintVertexBuffer : o.zoomOutPaintVertexBuffer;
              u && this._buffers.push(u);
            } else (o instanceof ca || o instanceof rs) && o.paintVertexBuffer && this._buffers.push(o.paintVertexBuffer);
          }
        }
        upload(e) {
          for (const n in this.binders) {
            const o = this.binders[n];
            (o instanceof ca || o instanceof rs || o instanceof In) && o.upload(e);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const e in this.binders) {
            const n = this.binders[e];
            (n instanceof ca || n instanceof rs || n instanceof In) && n.destroy();
          }
        }
      }
      class bo {
        constructor(e, n, o = () => !0) {
          this.programConfigurations = {};
          for (const u of e) this.programConfigurations[u.id] = new Rc(u, n, o);
          this.needsUpload = !1, this._featureMap = new oc(), this._bufferOffset = 0;
        }
        populatePaintArrays(e, n, o, u, f, m) {
          for (const S in this.programConfigurations) this.programConfigurations[S].populatePaintArrays(e, n, u, f, m);
          n.id !== void 0 && this._featureMap.add(n.id, o, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0;
        }
        updatePaintArrays(e, n, o, u) {
          for (const f of o) this.needsUpload = this.programConfigurations[f.id].updatePaintArrays(e, this._featureMap, n, f, u) || this.needsUpload;
        }
        get(e) {
          return this.programConfigurations[e];
        }
        upload(e) {
          if (this.needsUpload) {
            for (const n in this.programConfigurations) this.programConfigurations[n].upload(e);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
        }
      }
      function Hh(i, e) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[i] || [i.replace(`${e}-`, "").replace(/-/g, "_")];
      }
      function Bc(i, e, n) {
        const o = { color: { source: Y, composite: We }, number: { source: ce, composite: Y } }, u = function(f) {
          return { "line-pattern": { source: Nn, composite: Nn }, "fill-pattern": { source: Nn, composite: Nn }, "fill-extrusion-pattern": { source: Nn, composite: Nn } }[f];
        }(i);
        return u && u[n] || o[e][n];
      }
      Fe("ConstantBinder", Ol), Fe("CrossFadedConstantBinder", Na), Fe("SourceExpressionBinder", ca), Fe("CrossFadedCompositeBinder", In), Fe("CompositeExpressionBinder", rs), Fe("ProgramConfiguration", Rc, { omit: ["_buffers"] }), Fe("ProgramConfigurationSet", bo);
      const tr = 8192, Oc = Math.pow(2, 14) - 1, jc = -Oc - 1;
      function Ko(i) {
        const e = tr / i.extent, n = i.loadGeometry();
        for (let o = 0; o < n.length; o++) {
          const u = n[o];
          for (let f = 0; f < u.length; f++) {
            const m = u[f], S = Math.round(m.x * e), I = Math.round(m.y * e);
            m.x = Ht(S, jc, Oc), m.y = Ht(I, jc, Oc), (S < m.x || S > m.x + 1 || I < m.y || I > m.y + 1) && Pt("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return n;
      }
      function wo(i, e) {
        return { type: i.type, id: i.id, properties: i.properties, geometry: e ? Ko(i) : [] };
      }
      function uc(i, e, n, o, u) {
        i.emplaceBack(2 * e + (o + 1) / 2, 2 * n + (u + 1) / 2);
      }
      class Qo {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.id), this.index = e.index, this.hasPattern = !1, this.layoutVertexArray = new ws(), this.indexArray = new Pn(), this.segments = new zr(), this.programConfigurations = new bo(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(e, n, o) {
          const u = this.layers[0], f = [];
          let m = null, S = !1;
          u.type === "circle" && (m = u.layout.get("circle-sort-key"), S = !m.isConstant());
          for (const { feature: I, id: E, index: D, sourceLayerIndex: N } of e) {
            const j = this.layers[0]._featureFilter.needGeometry, H = wo(I, j);
            if (!this.layers[0]._featureFilter.filter(new Vi(this.zoom), H, o)) continue;
            const et = S ? m.evaluate(H, {}, o) : void 0, rt = { id: E, properties: I.properties, type: I.type, sourceLayerIndex: N, index: D, geometry: j ? H.geometry : Ko(I), patterns: {}, sortKey: et };
            f.push(rt);
          }
          S && f.sort((I, E) => I.sortKey - E.sortKey);
          for (const I of f) {
            const { geometry: E, index: D, sourceLayerIndex: N } = I, j = e[D].feature;
            this.addFeature(I, E, D, o), n.featureIndex.insert(j, E, D, N, this.index);
          }
        }
        update(e, n, o) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, n, this.stateDependentLayers, o);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, fl), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(e, n, o, u) {
          for (const f of n) for (const m of f) {
            const S = m.x, I = m.y;
            if (S < 0 || S >= tr || I < 0 || I >= tr) continue;
            const E = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), D = E.vertexLength;
            uc(this.layoutVertexArray, S, I, -1, -1), uc(this.layoutVertexArray, S, I, 1, -1), uc(this.layoutVertexArray, S, I, 1, 1), uc(this.layoutVertexArray, S, I, -1, 1), this.indexArray.emplaceBack(D, D + 1, D + 2), this.indexArray.emplaceBack(D, D + 3, D + 2), E.vertexLength += 4, E.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, {}, u);
        }
      }
      function dc(i, e) {
        for (let n = 0; n < i.length; n++) if (Ao(e, i[n])) return !0;
        for (let n = 0; n < e.length; n++) if (Ao(i, e[n])) return !0;
        return !!ua(i, e);
      }
      function pc(i, e, n) {
        return !!Ao(i, e) || !!jl(e, i, n);
      }
      function ha(i, e) {
        if (i.length === 1) return fh(e, i[0]);
        for (let n = 0; n < e.length; n++) {
          const o = e[n];
          for (let u = 0; u < o.length; u++) if (Ao(i, o[u])) return !0;
        }
        for (let n = 0; n < i.length; n++) if (fh(e, i[n])) return !0;
        for (let n = 0; n < e.length; n++) if (ua(i, e[n])) return !0;
        return !1;
      }
      function So(i, e, n) {
        if (i.length > 1) {
          if (ua(i, e)) return !0;
          for (let o = 0; o < e.length; o++) if (jl(e[o], i, n)) return !0;
        }
        for (let o = 0; o < i.length; o++) if (jl(i[o], e, n)) return !0;
        return !1;
      }
      function ua(i, e) {
        if (i.length === 0 || e.length === 0) return !1;
        for (let n = 0; n < i.length - 1; n++) {
          const o = i[n], u = i[n + 1];
          for (let f = 0; f < e.length - 1; f++) if (fc(o, u, e[f], e[f + 1])) return !0;
        }
        return !1;
      }
      function fc(i, e, n, o) {
        return bt(i, n, o) !== bt(e, n, o) && bt(i, e, n) !== bt(i, e, o);
      }
      function jl(i, e, n) {
        const o = n * n;
        if (e.length === 1) return i.distSqr(e[0]) < o;
        for (let u = 1; u < e.length; u++) if (qc(i, e[u - 1], e[u]) < o) return !0;
        return !1;
      }
      function qc(i, e, n) {
        const o = e.distSqr(n);
        if (o === 0) return i.distSqr(e);
        const u = ((i.x - e.x) * (n.x - e.x) + (i.y - e.y) * (n.y - e.y)) / o;
        return i.distSqr(u < 0 ? e : u > 1 ? n : n.sub(e)._mult(u)._add(e));
      }
      function fh(i, e) {
        let n, o, u, f = !1;
        for (let m = 0; m < i.length; m++) {
          n = i[m];
          for (let S = 0, I = n.length - 1; S < n.length; I = S++) o = n[S], u = n[I], o.y > e.y != u.y > e.y && e.x < (u.x - o.x) * (e.y - o.y) / (u.y - o.y) + o.x && (f = !f);
        }
        return f;
      }
      function Ao(i, e) {
        let n = !1;
        for (let o = 0, u = i.length - 1; o < i.length; u = o++) {
          const f = i[o], m = i[u];
          f.y > e.y != m.y > e.y && e.x < (m.x - f.x) * (e.y - f.y) / (m.y - f.y) + f.x && (n = !n);
        }
        return n;
      }
      function Uc(i, e, n) {
        const o = n[0], u = n[2];
        if (i.x < o.x && e.x < o.x || i.x > u.x && e.x > u.x || i.y < o.y && e.y < o.y || i.y > u.y && e.y > u.y) return !1;
        const f = bt(i, e, n[0]);
        return f !== bt(i, e, n[1]) || f !== bt(i, e, n[2]) || f !== bt(i, e, n[3]);
      }
      function Vc(i, e, n) {
        const o = e.paint.get(i).value;
        return o.kind === "constant" ? o.value : n.programConfigurations.get(e.id).getMaxValue(i);
      }
      function mh(i) {
        return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
      }
      function gh(i, e, n, o, u) {
        if (!e[0] && !e[1]) return i;
        const f = q.convert(e)._mult(u);
        n === "viewport" && f._rotate(-o);
        const m = [];
        for (let S = 0; S < i.length; S++) m.push(i[S].sub(f));
        return m;
      }
      let td, ed;
      Fe("CircleBucket", Qo, { omit: ["layers"] });
      var _f = { get paint() {
        return ed = ed || new h({ "circle-radius": new s(K.paint_circle["circle-radius"]), "circle-color": new s(K.paint_circle["circle-color"]), "circle-blur": new s(K.paint_circle["circle-blur"]), "circle-opacity": new s(K.paint_circle["circle-opacity"]), "circle-translate": new t(K.paint_circle["circle-translate"]), "circle-translate-anchor": new t(K.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new t(K.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new t(K.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new s(K.paint_circle["circle-stroke-width"]), "circle-stroke-color": new s(K.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new s(K.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return td = td || new h({ "circle-sort-key": new s(K.layout_circle["circle-sort-key"]) });
      } }, Fn = 1e-6, mc = typeof Float32Array < "u" ? Float32Array : Array;
      function Xh(i) {
        return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }
      function id(i, e, n) {
        var o = e[0], u = e[1], f = e[2], m = e[3], S = e[4], I = e[5], E = e[6], D = e[7], N = e[8], j = e[9], H = e[10], et = e[11], rt = e[12], dt = e[13], vt = e[14], Nt = e[15], kt = n[0], zt = n[1], Xt = n[2], me = n[3];
        return i[0] = kt * o + zt * S + Xt * N + me * rt, i[1] = kt * u + zt * I + Xt * j + me * dt, i[2] = kt * f + zt * E + Xt * H + me * vt, i[3] = kt * m + zt * D + Xt * et + me * Nt, i[4] = (kt = n[4]) * o + (zt = n[5]) * S + (Xt = n[6]) * N + (me = n[7]) * rt, i[5] = kt * u + zt * I + Xt * j + me * dt, i[6] = kt * f + zt * E + Xt * H + me * vt, i[7] = kt * m + zt * D + Xt * et + me * Nt, i[8] = (kt = n[8]) * o + (zt = n[9]) * S + (Xt = n[10]) * N + (me = n[11]) * rt, i[9] = kt * u + zt * I + Xt * j + me * dt, i[10] = kt * f + zt * E + Xt * H + me * vt, i[11] = kt * m + zt * D + Xt * et + me * Nt, i[12] = (kt = n[12]) * o + (zt = n[13]) * S + (Xt = n[14]) * N + (me = n[15]) * rt, i[13] = kt * u + zt * I + Xt * j + me * dt, i[14] = kt * f + zt * E + Xt * H + me * vt, i[15] = kt * m + zt * D + Xt * et + me * Nt, i;
      }
      Math.hypot || (Math.hypot = function() {
        for (var i = 0, e = arguments.length; e--; ) i += arguments[e] * arguments[e];
        return Math.sqrt(i);
      });
      var $c, vf = id;
      function yh(i, e, n) {
        var o = e[0], u = e[1], f = e[2], m = e[3];
        return i[0] = n[0] * o + n[4] * u + n[8] * f + n[12] * m, i[1] = n[1] * o + n[5] * u + n[9] * f + n[13] * m, i[2] = n[2] * o + n[6] * u + n[10] * f + n[14] * m, i[3] = n[3] * o + n[7] * u + n[11] * f + n[15] * m, i;
      }
      $c = new mc(4), mc != Float32Array && ($c[0] = 0, $c[1] = 0, $c[2] = 0, $c[3] = 0);
      class xf extends _ {
        constructor(e) {
          super(e, _f);
        }
        createBucket(e) {
          return new Qo(e);
        }
        queryRadius(e) {
          const n = e;
          return Vc("circle-radius", this, n) + Vc("circle-stroke-width", this, n) + mh(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(e, n, o, u, f, m, S, I) {
          const E = gh(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), m.angle, S), D = this.paint.get("circle-radius").evaluate(n, o) + this.paint.get("circle-stroke-width").evaluate(n, o), N = this.paint.get("circle-pitch-alignment") === "map", j = N ? E : function(et, rt) {
            return et.map((dt) => rd(dt, rt));
          }(E, I), H = N ? D * S : D;
          for (const et of u) for (const rt of et) {
            const dt = N ? rt : rd(rt, I);
            let vt = H;
            const Nt = yh([], [rt.x, rt.y, 0, 1], I);
            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? vt *= Nt[3] / m.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (vt *= m.cameraToCenterDistance / Nt[3]), pc(j, dt, vt)) return !0;
          }
          return !1;
        }
      }
      function rd(i, e) {
        const n = yh([], [i.x, i.y, 0, 1], e);
        return new q(n[0] / n[3], n[1] / n[3]);
      }
      class nd extends Qo {
      }
      let sd;
      Fe("HeatmapBucket", nd, { omit: ["layers"] });
      var bf = { get paint() {
        return sd = sd || new h({ "heatmap-radius": new s(K.paint_heatmap["heatmap-radius"]), "heatmap-weight": new s(K.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new t(K.paint_heatmap["heatmap-intensity"]), "heatmap-color": new a(K.paint_heatmap["heatmap-color"]), "heatmap-opacity": new t(K.paint_heatmap["heatmap-opacity"]) });
      } };
      function Yh(i, { width: e, height: n }, o, u) {
        if (u) {
          if (u instanceof Uint8ClampedArray) u = new Uint8Array(u.buffer);
          else if (u.length !== e * n * o) throw new RangeError(`mismatched image size. expected: ${u.length} but got: ${e * n * o}`);
        } else u = new Uint8Array(e * n * o);
        return i.width = e, i.height = n, i.data = u, i;
      }
      function ad(i, { width: e, height: n }, o) {
        if (e === i.width && n === i.height) return;
        const u = Yh({}, { width: e, height: n }, o);
        Jh(i, u, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(i.width, e), height: Math.min(i.height, n) }, o), i.width = e, i.height = n, i.data = u.data;
      }
      function Jh(i, e, n, o, u, f) {
        if (u.width === 0 || u.height === 0) return e;
        if (u.width > i.width || u.height > i.height || n.x > i.width - u.width || n.y > i.height - u.height) throw new RangeError("out of range source coordinates for image copy");
        if (u.width > e.width || u.height > e.height || o.x > e.width - u.width || o.y > e.height - u.height) throw new RangeError("out of range destination coordinates for image copy");
        const m = i.data, S = e.data;
        if (m === S) throw new Error("srcData equals dstData, so image is already copied");
        for (let I = 0; I < u.height; I++) {
          const E = ((n.y + I) * i.width + n.x) * f, D = ((o.y + I) * e.width + o.x) * f;
          for (let N = 0; N < u.width * f; N++) S[D + N] = m[E + N];
        }
        return e;
      }
      class Zc {
        constructor(e, n) {
          Yh(this, e, 1, n);
        }
        resize(e) {
          ad(this, e, 1);
        }
        clone() {
          return new Zc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, n, o, u, f) {
          Jh(e, n, o, u, f, 1);
        }
      }
      class Os {
        constructor(e, n) {
          Yh(this, e, 4, n);
        }
        resize(e) {
          ad(this, e, 4);
        }
        replace(e, n) {
          n ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
        }
        clone() {
          return new Os({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, n, o, u, f) {
          Jh(e, n, o, u, f, 4);
        }
      }
      function od(i) {
        const e = {}, n = i.resolution || 256, o = i.clips ? i.clips.length : 1, u = i.image || new Os({ width: n, height: o });
        if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
        const f = (m, S, I) => {
          e[i.evaluationKey] = I;
          const E = i.expression.evaluate(e);
          u.data[m + S + 0] = Math.floor(255 * E.r / E.a), u.data[m + S + 1] = Math.floor(255 * E.g / E.a), u.data[m + S + 2] = Math.floor(255 * E.b / E.a), u.data[m + S + 3] = Math.floor(255 * E.a);
        };
        if (i.clips) for (let m = 0, S = 0; m < o; ++m, S += 4 * n) for (let I = 0, E = 0; I < n; I++, E += 4) {
          const D = I / (n - 1), { start: N, end: j } = i.clips[m];
          f(S, E, N * (1 - D) + j * D);
        }
        else for (let m = 0, S = 0; m < n; m++, S += 4) f(0, S, m / (n - 1));
        return u;
      }
      Fe("AlphaImage", Zc), Fe("RGBAImage", Os);
      class wf extends _ {
        createBucket(e) {
          return new nd(e);
        }
        constructor(e) {
          super(e, bf), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(e) {
          e === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = od({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let ld;
      var Sf = { get paint() {
        return ld = ld || new h({ "hillshade-illumination-direction": new t(K.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new t(K.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new t(K.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new t(K.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new t(K.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new t(K.paint_hillshade["hillshade-accent-color"]) });
      } };
      class Af extends _ {
        constructor(e) {
          super(e, Sf);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const Pf = C([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: If } = Pf;
      function cd(i, e, n = 2) {
        const o = e && e.length, u = o ? e[0] * n : i.length;
        let f = hd(i, 0, u, n, !0);
        const m = [];
        if (!f || f.next === f.prev) return m;
        let S, I, E;
        if (o && (f = function(D, N, j, H) {
          const et = [];
          for (let rt = 0, dt = N.length; rt < dt; rt++) {
            const vt = hd(D, N[rt] * H, rt < dt - 1 ? N[rt + 1] * H : D.length, H, !1);
            vt === vt.next && (vt.steiner = !0), et.push(Df(vt));
          }
          et.sort(Ef);
          for (let rt = 0; rt < et.length; rt++) j = Mf(et[rt], j);
          return j;
        }(i, e, f, n)), i.length > 80 * n) {
          S = 1 / 0, I = 1 / 0;
          let D = -1 / 0, N = -1 / 0;
          for (let j = n; j < u; j += n) {
            const H = i[j], et = i[j + 1];
            H < S && (S = H), et < I && (I = et), H > D && (D = H), et > N && (N = et);
          }
          E = Math.max(D - S, N - I), E = E !== 0 ? 32767 / E : 0;
        }
        return Gc(f, m, n, S, I, E, 0), m;
      }
      function hd(i, e, n, o, u) {
        let f;
        if (u === function(m, S, I, E) {
          let D = 0;
          for (let N = S, j = I - E; N < I; N += E) D += (m[j] - m[N]) * (m[N + 1] + m[j + 1]), j = N;
          return D;
        }(i, e, n, o) > 0) for (let m = e; m < n; m += o) f = pd(m / o | 0, i[m], i[m + 1], f);
        else for (let m = n - o; m >= e; m -= o) f = pd(m / o | 0, i[m], i[m + 1], f);
        return f && _h(f, f.next) && (Hc(f), f = f.next), f;
      }
      function ql(i, e) {
        if (!i) return i;
        e || (e = i);
        let n, o = i;
        do
          if (n = !1, o.steiner || !_h(o, o.next) && Pr(o.prev, o, o.next) !== 0) o = o.next;
          else {
            if (Hc(o), o = e = o.prev, o === o.next) break;
            n = !0;
          }
        while (n || o !== e);
        return e;
      }
      function Gc(i, e, n, o, u, f, m) {
        if (!i) return;
        !m && f && function(I, E, D, N) {
          let j = I;
          do
            j.z === 0 && (j.z = Kh(j.x, j.y, E, D, N)), j.prevZ = j.prev, j.nextZ = j.next, j = j.next;
          while (j !== I);
          j.prevZ.nextZ = null, j.prevZ = null, function(H) {
            let et, rt = 1;
            do {
              let dt, vt = H;
              H = null;
              let Nt = null;
              for (et = 0; vt; ) {
                et++;
                let kt = vt, zt = 0;
                for (let me = 0; me < rt && (zt++, kt = kt.nextZ, kt); me++) ;
                let Xt = rt;
                for (; zt > 0 || Xt > 0 && kt; ) zt !== 0 && (Xt === 0 || !kt || vt.z <= kt.z) ? (dt = vt, vt = vt.nextZ, zt--) : (dt = kt, kt = kt.nextZ, Xt--), Nt ? Nt.nextZ = dt : H = dt, dt.prevZ = Nt, Nt = dt;
                vt = kt;
              }
              Nt.nextZ = null, rt *= 2;
            } while (et > 1);
          }(j);
        }(i, o, u, f);
        let S = i;
        for (; i.prev !== i.next; ) {
          const I = i.prev, E = i.next;
          if (f ? Tf(i, o, u, f) : kf(i)) e.push(I.i, i.i, E.i), Hc(i), i = E.next, S = E.next;
          else if ((i = E) === S) {
            m ? m === 1 ? Gc(i = Lf(ql(i), e), e, n, o, u, f, 2) : m === 2 && Cf(i, e, n, o, u, f) : Gc(ql(i), e, n, o, u, f, 1);
            break;
          }
        }
      }
      function kf(i) {
        const e = i.prev, n = i, o = i.next;
        if (Pr(e, n, o) >= 0) return !1;
        const u = e.x, f = n.x, m = o.x, S = e.y, I = n.y, E = o.y, D = u < f ? u < m ? u : m : f < m ? f : m, N = S < I ? S < E ? S : E : I < E ? I : E, j = u > f ? u > m ? u : m : f > m ? f : m, H = S > I ? S > E ? S : E : I > E ? I : E;
        let et = o.next;
        for (; et !== e; ) {
          if (et.x >= D && et.x <= j && et.y >= N && et.y <= H && gc(u, S, f, I, m, E, et.x, et.y) && Pr(et.prev, et, et.next) >= 0) return !1;
          et = et.next;
        }
        return !0;
      }
      function Tf(i, e, n, o) {
        const u = i.prev, f = i, m = i.next;
        if (Pr(u, f, m) >= 0) return !1;
        const S = u.x, I = f.x, E = m.x, D = u.y, N = f.y, j = m.y, H = S < I ? S < E ? S : E : I < E ? I : E, et = D < N ? D < j ? D : j : N < j ? N : j, rt = S > I ? S > E ? S : E : I > E ? I : E, dt = D > N ? D > j ? D : j : N > j ? N : j, vt = Kh(H, et, e, n, o), Nt = Kh(rt, dt, e, n, o);
        let kt = i.prevZ, zt = i.nextZ;
        for (; kt && kt.z >= vt && zt && zt.z <= Nt; ) {
          if (kt.x >= H && kt.x <= rt && kt.y >= et && kt.y <= dt && kt !== u && kt !== m && gc(S, D, I, N, E, j, kt.x, kt.y) && Pr(kt.prev, kt, kt.next) >= 0 || (kt = kt.prevZ, zt.x >= H && zt.x <= rt && zt.y >= et && zt.y <= dt && zt !== u && zt !== m && gc(S, D, I, N, E, j, zt.x, zt.y) && Pr(zt.prev, zt, zt.next) >= 0)) return !1;
          zt = zt.nextZ;
        }
        for (; kt && kt.z >= vt; ) {
          if (kt.x >= H && kt.x <= rt && kt.y >= et && kt.y <= dt && kt !== u && kt !== m && gc(S, D, I, N, E, j, kt.x, kt.y) && Pr(kt.prev, kt, kt.next) >= 0) return !1;
          kt = kt.prevZ;
        }
        for (; zt && zt.z <= Nt; ) {
          if (zt.x >= H && zt.x <= rt && zt.y >= et && zt.y <= dt && zt !== u && zt !== m && gc(S, D, I, N, E, j, zt.x, zt.y) && Pr(zt.prev, zt, zt.next) >= 0) return !1;
          zt = zt.nextZ;
        }
        return !0;
      }
      function Lf(i, e) {
        let n = i;
        do {
          const o = n.prev, u = n.next.next;
          !_h(o, u) && ud(o, n, n.next, u) && Wc(o, u) && Wc(u, o) && (e.push(o.i, n.i, u.i), Hc(n), Hc(n.next), n = i = u), n = n.next;
        } while (n !== i);
        return ql(n);
      }
      function Cf(i, e, n, o, u, f) {
        let m = i;
        do {
          let S = m.next.next;
          for (; S !== m.prev; ) {
            if (m.i !== S.i && Nf(m, S)) {
              let I = dd(m, S);
              return m = ql(m, m.next), I = ql(I, I.next), Gc(m, e, n, o, u, f, 0), void Gc(I, e, n, o, u, f, 0);
            }
            S = S.next;
          }
          m = m.next;
        } while (m !== i);
      }
      function Ef(i, e) {
        return i.x - e.x;
      }
      function Mf(i, e) {
        const n = function(u, f) {
          let m = f;
          const S = u.x, I = u.y;
          let E, D = -1 / 0;
          do {
            if (I <= m.y && I >= m.next.y && m.next.y !== m.y) {
              const rt = m.x + (I - m.y) * (m.next.x - m.x) / (m.next.y - m.y);
              if (rt <= S && rt > D && (D = rt, E = m.x < m.next.x ? m : m.next, rt === S)) return E;
            }
            m = m.next;
          } while (m !== f);
          if (!E) return null;
          const N = E, j = E.x, H = E.y;
          let et = 1 / 0;
          m = E;
          do {
            if (S >= m.x && m.x >= j && S !== m.x && gc(I < H ? S : D, I, j, H, I < H ? D : S, I, m.x, m.y)) {
              const rt = Math.abs(I - m.y) / (S - m.x);
              Wc(m, u) && (rt < et || rt === et && (m.x > E.x || m.x === E.x && zf(E, m))) && (E = m, et = rt);
            }
            m = m.next;
          } while (m !== N);
          return E;
        }(i, e);
        if (!n) return e;
        const o = dd(n, i);
        return ql(o, o.next), ql(n, n.next);
      }
      function zf(i, e) {
        return Pr(i.prev, i, e.prev) < 0 && Pr(e.next, i, i.next) < 0;
      }
      function Kh(i, e, n, o, u) {
        return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - n) * u | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - o) * u | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
      }
      function Df(i) {
        let e = i, n = i;
        do
          (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
        while (e !== i);
        return n;
      }
      function gc(i, e, n, o, u, f, m, S) {
        return (u - m) * (e - S) >= (i - m) * (f - S) && (i - m) * (o - S) >= (n - m) * (e - S) && (n - m) * (f - S) >= (u - m) * (o - S);
      }
      function Nf(i, e) {
        return i.next.i !== e.i && i.prev.i !== e.i && !function(n, o) {
          let u = n;
          do {
            if (u.i !== n.i && u.next.i !== n.i && u.i !== o.i && u.next.i !== o.i && ud(u, u.next, n, o)) return !0;
            u = u.next;
          } while (u !== n);
          return !1;
        }(i, e) && (Wc(i, e) && Wc(e, i) && function(n, o) {
          let u = n, f = !1;
          const m = (n.x + o.x) / 2, S = (n.y + o.y) / 2;
          do
            u.y > S != u.next.y > S && u.next.y !== u.y && m < (u.next.x - u.x) * (S - u.y) / (u.next.y - u.y) + u.x && (f = !f), u = u.next;
          while (u !== n);
          return f;
        }(i, e) && (Pr(i.prev, i, e.prev) || Pr(i, e.prev, e)) || _h(i, e) && Pr(i.prev, i, i.next) > 0 && Pr(e.prev, e, e.next) > 0);
      }
      function Pr(i, e, n) {
        return (e.y - i.y) * (n.x - e.x) - (e.x - i.x) * (n.y - e.y);
      }
      function _h(i, e) {
        return i.x === e.x && i.y === e.y;
      }
      function ud(i, e, n, o) {
        const u = xh(Pr(i, e, n)), f = xh(Pr(i, e, o)), m = xh(Pr(n, o, i)), S = xh(Pr(n, o, e));
        return u !== f && m !== S || !(u !== 0 || !vh(i, n, e)) || !(f !== 0 || !vh(i, o, e)) || !(m !== 0 || !vh(n, i, o)) || !(S !== 0 || !vh(n, e, o));
      }
      function vh(i, e, n) {
        return e.x <= Math.max(i.x, n.x) && e.x >= Math.min(i.x, n.x) && e.y <= Math.max(i.y, n.y) && e.y >= Math.min(i.y, n.y);
      }
      function xh(i) {
        return i > 0 ? 1 : i < 0 ? -1 : 0;
      }
      function Wc(i, e) {
        return Pr(i.prev, i, i.next) < 0 ? Pr(i, e, i.next) >= 0 && Pr(i, i.prev, e) >= 0 : Pr(i, e, i.prev) < 0 || Pr(i, i.next, e) < 0;
      }
      function dd(i, e) {
        const n = Qh(i.i, i.x, i.y), o = Qh(e.i, e.x, e.y), u = i.next, f = e.prev;
        return i.next = e, e.prev = i, n.next = u, u.prev = n, o.next = n, n.prev = o, f.next = o, o.prev = f, o;
      }
      function pd(i, e, n, o) {
        const u = Qh(i, e, n);
        return o ? (u.next = o.next, u.prev = o, o.next.prev = u, o.next = u) : (u.prev = u, u.next = u), u;
      }
      function Hc(i) {
        i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
      }
      function Qh(i, e, n) {
        return { i, x: e, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
      }
      function tu(i, e, n) {
        const o = n.patternDependencies;
        let u = !1;
        for (const f of e) {
          const m = f.paint.get(`${i}-pattern`);
          m.isConstant() || (u = !0);
          const S = m.constantOr(null);
          S && (u = !0, o[S.to] = !0, o[S.from] = !0);
        }
        return u;
      }
      function eu(i, e, n, o, u) {
        const f = u.patternDependencies;
        for (const m of e) {
          const S = m.paint.get(`${i}-pattern`).value;
          if (S.kind !== "constant") {
            let I = S.evaluate({ zoom: o - 1 }, n, {}, u.availableImages), E = S.evaluate({ zoom: o }, n, {}, u.availableImages), D = S.evaluate({ zoom: o + 1 }, n, {}, u.availableImages);
            I = I && I.name ? I.name : I, E = E && E.name ? E.name : E, D = D && D.name ? D.name : D, f[I] = !0, f[E] = !0, f[D] = !0, n.patterns[m.id] = { min: I, mid: E, max: D };
          }
        }
        return n;
      }
      class iu {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new oa(), this.indexArray = new Pn(), this.indexArray2 = new As(), this.programConfigurations = new bo(e.layers, e.zoom), this.segments = new zr(), this.segments2 = new zr(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(e, n, o) {
          this.hasPattern = tu("fill", this.layers, n);
          const u = this.layers[0].layout.get("fill-sort-key"), f = !u.isConstant(), m = [];
          for (const { feature: S, id: I, index: E, sourceLayerIndex: D } of e) {
            const N = this.layers[0]._featureFilter.needGeometry, j = wo(S, N);
            if (!this.layers[0]._featureFilter.filter(new Vi(this.zoom), j, o)) continue;
            const H = f ? u.evaluate(j, {}, o, n.availableImages) : void 0, et = { id: I, properties: S.properties, type: S.type, sourceLayerIndex: D, index: E, geometry: N ? j.geometry : Ko(S), patterns: {}, sortKey: H };
            m.push(et);
          }
          f && m.sort((S, I) => S.sortKey - I.sortKey);
          for (const S of m) {
            const { geometry: I, index: E, sourceLayerIndex: D } = S;
            if (this.hasPattern) {
              const N = eu("fill", this.layers, S, this.zoom, n);
              this.patternFeatures.push(N);
            } else this.addFeature(S, I, E, o, {});
            n.featureIndex.insert(e[E].feature, I, E, D, this.index);
          }
        }
        update(e, n, o) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, n, this.stateDependentLayers, o);
        }
        addFeatures(e, n, o) {
          for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, n, o);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, If), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(e, n, o, u, f) {
          for (const m of ds(n, 500)) {
            let S = 0;
            for (const H of m) S += H.length;
            const I = this.segments.prepareSegment(S, this.layoutVertexArray, this.indexArray), E = I.vertexLength, D = [], N = [];
            for (const H of m) {
              if (H.length === 0) continue;
              H !== m[0] && N.push(D.length / 2);
              const et = this.segments2.prepareSegment(H.length, this.layoutVertexArray, this.indexArray2), rt = et.vertexLength;
              this.layoutVertexArray.emplaceBack(H[0].x, H[0].y), this.indexArray2.emplaceBack(rt + H.length - 1, rt), D.push(H[0].x), D.push(H[0].y);
              for (let dt = 1; dt < H.length; dt++) this.layoutVertexArray.emplaceBack(H[dt].x, H[dt].y), this.indexArray2.emplaceBack(rt + dt - 1, rt + dt), D.push(H[dt].x), D.push(H[dt].y);
              et.vertexLength += H.length, et.primitiveLength += H.length;
            }
            const j = cd(D, N);
            for (let H = 0; H < j.length; H += 3) this.indexArray.emplaceBack(E + j[H], E + j[H + 1], E + j[H + 2]);
            I.vertexLength += S, I.primitiveLength += j.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, f, u);
        }
      }
      let fd, md;
      Fe("FillBucket", iu, { omit: ["layers", "patternFeatures"] });
      var Ff = { get paint() {
        return md = md || new h({ "fill-antialias": new t(K.paint_fill["fill-antialias"]), "fill-opacity": new s(K.paint_fill["fill-opacity"]), "fill-color": new s(K.paint_fill["fill-color"]), "fill-outline-color": new s(K.paint_fill["fill-outline-color"]), "fill-translate": new t(K.paint_fill["fill-translate"]), "fill-translate-anchor": new t(K.paint_fill["fill-translate-anchor"]), "fill-pattern": new c(K.paint_fill["fill-pattern"]) });
      }, get layout() {
        return fd = fd || new h({ "fill-sort-key": new s(K.layout_fill["fill-sort-key"]) });
      } };
      class Rf extends _ {
        constructor(e) {
          super(e, Ff);
        }
        recalculate(e, n) {
          super.recalculate(e, n);
          const o = this.paint._values["fill-outline-color"];
          o.value.kind === "constant" && o.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(e) {
          return new iu(e);
        }
        queryRadius() {
          return mh(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(e, n, o, u, f, m, S) {
          return ha(gh(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), m.angle, S), u);
        }
        isTileClipped() {
          return !0;
        }
      }
      const Bf = C([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Of = C([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: jf } = Bf;
      var ml = {}, qf = B, gd = yc;
      function yc(i, e, n, o, u) {
        this.properties = {}, this.extent = n, this.type = 0, this._pbf = i, this._geometry = -1, this._keys = o, this._values = u, i.readFields(Uf, this, e);
      }
      function Uf(i, e, n) {
        i == 1 ? e.id = n.readVarint() : i == 2 ? function(o, u) {
          for (var f = o.readVarint() + o.pos; o.pos < f; ) {
            var m = u._keys[o.readVarint()], S = u._values[o.readVarint()];
            u.properties[m] = S;
          }
        }(n, e) : i == 3 ? e.type = n.readVarint() : i == 4 && (e._geometry = n.pos);
      }
      function Vf(i) {
        for (var e, n, o = 0, u = 0, f = i.length, m = f - 1; u < f; m = u++) o += ((n = i[m]).x - (e = i[u]).x) * (e.y + n.y);
        return o;
      }
      yc.types = ["Unknown", "Point", "LineString", "Polygon"], yc.prototype.loadGeometry = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var e, n = i.readVarint() + i.pos, o = 1, u = 0, f = 0, m = 0, S = []; i.pos < n; ) {
          if (u <= 0) {
            var I = i.readVarint();
            o = 7 & I, u = I >> 3;
          }
          if (u--, o === 1 || o === 2) f += i.readSVarint(), m += i.readSVarint(), o === 1 && (e && S.push(e), e = []), e.push(new qf(f, m));
          else {
            if (o !== 7) throw new Error("unknown command " + o);
            e && e.push(e[0].clone());
          }
        }
        return e && S.push(e), S;
      }, yc.prototype.bbox = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var e = i.readVarint() + i.pos, n = 1, o = 0, u = 0, f = 0, m = 1 / 0, S = -1 / 0, I = 1 / 0, E = -1 / 0; i.pos < e; ) {
          if (o <= 0) {
            var D = i.readVarint();
            n = 7 & D, o = D >> 3;
          }
          if (o--, n === 1 || n === 2) (u += i.readSVarint()) < m && (m = u), u > S && (S = u), (f += i.readSVarint()) < I && (I = f), f > E && (E = f);
          else if (n !== 7) throw new Error("unknown command " + n);
        }
        return [m, I, S, E];
      }, yc.prototype.toGeoJSON = function(i, e, n) {
        var o, u, f = this.extent * Math.pow(2, n), m = this.extent * i, S = this.extent * e, I = this.loadGeometry(), E = yc.types[this.type];
        function D(H) {
          for (var et = 0; et < H.length; et++) {
            var rt = H[et];
            H[et] = [360 * (rt.x + m) / f - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (rt.y + S) / f) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var N = [];
            for (o = 0; o < I.length; o++) N[o] = I[o][0];
            D(I = N);
            break;
          case 2:
            for (o = 0; o < I.length; o++) D(I[o]);
            break;
          case 3:
            for (I = function(H) {
              var et = H.length;
              if (et <= 1) return [H];
              for (var rt, dt, vt = [], Nt = 0; Nt < et; Nt++) {
                var kt = Vf(H[Nt]);
                kt !== 0 && (dt === void 0 && (dt = kt < 0), dt === kt < 0 ? (rt && vt.push(rt), rt = [H[Nt]]) : rt.push(H[Nt]));
              }
              return rt && vt.push(rt), vt;
            }(I), o = 0; o < I.length; o++) for (u = 0; u < I[o].length; u++) D(I[o][u]);
        }
        I.length === 1 ? I = I[0] : E = "Multi" + E;
        var j = { type: "Feature", geometry: { type: E, coordinates: I }, properties: this.properties };
        return "id" in this && (j.id = this.id), j;
      };
      var $f = gd, yd = _d;
      function _d(i, e) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = i, this._keys = [], this._values = [], this._features = [], i.readFields(Zf, this, e), this.length = this._features.length;
      }
      function Zf(i, e, n) {
        i === 15 ? e.version = n.readVarint() : i === 1 ? e.name = n.readString() : i === 5 ? e.extent = n.readVarint() : i === 2 ? e._features.push(n.pos) : i === 3 ? e._keys.push(n.readString()) : i === 4 && e._values.push(function(o) {
          for (var u = null, f = o.readVarint() + o.pos; o.pos < f; ) {
            var m = o.readVarint() >> 3;
            u = m === 1 ? o.readString() : m === 2 ? o.readFloat() : m === 3 ? o.readDouble() : m === 4 ? o.readVarint64() : m === 5 ? o.readVarint() : m === 6 ? o.readSVarint() : m === 7 ? o.readBoolean() : null;
          }
          return u;
        }(n));
      }
      _d.prototype.feature = function(i) {
        if (i < 0 || i >= this._features.length) throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[i];
        var e = this._pbf.readVarint() + this._pbf.pos;
        return new $f(this._pbf, e, this.extent, this._keys, this._values);
      };
      var Gf = yd;
      function Wf(i, e, n) {
        if (i === 3) {
          var o = new Gf(n, n.readVarint() + n.pos);
          o.length && (e[o.name] = o);
        }
      }
      ml.VectorTile = function(i, e) {
        this.layers = i.readFields(Wf, {}, e);
      }, ml.VectorTileFeature = gd, ml.VectorTileLayer = yd;
      const Hf = ml.VectorTileFeature.types, ru = Math.pow(2, 13);
      function Xc(i, e, n, o, u, f, m, S) {
        i.emplaceBack(e, n, 2 * Math.floor(o * ru) + m, u * ru * 2, f * ru * 2, Math.round(S));
      }
      class nu {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.id), this.index = e.index, this.hasPattern = !1, this.layoutVertexArray = new Sr(), this.centroidVertexArray = new Hr(), this.indexArray = new Pn(), this.programConfigurations = new bo(e.layers, e.zoom), this.segments = new zr(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(e, n, o) {
          this.features = [], this.hasPattern = tu("fill-extrusion", this.layers, n);
          for (const { feature: u, id: f, index: m, sourceLayerIndex: S } of e) {
            const I = this.layers[0]._featureFilter.needGeometry, E = wo(u, I);
            if (!this.layers[0]._featureFilter.filter(new Vi(this.zoom), E, o)) continue;
            const D = { id: f, sourceLayerIndex: S, index: m, geometry: I ? E.geometry : Ko(u), properties: u.properties, type: u.type, patterns: {} };
            this.hasPattern ? this.features.push(eu("fill-extrusion", this.layers, D, this.zoom, n)) : this.addFeature(D, D.geometry, m, o, {}), n.featureIndex.insert(u, D.geometry, m, S, this.index, !0);
          }
        }
        addFeatures(e, n, o) {
          for (const u of this.features) {
            const { geometry: f } = u;
            this.addFeature(u, f, u.index, n, o);
          }
        }
        update(e, n, o) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, n, this.stateDependentLayers, o);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, jf), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Of.members, !0), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(e, n, o, u, f) {
          for (const m of ds(n, 500)) {
            const S = { x: 0, y: 0, vertexCount: 0 };
            let I = 0;
            for (const et of m) I += et.length;
            let E = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const et of m) {
              if (et.length === 0 || Yf(et)) continue;
              let rt = 0;
              for (let dt = 0; dt < et.length; dt++) {
                const vt = et[dt];
                if (dt >= 1) {
                  const Nt = et[dt - 1];
                  if (!Xf(vt, Nt)) {
                    E.vertexLength + 4 > zr.MAX_VERTEX_ARRAY_LENGTH && (E = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const kt = vt.sub(Nt)._perp()._unit(), zt = Nt.dist(vt);
                    rt + zt > 32768 && (rt = 0), Xc(this.layoutVertexArray, vt.x, vt.y, kt.x, kt.y, 0, 0, rt), Xc(this.layoutVertexArray, vt.x, vt.y, kt.x, kt.y, 0, 1, rt), S.x += 2 * vt.x, S.y += 2 * vt.y, S.vertexCount += 2, rt += zt, Xc(this.layoutVertexArray, Nt.x, Nt.y, kt.x, kt.y, 0, 0, rt), Xc(this.layoutVertexArray, Nt.x, Nt.y, kt.x, kt.y, 0, 1, rt), S.x += 2 * Nt.x, S.y += 2 * Nt.y, S.vertexCount += 2;
                    const Xt = E.vertexLength;
                    this.indexArray.emplaceBack(Xt, Xt + 2, Xt + 1), this.indexArray.emplaceBack(Xt + 1, Xt + 2, Xt + 3), E.vertexLength += 4, E.primitiveLength += 2;
                  }
                }
              }
            }
            if (E.vertexLength + I > zr.MAX_VERTEX_ARRAY_LENGTH && (E = this.segments.prepareSegment(I, this.layoutVertexArray, this.indexArray)), Hf[e.type] !== "Polygon") continue;
            const D = [], N = [], j = E.vertexLength;
            for (const et of m) if (et.length !== 0) {
              et !== m[0] && N.push(D.length / 2);
              for (let rt = 0; rt < et.length; rt++) {
                const dt = et[rt];
                Xc(this.layoutVertexArray, dt.x, dt.y, 0, 0, 1, 1, 0), S.x += dt.x, S.y += dt.y, S.vertexCount += 1, D.push(dt.x), D.push(dt.y);
              }
            }
            const H = cd(D, N);
            for (let et = 0; et < H.length; et += 3) this.indexArray.emplaceBack(j + H[et], j + H[et + 2], j + H[et + 1]);
            E.primitiveLength += H.length / 3, E.vertexLength += I;
            for (let et = 0; et < S.vertexCount; et++) {
              const rt = Math.floor(S.x / S.vertexCount), dt = Math.floor(S.y / S.vertexCount);
              this.centroidVertexArray.emplaceBack(rt, dt);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, f, u);
        }
      }
      function Xf(i, e) {
        return i.x === e.x && (i.x < 0 || i.x > tr) || i.y === e.y && (i.y < 0 || i.y > tr);
      }
      function Yf(i) {
        return i.every((e) => e.x < 0) || i.every((e) => e.x > tr) || i.every((e) => e.y < 0) || i.every((e) => e.y > tr);
      }
      let vd;
      Fe("FillExtrusionBucket", nu, { omit: ["layers", "features"] });
      var Jf = { get paint() {
        return vd = vd || new h({ "fill-extrusion-opacity": new t(K["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new s(K["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new t(K["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new t(K["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new c(K["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new s(K["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new s(K["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new t(K["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class Kf extends _ {
        constructor(e) {
          super(e, Jf);
        }
        createBucket(e) {
          return new nu(e);
        }
        queryRadius() {
          return mh(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(e, n, o, u, f, m, S, I) {
          const E = gh(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), m.angle, S), D = this.paint.get("fill-extrusion-height").evaluate(n, o), N = this.paint.get("fill-extrusion-base").evaluate(n, o), j = function(et, rt, dt, vt) {
            const Nt = [];
            for (const kt of et) {
              const zt = [kt.x, kt.y, 0, 1];
              yh(zt, zt, rt), Nt.push(new q(zt[0] / zt[3], zt[1] / zt[3]));
            }
            return Nt;
          }(E, I), H = function(et, rt, dt, vt) {
            const Nt = [], kt = [], zt = vt[8] * rt, Xt = vt[9] * rt, me = vt[10] * rt, Ee = vt[11] * rt, ti = vt[8] * dt, Ie = vt[9] * dt, Se = vt[10] * dt, qe = vt[11] * dt;
            for (const Oe of et) {
              const Be = [], ae = [];
              for (const Ze of Oe) {
                const je = Ze.x, li = Ze.y, Ji = vt[0] * je + vt[4] * li + vt[12], Hi = vt[1] * je + vt[5] * li + vt[13], Jr = vt[2] * je + vt[6] * li + vt[14], da = vt[3] * je + vt[7] * li + vt[15], gn = Jr + me, Kr = da + Ee, Rn = Ji + ti, Bn = Hi + Ie, On = Jr + Se, xr = da + qe, Qr = new q((Ji + zt) / Kr, (Hi + Xt) / Kr);
                Qr.z = gn / Kr, Be.push(Qr);
                const kn = new q(Rn / xr, Bn / xr);
                kn.z = On / xr, ae.push(kn);
              }
              Nt.push(Be), kt.push(ae);
            }
            return [Nt, kt];
          }(u, N, D, I);
          return function(et, rt, dt) {
            let vt = 1 / 0;
            ha(dt, rt) && (vt = xd(dt, rt[0]));
            for (let Nt = 0; Nt < rt.length; Nt++) {
              const kt = rt[Nt], zt = et[Nt];
              for (let Xt = 0; Xt < kt.length - 1; Xt++) {
                const me = kt[Xt], Ee = [me, kt[Xt + 1], zt[Xt + 1], zt[Xt], me];
                dc(dt, Ee) && (vt = Math.min(vt, xd(dt, Ee)));
              }
            }
            return vt !== 1 / 0 && vt;
          }(H[0], H[1], j);
        }
      }
      function Yc(i, e) {
        return i.x * e.x + i.y * e.y;
      }
      function xd(i, e) {
        if (i.length === 1) {
          let n = 0;
          const o = e[n++];
          let u;
          for (; !u || o.equals(u); ) if (u = e[n++], !u) return 1 / 0;
          for (; n < e.length; n++) {
            const f = e[n], m = i[0], S = u.sub(o), I = f.sub(o), E = m.sub(o), D = Yc(S, S), N = Yc(S, I), j = Yc(I, I), H = Yc(E, S), et = Yc(E, I), rt = D * j - N * N, dt = (j * H - N * et) / rt, vt = (D * et - N * H) / rt, Nt = o.z * (1 - dt - vt) + u.z * dt + f.z * vt;
            if (isFinite(Nt)) return Nt;
          }
          return 1 / 0;
        }
        {
          let n = 1 / 0;
          for (const o of e) n = Math.min(n, o.z);
          return n;
        }
      }
      const Qf = C([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: tm } = Qf, em = C([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: im } = em, rm = ml.VectorTileFeature.types, nm = Math.cos(Math.PI / 180 * 37.5), bd = Math.pow(2, 14) / 0.5;
      class su {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n) => {
            this.gradients[n.id] = {};
          }), this.layoutVertexArray = new Ri(), this.layoutVertexArray2 = new Ss(), this.indexArray = new Pn(), this.programConfigurations = new bo(e.layers, e.zoom), this.segments = new zr(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(e, n, o) {
          this.hasPattern = tu("line", this.layers, n);
          const u = this.layers[0].layout.get("line-sort-key"), f = !u.isConstant(), m = [];
          for (const { feature: S, id: I, index: E, sourceLayerIndex: D } of e) {
            const N = this.layers[0]._featureFilter.needGeometry, j = wo(S, N);
            if (!this.layers[0]._featureFilter.filter(new Vi(this.zoom), j, o)) continue;
            const H = f ? u.evaluate(j, {}, o) : void 0, et = { id: I, properties: S.properties, type: S.type, sourceLayerIndex: D, index: E, geometry: N ? j.geometry : Ko(S), patterns: {}, sortKey: H };
            m.push(et);
          }
          f && m.sort((S, I) => S.sortKey - I.sortKey);
          for (const S of m) {
            const { geometry: I, index: E, sourceLayerIndex: D } = S;
            if (this.hasPattern) {
              const N = eu("line", this.layers, S, this.zoom, n);
              this.patternFeatures.push(N);
            } else this.addFeature(S, I, E, o, {});
            n.featureIndex.insert(e[E].feature, I, E, D, this.index);
          }
        }
        update(e, n, o) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, n, this.stateDependentLayers, o);
        }
        addFeatures(e, n, o) {
          for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, n, o);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, im)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, tm), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(e) {
          if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
        }
        addFeature(e, n, o, u, f) {
          const m = this.layers[0].layout, S = m.get("line-join").evaluate(e, {}), I = m.get("line-cap"), E = m.get("line-miter-limit"), D = m.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(e);
          for (const N of n) this.addLine(N, e, S, I, E, D);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, f, u);
        }
        addLine(e, n, o, u, f, m) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let vt = 0; vt < e.length - 1; vt++) this.totalDistance += e[vt].dist(e[vt + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const S = rm[n.type] === "Polygon";
          let I = e.length;
          for (; I >= 2 && e[I - 1].equals(e[I - 2]); ) I--;
          let E = 0;
          for (; E < I - 1 && e[E].equals(e[E + 1]); ) E++;
          if (I < (S ? 3 : 2)) return;
          o === "bevel" && (f = 1.05);
          const D = this.overscaling <= 16 ? 15 * tr / (512 * this.overscaling) : 0, N = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
          let j, H, et, rt, dt;
          this.e1 = this.e2 = -1, S && (j = e[I - 2], dt = e[E].sub(j)._unit()._perp());
          for (let vt = E; vt < I; vt++) {
            if (et = vt === I - 1 ? S ? e[E + 1] : void 0 : e[vt + 1], et && e[vt].equals(et)) continue;
            dt && (rt = dt), j && (H = j), j = e[vt], dt = et ? et.sub(j)._unit()._perp() : rt, rt = rt || dt;
            let Nt = rt.add(dt);
            Nt.x === 0 && Nt.y === 0 || Nt._unit();
            const kt = rt.x * dt.x + rt.y * dt.y, zt = Nt.x * dt.x + Nt.y * dt.y, Xt = zt !== 0 ? 1 / zt : 1 / 0, me = 2 * Math.sqrt(2 - 2 * zt), Ee = zt < nm && H && et, ti = rt.x * dt.y - rt.y * dt.x > 0;
            if (Ee && vt > E) {
              const qe = j.dist(H);
              if (qe > 2 * D) {
                const Oe = j.sub(j.sub(H)._mult(D / qe)._round());
                this.updateDistance(H, Oe), this.addCurrentVertex(Oe, rt, 0, 0, N), H = Oe;
              }
            }
            const Ie = H && et;
            let Se = Ie ? o : S ? "butt" : u;
            if (Ie && Se === "round" && (Xt < m ? Se = "miter" : Xt <= 2 && (Se = "fakeround")), Se === "miter" && Xt > f && (Se = "bevel"), Se === "bevel" && (Xt > 2 && (Se = "flipbevel"), Xt < f && (Se = "miter")), H && this.updateDistance(H, j), Se === "miter") Nt._mult(Xt), this.addCurrentVertex(j, Nt, 0, 0, N);
            else if (Se === "flipbevel") {
              if (Xt > 100) Nt = dt.mult(-1);
              else {
                const qe = Xt * rt.add(dt).mag() / rt.sub(dt).mag();
                Nt._perp()._mult(qe * (ti ? -1 : 1));
              }
              this.addCurrentVertex(j, Nt, 0, 0, N), this.addCurrentVertex(j, Nt.mult(-1), 0, 0, N);
            } else if (Se === "bevel" || Se === "fakeround") {
              const qe = -Math.sqrt(Xt * Xt - 1), Oe = ti ? qe : 0, Be = ti ? 0 : qe;
              if (H && this.addCurrentVertex(j, rt, Oe, Be, N), Se === "fakeround") {
                const ae = Math.round(180 * me / Math.PI / 20);
                for (let Ze = 1; Ze < ae; Ze++) {
                  let je = Ze / ae;
                  if (je !== 0.5) {
                    const Ji = je - 0.5;
                    je += je * Ji * (je - 1) * ((1.0904 + kt * (kt * (3.55645 - 1.43519 * kt) - 3.2452)) * Ji * Ji + (0.848013 + kt * (0.215638 * kt - 1.06021)));
                  }
                  const li = dt.sub(rt)._mult(je)._add(rt)._unit()._mult(ti ? -1 : 1);
                  this.addHalfVertex(j, li.x, li.y, !1, ti, 0, N);
                }
              }
              et && this.addCurrentVertex(j, dt, -Oe, -Be, N);
            } else if (Se === "butt") this.addCurrentVertex(j, Nt, 0, 0, N);
            else if (Se === "square") {
              const qe = H ? 1 : -1;
              this.addCurrentVertex(j, Nt, qe, qe, N);
            } else Se === "round" && (H && (this.addCurrentVertex(j, rt, 0, 0, N), this.addCurrentVertex(j, rt, 1, 1, N, !0)), et && (this.addCurrentVertex(j, dt, -1, -1, N, !0), this.addCurrentVertex(j, dt, 0, 0, N)));
            if (Ee && vt < I - 1) {
              const qe = j.dist(et);
              if (qe > 2 * D) {
                const Oe = j.add(et.sub(j)._mult(D / qe)._round());
                this.updateDistance(j, Oe), this.addCurrentVertex(Oe, dt, 0, 0, N), j = Oe;
              }
            }
          }
        }
        addCurrentVertex(e, n, o, u, f, m = !1) {
          const S = n.y * u - n.x, I = -n.y - n.x * u;
          this.addHalfVertex(e, n.x + n.y * o, n.y - n.x * o, m, !1, o, f), this.addHalfVertex(e, S, I, m, !0, -u, f), this.distance > bd / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, n, o, u, f, m));
        }
        addHalfVertex({ x: e, y: n }, o, u, f, m, S, I) {
          const E = 0.5 * (this.lineClips ? this.scaledDistance * (bd - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((e << 1) + (f ? 1 : 0), (n << 1) + (m ? 1 : 0), Math.round(63 * o) + 128, Math.round(63 * u) + 128, 1 + (S === 0 ? 0 : S < 0 ? -1 : 1) | (63 & E) << 2, E >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const D = I.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, D), I.primitiveLength++), m ? this.e2 = D : this.e1 = D;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(e, n) {
          this.distance += e.dist(n), this.updateScaledDistance();
        }
      }
      let wd, Sd;
      Fe("LineBucket", su, { omit: ["layers", "patternFeatures"] });
      var Ad = { get paint() {
        return Sd = Sd || new h({ "line-opacity": new s(K.paint_line["line-opacity"]), "line-color": new s(K.paint_line["line-color"]), "line-translate": new t(K.paint_line["line-translate"]), "line-translate-anchor": new t(K.paint_line["line-translate-anchor"]), "line-width": new s(K.paint_line["line-width"]), "line-gap-width": new s(K.paint_line["line-gap-width"]), "line-offset": new s(K.paint_line["line-offset"]), "line-blur": new s(K.paint_line["line-blur"]), "line-dasharray": new r(K.paint_line["line-dasharray"]), "line-pattern": new c(K.paint_line["line-pattern"]), "line-gradient": new a(K.paint_line["line-gradient"]) });
      }, get layout() {
        return wd = wd || new h({ "line-cap": new t(K.layout_line["line-cap"]), "line-join": new s(K.layout_line["line-join"]), "line-miter-limit": new t(K.layout_line["line-miter-limit"]), "line-round-limit": new t(K.layout_line["line-round-limit"]), "line-sort-key": new s(K.layout_line["line-sort-key"]) });
      } };
      class sm extends s {
        possiblyEvaluate(e, n) {
          return n = new Vi(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(e, n);
        }
        evaluate(e, n, o, u) {
          return n = jt({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(e, n, o, u);
        }
      }
      let bh;
      class am extends _ {
        constructor(e) {
          super(e, Ad), this.gradientVersion = 0, bh || (bh = new sm(Ad.paint.properties["line-width"].specification), bh.useIntegerZoom = !0);
        }
        _handleSpecialPaintPropertyUpdate(e) {
          if (e === "line-gradient") {
            const n = this.gradientExpression();
            this.stepInterpolant = !!function(o) {
              return o._styleExpression !== void 0;
            }(n) && n._styleExpression.expression instanceof Hs, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(e, n) {
          super.recalculate(e, n), this.paint._values["line-floorwidth"] = bh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
        }
        createBucket(e) {
          return new su(e);
        }
        queryRadius(e) {
          const n = e, o = Pd(Vc("line-width", this, n), Vc("line-gap-width", this, n)), u = Vc("line-offset", this, n);
          return o / 2 + Math.abs(u) + mh(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(e, n, o, u, f, m, S) {
          const I = gh(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), m.angle, S), E = S / 2 * Pd(this.paint.get("line-width").evaluate(n, o), this.paint.get("line-gap-width").evaluate(n, o)), D = this.paint.get("line-offset").evaluate(n, o);
          return D && (u = function(N, j) {
            const H = [];
            for (let et = 0; et < N.length; et++) {
              const rt = N[et], dt = [];
              for (let vt = 0; vt < rt.length; vt++) {
                const Nt = rt[vt - 1], kt = rt[vt], zt = rt[vt + 1], Xt = vt === 0 ? new q(0, 0) : kt.sub(Nt)._unit()._perp(), me = vt === rt.length - 1 ? new q(0, 0) : zt.sub(kt)._unit()._perp(), Ee = Xt._add(me)._unit(), ti = Ee.x * me.x + Ee.y * me.y;
                ti !== 0 && Ee._mult(1 / ti), dt.push(Ee._mult(j)._add(kt));
              }
              H.push(dt);
            }
            return H;
          }(u, D * S)), function(N, j, H) {
            for (let et = 0; et < j.length; et++) {
              const rt = j[et];
              if (N.length >= 3) {
                for (let dt = 0; dt < rt.length; dt++) if (Ao(N, rt[dt])) return !0;
              }
              if (So(N, rt, H)) return !0;
            }
            return !1;
          }(I, u, E);
        }
        isTileClipped() {
          return !0;
        }
      }
      function Pd(i, e) {
        return e > 0 ? e + 2 * i : i;
      }
      const om = C([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), lm = C([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      C([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const cm = C([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      C([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Id = C([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), hm = C([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function um(i, e, n) {
        return i.sections.forEach((o) => {
          o.text = function(u, f, m) {
            const S = f.layout.get("text-transform").evaluate(m, {});
            return S === "uppercase" ? u = u.toLocaleUpperCase() : S === "lowercase" && (u = u.toLocaleLowerCase()), bs.applyArabicShaping && (u = bs.applyArabicShaping(u)), u;
          }(o.text, e, n);
        }), i;
      }
      C([{ name: "triangle", components: 3, type: "Uint16" }]), C([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), C([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), C([{ type: "Float32", name: "offsetX" }]), C([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), C([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const Jc = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
      var Br = 24, kd = Wi, Td = function(i, e, n, o, u) {
        var f, m, S = 8 * u - o - 1, I = (1 << S) - 1, E = I >> 1, D = -7, N = u - 1, j = -1, H = i[e + N];
        for (N += j, f = H & (1 << -D) - 1, H >>= -D, D += S; D > 0; f = 256 * f + i[e + N], N += j, D -= 8) ;
        for (m = f & (1 << -D) - 1, f >>= -D, D += o; D > 0; m = 256 * m + i[e + N], N += j, D -= 8) ;
        if (f === 0) f = 1 - E;
        else {
          if (f === I) return m ? NaN : 1 / 0 * (H ? -1 : 1);
          m += Math.pow(2, o), f -= E;
        }
        return (H ? -1 : 1) * m * Math.pow(2, f - o);
      }, Ld = function(i, e, n, o, u, f) {
        var m, S, I, E = 8 * f - u - 1, D = (1 << E) - 1, N = D >> 1, j = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, H = 0, et = 1, rt = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (S = isNaN(e) ? 1 : 0, m = D) : (m = Math.floor(Math.log(e) / Math.LN2), e * (I = Math.pow(2, -m)) < 1 && (m--, I *= 2), (e += m + N >= 1 ? j / I : j * Math.pow(2, 1 - N)) * I >= 2 && (m++, I /= 2), m + N >= D ? (S = 0, m = D) : m + N >= 1 ? (S = (e * I - 1) * Math.pow(2, u), m += N) : (S = e * Math.pow(2, N - 1) * Math.pow(2, u), m = 0)); u >= 8; i[n + H] = 255 & S, H += et, S /= 256, u -= 8) ;
        for (m = m << u | S, E += u; E > 0; i[n + H] = 255 & m, H += et, m /= 256, E -= 8) ;
        i[n + H - et] |= 128 * rt;
      };
      function Wi(i) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(i) ? i : new Uint8Array(i || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      Wi.Varint = 0, Wi.Fixed64 = 1, Wi.Bytes = 2, Wi.Fixed32 = 5;
      var au = 4294967296, Cd = 1 / au, Ed = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
      function tl(i) {
        return i.type === Wi.Bytes ? i.readVarint() + i.pos : i.pos + 1;
      }
      function _c(i, e, n) {
        return n ? 4294967296 * e + (i >>> 0) : 4294967296 * (e >>> 0) + (i >>> 0);
      }
      function Md(i, e, n) {
        var o = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
        n.realloc(o);
        for (var u = n.pos - 1; u >= i; u--) n.buf[u + o] = n.buf[u];
      }
      function dm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeVarint(i[n]);
      }
      function pm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeSVarint(i[n]);
      }
      function fm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeFloat(i[n]);
      }
      function mm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeDouble(i[n]);
      }
      function gm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeBoolean(i[n]);
      }
      function ym(i, e) {
        for (var n = 0; n < i.length; n++) e.writeFixed32(i[n]);
      }
      function _m(i, e) {
        for (var n = 0; n < i.length; n++) e.writeSFixed32(i[n]);
      }
      function vm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeFixed64(i[n]);
      }
      function xm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeSFixed64(i[n]);
      }
      function wh(i, e) {
        return (i[e] | i[e + 1] << 8 | i[e + 2] << 16) + 16777216 * i[e + 3];
      }
      function vc(i, e, n) {
        i[n] = e, i[n + 1] = e >>> 8, i[n + 2] = e >>> 16, i[n + 3] = e >>> 24;
      }
      function zd(i, e) {
        return (i[e] | i[e + 1] << 8 | i[e + 2] << 16) + (i[e + 3] << 24);
      }
      Wi.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(i, e, n) {
        for (n = n || this.length; this.pos < n; ) {
          var o = this.readVarint(), u = o >> 3, f = this.pos;
          this.type = 7 & o, i(u, e, this), this.pos === f && this.skip(o);
        }
        return e;
      }, readMessage: function(i, e) {
        return this.readFields(i, e, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var i = wh(this.buf, this.pos);
        return this.pos += 4, i;
      }, readSFixed32: function() {
        var i = zd(this.buf, this.pos);
        return this.pos += 4, i;
      }, readFixed64: function() {
        var i = wh(this.buf, this.pos) + wh(this.buf, this.pos + 4) * au;
        return this.pos += 8, i;
      }, readSFixed64: function() {
        var i = wh(this.buf, this.pos) + zd(this.buf, this.pos + 4) * au;
        return this.pos += 8, i;
      }, readFloat: function() {
        var i = Td(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, i;
      }, readDouble: function() {
        var i = Td(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, i;
      }, readVarint: function(i) {
        var e, n, o = this.buf;
        return e = 127 & (n = o[this.pos++]), n < 128 ? e : (e |= (127 & (n = o[this.pos++])) << 7, n < 128 ? e : (e |= (127 & (n = o[this.pos++])) << 14, n < 128 ? e : (e |= (127 & (n = o[this.pos++])) << 21, n < 128 ? e : function(u, f, m) {
          var S, I, E = m.buf;
          if (S = (112 & (I = E[m.pos++])) >> 4, I < 128 || (S |= (127 & (I = E[m.pos++])) << 3, I < 128) || (S |= (127 & (I = E[m.pos++])) << 10, I < 128) || (S |= (127 & (I = E[m.pos++])) << 17, I < 128) || (S |= (127 & (I = E[m.pos++])) << 24, I < 128) || (S |= (1 & (I = E[m.pos++])) << 31, I < 128)) return _c(u, S, f);
          throw new Error("Expected varint not more than 10 bytes");
        }(e |= (15 & (n = o[this.pos])) << 28, i, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var i = this.readVarint();
        return i % 2 == 1 ? (i + 1) / -2 : i / 2;
      }, readBoolean: function() {
        return !!this.readVarint();
      }, readString: function() {
        var i = this.readVarint() + this.pos, e = this.pos;
        return this.pos = i, i - e >= 12 && Ed ? function(n, o, u) {
          return Ed.decode(n.subarray(o, u));
        }(this.buf, e, i) : function(n, o, u) {
          for (var f = "", m = o; m < u; ) {
            var S, I, E, D = n[m], N = null, j = D > 239 ? 4 : D > 223 ? 3 : D > 191 ? 2 : 1;
            if (m + j > u) break;
            j === 1 ? D < 128 && (N = D) : j === 2 ? (192 & (S = n[m + 1])) == 128 && (N = (31 & D) << 6 | 63 & S) <= 127 && (N = null) : j === 3 ? (I = n[m + 2], (192 & (S = n[m + 1])) == 128 && (192 & I) == 128 && ((N = (15 & D) << 12 | (63 & S) << 6 | 63 & I) <= 2047 || N >= 55296 && N <= 57343) && (N = null)) : j === 4 && (I = n[m + 2], E = n[m + 3], (192 & (S = n[m + 1])) == 128 && (192 & I) == 128 && (192 & E) == 128 && ((N = (15 & D) << 18 | (63 & S) << 12 | (63 & I) << 6 | 63 & E) <= 65535 || N >= 1114112) && (N = null)), N === null ? (N = 65533, j = 1) : N > 65535 && (N -= 65536, f += String.fromCharCode(N >>> 10 & 1023 | 55296), N = 56320 | 1023 & N), f += String.fromCharCode(N), m += j;
          }
          return f;
        }(this.buf, e, i);
      }, readBytes: function() {
        var i = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, i);
        return this.pos = i, e;
      }, readPackedVarint: function(i, e) {
        if (this.type !== Wi.Bytes) return i.push(this.readVarint(e));
        var n = tl(this);
        for (i = i || []; this.pos < n; ) i.push(this.readVarint(e));
        return i;
      }, readPackedSVarint: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readSVarint());
        var e = tl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readSVarint());
        return i;
      }, readPackedBoolean: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readBoolean());
        var e = tl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readBoolean());
        return i;
      }, readPackedFloat: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readFloat());
        var e = tl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readFloat());
        return i;
      }, readPackedDouble: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readDouble());
        var e = tl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readDouble());
        return i;
      }, readPackedFixed32: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readFixed32());
        var e = tl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readFixed32());
        return i;
      }, readPackedSFixed32: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readSFixed32());
        var e = tl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readSFixed32());
        return i;
      }, readPackedFixed64: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readFixed64());
        var e = tl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readFixed64());
        return i;
      }, readPackedSFixed64: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readSFixed64());
        var e = tl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readSFixed64());
        return i;
      }, skip: function(i) {
        var e = 7 & i;
        if (e === Wi.Varint) for (; this.buf[this.pos++] > 127; ) ;
        else if (e === Wi.Bytes) this.pos = this.readVarint() + this.pos;
        else if (e === Wi.Fixed32) this.pos += 4;
        else {
          if (e !== Wi.Fixed64) throw new Error("Unimplemented type: " + e);
          this.pos += 8;
        }
      }, writeTag: function(i, e) {
        this.writeVarint(i << 3 | e);
      }, realloc: function(i) {
        for (var e = this.length || 16; e < this.pos + i; ) e *= 2;
        if (e !== this.length) {
          var n = new Uint8Array(e);
          n.set(this.buf), this.buf = n, this.length = e;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(i) {
        this.realloc(4), vc(this.buf, i, this.pos), this.pos += 4;
      }, writeSFixed32: function(i) {
        this.realloc(4), vc(this.buf, i, this.pos), this.pos += 4;
      }, writeFixed64: function(i) {
        this.realloc(8), vc(this.buf, -1 & i, this.pos), vc(this.buf, Math.floor(i * Cd), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(i) {
        this.realloc(8), vc(this.buf, -1 & i, this.pos), vc(this.buf, Math.floor(i * Cd), this.pos + 4), this.pos += 8;
      }, writeVarint: function(i) {
        (i = +i || 0) > 268435455 || i < 0 ? function(e, n) {
          var o, u;
          if (e >= 0 ? (o = e % 4294967296 | 0, u = e / 4294967296 | 0) : (u = ~(-e / 4294967296), 4294967295 ^ (o = ~(-e % 4294967296)) ? o = o + 1 | 0 : (o = 0, u = u + 1 | 0)), e >= 18446744073709552e3 || e < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
          n.realloc(10), function(f, m, S) {
            S.buf[S.pos++] = 127 & f | 128, f >>>= 7, S.buf[S.pos++] = 127 & f | 128, f >>>= 7, S.buf[S.pos++] = 127 & f | 128, f >>>= 7, S.buf[S.pos++] = 127 & f | 128, S.buf[S.pos] = 127 & (f >>>= 7);
          }(o, 0, n), function(f, m) {
            var S = (7 & f) << 4;
            m.buf[m.pos++] |= S | ((f >>>= 3) ? 128 : 0), f && (m.buf[m.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (m.buf[m.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (m.buf[m.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (m.buf[m.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (m.buf[m.pos++] = 127 & f)))));
          }(u, n);
        }(i, this) : (this.realloc(4), this.buf[this.pos++] = 127 & i | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = i >>> 7 & 127))));
      }, writeSVarint: function(i) {
        this.writeVarint(i < 0 ? 2 * -i - 1 : 2 * i);
      }, writeBoolean: function(i) {
        this.writeVarint(!!i);
      }, writeString: function(i) {
        i = String(i), this.realloc(4 * i.length), this.pos++;
        var e = this.pos;
        this.pos = function(o, u, f) {
          for (var m, S, I = 0; I < u.length; I++) {
            if ((m = u.charCodeAt(I)) > 55295 && m < 57344) {
              if (!S) {
                m > 56319 || I + 1 === u.length ? (o[f++] = 239, o[f++] = 191, o[f++] = 189) : S = m;
                continue;
              }
              if (m < 56320) {
                o[f++] = 239, o[f++] = 191, o[f++] = 189, S = m;
                continue;
              }
              m = S - 55296 << 10 | m - 56320 | 65536, S = null;
            } else S && (o[f++] = 239, o[f++] = 191, o[f++] = 189, S = null);
            m < 128 ? o[f++] = m : (m < 2048 ? o[f++] = m >> 6 | 192 : (m < 65536 ? o[f++] = m >> 12 | 224 : (o[f++] = m >> 18 | 240, o[f++] = m >> 12 & 63 | 128), o[f++] = m >> 6 & 63 | 128), o[f++] = 63 & m | 128);
          }
          return f;
        }(this.buf, i, this.pos);
        var n = this.pos - e;
        n >= 128 && Md(e, n, this), this.pos = e - 1, this.writeVarint(n), this.pos += n;
      }, writeFloat: function(i) {
        this.realloc(4), Ld(this.buf, i, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(i) {
        this.realloc(8), Ld(this.buf, i, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(i) {
        var e = i.length;
        this.writeVarint(e), this.realloc(e);
        for (var n = 0; n < e; n++) this.buf[this.pos++] = i[n];
      }, writeRawMessage: function(i, e) {
        this.pos++;
        var n = this.pos;
        i(e, this);
        var o = this.pos - n;
        o >= 128 && Md(n, o, this), this.pos = n - 1, this.writeVarint(o), this.pos += o;
      }, writeMessage: function(i, e, n) {
        this.writeTag(i, Wi.Bytes), this.writeRawMessage(e, n);
      }, writePackedVarint: function(i, e) {
        e.length && this.writeMessage(i, dm, e);
      }, writePackedSVarint: function(i, e) {
        e.length && this.writeMessage(i, pm, e);
      }, writePackedBoolean: function(i, e) {
        e.length && this.writeMessage(i, gm, e);
      }, writePackedFloat: function(i, e) {
        e.length && this.writeMessage(i, fm, e);
      }, writePackedDouble: function(i, e) {
        e.length && this.writeMessage(i, mm, e);
      }, writePackedFixed32: function(i, e) {
        e.length && this.writeMessage(i, ym, e);
      }, writePackedSFixed32: function(i, e) {
        e.length && this.writeMessage(i, _m, e);
      }, writePackedFixed64: function(i, e) {
        e.length && this.writeMessage(i, vm, e);
      }, writePackedSFixed64: function(i, e) {
        e.length && this.writeMessage(i, xm, e);
      }, writeBytesField: function(i, e) {
        this.writeTag(i, Wi.Bytes), this.writeBytes(e);
      }, writeFixed32Field: function(i, e) {
        this.writeTag(i, Wi.Fixed32), this.writeFixed32(e);
      }, writeSFixed32Field: function(i, e) {
        this.writeTag(i, Wi.Fixed32), this.writeSFixed32(e);
      }, writeFixed64Field: function(i, e) {
        this.writeTag(i, Wi.Fixed64), this.writeFixed64(e);
      }, writeSFixed64Field: function(i, e) {
        this.writeTag(i, Wi.Fixed64), this.writeSFixed64(e);
      }, writeVarintField: function(i, e) {
        this.writeTag(i, Wi.Varint), this.writeVarint(e);
      }, writeSVarintField: function(i, e) {
        this.writeTag(i, Wi.Varint), this.writeSVarint(e);
      }, writeStringField: function(i, e) {
        this.writeTag(i, Wi.Bytes), this.writeString(e);
      }, writeFloatField: function(i, e) {
        this.writeTag(i, Wi.Fixed32), this.writeFloat(e);
      }, writeDoubleField: function(i, e) {
        this.writeTag(i, Wi.Fixed64), this.writeDouble(e);
      }, writeBooleanField: function(i, e) {
        this.writeVarintField(i, !!e);
      } };
      var ou = M(kd);
      const lu = 3;
      function bm(i, e, n) {
        i === 1 && n.readMessage(wm, e);
      }
      function wm(i, e, n) {
        if (i === 3) {
          const { id: o, bitmap: u, width: f, height: m, left: S, top: I, advance: E } = n.readMessage(Sm, {});
          e.push({ id: o, bitmap: new Zc({ width: f + 2 * lu, height: m + 2 * lu }, u), metrics: { width: f, height: m, left: S, top: I, advance: E } });
        }
      }
      function Sm(i, e, n) {
        i === 1 ? e.id = n.readVarint() : i === 2 ? e.bitmap = n.readBytes() : i === 3 ? e.width = n.readVarint() : i === 4 ? e.height = n.readVarint() : i === 5 ? e.left = n.readSVarint() : i === 6 ? e.top = n.readSVarint() : i === 7 && (e.advance = n.readVarint());
      }
      const Dd = lu;
      function Nd(i) {
        let e = 0, n = 0;
        for (const m of i) e += m.w * m.h, n = Math.max(n, m.w);
        i.sort((m, S) => S.h - m.h);
        const o = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), n), h: 1 / 0 }];
        let u = 0, f = 0;
        for (const m of i) for (let S = o.length - 1; S >= 0; S--) {
          const I = o[S];
          if (!(m.w > I.w || m.h > I.h)) {
            if (m.x = I.x, m.y = I.y, f = Math.max(f, m.y + m.h), u = Math.max(u, m.x + m.w), m.w === I.w && m.h === I.h) {
              const E = o.pop();
              S < o.length && (o[S] = E);
            } else m.h === I.h ? (I.x += m.w, I.w -= m.w) : m.w === I.w ? (I.y += m.h, I.h -= m.h) : (o.push({ x: I.x + m.w, y: I.y, w: I.w - m.w, h: m.h }), I.y += m.h, I.h -= m.h);
            break;
          }
        }
        return { w: u, h: f, fill: e / (u * f) || 0 };
      }
      const ns = 1;
      class cu {
        constructor(e, { pixelRatio: n, version: o, stretchX: u, stretchY: f, content: m, textFitWidth: S, textFitHeight: I }) {
          this.paddedRect = e, this.pixelRatio = n, this.stretchX = u, this.stretchY = f, this.content = m, this.version = o, this.textFitWidth = S, this.textFitHeight = I;
        }
        get tl() {
          return [this.paddedRect.x + ns, this.paddedRect.y + ns];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - ns, this.paddedRect.y + this.paddedRect.h - ns];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * ns) / this.pixelRatio, (this.paddedRect.h - 2 * ns) / this.pixelRatio];
        }
      }
      class Fd {
        constructor(e, n) {
          const o = {}, u = {};
          this.haveRenderCallbacks = [];
          const f = [];
          this.addImages(e, o, f), this.addImages(n, u, f);
          const { w: m, h: S } = Nd(f), I = new Os({ width: m || 1, height: S || 1 });
          for (const E in e) {
            const D = e[E], N = o[E].paddedRect;
            Os.copy(D.data, I, { x: 0, y: 0 }, { x: N.x + ns, y: N.y + ns }, D.data);
          }
          for (const E in n) {
            const D = n[E], N = u[E].paddedRect, j = N.x + ns, H = N.y + ns, et = D.data.width, rt = D.data.height;
            Os.copy(D.data, I, { x: 0, y: 0 }, { x: j, y: H }, D.data), Os.copy(D.data, I, { x: 0, y: rt - 1 }, { x: j, y: H - 1 }, { width: et, height: 1 }), Os.copy(D.data, I, { x: 0, y: 0 }, { x: j, y: H + rt }, { width: et, height: 1 }), Os.copy(D.data, I, { x: et - 1, y: 0 }, { x: j - 1, y: H }, { width: 1, height: rt }), Os.copy(D.data, I, { x: 0, y: 0 }, { x: j + et, y: H }, { width: 1, height: rt });
          }
          this.image = I, this.iconPositions = o, this.patternPositions = u;
        }
        addImages(e, n, o) {
          for (const u in e) {
            const f = e[u], m = { x: 0, y: 0, w: f.data.width + 2 * ns, h: f.data.height + 2 * ns };
            o.push(m), n[u] = new cu(m, f), f.hasRenderCallback && this.haveRenderCallbacks.push(u);
          }
        }
        patchUpdatedImages(e, n) {
          e.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const o in e.updatedImages) this.patchUpdatedImage(this.iconPositions[o], e.getImage(o), n), this.patchUpdatedImage(this.patternPositions[o], e.getImage(o), n);
        }
        patchUpdatedImage(e, n, o) {
          if (!e || !n || e.version === n.version) return;
          e.version = n.version;
          const [u, f] = e.tl;
          o.update(n.data, void 0, { x: u, y: f });
        }
      }
      var gl;
      Fe("ImagePosition", cu), Fe("ImageAtlas", Fd), v.ah = void 0, (gl = v.ah || (v.ah = {}))[gl.none = 0] = "none", gl[gl.horizontal = 1] = "horizontal", gl[gl.vertical = 2] = "vertical", gl[gl.horizontalOnly = 3] = "horizontalOnly";
      const Kc = -17;
      class Qc {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(e, n) {
          const o = new Qc();
          return o.scale = e || 1, o.fontStack = n, o;
        }
        static forImage(e) {
          const n = new Qc();
          return n.imageName = e, n;
        }
      }
      class xc {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(e, n) {
          const o = new xc();
          for (let u = 0; u < e.sections.length; u++) {
            const f = e.sections[u];
            f.image ? o.addImageSection(f) : o.addTextSection(f, n);
          }
          return o;
        }
        length() {
          return this.text.length;
        }
        getSection(e) {
          return this.sections[this.sectionIndex[e]];
        }
        getSectionIndex(e) {
          return this.sectionIndex[e];
        }
        getCharCode(e) {
          return this.text.charCodeAt(e);
        }
        verticalizePunctuation() {
          this.text = function(e) {
            let n = "";
            for (let o = 0; o < e.length; o++) {
              const u = e.charCodeAt(o + 1) || null, f = e.charCodeAt(o - 1) || null;
              n += u && mo(u) && !Jc[e[o + 1]] || f && mo(f) && !Jc[e[o - 1]] || !Jc[e[o]] ? e[o] : Jc[e[o]];
            }
            return n;
          }(this.text);
        }
        trim() {
          let e = 0;
          for (let o = 0; o < this.text.length && Ah[this.text.charCodeAt(o)]; o++) e++;
          let n = this.text.length;
          for (let o = this.text.length - 1; o >= 0 && o >= e && Ah[this.text.charCodeAt(o)]; o--) n--;
          this.text = this.text.substring(e, n), this.sectionIndex = this.sectionIndex.slice(e, n);
        }
        substring(e, n) {
          const o = new xc();
          return o.text = this.text.substring(e, n), o.sectionIndex = this.sectionIndex.slice(e, n), o.sections = this.sections, o;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((e, n) => Math.max(e, this.sections[n].scale), 0);
        }
        addTextSection(e, n) {
          this.text += e.text, this.sections.push(Qc.forText(e.scale, e.fontStack || n));
          const o = this.sections.length - 1;
          for (let u = 0; u < e.text.length; ++u) this.sectionIndex.push(o);
        }
        addImageSection(e) {
          const n = e.image ? e.image.name : "";
          if (n.length === 0) return void Pt("Can't add FormattedSection with an empty image.");
          const o = this.getNextImageSectionCharCode();
          o ? (this.text += String.fromCharCode(o), this.sections.push(Qc.forImage(n)), this.sectionIndex.push(this.sections.length - 1)) : Pt("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Sh(i, e, n, o, u, f, m, S, I, E, D, N, j, H, et) {
        const rt = xc.fromFeature(i, u);
        let dt;
        N === v.ah.vertical && rt.verticalizePunctuation();
        const { processBidirectionalText: vt, processStyledBidirectionalText: Nt } = bs;
        if (vt && rt.sections.length === 1) {
          dt = [];
          const Xt = vt(rt.toString(), hu(rt, E, f, e, o, H));
          for (const me of Xt) {
            const Ee = new xc();
            Ee.text = me, Ee.sections = rt.sections;
            for (let ti = 0; ti < me.length; ti++) Ee.sectionIndex.push(0);
            dt.push(Ee);
          }
        } else if (Nt) {
          dt = [];
          const Xt = Nt(rt.text, rt.sectionIndex, hu(rt, E, f, e, o, H));
          for (const me of Xt) {
            const Ee = new xc();
            Ee.text = me[0], Ee.sectionIndex = me[1], Ee.sections = rt.sections, dt.push(Ee);
          }
        } else dt = function(Xt, me) {
          const Ee = [], ti = Xt.text;
          let Ie = 0;
          for (const Se of me) Ee.push(Xt.substring(Ie, Se)), Ie = Se;
          return Ie < ti.length && Ee.push(Xt.substring(Ie, ti.length)), Ee;
        }(rt, hu(rt, E, f, e, o, H));
        const kt = [], zt = { positionedLines: kt, text: rt.toString(), top: D[1], bottom: D[1], left: D[0], right: D[0], writingMode: N, iconsInText: !1, verticalizable: !1 };
        return function(Xt, me, Ee, ti, Ie, Se, qe, Oe, Be, ae, Ze, je) {
          let li = 0, Ji = Kc, Hi = 0, Jr = 0;
          const da = Oe === "right" ? 1 : Oe === "left" ? 0 : 0.5;
          let gn = 0;
          for (const xr of Ie) {
            xr.trim();
            const Qr = xr.getMaxScale(), kn = (Qr - 1) * Br, yn = { positionedGlyphs: [], lineOffset: 0 };
            Xt.positionedLines[gn] = yn;
            const jn = yn.positionedGlyphs;
            let _n = 0;
            if (!xr.length()) {
              Ji += Se, ++gn;
              continue;
            }
            for (let ss = 0; ss < xr.length(); ss++) {
              const Bi = xr.getSection(ss), er = xr.getSectionIndex(ss), or = xr.getCharCode(ss);
              let Ps = 0, yr = null, Ac = null, Io = null, ko = Br;
              const pa = !(Be === v.ah.horizontal || !Ze && !Bs(or) || Ze && (Ah[or] || (Kr = or, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(Kr)))));
              if (Bi.imageName) {
                const Us = ti[Bi.imageName];
                if (!Us) continue;
                Io = Bi.imageName, Xt.iconsInText = Xt.iconsInText || !0, Ac = Us.paddedRect;
                const cn = Us.displaySize;
                Bi.scale = Bi.scale * Br / je, yr = { width: cn[0], height: cn[1], left: ns, top: -Dd, advance: pa ? cn[1] : cn[0] }, Ps = kn + (Br - cn[1] * Bi.scale), ko = yr.advance;
                const el = pa ? cn[0] * Bi.scale - Br * Qr : cn[1] * Bi.scale - Br * Qr;
                el > 0 && el > _n && (_n = el);
              } else {
                const Us = Ee[Bi.fontStack], cn = Us && Us[or];
                if (cn && cn.rect) Ac = cn.rect, yr = cn.metrics;
                else {
                  const el = me[Bi.fontStack], sh = el && el[or];
                  if (!sh) continue;
                  yr = sh.metrics;
                }
                Ps = (Qr - Bi.scale) * Br;
              }
              pa ? (Xt.verticalizable = !0, jn.push({ glyph: or, imageName: Io, x: li, y: Ji + Ps, vertical: pa, scale: Bi.scale, fontStack: Bi.fontStack, sectionIndex: er, metrics: yr, rect: Ac }), li += ko * Bi.scale + ae) : (jn.push({ glyph: or, imageName: Io, x: li, y: Ji + Ps, vertical: pa, scale: Bi.scale, fontStack: Bi.fontStack, sectionIndex: er, metrics: yr, rect: Ac }), li += yr.advance * Bi.scale + ae);
            }
            jn.length !== 0 && (Hi = Math.max(li - ae, Hi), km(jn, 0, jn.length - 1, da, _n)), li = 0;
            const qs = Se * Qr + _n;
            yn.lineOffset = Math.max(_n, kn), Ji += qs, Jr = Math.max(qs, Jr), ++gn;
          }
          var Kr;
          const Rn = Ji - Kc, { horizontalAlign: Bn, verticalAlign: On } = uu(qe);
          (function(xr, Qr, kn, yn, jn, _n, qs, ss, Bi) {
            const er = (Qr - kn) * jn;
            let or = 0;
            or = _n !== qs ? -ss * yn - Kc : (-yn * Bi + 0.5) * qs;
            for (const Ps of xr) for (const yr of Ps.positionedGlyphs) yr.x += er, yr.y += or;
          })(Xt.positionedLines, da, Bn, On, Hi, Jr, Se, Rn, Ie.length), Xt.top += -On * Rn, Xt.bottom = Xt.top + Rn, Xt.left += -Bn * Hi, Xt.right = Xt.left + Hi;
        }(zt, e, n, o, dt, m, S, I, N, E, j, et), !function(Xt) {
          for (const me of Xt) if (me.positionedGlyphs.length !== 0) return !1;
          return !0;
        }(kt) && zt;
      }
      const Ah = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Am = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, Pm = { 40: !0 };
      function Rd(i, e, n, o, u, f) {
        if (e.imageName) {
          const m = o[e.imageName];
          return m ? m.displaySize[0] * e.scale * Br / f + u : 0;
        }
        {
          const m = n[e.fontStack], S = m && m[i];
          return S ? S.metrics.advance * e.scale + u : 0;
        }
      }
      function Bd(i, e, n, o) {
        const u = Math.pow(i - e, 2);
        return o ? i < e ? u / 2 : 2 * u : u + Math.abs(n) * n;
      }
      function Im(i, e, n) {
        let o = 0;
        return i === 10 && (o -= 1e4), n && (o += 150), i !== 40 && i !== 65288 || (o += 50), e !== 41 && e !== 65289 || (o += 50), o;
      }
      function Od(i, e, n, o, u, f) {
        let m = null, S = Bd(e, n, u, f);
        for (const I of o) {
          const E = Bd(e - I.x, n, u, f) + I.badness;
          E <= S && (m = I, S = E);
        }
        return { index: i, x: e, priorBreak: m, badness: S };
      }
      function jd(i) {
        return i ? jd(i.priorBreak).concat(i.index) : [];
      }
      function hu(i, e, n, o, u, f) {
        if (!i) return [];
        const m = [], S = function(N, j, H, et, rt, dt) {
          let vt = 0;
          for (let Nt = 0; Nt < N.length(); Nt++) {
            const kt = N.getSection(Nt);
            vt += Rd(N.getCharCode(Nt), kt, et, rt, j, dt);
          }
          return vt / Math.max(1, Math.ceil(vt / H));
        }(i, e, n, o, u, f), I = i.text.indexOf("") >= 0;
        let E = 0;
        for (let N = 0; N < i.length(); N++) {
          const j = i.getSection(N), H = i.getCharCode(N);
          if (Ah[H] || (E += Rd(H, j, o, u, e, f)), N < i.length() - 1) {
            const et = !((D = H) < 11904) && (!!ui["CJK Compatibility Forms"](D) || !!ui["CJK Compatibility"](D) || !!ui["CJK Strokes"](D) || !!ui["CJK Symbols and Punctuation"](D) || !!ui["Enclosed CJK Letters and Months"](D) || !!ui["Halfwidth and Fullwidth Forms"](D) || !!ui["Ideographic Description Characters"](D) || !!ui["Vertical Forms"](D) || zl.test(String.fromCodePoint(D)));
            (Am[H] || et || j.imageName || N !== i.length() - 2 && Pm[i.getCharCode(N + 1)]) && m.push(Od(N + 1, E, S, m, Im(H, i.getCharCode(N + 1), et && I), !1));
          }
        }
        var D;
        return jd(Od(i.length(), E, S, m, 0, !0));
      }
      function uu(i) {
        let e = 0.5, n = 0.5;
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            e = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e = 0;
        }
        switch (i) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            n = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            n = 0;
        }
        return { horizontalAlign: e, verticalAlign: n };
      }
      function km(i, e, n, o, u) {
        if (!o && !u) return;
        const f = i[n], m = (i[n].x + f.metrics.advance * f.scale) * o;
        for (let S = e; S <= n; S++) i[S].x -= m, i[S].y += u;
      }
      function Tm(i, e, n) {
        const { horizontalAlign: o, verticalAlign: u } = uu(n), f = e[0] - i.displaySize[0] * o, m = e[1] - i.displaySize[1] * u;
        return { image: i, top: m, bottom: m + i.displaySize[1], left: f, right: f + i.displaySize[0] };
      }
      function qd(i) {
        var e, n;
        let o = i.left, u = i.top, f = i.right - o, m = i.bottom - u;
        const S = (e = i.image.textFitWidth) !== null && e !== void 0 ? e : "stretchOrShrink", I = (n = i.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", E = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
        if (I === "proportional") {
          if (S === "stretchOnly" && f / m < E || S === "proportional") {
            const D = Math.ceil(m * E);
            o *= D / f, f = D;
          }
        } else if (S === "proportional" && I === "stretchOnly" && E !== 0 && f / m > E) {
          const D = Math.ceil(f / E);
          u *= D / m, m = D;
        }
        return { x1: o, y1: u, x2: o + f, y2: u + m };
      }
      function Ud(i, e, n, o, u, f) {
        const m = i.image;
        let S;
        if (m.content) {
          const dt = m.content, vt = m.pixelRatio || 1;
          S = [dt[0] / vt, dt[1] / vt, m.displaySize[0] - dt[2] / vt, m.displaySize[1] - dt[3] / vt];
        }
        const I = e.left * f, E = e.right * f;
        let D, N, j, H;
        n === "width" || n === "both" ? (H = u[0] + I - o[3], N = u[0] + E + o[1]) : (H = u[0] + (I + E - m.displaySize[0]) / 2, N = H + m.displaySize[0]);
        const et = e.top * f, rt = e.bottom * f;
        return n === "height" || n === "both" ? (D = u[1] + et - o[0], j = u[1] + rt + o[2]) : (D = u[1] + (et + rt - m.displaySize[1]) / 2, j = D + m.displaySize[1]), { image: m, top: D, right: N, bottom: j, left: H, collisionPadding: S };
      }
      const th = 255, Po = 128, yl = th * Po;
      function Vd(i, e) {
        const { expression: n } = e;
        if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new Vi(i + 1)) };
        if (n.kind === "source") return { kind: "source" };
        {
          const { zoomStops: o, interpolationType: u } = n;
          let f = 0;
          for (; f < o.length && o[f] <= i; ) f++;
          f = Math.max(0, f - 1);
          let m = f;
          for (; m < o.length && o[m] < i + 1; ) m++;
          m = Math.min(o.length - 1, m);
          const S = o[f], I = o[m];
          return n.kind === "composite" ? { kind: "composite", minZoom: S, maxZoom: I, interpolationType: u } : { kind: "camera", minZoom: S, maxZoom: I, minSize: n.evaluate(new Vi(S)), maxSize: n.evaluate(new Vi(I)), interpolationType: u };
        }
      }
      function du(i, e, n) {
        let o = "never";
        const u = i.get(e);
        return u ? o = u : i.get(n) && (o = "always"), o;
      }
      const Lm = ml.VectorTileFeature.types, Cm = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Ph(i, e, n, o, u, f, m, S, I, E, D, N, j) {
        const H = S ? Math.min(yl, Math.round(S[0])) : 0, et = S ? Math.min(yl, Math.round(S[1])) : 0;
        i.emplaceBack(e, n, Math.round(32 * o), Math.round(32 * u), f, m, (H << 1) + (I ? 1 : 0), et, 16 * E, 16 * D, 256 * N, 256 * j);
      }
      function pu(i, e, n) {
        i.emplaceBack(e.x, e.y, n), i.emplaceBack(e.x, e.y, n), i.emplaceBack(e.x, e.y, n), i.emplaceBack(e.x, e.y, n);
      }
      function Em(i) {
        for (const e of i.sections) if (ic(e.text)) return !0;
        return !1;
      }
      class fu {
        constructor(e) {
          this.layoutVertexArray = new Xr(), this.indexArray = new Pn(), this.programConfigurations = e, this.segments = new zr(), this.dynamicLayoutVertexArray = new Ar(), this.opacityVertexArray = new Rr(), this.hasVisibleVertices = !1, this.placedSymbolArray = new ri();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(e, n, o, u) {
          this.isEmpty() || (o && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, om.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, lm.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, Cm, !0), this.opacityVertexBuffer.itemSize = 1), (o || u) && this.programConfigurations.upload(e));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      Fe("SymbolBuffers", fu);
      class mu {
        constructor(e, n, o) {
          this.layoutVertexArray = new e(), this.layoutAttributes = n, this.indexArray = new o(), this.segments = new zr(), this.collisionVertexArray = new Yr();
        }
        upload(e) {
          this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, cm.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      Fe("CollisionBuffers", mu);
      class bc {
        constructor(e) {
          this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((m) => m.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Xh([]), this.placementViewportMatrix = Xh([]);
          const n = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Vd(this.zoom, n["text-size"]), this.iconSizeData = Vd(this.zoom, n["icon-size"]);
          const o = this.layers[0].layout, u = o.get("symbol-sort-key"), f = o.get("symbol-z-order");
          this.canOverlap = du(o, "text-overlap", "text-allow-overlap") !== "never" || du(o, "icon-overlap", "icon-allow-overlap") !== "never" || o.get("text-ignore-placement") || o.get("icon-ignore-placement"), this.sortFeaturesByKey = f !== "viewport-y" && !u.isConstant(), this.sortFeaturesByY = (f === "viewport-y" || f === "auto" && !this.sortFeaturesByKey) && this.canOverlap, o.get("symbol-placement") === "point" && (this.writingModes = o.get("text-writing-mode").map((m) => v.ah[m])), this.stateDependentLayerIds = this.layers.filter((m) => m.isStateDependent()).map((m) => m.id), this.sourceID = e.sourceID;
        }
        createArrays() {
          this.text = new fu(new bo(this.layers, this.zoom, (e) => /^text/.test(e))), this.icon = new fu(new bo(this.layers, this.zoom, (e) => /^icon/.test(e))), this.glyphOffsetArray = new zi(), this.lineVertexArray = new Fi(), this.symbolInstances = new Gi(), this.textAnchorOffsets = new Mr();
        }
        calculateGlyphDependencies(e, n, o, u, f) {
          for (let m = 0; m < e.length; m++) if (n[e.charCodeAt(m)] = !0, (o || u) && f) {
            const S = Jc[e.charAt(m)];
            S && (n[S.charCodeAt(0)] = !0);
          }
        }
        populate(e, n, o) {
          const u = this.layers[0], f = u.layout, m = f.get("text-font"), S = f.get("text-field"), I = f.get("icon-image"), E = (S.value.kind !== "constant" || S.value.value instanceof Vr && !S.value.value.isEmpty() || S.value.value.toString().length > 0) && (m.value.kind !== "constant" || m.value.value.length > 0), D = I.value.kind !== "constant" || !!I.value.value || Object.keys(I.parameters).length > 0, N = f.get("symbol-sort-key");
          if (this.features = [], !E && !D) return;
          const j = n.iconDependencies, H = n.glyphDependencies, et = n.availableImages, rt = new Vi(this.zoom);
          for (const { feature: dt, id: vt, index: Nt, sourceLayerIndex: kt } of e) {
            const zt = u._featureFilter.needGeometry, Xt = wo(dt, zt);
            if (!u._featureFilter.filter(rt, Xt, o)) continue;
            let me, Ee;
            if (zt || (Xt.geometry = Ko(dt)), E) {
              const Ie = u.getValueAndResolveTokens("text-field", Xt, o, et), Se = Vr.factory(Ie), qe = this.hasRTLText = this.hasRTLText || Em(Se);
              (!qe || bs.getRTLTextPluginStatus() === "unavailable" || qe && bs.isParsed()) && (me = um(Se, u, Xt));
            }
            if (D) {
              const Ie = u.getValueAndResolveTokens("icon-image", Xt, o, et);
              Ee = Ie instanceof br ? Ie : br.fromString(Ie);
            }
            if (!me && !Ee) continue;
            const ti = this.sortFeaturesByKey ? N.evaluate(Xt, {}, o) : void 0;
            if (this.features.push({ id: vt, text: me, icon: Ee, index: Nt, sourceLayerIndex: kt, geometry: Xt.geometry, properties: dt.properties, type: Lm[dt.type], sortKey: ti }), Ee && (j[Ee.name] = !0), me) {
              const Ie = m.evaluate(Xt, {}, o).join(","), Se = f.get("text-rotation-alignment") !== "viewport" && f.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(v.ah.vertical) >= 0;
              for (const qe of me.sections) if (qe.image) j[qe.image.name] = !0;
              else {
                const Oe = El(me.toString()), Be = qe.fontStack || Ie, ae = H[Be] = H[Be] || {};
                this.calculateGlyphDependencies(qe.text, ae, Se, this.allowVerticalPlacement, Oe);
              }
            }
          }
          f.get("symbol-placement") === "line" && (this.features = function(dt) {
            const vt = {}, Nt = {}, kt = [];
            let zt = 0;
            function Xt(Ie) {
              kt.push(dt[Ie]), zt++;
            }
            function me(Ie, Se, qe) {
              const Oe = Nt[Ie];
              return delete Nt[Ie], Nt[Se] = Oe, kt[Oe].geometry[0].pop(), kt[Oe].geometry[0] = kt[Oe].geometry[0].concat(qe[0]), Oe;
            }
            function Ee(Ie, Se, qe) {
              const Oe = vt[Se];
              return delete vt[Se], vt[Ie] = Oe, kt[Oe].geometry[0].shift(), kt[Oe].geometry[0] = qe[0].concat(kt[Oe].geometry[0]), Oe;
            }
            function ti(Ie, Se, qe) {
              const Oe = qe ? Se[0][Se[0].length - 1] : Se[0][0];
              return `${Ie}:${Oe.x}:${Oe.y}`;
            }
            for (let Ie = 0; Ie < dt.length; Ie++) {
              const Se = dt[Ie], qe = Se.geometry, Oe = Se.text ? Se.text.toString() : null;
              if (!Oe) {
                Xt(Ie);
                continue;
              }
              const Be = ti(Oe, qe), ae = ti(Oe, qe, !0);
              if (Be in Nt && ae in vt && Nt[Be] !== vt[ae]) {
                const Ze = Ee(Be, ae, qe), je = me(Be, ae, kt[Ze].geometry);
                delete vt[Be], delete Nt[ae], Nt[ti(Oe, kt[je].geometry, !0)] = je, kt[Ze].geometry = null;
              } else Be in Nt ? me(Be, ae, qe) : ae in vt ? Ee(Be, ae, qe) : (Xt(Ie), vt[Be] = zt - 1, Nt[ae] = zt - 1);
            }
            return kt.filter((Ie) => Ie.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((dt, vt) => dt.sortKey - vt.sortKey);
        }
        update(e, n, o) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, n, this.layers, o), this.icon.programConfigurations.updatePaintArrays(e, n, this.layers, o));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(e) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(e, n) {
          const o = this.lineVertexArray.length;
          if (e.segment !== void 0) {
            let u = e.dist(n[e.segment + 1]), f = e.dist(n[e.segment]);
            const m = {};
            for (let S = e.segment + 1; S < n.length; S++) m[S] = { x: n[S].x, y: n[S].y, tileUnitDistanceFromAnchor: u }, S < n.length - 1 && (u += n[S + 1].dist(n[S]));
            for (let S = e.segment || 0; S >= 0; S--) m[S] = { x: n[S].x, y: n[S].y, tileUnitDistanceFromAnchor: f }, S > 0 && (f += n[S - 1].dist(n[S]));
            for (let S = 0; S < n.length; S++) {
              const I = m[S];
              this.lineVertexArray.emplaceBack(I.x, I.y, I.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: o, lineLength: this.lineVertexArray.length - o };
        }
        addSymbols(e, n, o, u, f, m, S, I, E, D, N, j) {
          const H = e.indexArray, et = e.layoutVertexArray, rt = e.segments.prepareSegment(4 * n.length, et, H, this.canOverlap ? m.sortKey : void 0), dt = this.glyphOffsetArray.length, vt = rt.vertexLength, Nt = this.allowVerticalPlacement && S === v.ah.vertical ? Math.PI / 2 : 0, kt = m.text && m.text.sections;
          for (let zt = 0; zt < n.length; zt++) {
            const { tl: Xt, tr: me, bl: Ee, br: ti, tex: Ie, pixelOffsetTL: Se, pixelOffsetBR: qe, minFontScaleX: Oe, minFontScaleY: Be, glyphOffset: ae, isSDF: Ze, sectionIndex: je } = n[zt], li = rt.vertexLength, Ji = ae[1];
            Ph(et, I.x, I.y, Xt.x, Ji + Xt.y, Ie.x, Ie.y, o, Ze, Se.x, Se.y, Oe, Be), Ph(et, I.x, I.y, me.x, Ji + me.y, Ie.x + Ie.w, Ie.y, o, Ze, qe.x, Se.y, Oe, Be), Ph(et, I.x, I.y, Ee.x, Ji + Ee.y, Ie.x, Ie.y + Ie.h, o, Ze, Se.x, qe.y, Oe, Be), Ph(et, I.x, I.y, ti.x, Ji + ti.y, Ie.x + Ie.w, Ie.y + Ie.h, o, Ze, qe.x, qe.y, Oe, Be), pu(e.dynamicLayoutVertexArray, I, Nt), H.emplaceBack(li, li + 1, li + 2), H.emplaceBack(li + 1, li + 2, li + 3), rt.vertexLength += 4, rt.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(ae[0]), zt !== n.length - 1 && je === n[zt + 1].sectionIndex || e.programConfigurations.populatePaintArrays(et.length, m, m.index, {}, j, kt && kt[je]);
          }
          e.placedSymbolArray.emplaceBack(I.x, I.y, dt, this.glyphOffsetArray.length - dt, vt, E, D, I.segment, o ? o[0] : 0, o ? o[1] : 0, u[0], u[1], S, 0, !1, 0, N);
        }
        _addCollisionDebugVertex(e, n, o, u, f, m) {
          return n.emplaceBack(0, 0), e.emplaceBack(o.x, o.y, u, f, Math.round(m.x), Math.round(m.y));
        }
        addCollisionDebugVertices(e, n, o, u, f, m, S) {
          const I = f.segments.prepareSegment(4, f.layoutVertexArray, f.indexArray), E = I.vertexLength, D = f.layoutVertexArray, N = f.collisionVertexArray, j = S.anchorX, H = S.anchorY;
          this._addCollisionDebugVertex(D, N, m, j, H, new q(e, n)), this._addCollisionDebugVertex(D, N, m, j, H, new q(o, n)), this._addCollisionDebugVertex(D, N, m, j, H, new q(o, u)), this._addCollisionDebugVertex(D, N, m, j, H, new q(e, u)), I.vertexLength += 4;
          const et = f.indexArray;
          et.emplaceBack(E, E + 1), et.emplaceBack(E + 1, E + 2), et.emplaceBack(E + 2, E + 3), et.emplaceBack(E + 3, E), I.primitiveLength += 4;
        }
        addDebugCollisionBoxes(e, n, o, u) {
          for (let f = e; f < n; f++) {
            const m = this.collisionBoxArray.get(f);
            this.addCollisionDebugVertices(m.x1, m.y1, m.x2, m.y2, u ? this.textCollisionBox : this.iconCollisionBox, m.anchorPoint, o);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new mu(Yi, Id.members, As), this.iconCollisionBox = new mu(Yi, Id.members, As);
          for (let e = 0; e < this.symbolInstances.length; e++) {
            const n = this.symbolInstances.get(e);
            this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(e, n, o, u, f, m, S, I, E) {
          const D = {};
          for (let N = n; N < o; N++) {
            const j = e.get(N);
            D.textBox = { x1: j.x1, y1: j.y1, x2: j.x2, y2: j.y2, anchorPointX: j.anchorPointX, anchorPointY: j.anchorPointY }, D.textFeatureIndex = j.featureIndex;
            break;
          }
          for (let N = u; N < f; N++) {
            const j = e.get(N);
            D.verticalTextBox = { x1: j.x1, y1: j.y1, x2: j.x2, y2: j.y2, anchorPointX: j.anchorPointX, anchorPointY: j.anchorPointY }, D.verticalTextFeatureIndex = j.featureIndex;
            break;
          }
          for (let N = m; N < S; N++) {
            const j = e.get(N);
            D.iconBox = { x1: j.x1, y1: j.y1, x2: j.x2, y2: j.y2, anchorPointX: j.anchorPointX, anchorPointY: j.anchorPointY }, D.iconFeatureIndex = j.featureIndex;
            break;
          }
          for (let N = I; N < E; N++) {
            const j = e.get(N);
            D.verticalIconBox = { x1: j.x1, y1: j.y1, x2: j.x2, y2: j.y2, anchorPointX: j.anchorPointX, anchorPointY: j.anchorPointY }, D.verticalIconFeatureIndex = j.featureIndex;
            break;
          }
          return D;
        }
        deserializeCollisionBoxes(e) {
          this.collisionArrays = [];
          for (let n = 0; n < this.symbolInstances.length; n++) {
            const o = this.symbolInstances.get(n);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, o.textBoxStartIndex, o.textBoxEndIndex, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o.iconBoxStartIndex, o.iconBoxEndIndex, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(e, n) {
          const o = e.placedSymbolArray.get(n), u = o.vertexStartIndex + 4 * o.numGlyphs;
          for (let f = o.vertexStartIndex; f < u; f += 4) e.indexArray.emplaceBack(f, f + 1, f + 2), e.indexArray.emplaceBack(f + 1, f + 2, f + 3);
        }
        getSortedSymbolIndexes(e) {
          if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const n = Math.sin(e), o = Math.cos(e), u = [], f = [], m = [];
          for (let S = 0; S < this.symbolInstances.length; ++S) {
            m.push(S);
            const I = this.symbolInstances.get(S);
            u.push(0 | Math.round(n * I.anchorX + o * I.anchorY)), f.push(I.featureIndex);
          }
          return m.sort((S, I) => u[S] - u[I] || f[I] - f[S]), m;
        }
        addToSortKeyRanges(e, n) {
          const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          o && o.sortKey === n ? o.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
        }
        sortFeatures(e) {
          if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const n of this.symbolInstanceIndexes) {
              const o = this.symbolInstances.get(n);
              this.featureSortOrder.push(o.featureIndex), [o.rightJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.leftJustifiedTextSymbolIndex].forEach((u, f, m) => {
                u >= 0 && m.indexOf(u) === f && this.addIndicesForPlacedSymbol(this.text, u);
              }), o.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, o.verticalPlacedTextSymbolIndex), o.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.placedIconSymbolIndex), o.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let $d, Zd;
      Fe("SymbolBucket", bc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), bc.MAX_GLYPHS = 65535, bc.addDynamicAttributes = pu;
      var gu = { get paint() {
        return Zd = Zd || new h({ "icon-opacity": new s(K.paint_symbol["icon-opacity"]), "icon-color": new s(K.paint_symbol["icon-color"]), "icon-halo-color": new s(K.paint_symbol["icon-halo-color"]), "icon-halo-width": new s(K.paint_symbol["icon-halo-width"]), "icon-halo-blur": new s(K.paint_symbol["icon-halo-blur"]), "icon-translate": new t(K.paint_symbol["icon-translate"]), "icon-translate-anchor": new t(K.paint_symbol["icon-translate-anchor"]), "text-opacity": new s(K.paint_symbol["text-opacity"]), "text-color": new s(K.paint_symbol["text-color"], { runtimeType: ki, getOverride: (i) => i.textColor, hasOverride: (i) => !!i.textColor }), "text-halo-color": new s(K.paint_symbol["text-halo-color"]), "text-halo-width": new s(K.paint_symbol["text-halo-width"]), "text-halo-blur": new s(K.paint_symbol["text-halo-blur"]), "text-translate": new t(K.paint_symbol["text-translate"]), "text-translate-anchor": new t(K.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return $d = $d || new h({ "symbol-placement": new t(K.layout_symbol["symbol-placement"]), "symbol-spacing": new t(K.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new t(K.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new s(K.layout_symbol["symbol-sort-key"]), "symbol-z-order": new t(K.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new t(K.layout_symbol["icon-allow-overlap"]), "icon-overlap": new t(K.layout_symbol["icon-overlap"]), "icon-ignore-placement": new t(K.layout_symbol["icon-ignore-placement"]), "icon-optional": new t(K.layout_symbol["icon-optional"]), "icon-rotation-alignment": new t(K.layout_symbol["icon-rotation-alignment"]), "icon-size": new s(K.layout_symbol["icon-size"]), "icon-text-fit": new t(K.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new t(K.layout_symbol["icon-text-fit-padding"]), "icon-image": new s(K.layout_symbol["icon-image"]), "icon-rotate": new s(K.layout_symbol["icon-rotate"]), "icon-padding": new s(K.layout_symbol["icon-padding"]), "icon-keep-upright": new t(K.layout_symbol["icon-keep-upright"]), "icon-offset": new s(K.layout_symbol["icon-offset"]), "icon-anchor": new s(K.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new t(K.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new t(K.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new t(K.layout_symbol["text-rotation-alignment"]), "text-field": new s(K.layout_symbol["text-field"]), "text-font": new s(K.layout_symbol["text-font"]), "text-size": new s(K.layout_symbol["text-size"]), "text-max-width": new s(K.layout_symbol["text-max-width"]), "text-line-height": new t(K.layout_symbol["text-line-height"]), "text-letter-spacing": new s(K.layout_symbol["text-letter-spacing"]), "text-justify": new s(K.layout_symbol["text-justify"]), "text-radial-offset": new s(K.layout_symbol["text-radial-offset"]), "text-variable-anchor": new t(K.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new s(K.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new s(K.layout_symbol["text-anchor"]), "text-max-angle": new t(K.layout_symbol["text-max-angle"]), "text-writing-mode": new t(K.layout_symbol["text-writing-mode"]), "text-rotate": new s(K.layout_symbol["text-rotate"]), "text-padding": new t(K.layout_symbol["text-padding"]), "text-keep-upright": new t(K.layout_symbol["text-keep-upright"]), "text-transform": new s(K.layout_symbol["text-transform"]), "text-offset": new s(K.layout_symbol["text-offset"]), "text-allow-overlap": new t(K.layout_symbol["text-allow-overlap"]), "text-overlap": new t(K.layout_symbol["text-overlap"]), "text-ignore-placement": new t(K.layout_symbol["text-ignore-placement"]), "text-optional": new t(K.layout_symbol["text-optional"]) });
      } };
      class Gd {
        constructor(e) {
          if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = e.property.overrides ? e.property.overrides.runtimeType : lr, this.defaultValue = e;
        }
        evaluate(e) {
          if (e.formattedSection) {
            const n = this.defaultValue.property.overrides;
            if (n && n.hasOverride(e.formattedSection)) return n.getOverride(e.formattedSection);
          }
          return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(e) {
          this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      Fe("FormatSectionOverride", Gd, { omit: ["defaultValue"] });
      class Ih extends _ {
        constructor(e) {
          super(e, gu);
        }
        recalculate(e, n) {
          if (super.recalculate(e, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const o = this.layout.get("text-writing-mode");
            if (o) {
              const u = [];
              for (const f of o) u.indexOf(f) < 0 && u.push(f);
              this.layout._values["text-writing-mode"] = u;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(e, n, o, u) {
          const f = this.layout.get(e).evaluate(n, {}, o, u), m = this._unevaluatedLayout._values[e];
          return m.isDataDriven() || zn(m.value) || !f ? f : function(S, I) {
            return I.replace(/{([^{}]+)}/g, (E, D) => S && D in S ? String(S[D]) : "");
          }(n.properties, f);
        }
        createBucket(e) {
          return new bc(e);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const e of gu.paint.overridableProperties) {
            if (!Ih.hasPaintOverride(this.layout, e)) continue;
            const n = this.paint.get(e), o = new Gd(n), u = new zs(o, n.property.specification);
            let f = null;
            f = n.value.kind === "constant" || n.value.kind === "source" ? new un("source", u) : new Ds("composite", u, n.value.zoomStops), this.paint._values[e] = new es(n.property, f, n.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(e, n, o) {
          return !(!this.layout || n.isDataDriven() || o.isDataDriven()) && Ih.hasPaintOverride(this.layout, e);
        }
        static hasPaintOverride(e, n) {
          const o = e.get("text-field"), u = gu.paint.properties[n];
          let f = !1;
          const m = (S) => {
            for (const I of S) if (u.overrides && u.overrides.hasOverride(I)) return void (f = !0);
          };
          if (o.value.kind === "constant" && o.value.value instanceof Vr) m(o.value.value.sections);
          else if (o.value.kind === "source") {
            const S = (E) => {
              f || (E instanceof ls && dr(E.value) === qi ? m(E.value.sections) : E instanceof Xa ? m(E.sections) : E.eachChild(S));
            }, I = o.value;
            I._styleExpression && S(I._styleExpression.expression);
          }
          return f;
        }
      }
      let Wd;
      var Mm = { get paint() {
        return Wd = Wd || new h({ "background-color": new t(K.paint_background["background-color"]), "background-pattern": new r(K.paint_background["background-pattern"]), "background-opacity": new t(K.paint_background["background-opacity"]) });
      } };
      class zm extends _ {
        constructor(e) {
          super(e, Mm);
        }
      }
      let Hd;
      var Dm = { get paint() {
        return Hd = Hd || new h({ "raster-opacity": new t(K.paint_raster["raster-opacity"]), "raster-hue-rotate": new t(K.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new t(K.paint_raster["raster-brightness-min"]), "raster-brightness-max": new t(K.paint_raster["raster-brightness-max"]), "raster-saturation": new t(K.paint_raster["raster-saturation"]), "raster-contrast": new t(K.paint_raster["raster-contrast"]), "raster-resampling": new t(K.paint_raster["raster-resampling"]), "raster-fade-duration": new t(K.paint_raster["raster-fade-duration"]) });
      } };
      class Nm extends _ {
        constructor(e) {
          super(e, Dm);
        }
      }
      class Fm extends _ {
        constructor(e) {
          super(e, {}), this.onAdd = (n) => {
            this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl);
          }, this.onRemove = (n) => {
            this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl);
          }, this.implementation = e;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class Rm {
        constructor(e) {
          this._methodToThrottle = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const yu = 63710088e-1;
      class _l {
        constructor(e, n) {
          if (isNaN(e) || isNaN(n)) throw new Error(`Invalid LngLat object: (${e}, ${n})`);
          if (this.lng = +e, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new _l(pe(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(e) {
          const n = Math.PI / 180, o = this.lat * n, u = e.lat * n, f = Math.sin(o) * Math.sin(u) + Math.cos(o) * Math.cos(u) * Math.cos((e.lng - this.lng) * n);
          return yu * Math.acos(Math.min(f, 1));
        }
        static convert(e) {
          if (e instanceof _l) return e;
          if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new _l(Number(e[0]), Number(e[1]));
          if (!Array.isArray(e) && typeof e == "object" && e !== null) return new _l(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Xd = 2 * Math.PI * yu;
      function Yd(i) {
        return Xd * Math.cos(i * Math.PI / 180);
      }
      function Jd(i) {
        return (180 + i) / 360;
      }
      function Kd(i) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360;
      }
      function Qd(i, e) {
        return i / Yd(e);
      }
      function _u(i) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90;
      }
      class eh {
        constructor(e, n, o = 0) {
          this.x = +e, this.y = +n, this.z = +o;
        }
        static fromLngLat(e, n = 0) {
          const o = _l.convert(e);
          return new eh(Jd(o.lng), Kd(o.lat), Qd(n, o.lat));
        }
        toLngLat() {
          return new _l(360 * this.x - 180, _u(this.y));
        }
        toAltitude() {
          return this.z * Yd(_u(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Xd * (e = _u(this.y), 1 / Math.cos(e * Math.PI / 180));
          var e;
        }
      }
      function tp(i, e, n) {
        var o = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
        return [i * o - 2 * Math.PI * 6378137 / 2, e * o - 2 * Math.PI * 6378137 / 2];
      }
      class vu {
        constructor(e, n, o) {
          if (!function(u, f, m) {
            return !(u < 0 || u > 25 || m < 0 || m >= Math.pow(2, u) || f < 0 || f >= Math.pow(2, u));
          }(e, n, o)) throw new Error(`x=${n}, y=${o}, z=${e} outside of bounds. 0<=x<${Math.pow(2, e)}, 0<=y<${Math.pow(2, e)} 0<=z<=25 `);
          this.z = e, this.x = n, this.y = o, this.key = ih(0, e, e, n, o);
        }
        equals(e) {
          return this.z === e.z && this.x === e.x && this.y === e.y;
        }
        url(e, n, o) {
          const u = (m = this.y, S = this.z, I = tp(256 * (f = this.x), 256 * (m = Math.pow(2, S) - m - 1), S), E = tp(256 * (f + 1), 256 * (m + 1), S), I[0] + "," + I[1] + "," + E[0] + "," + E[1]);
          var f, m, S, I, E;
          const D = function(N, j, H) {
            let et, rt = "";
            for (let dt = N; dt > 0; dt--) et = 1 << dt - 1, rt += (j & et ? 1 : 0) + (H & et ? 2 : 0);
            return rt;
          }(this.z, this.x, this.y);
          return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(o === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, D).replace(/{bbox-epsg-3857}/g, u);
        }
        isChildOf(e) {
          const n = this.z - e.z;
          return n > 0 && e.x === this.x >> n && e.y === this.y >> n;
        }
        getTilePoint(e) {
          const n = Math.pow(2, this.z);
          return new q((e.x * n - this.x) * tr, (e.y * n - this.y) * tr);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class ep {
        constructor(e, n) {
          this.wrap = e, this.canonical = n, this.key = ih(e, n.z, n.z, n.x, n.y);
        }
      }
      class js {
        constructor(e, n, o, u, f) {
          if (e < o) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${o}`);
          this.overscaledZ = e, this.wrap = n, this.canonical = new vu(o, +u, +f), this.key = ih(n, e, o, u, f);
        }
        clone() {
          return new js(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(e) {
          return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
        }
        scaledTo(e) {
          if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
          const n = this.canonical.z - e;
          return e > this.canonical.z ? new js(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new js(e, this.wrap, e, this.canonical.x >> n, this.canonical.y >> n);
        }
        calculateScaledKey(e, n) {
          if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
          const o = this.canonical.z - e;
          return e > this.canonical.z ? ih(this.wrap * +n, e, this.canonical.z, this.canonical.x, this.canonical.y) : ih(this.wrap * +n, e, e, this.canonical.x >> o, this.canonical.y >> o);
        }
        isChildOf(e) {
          if (e.wrap !== this.wrap) return !1;
          const n = this.canonical.z - e.canonical.z;
          return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> n && e.canonical.y === this.canonical.y >> n;
        }
        children(e) {
          if (this.overscaledZ >= e) return [new js(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const n = this.canonical.z + 1, o = 2 * this.canonical.x, u = 2 * this.canonical.y;
          return [new js(n, this.wrap, n, o, u), new js(n, this.wrap, n, o + 1, u), new js(n, this.wrap, n, o, u + 1), new js(n, this.wrap, n, o + 1, u + 1)];
        }
        isLessThan(e) {
          return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
        }
        wrapped() {
          return new js(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(e) {
          return new js(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new ep(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(e) {
          return this.canonical.getTilePoint(new eh(e.x - this.wrap, e.y));
        }
      }
      function ih(i, e, n, o, u) {
        (i *= 2) < 0 && (i = -1 * i - 1);
        const f = 1 << n;
        return (f * f * i + f * u + o).toString(36) + n.toString(36) + e.toString(36);
      }
      Fe("CanonicalTileID", vu), Fe("OverscaledTileID", js, { omit: ["posMatrix"] });
      class ip {
        constructor(e, n, o, u = 1, f = 1, m = 1, S = 0) {
          if (this.uid = e, n.height !== n.width) throw new RangeError("DEM tiles must be square");
          if (o && !["mapbox", "terrarium", "custom"].includes(o)) return void Pt(`"${o}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = n.height;
          const I = this.dim = n.height - 2;
          switch (this.data = new Uint32Array(n.data.buffer), o) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = u, this.greenFactor = f, this.blueFactor = m, this.baseShift = S;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let E = 0; E < I; E++) this.data[this._idx(-1, E)] = this.data[this._idx(0, E)], this.data[this._idx(I, E)] = this.data[this._idx(I - 1, E)], this.data[this._idx(E, -1)] = this.data[this._idx(E, 0)], this.data[this._idx(E, I)] = this.data[this._idx(E, I - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(I, -1)] = this.data[this._idx(I - 1, 0)], this.data[this._idx(-1, I)] = this.data[this._idx(0, I - 1)], this.data[this._idx(I, I)] = this.data[this._idx(I - 1, I - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let E = 0; E < I; E++) for (let D = 0; D < I; D++) {
            const N = this.get(E, D);
            N > this.max && (this.max = N), N < this.min && (this.min = N);
          }
        }
        get(e, n) {
          const o = new Uint8Array(this.data.buffer), u = 4 * this._idx(e, n);
          return this.unpack(o[u], o[u + 1], o[u + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(e, n) {
          if (e < -1 || e >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (n + 1) * this.stride + (e + 1);
        }
        unpack(e, n, o) {
          return e * this.redFactor + n * this.greenFactor + o * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new Os({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(e, n, o) {
          if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
          let u = n * this.dim, f = n * this.dim + this.dim, m = o * this.dim, S = o * this.dim + this.dim;
          switch (n) {
            case -1:
              u = f - 1;
              break;
            case 1:
              f = u + 1;
          }
          switch (o) {
            case -1:
              m = S - 1;
              break;
            case 1:
              S = m + 1;
          }
          const I = -n * this.dim, E = -o * this.dim;
          for (let D = m; D < S; D++) for (let N = u; N < f; N++) this.data[this._idx(N, D)] = e.data[this._idx(N + I, D + E)];
        }
      }
      Fe("DEMData", ip);
      class rp {
        constructor(e) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let n = 0; n < e.length; n++) {
            const o = e[n];
            this._stringToNumber[o] = n, this._numberToString[n] = o;
          }
        }
        encode(e) {
          return this._stringToNumber[e];
        }
        decode(e) {
          if (e >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[e];
        }
      }
      class np {
        constructor(e, n, o, u, f) {
          this.type = "Feature", this._vectorTileFeature = e, e._z = n, e._x = o, e._y = u, this.properties = e.properties, this.id = f;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(e) {
          this._geometry = e;
        }
        toJSON() {
          const e = { geometry: this.geometry };
          for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (e[n] = this[n]);
          return e;
        }
      }
      class sp {
        constructor(e, n) {
          this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new po(tr, 16, 0), this.grid3D = new po(tr, 16, 0), this.featureIndexArray = new ar(), this.promoteId = n;
        }
        insert(e, n, o, u, f, m) {
          const S = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(o, u, f);
          const I = m ? this.grid3D : this.grid;
          for (let E = 0; E < n.length; E++) {
            const D = n[E], N = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let j = 0; j < D.length; j++) {
              const H = D[j];
              N[0] = Math.min(N[0], H.x), N[1] = Math.min(N[1], H.y), N[2] = Math.max(N[2], H.x), N[3] = Math.max(N[3], H.y);
            }
            N[0] < tr && N[1] < tr && N[2] >= 0 && N[3] >= 0 && I.insert(S, N[0], N[1], N[2], N[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new ml.VectorTile(new ou(this.rawTileData)).layers, this.sourceLayerCoder = new rp(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(e, n, o, u) {
          this.loadVTLayers();
          const f = e.params || {}, m = tr / e.tileSize / e.scale, S = dn(f.filter), I = e.queryGeometry, E = e.queryPadding * m, D = op(I), N = this.grid.query(D.minX - E, D.minY - E, D.maxX + E, D.maxY + E), j = op(e.cameraQueryGeometry), H = this.grid3D.query(j.minX - E, j.minY - E, j.maxX + E, j.maxY + E, (dt, vt, Nt, kt) => function(zt, Xt, me, Ee, ti) {
            for (const Se of zt) if (Xt <= Se.x && me <= Se.y && Ee >= Se.x && ti >= Se.y) return !0;
            const Ie = [new q(Xt, me), new q(Xt, ti), new q(Ee, ti), new q(Ee, me)];
            if (zt.length > 2) {
              for (const Se of Ie) if (Ao(zt, Se)) return !0;
            }
            for (let Se = 0; Se < zt.length - 1; Se++) if (Uc(zt[Se], zt[Se + 1], Ie)) return !0;
            return !1;
          }(e.cameraQueryGeometry, dt - E, vt - E, Nt + E, kt + E));
          for (const dt of H) N.push(dt);
          N.sort(Bm);
          const et = {};
          let rt;
          for (let dt = 0; dt < N.length; dt++) {
            const vt = N[dt];
            if (vt === rt) continue;
            rt = vt;
            const Nt = this.featureIndexArray.get(vt);
            let kt = null;
            this.loadMatchingFeature(et, Nt.bucketIndex, Nt.sourceLayerIndex, Nt.featureIndex, S, f.layers, f.availableImages, n, o, u, (zt, Xt, me) => (kt || (kt = Ko(zt)), Xt.queryIntersectsFeature(I, zt, me, kt, this.z, e.transform, m, e.pixelPosMatrix)));
          }
          return et;
        }
        loadMatchingFeature(e, n, o, u, f, m, S, I, E, D, N) {
          const j = this.bucketLayerIDs[n];
          if (m && !function(dt, vt) {
            for (let Nt = 0; Nt < dt.length; Nt++) if (vt.indexOf(dt[Nt]) >= 0) return !0;
            return !1;
          }(m, j)) return;
          const H = this.sourceLayerCoder.decode(o), et = this.vtLayers[H].feature(u);
          if (f.needGeometry) {
            const dt = wo(et, !0);
            if (!f.filter(new Vi(this.tileID.overscaledZ), dt, this.tileID.canonical)) return;
          } else if (!f.filter(new Vi(this.tileID.overscaledZ), et)) return;
          const rt = this.getId(et, H);
          for (let dt = 0; dt < j.length; dt++) {
            const vt = j[dt];
            if (m && m.indexOf(vt) < 0) continue;
            const Nt = I[vt];
            if (!Nt) continue;
            let kt = {};
            rt && D && (kt = D.getState(Nt.sourceLayer || "_geojsonTileLayer", rt));
            const zt = jt({}, E[vt]);
            zt.paint = ap(zt.paint, Nt.paint, et, kt, S), zt.layout = ap(zt.layout, Nt.layout, et, kt, S);
            const Xt = !N || N(et, Nt, kt);
            if (!Xt) continue;
            const me = new np(et, this.z, this.x, this.y, rt);
            me.layer = zt;
            let Ee = e[vt];
            Ee === void 0 && (Ee = e[vt] = []), Ee.push({ featureIndex: u, feature: me, intersectionZ: Xt });
          }
        }
        lookupSymbolFeatures(e, n, o, u, f, m, S, I) {
          const E = {};
          this.loadVTLayers();
          const D = dn(f);
          for (const N of e) this.loadMatchingFeature(E, o, u, N, D, m, S, I, n);
          return E;
        }
        hasLayer(e) {
          for (const n of this.bucketLayerIDs) for (const o of n) if (e === o) return !0;
          return !1;
        }
        getId(e, n) {
          let o = e.id;
          return this.promoteId && (o = e.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof o == "boolean" && (o = Number(o))), o;
        }
      }
      function ap(i, e, n, o, u) {
        return le(i, (f, m) => {
          const S = e instanceof p ? e.get(m) : null;
          return S && S.evaluate ? S.evaluate(n, o, u) : S;
        });
      }
      function op(i) {
        let e = 1 / 0, n = 1 / 0, o = -1 / 0, u = -1 / 0;
        for (const f of i) e = Math.min(e, f.x), n = Math.min(n, f.y), o = Math.max(o, f.x), u = Math.max(u, f.y);
        return { minX: e, minY: n, maxX: o, maxY: u };
      }
      function Bm(i, e) {
        return e - i;
      }
      function lp(i, e, n, o, u) {
        const f = [];
        for (let m = 0; m < i.length; m++) {
          const S = i[m];
          let I;
          for (let E = 0; E < S.length - 1; E++) {
            let D = S[E], N = S[E + 1];
            D.x < e && N.x < e || (D.x < e ? D = new q(e, D.y + (e - D.x) / (N.x - D.x) * (N.y - D.y))._round() : N.x < e && (N = new q(e, D.y + (e - D.x) / (N.x - D.x) * (N.y - D.y))._round()), D.y < n && N.y < n || (D.y < n ? D = new q(D.x + (n - D.y) / (N.y - D.y) * (N.x - D.x), n)._round() : N.y < n && (N = new q(D.x + (n - D.y) / (N.y - D.y) * (N.x - D.x), n)._round()), D.x >= o && N.x >= o || (D.x >= o ? D = new q(o, D.y + (o - D.x) / (N.x - D.x) * (N.y - D.y))._round() : N.x >= o && (N = new q(o, D.y + (o - D.x) / (N.x - D.x) * (N.y - D.y))._round()), D.y >= u && N.y >= u || (D.y >= u ? D = new q(D.x + (u - D.y) / (N.y - D.y) * (N.x - D.x), u)._round() : N.y >= u && (N = new q(D.x + (u - D.y) / (N.y - D.y) * (N.x - D.x), u)._round()), I && D.equals(I[I.length - 1]) || (I = [D], f.push(I)), I.push(N)))));
          }
        }
        return f;
      }
      Fe("FeatureIndex", sp, { omit: ["rawTileData", "sourceLayerCoder"] });
      class vl extends q {
        constructor(e, n, o, u) {
          super(e, n), this.angle = o, u !== void 0 && (this.segment = u);
        }
        clone() {
          return new vl(this.x, this.y, this.angle, this.segment);
        }
      }
      function cp(i, e, n, o, u) {
        if (e.segment === void 0 || n === 0) return !0;
        let f = e, m = e.segment + 1, S = 0;
        for (; S > -n / 2; ) {
          if (m--, m < 0) return !1;
          S -= i[m].dist(f), f = i[m];
        }
        S += i[m].dist(i[m + 1]), m++;
        const I = [];
        let E = 0;
        for (; S < n / 2; ) {
          const D = i[m], N = i[m + 1];
          if (!N) return !1;
          let j = i[m - 1].angleTo(D) - D.angleTo(N);
          for (j = Math.abs((j + 3 * Math.PI) % (2 * Math.PI) - Math.PI), I.push({ distance: S, angleDelta: j }), E += j; S - I[0].distance > o; ) E -= I.shift().angleDelta;
          if (E > u) return !1;
          m++, S += D.dist(N);
        }
        return !0;
      }
      function hp(i) {
        let e = 0;
        for (let n = 0; n < i.length - 1; n++) e += i[n].dist(i[n + 1]);
        return e;
      }
      function up(i, e, n) {
        return i ? 0.6 * e * n : 0;
      }
      function dp(i, e) {
        return Math.max(i ? i.right - i.left : 0, e ? e.right - e.left : 0);
      }
      function Om(i, e, n, o, u, f) {
        const m = up(n, u, f), S = dp(n, o) * f;
        let I = 0;
        const E = hp(i) / 2;
        for (let D = 0; D < i.length - 1; D++) {
          const N = i[D], j = i[D + 1], H = N.dist(j);
          if (I + H > E) {
            const et = (E - I) / H, rt = Zr.number(N.x, j.x, et), dt = Zr.number(N.y, j.y, et), vt = new vl(rt, dt, j.angleTo(N), D);
            return vt._round(), !m || cp(i, vt, S, m, e) ? vt : void 0;
          }
          I += H;
        }
      }
      function jm(i, e, n, o, u, f, m, S, I) {
        const E = up(o, f, m), D = dp(o, u), N = D * m, j = i[0].x === 0 || i[0].x === I || i[0].y === 0 || i[0].y === I;
        return e - N < e / 4 && (e = N + e / 4), pp(i, j ? e / 2 * S % e : (D / 2 + 2 * f) * m * S % e, e, E, n, N, j, !1, I);
      }
      function pp(i, e, n, o, u, f, m, S, I) {
        const E = f / 2, D = hp(i);
        let N = 0, j = e - n, H = [];
        for (let et = 0; et < i.length - 1; et++) {
          const rt = i[et], dt = i[et + 1], vt = rt.dist(dt), Nt = dt.angleTo(rt);
          for (; j + n < N + vt; ) {
            j += n;
            const kt = (j - N) / vt, zt = Zr.number(rt.x, dt.x, kt), Xt = Zr.number(rt.y, dt.y, kt);
            if (zt >= 0 && zt < I && Xt >= 0 && Xt < I && j - E >= 0 && j + E <= D) {
              const me = new vl(zt, Xt, Nt, et);
              me._round(), o && !cp(i, me, f, o, u) || H.push(me);
            }
          }
          N += vt;
        }
        return S || H.length || m || (H = pp(i, N / 2, n, o, u, f, m, !0, I)), H;
      }
      Fe("Anchor", vl);
      const wc = ns;
      function fp(i, e, n, o) {
        const u = [], f = i.image, m = f.pixelRatio, S = f.paddedRect.w - 2 * wc, I = f.paddedRect.h - 2 * wc;
        let E = { x1: i.left, y1: i.top, x2: i.right, y2: i.bottom };
        const D = f.stretchX || [[0, S]], N = f.stretchY || [[0, I]], j = (ae, Ze) => ae + Ze[1] - Ze[0], H = D.reduce(j, 0), et = N.reduce(j, 0), rt = S - H, dt = I - et;
        let vt = 0, Nt = H, kt = 0, zt = et, Xt = 0, me = rt, Ee = 0, ti = dt;
        if (f.content && o) {
          const ae = f.content, Ze = ae[2] - ae[0], je = ae[3] - ae[1];
          (f.textFitWidth || f.textFitHeight) && (E = qd(i)), vt = kh(D, 0, ae[0]), kt = kh(N, 0, ae[1]), Nt = kh(D, ae[0], ae[2]), zt = kh(N, ae[1], ae[3]), Xt = ae[0] - vt, Ee = ae[1] - kt, me = Ze - Nt, ti = je - zt;
        }
        const Ie = E.x1, Se = E.y1, qe = E.x2 - Ie, Oe = E.y2 - Se, Be = (ae, Ze, je, li) => {
          const Ji = Th(ae.stretch - vt, Nt, qe, Ie), Hi = Lh(ae.fixed - Xt, me, ae.stretch, H), Jr = Th(Ze.stretch - kt, zt, Oe, Se), da = Lh(Ze.fixed - Ee, ti, Ze.stretch, et), gn = Th(je.stretch - vt, Nt, qe, Ie), Kr = Lh(je.fixed - Xt, me, je.stretch, H), Rn = Th(li.stretch - kt, zt, Oe, Se), Bn = Lh(li.fixed - Ee, ti, li.stretch, et), On = new q(Ji, Jr), xr = new q(gn, Jr), Qr = new q(gn, Rn), kn = new q(Ji, Rn), yn = new q(Hi / m, da / m), jn = new q(Kr / m, Bn / m), _n = e * Math.PI / 180;
          if (_n) {
            const Bi = Math.sin(_n), er = Math.cos(_n), or = [er, -Bi, Bi, er];
            On._matMult(or), xr._matMult(or), kn._matMult(or), Qr._matMult(or);
          }
          const qs = ae.stretch + ae.fixed, ss = Ze.stretch + Ze.fixed;
          return { tl: On, tr: xr, bl: kn, br: Qr, tex: { x: f.paddedRect.x + wc + qs, y: f.paddedRect.y + wc + ss, w: je.stretch + je.fixed - qs, h: li.stretch + li.fixed - ss }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: yn, pixelOffsetBR: jn, minFontScaleX: me / m / qe, minFontScaleY: ti / m / Oe, isSDF: n };
        };
        if (o && (f.stretchX || f.stretchY)) {
          const ae = mp(D, rt, H), Ze = mp(N, dt, et);
          for (let je = 0; je < ae.length - 1; je++) {
            const li = ae[je], Ji = ae[je + 1];
            for (let Hi = 0; Hi < Ze.length - 1; Hi++) u.push(Be(li, Ze[Hi], Ji, Ze[Hi + 1]));
          }
        } else u.push(Be({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: S + 1 }, { fixed: 0, stretch: I + 1 }));
        return u;
      }
      function kh(i, e, n) {
        let o = 0;
        for (const u of i) o += Math.max(e, Math.min(n, u[1])) - Math.max(e, Math.min(n, u[0]));
        return o;
      }
      function mp(i, e, n) {
        const o = [{ fixed: -wc, stretch: 0 }];
        for (const [u, f] of i) {
          const m = o[o.length - 1];
          o.push({ fixed: u - m.stretch, stretch: m.stretch }), o.push({ fixed: u - m.stretch, stretch: m.stretch + (f - u) });
        }
        return o.push({ fixed: e + wc, stretch: n }), o;
      }
      function Th(i, e, n, o) {
        return i / e * n + o;
      }
      function Lh(i, e, n, o) {
        return i - e * n / o;
      }
      class Ch {
        constructor(e, n, o, u, f, m, S, I, E, D) {
          var N;
          if (this.boxStartIndex = e.length, E) {
            let j = m.top, H = m.bottom;
            const et = m.collisionPadding;
            et && (j -= et[1], H += et[3]);
            let rt = H - j;
            rt > 0 && (rt = Math.max(10, rt), this.circleDiameter = rt);
          } else {
            const j = !((N = m.image) === null || N === void 0) && N.content && (m.image.textFitWidth || m.image.textFitHeight) ? qd(m) : { x1: m.left, y1: m.top, x2: m.right, y2: m.bottom };
            j.y1 = j.y1 * S - I[0], j.y2 = j.y2 * S + I[2], j.x1 = j.x1 * S - I[3], j.x2 = j.x2 * S + I[1];
            const H = m.collisionPadding;
            if (H && (j.x1 -= H[0] * S, j.y1 -= H[1] * S, j.x2 += H[2] * S, j.y2 += H[3] * S), D) {
              const et = new q(j.x1, j.y1), rt = new q(j.x2, j.y1), dt = new q(j.x1, j.y2), vt = new q(j.x2, j.y2), Nt = D * Math.PI / 180;
              et._rotate(Nt), rt._rotate(Nt), dt._rotate(Nt), vt._rotate(Nt), j.x1 = Math.min(et.x, rt.x, dt.x, vt.x), j.x2 = Math.max(et.x, rt.x, dt.x, vt.x), j.y1 = Math.min(et.y, rt.y, dt.y, vt.y), j.y2 = Math.max(et.y, rt.y, dt.y, vt.y);
            }
            e.emplaceBack(n.x, n.y, j.x1, j.y1, j.x2, j.y2, o, u, f);
          }
          this.boxEndIndex = e.length;
        }
      }
      class qm {
        constructor(e = [], n = (o, u) => o < u ? -1 : o > u ? 1 : 0) {
          if (this.data = e, this.length = this.data.length, this.compare = n, this.length > 0) for (let o = (this.length >> 1) - 1; o >= 0; o--) this._down(o);
        }
        push(e) {
          this.data.push(e), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const e = this.data[0], n = this.data.pop();
          return --this.length > 0 && (this.data[0] = n, this._down(0)), e;
        }
        peek() {
          return this.data[0];
        }
        _up(e) {
          const { data: n, compare: o } = this, u = n[e];
          for (; e > 0; ) {
            const f = e - 1 >> 1, m = n[f];
            if (o(u, m) >= 0) break;
            n[e] = m, e = f;
          }
          n[e] = u;
        }
        _down(e) {
          const { data: n, compare: o } = this, u = this.length >> 1, f = n[e];
          for (; e < u; ) {
            let m = 1 + (e << 1);
            const S = m + 1;
            if (S < this.length && o(n[S], n[m]) < 0 && (m = S), o(n[m], f) >= 0) break;
            n[e] = n[m], e = m;
          }
          n[e] = f;
        }
      }
      function Um(i, e = 1, n = !1) {
        let o = 1 / 0, u = 1 / 0, f = -1 / 0, m = -1 / 0;
        const S = i[0];
        for (let H = 0; H < S.length; H++) {
          const et = S[H];
          (!H || et.x < o) && (o = et.x), (!H || et.y < u) && (u = et.y), (!H || et.x > f) && (f = et.x), (!H || et.y > m) && (m = et.y);
        }
        const I = Math.min(f - o, m - u);
        let E = I / 2;
        const D = new qm([], Vm);
        if (I === 0) return new q(o, u);
        for (let H = o; H < f; H += I) for (let et = u; et < m; et += I) D.push(new Sc(H + E, et + E, E, i));
        let N = function(H) {
          let et = 0, rt = 0, dt = 0;
          const vt = H[0];
          for (let Nt = 0, kt = vt.length, zt = kt - 1; Nt < kt; zt = Nt++) {
            const Xt = vt[Nt], me = vt[zt], Ee = Xt.x * me.y - me.x * Xt.y;
            rt += (Xt.x + me.x) * Ee, dt += (Xt.y + me.y) * Ee, et += 3 * Ee;
          }
          return new Sc(rt / et, dt / et, 0, H);
        }(i), j = D.length;
        for (; D.length; ) {
          const H = D.pop();
          (H.d > N.d || !N.d) && (N = H, n && console.log("found best %d after %d probes", Math.round(1e4 * H.d) / 1e4, j)), H.max - N.d <= e || (E = H.h / 2, D.push(new Sc(H.p.x - E, H.p.y - E, E, i)), D.push(new Sc(H.p.x + E, H.p.y - E, E, i)), D.push(new Sc(H.p.x - E, H.p.y + E, E, i)), D.push(new Sc(H.p.x + E, H.p.y + E, E, i)), j += 4);
        }
        return n && (console.log(`num probes: ${j}`), console.log(`best distance: ${N.d}`)), N.p;
      }
      function Vm(i, e) {
        return e.max - i.max;
      }
      function Sc(i, e, n, o) {
        this.p = new q(i, e), this.h = n, this.d = function(u, f) {
          let m = !1, S = 1 / 0;
          for (let I = 0; I < f.length; I++) {
            const E = f[I];
            for (let D = 0, N = E.length, j = N - 1; D < N; j = D++) {
              const H = E[D], et = E[j];
              H.y > u.y != et.y > u.y && u.x < (et.x - H.x) * (u.y - H.y) / (et.y - H.y) + H.x && (m = !m), S = Math.min(S, qc(u, H, et));
            }
          }
          return (m ? 1 : -1) * Math.sqrt(S);
        }(this.p, o), this.max = this.d + this.h * Math.SQRT2;
      }
      var mn;
      v.aq = void 0, (mn = v.aq || (v.aq = {}))[mn.center = 1] = "center", mn[mn.left = 2] = "left", mn[mn.right = 3] = "right", mn[mn.top = 4] = "top", mn[mn.bottom = 5] = "bottom", mn[mn["top-left"] = 6] = "top-left", mn[mn["top-right"] = 7] = "top-right", mn[mn["bottom-left"] = 8] = "bottom-left", mn[mn["bottom-right"] = 9] = "bottom-right";
      const xl = 7, xu = Number.POSITIVE_INFINITY;
      function gp(i, e) {
        return e[1] !== xu ? function(n, o, u) {
          let f = 0, m = 0;
          switch (o = Math.abs(o), u = Math.abs(u), n) {
            case "top-right":
            case "top-left":
            case "top":
              m = u - xl;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              m = -u + xl;
          }
          switch (n) {
            case "top-right":
            case "bottom-right":
            case "right":
              f = -o;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              f = o;
          }
          return [f, m];
        }(i, e[0], e[1]) : function(n, o) {
          let u = 0, f = 0;
          o < 0 && (o = 0);
          const m = o / Math.SQRT2;
          switch (n) {
            case "top-right":
            case "top-left":
              f = m - xl;
              break;
            case "bottom-right":
            case "bottom-left":
              f = -m + xl;
              break;
            case "bottom":
              f = -o + xl;
              break;
            case "top":
              f = o - xl;
          }
          switch (n) {
            case "top-right":
            case "bottom-right":
              u = -m;
              break;
            case "top-left":
            case "bottom-left":
              u = m;
              break;
            case "left":
              u = o;
              break;
            case "right":
              u = -o;
          }
          return [u, f];
        }(i, e[0]);
      }
      function yp(i, e, n) {
        var o;
        const u = i.layout, f = (o = u.get("text-variable-anchor-offset")) === null || o === void 0 ? void 0 : o.evaluate(e, {}, n);
        if (f) {
          const S = f.values, I = [];
          for (let E = 0; E < S.length; E += 2) {
            const D = I[E] = S[E], N = S[E + 1].map((j) => j * Br);
            D.startsWith("top") ? N[1] -= xl : D.startsWith("bottom") && (N[1] += xl), I[E + 1] = N;
          }
          return new en(I);
        }
        const m = u.get("text-variable-anchor");
        if (m) {
          let S;
          S = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [u.get("text-radial-offset").evaluate(e, {}, n) * Br, xu] : u.get("text-offset").evaluate(e, {}, n).map((E) => E * Br);
          const I = [];
          for (const E of m) I.push(E, gp(E, S));
          return new en(I);
        }
        return null;
      }
      function bu(i) {
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function $m(i, e, n, o, u, f, m, S, I, E, D) {
        let N = f.textMaxSize.evaluate(e, {});
        N === void 0 && (N = m);
        const j = i.layers[0].layout, H = j.get("icon-offset").evaluate(e, {}, D), et = vp(n.horizontal), rt = m / 24, dt = i.tilePixelRatio * rt, vt = i.tilePixelRatio * N / 24, Nt = i.tilePixelRatio * S, kt = i.tilePixelRatio * j.get("symbol-spacing"), zt = j.get("text-padding") * i.tilePixelRatio, Xt = function(ae, Ze, je, li = 1) {
          const Ji = ae.get("icon-padding").evaluate(Ze, {}, je), Hi = Ji && Ji.values;
          return [Hi[0] * li, Hi[1] * li, Hi[2] * li, Hi[3] * li];
        }(j, e, D, i.tilePixelRatio), me = j.get("text-max-angle") / 180 * Math.PI, Ee = j.get("text-rotation-alignment") !== "viewport" && j.get("symbol-placement") !== "point", ti = j.get("icon-rotation-alignment") === "map" && j.get("symbol-placement") !== "point", Ie = j.get("symbol-placement"), Se = kt / 2, qe = j.get("icon-text-fit");
        let Oe;
        o && qe !== "none" && (i.allowVerticalPlacement && n.vertical && (Oe = Ud(o, n.vertical, qe, j.get("icon-text-fit-padding"), H, rt)), et && (o = Ud(o, et, qe, j.get("icon-text-fit-padding"), H, rt)));
        const Be = (ae, Ze) => {
          Ze.x < 0 || Ze.x >= tr || Ze.y < 0 || Ze.y >= tr || function(je, li, Ji, Hi, Jr, da, gn, Kr, Rn, Bn, On, xr, Qr, kn, yn, jn, _n, qs, ss, Bi, er, or, Ps, yr, Ac) {
            const Io = je.addToLineVertexArray(li, Ji);
            let ko, pa, Us, cn, el = 0, sh = 0, Sp = 0, Ap = 0, Lu = -1, Cu = -1;
            const il = {};
            let Pp = Fc("");
            if (je.allowVerticalPlacement && Hi.vertical) {
              const Tn = Kr.layout.get("text-rotate").evaluate(er, {}, yr) + 90;
              Us = new Ch(Rn, li, Bn, On, xr, Hi.vertical, Qr, kn, yn, Tn), gn && (cn = new Ch(Rn, li, Bn, On, xr, gn, _n, qs, yn, Tn));
            }
            if (Jr) {
              const Tn = Kr.layout.get("icon-rotate").evaluate(er, {}), Vs = Kr.layout.get("icon-text-fit") !== "none", Ul = fp(Jr, Tn, Ps, Vs), Ra = gn ? fp(gn, Tn, Ps, Vs) : void 0;
              pa = new Ch(Rn, li, Bn, On, xr, Jr, _n, qs, !1, Tn), el = 4 * Ul.length;
              const Vl = je.iconSizeData;
              let To = null;
              Vl.kind === "source" ? (To = [Po * Kr.layout.get("icon-size").evaluate(er, {})], To[0] > yl && Pt(`${je.layerIds[0]}: Value for "icon-size" is >= ${th}. Reduce your "icon-size".`)) : Vl.kind === "composite" && (To = [Po * or.compositeIconSizes[0].evaluate(er, {}, yr), Po * or.compositeIconSizes[1].evaluate(er, {}, yr)], (To[0] > yl || To[1] > yl) && Pt(`${je.layerIds[0]}: Value for "icon-size" is >= ${th}. Reduce your "icon-size".`)), je.addSymbols(je.icon, Ul, To, Bi, ss, er, v.ah.none, li, Io.lineStartIndex, Io.lineLength, -1, yr), Lu = je.icon.placedSymbolArray.length - 1, Ra && (sh = 4 * Ra.length, je.addSymbols(je.icon, Ra, To, Bi, ss, er, v.ah.vertical, li, Io.lineStartIndex, Io.lineLength, -1, yr), Cu = je.icon.placedSymbolArray.length - 1);
            }
            const Ip = Object.keys(Hi.horizontal);
            for (const Tn of Ip) {
              const Vs = Hi.horizontal[Tn];
              if (!ko) {
                Pp = Fc(Vs.text);
                const Ra = Kr.layout.get("text-rotate").evaluate(er, {}, yr);
                ko = new Ch(Rn, li, Bn, On, xr, Vs, Qr, kn, yn, Ra);
              }
              const Ul = Vs.positionedLines.length === 1;
              if (Sp += _p(je, li, Vs, da, Kr, yn, er, jn, Io, Hi.vertical ? v.ah.horizontal : v.ah.horizontalOnly, Ul ? Ip : [Tn], il, Lu, or, yr), Ul) break;
            }
            Hi.vertical && (Ap += _p(je, li, Hi.vertical, da, Kr, yn, er, jn, Io, v.ah.vertical, ["vertical"], il, Cu, or, yr));
            const Wm = ko ? ko.boxStartIndex : je.collisionBoxArray.length, Hm = ko ? ko.boxEndIndex : je.collisionBoxArray.length, Xm = Us ? Us.boxStartIndex : je.collisionBoxArray.length, Ym = Us ? Us.boxEndIndex : je.collisionBoxArray.length, Jm = pa ? pa.boxStartIndex : je.collisionBoxArray.length, Km = pa ? pa.boxEndIndex : je.collisionBoxArray.length, Qm = cn ? cn.boxStartIndex : je.collisionBoxArray.length, tg = cn ? cn.boxEndIndex : je.collisionBoxArray.length;
            let Fa = -1;
            const Mh = (Tn, Vs) => Tn && Tn.circleDiameter ? Math.max(Tn.circleDiameter, Vs) : Vs;
            Fa = Mh(ko, Fa), Fa = Mh(Us, Fa), Fa = Mh(pa, Fa), Fa = Mh(cn, Fa);
            const kp = Fa > -1 ? 1 : 0;
            kp && (Fa *= Ac / Br), je.glyphOffsetArray.length >= bc.MAX_GLYPHS && Pt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), er.sortKey !== void 0 && je.addToSortKeyRanges(je.symbolInstances.length, er.sortKey);
            const eg = yp(Kr, er, yr), [ig, rg] = function(Tn, Vs) {
              const Ul = Tn.length, Ra = Vs == null ? void 0 : Vs.values;
              if ((Ra == null ? void 0 : Ra.length) > 0) for (let Vl = 0; Vl < Ra.length; Vl += 2) {
                const To = Ra[Vl + 1];
                Tn.emplaceBack(v.aq[Ra[Vl]], To[0], To[1]);
              }
              return [Ul, Tn.length];
            }(je.textAnchorOffsets, eg);
            je.symbolInstances.emplaceBack(li.x, li.y, il.right >= 0 ? il.right : -1, il.center >= 0 ? il.center : -1, il.left >= 0 ? il.left : -1, il.vertical || -1, Lu, Cu, Pp, Wm, Hm, Xm, Ym, Jm, Km, Qm, tg, Bn, Sp, Ap, el, sh, kp, 0, Qr, Fa, ig, rg);
          }(i, Ze, ae, n, o, u, Oe, i.layers[0], i.collisionBoxArray, e.index, e.sourceLayerIndex, i.index, dt, [zt, zt, zt, zt], Ee, I, Nt, Xt, ti, H, e, f, E, D, m);
        };
        if (Ie === "line") for (const ae of lp(e.geometry, 0, 0, tr, tr)) {
          const Ze = jm(ae, kt, me, n.vertical || et, o, 24, vt, i.overscaling, tr);
          for (const je of Ze) et && Zm(i, et.text, Se, je) || Be(ae, je);
        }
        else if (Ie === "line-center") {
          for (const ae of e.geometry) if (ae.length > 1) {
            const Ze = Om(ae, me, n.vertical || et, o, 24, vt);
            Ze && Be(ae, Ze);
          }
        } else if (e.type === "Polygon") for (const ae of ds(e.geometry, 0)) {
          const Ze = Um(ae, 16);
          Be(ae[0], new vl(Ze.x, Ze.y, 0));
        }
        else if (e.type === "LineString") for (const ae of e.geometry) Be(ae, new vl(ae[0].x, ae[0].y, 0));
        else if (e.type === "Point") for (const ae of e.geometry) for (const Ze of ae) Be([Ze], new vl(Ze.x, Ze.y, 0));
      }
      function _p(i, e, n, o, u, f, m, S, I, E, D, N, j, H, et) {
        const rt = function(Nt, kt, zt, Xt, me, Ee, ti, Ie) {
          const Se = Xt.layout.get("text-rotate").evaluate(Ee, {}) * Math.PI / 180, qe = [];
          for (const Oe of kt.positionedLines) for (const Be of Oe.positionedGlyphs) {
            if (!Be.rect) continue;
            const ae = Be.rect || {};
            let Ze = Dd + 1, je = !0, li = 1, Ji = 0;
            const Hi = (me || Ie) && Be.vertical, Jr = Be.metrics.advance * Be.scale / 2;
            if (Ie && kt.verticalizable && (Ji = Oe.lineOffset / 2 - (Be.imageName ? -(Br - Be.metrics.width * Be.scale) / 2 : (Be.scale - 1) * Br)), Be.imageName) {
              const Bi = ti[Be.imageName];
              je = Bi.sdf, li = Bi.pixelRatio, Ze = ns / li;
            }
            const da = me ? [Be.x + Jr, Be.y] : [0, 0];
            let gn = me ? [0, 0] : [Be.x + Jr + zt[0], Be.y + zt[1] - Ji], Kr = [0, 0];
            Hi && (Kr = gn, gn = [0, 0]);
            const Rn = Be.metrics.isDoubleResolution ? 2 : 1, Bn = (Be.metrics.left - Ze) * Be.scale - Jr + gn[0], On = (-Be.metrics.top - Ze) * Be.scale + gn[1], xr = Bn + ae.w / Rn * Be.scale / li, Qr = On + ae.h / Rn * Be.scale / li, kn = new q(Bn, On), yn = new q(xr, On), jn = new q(Bn, Qr), _n = new q(xr, Qr);
            if (Hi) {
              const Bi = new q(-Jr, Jr - Kc), er = -Math.PI / 2, or = Br / 2 - Jr, Ps = new q(5 - Kc - or, -(Be.imageName ? or : 0)), yr = new q(...Kr);
              kn._rotateAround(er, Bi)._add(Ps)._add(yr), yn._rotateAround(er, Bi)._add(Ps)._add(yr), jn._rotateAround(er, Bi)._add(Ps)._add(yr), _n._rotateAround(er, Bi)._add(Ps)._add(yr);
            }
            if (Se) {
              const Bi = Math.sin(Se), er = Math.cos(Se), or = [er, -Bi, Bi, er];
              kn._matMult(or), yn._matMult(or), jn._matMult(or), _n._matMult(or);
            }
            const qs = new q(0, 0), ss = new q(0, 0);
            qe.push({ tl: kn, tr: yn, bl: jn, br: _n, tex: ae, writingMode: kt.writingMode, glyphOffset: da, sectionIndex: Be.sectionIndex, isSDF: je, pixelOffsetTL: qs, pixelOffsetBR: ss, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return qe;
        }(0, n, S, u, f, m, o, i.allowVerticalPlacement), dt = i.textSizeData;
        let vt = null;
        dt.kind === "source" ? (vt = [Po * u.layout.get("text-size").evaluate(m, {})], vt[0] > yl && Pt(`${i.layerIds[0]}: Value for "text-size" is >= ${th}. Reduce your "text-size".`)) : dt.kind === "composite" && (vt = [Po * H.compositeTextSizes[0].evaluate(m, {}, et), Po * H.compositeTextSizes[1].evaluate(m, {}, et)], (vt[0] > yl || vt[1] > yl) && Pt(`${i.layerIds[0]}: Value for "text-size" is >= ${th}. Reduce your "text-size".`)), i.addSymbols(i.text, rt, vt, S, f, m, E, e, I.lineStartIndex, I.lineLength, j, et);
        for (const Nt of D) N[Nt] = i.text.placedSymbolArray.length - 1;
        return 4 * rt.length;
      }
      function vp(i) {
        for (const e in i) return i[e];
        return null;
      }
      function Zm(i, e, n, o) {
        const u = i.compareText;
        if (e in u) {
          const f = u[e];
          for (let m = f.length - 1; m >= 0; m--) if (o.dist(f[m]) < n) return !0;
        } else u[e] = [];
        return u[e].push(o), !1;
      }
      const xp = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class wu {
        static from(e) {
          if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [n, o] = new Uint8Array(e, 0, 2);
          if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const u = o >> 4;
          if (u !== 1) throw new Error(`Got v${u} data when expected v1.`);
          const f = xp[15 & o];
          if (!f) throw new Error("Unrecognized array type.");
          const [m] = new Uint16Array(e, 2, 1), [S] = new Uint32Array(e, 4, 1);
          return new wu(S, m, f, e);
        }
        constructor(e, n = 64, o = Float64Array, u) {
          if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
          this.numItems = +e, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = o, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
          const f = xp.indexOf(this.ArrayType), m = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, S = e * this.IndexArrayType.BYTES_PER_ELEMENT, I = (8 - S % 8) % 8;
          if (f < 0) throw new Error(`Unexpected typed array class: ${o}.`);
          u && u instanceof ArrayBuffer ? (this.data = u, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + S + I, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + m + S + I), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + S + I, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + f]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = e);
        }
        add(e, n) {
          const o = this._pos >> 1;
          return this.ids[o] = o, this.coords[this._pos++] = e, this.coords[this._pos++] = n, o;
        }
        finish() {
          const e = this._pos >> 1;
          if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
          return Su(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(e, n, o, u) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: f, coords: m, nodeSize: S } = this, I = [0, f.length - 1, 0], E = [];
          for (; I.length; ) {
            const D = I.pop() || 0, N = I.pop() || 0, j = I.pop() || 0;
            if (N - j <= S) {
              for (let dt = j; dt <= N; dt++) {
                const vt = m[2 * dt], Nt = m[2 * dt + 1];
                vt >= e && vt <= o && Nt >= n && Nt <= u && E.push(f[dt]);
              }
              continue;
            }
            const H = j + N >> 1, et = m[2 * H], rt = m[2 * H + 1];
            et >= e && et <= o && rt >= n && rt <= u && E.push(f[H]), (D === 0 ? e <= et : n <= rt) && (I.push(j), I.push(H - 1), I.push(1 - D)), (D === 0 ? o >= et : u >= rt) && (I.push(H + 1), I.push(N), I.push(1 - D));
          }
          return E;
        }
        within(e, n, o) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: u, coords: f, nodeSize: m } = this, S = [0, u.length - 1, 0], I = [], E = o * o;
          for (; S.length; ) {
            const D = S.pop() || 0, N = S.pop() || 0, j = S.pop() || 0;
            if (N - j <= m) {
              for (let dt = j; dt <= N; dt++) wp(f[2 * dt], f[2 * dt + 1], e, n) <= E && I.push(u[dt]);
              continue;
            }
            const H = j + N >> 1, et = f[2 * H], rt = f[2 * H + 1];
            wp(et, rt, e, n) <= E && I.push(u[H]), (D === 0 ? e - o <= et : n - o <= rt) && (S.push(j), S.push(H - 1), S.push(1 - D)), (D === 0 ? e + o >= et : n + o >= rt) && (S.push(H + 1), S.push(N), S.push(1 - D));
          }
          return I;
        }
      }
      function Su(i, e, n, o, u, f) {
        if (u - o <= n) return;
        const m = o + u >> 1;
        bp(i, e, m, o, u, f), Su(i, e, n, o, m - 1, 1 - f), Su(i, e, n, m + 1, u, 1 - f);
      }
      function bp(i, e, n, o, u, f) {
        for (; u > o; ) {
          if (u - o > 600) {
            const E = u - o + 1, D = n - o + 1, N = Math.log(E), j = 0.5 * Math.exp(2 * N / 3), H = 0.5 * Math.sqrt(N * j * (E - j) / E) * (D - E / 2 < 0 ? -1 : 1);
            bp(i, e, n, Math.max(o, Math.floor(n - D * j / E + H)), Math.min(u, Math.floor(n + (E - D) * j / E + H)), f);
          }
          const m = e[2 * n + f];
          let S = o, I = u;
          for (rh(i, e, o, n), e[2 * u + f] > m && rh(i, e, o, u); S < I; ) {
            for (rh(i, e, S, I), S++, I--; e[2 * S + f] < m; ) S++;
            for (; e[2 * I + f] > m; ) I--;
          }
          e[2 * o + f] === m ? rh(i, e, o, I) : (I++, rh(i, e, I, u)), I <= n && (o = I + 1), n <= I && (u = I - 1);
        }
      }
      function rh(i, e, n, o) {
        Au(i, n, o), Au(e, 2 * n, 2 * o), Au(e, 2 * n + 1, 2 * o + 1);
      }
      function Au(i, e, n) {
        const o = i[e];
        i[e] = i[n], i[n] = o;
      }
      function wp(i, e, n, o) {
        const u = i - n, f = e - o;
        return u * u + f * f;
      }
      var Pu;
      v.bf = void 0, (Pu = v.bf || (v.bf = {})).create = "create", Pu.load = "load", Pu.fullLoad = "fullLoad";
      let Eh = null, nh = [];
      const Iu = 1e3 / 60, ku = "loadTime", Tu = "fullLoadTime", Gm = { mark(i) {
        performance.mark(i);
      }, frame(i) {
        const e = i;
        Eh != null && nh.push(e - Eh), Eh = e;
      }, clearMetrics() {
        Eh = null, nh = [], performance.clearMeasures(ku), performance.clearMeasures(Tu);
        for (const i in v.bf) performance.clearMarks(v.bf[i]);
      }, getPerformanceMetrics() {
        performance.measure(ku, v.bf.create, v.bf.load), performance.measure(Tu, v.bf.create, v.bf.fullLoad);
        const i = performance.getEntriesByName(ku)[0].duration, e = performance.getEntriesByName(Tu)[0].duration, n = nh.length, o = 1 / (nh.reduce((f, m) => f + m, 0) / n / 1e3), u = nh.filter((f) => f > Iu).reduce((f, m) => f + (m - Iu) / Iu, 0);
        return { loadTime: i, fullLoadTime: e, fps: o, percentDroppedFrames: u / (n + u) * 100, totalFrames: n };
      } };
      v.$ = class extends Z {
      }, v.A = mc, v.B = Dc, v.C = function(i) {
        if (Yt == null) {
          const e = i.navigator ? i.navigator.userAgent : null;
          Yt = !!i.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
        }
        return Yt;
      }, v.D = t, v.E = ie, v.F = class {
        constructor(i, e) {
          this.target = i, this.mapId = e, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Rm(() => this.process()), this.subscription = function(n, o, u, f) {
            return n.addEventListener(o, u, !1), { unsubscribe: () => {
              n.removeEventListener(o, u, !1);
            } };
          }(this.target, "message", (n) => this.receive(n)), this.globalScope = Jt(self) ? i : window;
        }
        registerMessageHandler(i, e) {
          this.messageHandlers[i] = e;
        }
        sendAsync(i, e) {
          return new Promise((n, o) => {
            const u = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[u] = { resolve: n, reject: o }, e && e.signal.addEventListener("abort", () => {
              delete this.resolveRejects[u];
              const S = { id: u, type: "<cancel>", origin: location.origin, targetMapId: i.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(S);
            }, { once: !0 });
            const f = [], m = Object.assign(Object.assign({}, i), { id: u, sourceMapId: this.mapId, origin: location.origin, data: Xo(i.data, f) });
            this.target.postMessage(m, { transfer: f });
          });
        }
        receive(i) {
          const e = i.data, n = e.id;
          if (!(e.origin !== "file://" && location.origin !== "file://" && e.origin !== "resource://android" && location.origin !== "resource://android" && e.origin !== location.origin || e.targetMapId && this.mapId !== e.targetMapId)) {
            if (e.type === "<cancel>") {
              delete this.tasks[n];
              const o = this.abortControllers[n];
              return delete this.abortControllers[n], void (o && o.abort());
            }
            if (Jt(self) || e.mustQueue) return this.tasks[n] = e, this.taskQueue.push(n), void this.invoker.trigger();
            this.processTask(n, e);
          }
        }
        process() {
          if (this.taskQueue.length === 0) return;
          const i = this.taskQueue.shift(), e = this.tasks[i];
          delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), e && this.processTask(i, e);
        }
        processTask(i, e) {
          return l(this, void 0, void 0, function* () {
            if (e.type === "<response>") {
              const u = this.resolveRejects[i];
              return delete this.resolveRejects[i], u ? void (e.error ? u.reject(fo(e.error)) : u.resolve(fo(e.data))) : void 0;
            }
            if (!this.messageHandlers[e.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${e.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const n = fo(e.data), o = new AbortController();
            this.abortControllers[i] = o;
            try {
              const u = yield this.messageHandlers[e.type](e.sourceMapId, n, o);
              this.completeTask(i, null, u);
            } catch (u) {
              this.completeTask(i, u);
            }
          });
        }
        completeTask(i, e, n) {
          const o = [];
          delete this.abortControllers[i];
          const u = { id: i, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e ? Xo(e) : null, data: Xo(n, o) };
          this.target.postMessage(u, { transfer: o });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, v.G = Dt, v.H = function() {
        var i = new mc(16);
        return mc != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
      }, v.I = cu, v.J = function(i, e, n) {
        var o, u, f, m, S, I, E, D, N, j, H, et, rt = n[0], dt = n[1], vt = n[2];
        return e === i ? (i[12] = e[0] * rt + e[4] * dt + e[8] * vt + e[12], i[13] = e[1] * rt + e[5] * dt + e[9] * vt + e[13], i[14] = e[2] * rt + e[6] * dt + e[10] * vt + e[14], i[15] = e[3] * rt + e[7] * dt + e[11] * vt + e[15]) : (u = e[1], f = e[2], m = e[3], S = e[4], I = e[5], E = e[6], D = e[7], N = e[8], j = e[9], H = e[10], et = e[11], i[0] = o = e[0], i[1] = u, i[2] = f, i[3] = m, i[4] = S, i[5] = I, i[6] = E, i[7] = D, i[8] = N, i[9] = j, i[10] = H, i[11] = et, i[12] = o * rt + S * dt + N * vt + e[12], i[13] = u * rt + I * dt + j * vt + e[13], i[14] = f * rt + E * dt + H * vt + e[14], i[15] = m * rt + D * dt + et * vt + e[15]), i;
      }, v.K = function(i, e, n) {
        var o = n[0], u = n[1], f = n[2];
        return i[0] = e[0] * o, i[1] = e[1] * o, i[2] = e[2] * o, i[3] = e[3] * o, i[4] = e[4] * u, i[5] = e[5] * u, i[6] = e[6] * u, i[7] = e[7] * u, i[8] = e[8] * f, i[9] = e[9] * f, i[10] = e[10] * f, i[11] = e[11] * f, i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
      }, v.L = id, v.M = function(i, e) {
        const n = {};
        for (let o = 0; o < e.length; o++) {
          const u = e[o];
          u in i && (n[u] = i[u]);
        }
        return n;
      }, v.N = _l, v.O = Jd, v.P = q, v.Q = Kd, v.R = Os, v.S = js, v.T = yo, v.U = st, v.V = gt, v.W = se, v.X = tr, v.Y = C, v.Z = eh, v._ = l, v.a = _t, v.a$ = function(i, e) {
        return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
      }, v.a0 = zr, v.a1 = vu, v.a2 = he, v.a3 = (i) => {
        const e = window.document.createElement("video");
        return e.muted = !0, new Promise((n) => {
          e.onloadstart = () => {
            n(e);
          };
          for (const o of i) {
            const u = window.document.createElement("source");
            xe(o) || (e.crossOrigin = "Anonymous"), u.src = o, e.appendChild(u);
          }
        });
      }, v.a4 = function() {
        return Tt++;
      }, v.a5 = Mi, v.a6 = bc, v.a7 = dn, v.a8 = wo, v.a9 = np, v.aA = function(i) {
        if (i.type === "custom") return new Fm(i);
        switch (i.type) {
          case "background":
            return new zm(i);
          case "circle":
            return new xf(i);
          case "fill":
            return new Rf(i);
          case "fill-extrusion":
            return new Kf(i);
          case "heatmap":
            return new wf(i);
          case "hillshade":
            return new Af(i);
          case "line":
            return new am(i);
          case "raster":
            return new Nm(i);
          case "symbol":
            return new Ih(i);
        }
      }, v.aB = at, v.aC = function(i, e) {
        if (!i) return [{ command: "setStyle", args: [e] }];
        let n = [];
        try {
          if (!oe(i.version, e.version)) return [{ command: "setStyle", args: [e] }];
          oe(i.center, e.center) || n.push({ command: "setCenter", args: [e.center] }), oe(i.zoom, e.zoom) || n.push({ command: "setZoom", args: [e.zoom] }), oe(i.bearing, e.bearing) || n.push({ command: "setBearing", args: [e.bearing] }), oe(i.pitch, e.pitch) || n.push({ command: "setPitch", args: [e.pitch] }), oe(i.sprite, e.sprite) || n.push({ command: "setSprite", args: [e.sprite] }), oe(i.glyphs, e.glyphs) || n.push({ command: "setGlyphs", args: [e.glyphs] }), oe(i.transition, e.transition) || n.push({ command: "setTransition", args: [e.transition] }), oe(i.light, e.light) || n.push({ command: "setLight", args: [e.light] }), oe(i.terrain, e.terrain) || n.push({ command: "setTerrain", args: [e.terrain] }), oe(i.sky, e.sky) || n.push({ command: "setSky", args: [e.sky] }), oe(i.projection, e.projection) || n.push({ command: "setProjection", args: [e.projection] });
          const o = {}, u = [];
          (function(m, S, I, E) {
            let D;
            for (D in S = S || {}, m = m || {}) Object.prototype.hasOwnProperty.call(m, D) && (Object.prototype.hasOwnProperty.call(S, D) || Ae(D, I, E));
            for (D in S) Object.prototype.hasOwnProperty.call(S, D) && (Object.prototype.hasOwnProperty.call(m, D) ? oe(m[D], S[D]) || (m[D].type === "geojson" && S[D].type === "geojson" && hi(m, S, D) ? ye(I, { command: "setGeoJSONSourceData", args: [D, S[D].data] }) : $e(D, S, I, E)) : De(D, S, I));
          })(i.sources, e.sources, u, o);
          const f = [];
          i.layers && i.layers.forEach((m) => {
            "source" in m && o[m.source] ? n.push({ command: "removeLayer", args: [m.id] }) : f.push(m);
          }), n = n.concat(u), function(m, S, I) {
            S = S || [];
            const E = (m = m || []).map(_i), D = S.map(_i), N = m.reduce(Ii, {}), j = S.reduce(Ii, {}), H = E.slice(), et = /* @__PURE__ */ Object.create(null);
            let rt, dt, vt, Nt, kt;
            for (let zt = 0, Xt = 0; zt < E.length; zt++) rt = E[zt], Object.prototype.hasOwnProperty.call(j, rt) ? Xt++ : (ye(I, { command: "removeLayer", args: [rt] }), H.splice(H.indexOf(rt, Xt), 1));
            for (let zt = 0, Xt = 0; zt < D.length; zt++) rt = D[D.length - 1 - zt], H[H.length - 1 - zt] !== rt && (Object.prototype.hasOwnProperty.call(N, rt) ? (ye(I, { command: "removeLayer", args: [rt] }), H.splice(H.lastIndexOf(rt, H.length - Xt), 1)) : Xt++, Nt = H[H.length - zt], ye(I, { command: "addLayer", args: [j[rt], Nt] }), H.splice(H.length - zt, 0, rt), et[rt] = !0);
            for (let zt = 0; zt < D.length; zt++) if (rt = D[zt], dt = N[rt], vt = j[rt], !et[rt] && !oe(dt, vt)) if (oe(dt.source, vt.source) && oe(dt["source-layer"], vt["source-layer"]) && oe(dt.type, vt.type)) {
              for (kt in si(dt.layout, vt.layout, I, rt, null, "setLayoutProperty"), si(dt.paint, vt.paint, I, rt, null, "setPaintProperty"), oe(dt.filter, vt.filter) || ye(I, { command: "setFilter", args: [rt, vt.filter] }), oe(dt.minzoom, vt.minzoom) && oe(dt.maxzoom, vt.maxzoom) || ye(I, { command: "setLayerZoomRange", args: [rt, vt.minzoom, vt.maxzoom] }), dt) Object.prototype.hasOwnProperty.call(dt, kt) && kt !== "layout" && kt !== "paint" && kt !== "filter" && kt !== "metadata" && kt !== "minzoom" && kt !== "maxzoom" && (kt.indexOf("paint.") === 0 ? si(dt[kt], vt[kt], I, rt, kt.slice(6), "setPaintProperty") : oe(dt[kt], vt[kt]) || ye(I, { command: "setLayerProperty", args: [rt, kt, vt[kt]] }));
              for (kt in vt) Object.prototype.hasOwnProperty.call(vt, kt) && !Object.prototype.hasOwnProperty.call(dt, kt) && kt !== "layout" && kt !== "paint" && kt !== "filter" && kt !== "metadata" && kt !== "minzoom" && kt !== "maxzoom" && (kt.indexOf("paint.") === 0 ? si(dt[kt], vt[kt], I, rt, kt.slice(6), "setPaintProperty") : oe(dt[kt], vt[kt]) || ye(I, { command: "setLayerProperty", args: [rt, kt, vt[kt]] }));
            } else ye(I, { command: "removeLayer", args: [rt] }), Nt = H[H.lastIndexOf(rt) + 1], ye(I, { command: "addLayer", args: [vt, Nt] });
          }(f, e.layers, n);
        } catch (o) {
          console.warn("Unable to compute style diff:", o), n = [{ command: "setStyle", args: [e] }];
        }
        return n;
      }, v.aD = function(i) {
        const e = [], n = i.id;
        return n === void 0 && e.push({ message: `layers.${n}: missing required property "id"` }), i.render === void 0 && e.push({ message: `layers.${n}: missing required method "render"` }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && e.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), e;
      }, v.aE = function i(e, n) {
        if (Array.isArray(e)) {
          if (!Array.isArray(n) || e.length !== n.length) return !1;
          for (let o = 0; o < e.length; o++) if (!i(e[o], n[o])) return !1;
          return !0;
        }
        if (typeof e == "object" && e !== null && n !== null) {
          if (typeof n != "object" || Object.keys(e).length !== Object.keys(n).length) return !1;
          for (const o in e) if (!i(e[o], n[o])) return !1;
          return !0;
        }
        return e === n;
      }, v.aF = le, v.aG = ne, v.aH = class extends xo {
        constructor(i, e) {
          super(i, e), this.current = 0;
        }
        set(i) {
          this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i));
        }
      }, v.aI = Fl, v.aJ = class extends xo {
        constructor(i, e) {
          super(i, e), this.current = Bl;
        }
        set(i) {
          if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
          for (let e = 1; e < 16; e++) if (i[e] !== this.current[e]) {
            this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
            break;
          }
        }
      }, v.aK = Rl, v.aL = cc, v.aM = Ni, v.aN = class extends xo {
        constructor(i, e) {
          super(i, e), this.current = [0, 0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]));
        }
      }, v.aO = class extends xo {
        constructor(i, e) {
          super(i, e), this.current = [0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]));
        }
      }, v.aP = function(i, e, n, o, u, f, m) {
        var S = 1 / (e - n), I = 1 / (o - u), E = 1 / (f - m);
        return i[0] = -2 * S, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * I, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * E, i[11] = 0, i[12] = (e + n) * S, i[13] = (u + o) * I, i[14] = (m + f) * E, i[15] = 1, i;
      }, v.aQ = vf, v.aR = class extends qt {
      }, v.aS = hm, v.aT = class extends Bt {
      }, v.aU = function(i) {
        return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
      }, v.aV = od, v.aW = Hr, v.aX = Pn, v.aY = class extends we {
      }, v.aZ = function(i, e) {
        return i[0] === e[0] && i[1] === e[1] && i[2] === e[2] && i[3] === e[3] && i[4] === e[4] && i[5] === e[5] && i[6] === e[6] && i[7] === e[7] && i[8] === e[8] && i[9] === e[9] && i[10] === e[10] && i[11] === e[11] && i[12] === e[12] && i[13] === e[13] && i[14] === e[14] && i[15] === e[15];
      }, v.a_ = function(i, e) {
        var n = i[0], o = i[1], u = i[2], f = i[3], m = i[4], S = i[5], I = i[6], E = i[7], D = i[8], N = i[9], j = i[10], H = i[11], et = i[12], rt = i[13], dt = i[14], vt = i[15], Nt = e[0], kt = e[1], zt = e[2], Xt = e[3], me = e[4], Ee = e[5], ti = e[6], Ie = e[7], Se = e[8], qe = e[9], Oe = e[10], Be = e[11], ae = e[12], Ze = e[13], je = e[14], li = e[15];
        return Math.abs(n - Nt) <= Fn * Math.max(1, Math.abs(n), Math.abs(Nt)) && Math.abs(o - kt) <= Fn * Math.max(1, Math.abs(o), Math.abs(kt)) && Math.abs(u - zt) <= Fn * Math.max(1, Math.abs(u), Math.abs(zt)) && Math.abs(f - Xt) <= Fn * Math.max(1, Math.abs(f), Math.abs(Xt)) && Math.abs(m - me) <= Fn * Math.max(1, Math.abs(m), Math.abs(me)) && Math.abs(S - Ee) <= Fn * Math.max(1, Math.abs(S), Math.abs(Ee)) && Math.abs(I - ti) <= Fn * Math.max(1, Math.abs(I), Math.abs(ti)) && Math.abs(E - Ie) <= Fn * Math.max(1, Math.abs(E), Math.abs(Ie)) && Math.abs(D - Se) <= Fn * Math.max(1, Math.abs(D), Math.abs(Se)) && Math.abs(N - qe) <= Fn * Math.max(1, Math.abs(N), Math.abs(qe)) && Math.abs(j - Oe) <= Fn * Math.max(1, Math.abs(j), Math.abs(Oe)) && Math.abs(H - Be) <= Fn * Math.max(1, Math.abs(H), Math.abs(Be)) && Math.abs(et - ae) <= Fn * Math.max(1, Math.abs(et), Math.abs(ae)) && Math.abs(rt - Ze) <= Fn * Math.max(1, Math.abs(rt), Math.abs(Ze)) && Math.abs(dt - je) <= Fn * Math.max(1, Math.abs(dt), Math.abs(je)) && Math.abs(vt - li) <= Fn * Math.max(1, Math.abs(vt), Math.abs(li));
      }, v.aa = function(i) {
        const e = {};
        if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (n, o, u, f) => {
          const m = u || f;
          return e[o] = !m || m.toLowerCase(), "";
        }), e["max-age"]) {
          const n = parseInt(e["max-age"], 10);
          isNaN(n) ? delete e["max-age"] : e["max-age"] = n;
        }
        return e;
      }, v.ab = function(i, e) {
        const n = [];
        for (const o in i) o in e || n.push(o);
        return n;
      }, v.ac = Ht, v.ad = function(i, e, n) {
        var o = Math.sin(n), u = Math.cos(n), f = e[0], m = e[1], S = e[2], I = e[3], E = e[4], D = e[5], N = e[6], j = e[7];
        return e !== i && (i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[0] = f * u + E * o, i[1] = m * u + D * o, i[2] = S * u + N * o, i[3] = I * u + j * o, i[4] = E * u - f * o, i[5] = D * u - m * o, i[6] = N * u - S * o, i[7] = j * u - I * o, i;
      }, v.ae = function(i) {
        var e = new mc(16);
        return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], e;
      }, v.af = yh, v.ag = function(i, e) {
        let n = 0, o = 0;
        if (i.kind === "constant") o = i.layoutSize;
        else if (i.kind !== "source") {
          const { interpolationType: u, minZoom: f, maxZoom: m } = i, S = u ? Ht(Ye.interpolationFactor(u, e, f, m), 0, 1) : 0;
          i.kind === "camera" ? o = Zr.number(i.minSize, i.maxSize, S) : n = S;
        }
        return { uSizeT: n, uSize: o };
      }, v.ai = function(i, { uSize: e, uSizeT: n }, { lowerSize: o, upperSize: u }) {
        return i.kind === "source" ? o / Po : i.kind === "composite" ? Zr.number(o / Po, u / Po, n) : e;
      }, v.aj = pu, v.ak = function(i, e, n, o) {
        const u = e.y - i.y, f = e.x - i.x, m = o.y - n.y, S = o.x - n.x, I = m * f - S * u;
        if (I === 0) return null;
        const E = (S * (i.y - n.y) - m * (i.x - n.x)) / I;
        return new q(i.x + E * f, i.y + E * u);
      }, v.al = lp, v.am = dc, v.an = Xh, v.ao = function(i) {
        let e = 1 / 0, n = 1 / 0, o = -1 / 0, u = -1 / 0;
        for (const f of i) e = Math.min(e, f.x), n = Math.min(n, f.y), o = Math.max(o, f.x), u = Math.max(u, f.y);
        return [e, n, o, u];
      }, v.ap = Br, v.ar = du, v.as = function(i, e) {
        var n = e[0], o = e[1], u = e[2], f = e[3], m = e[4], S = e[5], I = e[6], E = e[7], D = e[8], N = e[9], j = e[10], H = e[11], et = e[12], rt = e[13], dt = e[14], vt = e[15], Nt = n * S - o * m, kt = n * I - u * m, zt = n * E - f * m, Xt = o * I - u * S, me = o * E - f * S, Ee = u * E - f * I, ti = D * rt - N * et, Ie = D * dt - j * et, Se = D * vt - H * et, qe = N * dt - j * rt, Oe = N * vt - H * rt, Be = j * vt - H * dt, ae = Nt * Be - kt * Oe + zt * qe + Xt * Se - me * Ie + Ee * ti;
        return ae ? (i[0] = (S * Be - I * Oe + E * qe) * (ae = 1 / ae), i[1] = (u * Oe - o * Be - f * qe) * ae, i[2] = (rt * Ee - dt * me + vt * Xt) * ae, i[3] = (j * me - N * Ee - H * Xt) * ae, i[4] = (I * Se - m * Be - E * Ie) * ae, i[5] = (n * Be - u * Se + f * Ie) * ae, i[6] = (dt * zt - et * Ee - vt * kt) * ae, i[7] = (D * Ee - j * zt + H * kt) * ae, i[8] = (m * Oe - S * Se + E * ti) * ae, i[9] = (o * Se - n * Oe - f * ti) * ae, i[10] = (et * me - rt * zt + vt * Nt) * ae, i[11] = (N * zt - D * me - H * Nt) * ae, i[12] = (S * Ie - m * qe - I * ti) * ae, i[13] = (n * qe - o * Ie + u * ti) * ae, i[14] = (rt * kt - et * Xt - dt * Nt) * ae, i[15] = (D * Xt - N * kt + j * Nt) * ae, i) : null;
      }, v.at = bu, v.au = uu, v.av = wu, v.aw = function() {
        const i = {}, e = K.$version;
        for (const n in K.$root) {
          const o = K.$root[n];
          if (o.required) {
            let u = null;
            u = n === "version" ? e : o.type === "array" ? [] : {}, u != null && (i[n] = u);
          }
        }
        return i;
      }, v.ax = pn, v.ay = Vt, v.az = function(i) {
        i = i.slice();
        const e = /* @__PURE__ */ Object.create(null);
        for (let n = 0; n < i.length; n++) e[i[n].id] = i[n];
        for (let n = 0; n < i.length; n++) "ref" in i[n] && (i[n] = Ue(i[n], e[i[n].ref]));
        return i;
      }, v.b = te, v.b0 = function(i, e, n) {
        return i[0] = e[0] * n[0], i[1] = e[1] * n[1], i[2] = e[2] * n[2], i[3] = e[3] * n[3], i;
      }, v.b1 = function(i, e) {
        return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] * e[3];
      }, v.b2 = pe, v.b3 = ep, v.b4 = Qd, v.b5 = function(i, e, n, o, u) {
        var f, m = 1 / Math.tan(e / 2);
        return i[0] = m / n, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = m, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, u != null && u !== 1 / 0 ? (i[10] = (u + o) * (f = 1 / (o - u)), i[14] = 2 * u * o * f) : (i[10] = -1, i[14] = -2 * o), i;
      }, v.b6 = function(i, e, n) {
        var o = Math.sin(n), u = Math.cos(n), f = e[4], m = e[5], S = e[6], I = e[7], E = e[8], D = e[9], N = e[10], j = e[11];
        return e !== i && (i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[4] = f * u + E * o, i[5] = m * u + D * o, i[6] = S * u + N * o, i[7] = I * u + j * o, i[8] = E * u - f * o, i[9] = D * u - m * o, i[10] = N * u - S * o, i[11] = j * u - I * o, i;
      }, v.b7 = Mt, v.b8 = Qt, v.b9 = function(i) {
        return i * Math.PI / 180;
      }, v.bA = function(i) {
        return i.message === Q;
      }, v.bB = on, v.bC = bs, v.ba = function(i, e) {
        const { x: n, y: o } = eh.fromLngLat(e);
        return !(i < 0 || i > 25 || o < 0 || o >= 1 || n < 0 || n >= 1);
      }, v.bb = function(i, e) {
        return i[0] = e[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = e[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = e[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }, v.bc = class extends W {
      }, v.bd = yu, v.be = Gm, v.bg = Ot, v.bh = function(i, e) {
        _t.REGISTERED_PROTOCOLS[i] = e;
      }, v.bi = function(i) {
        delete _t.REGISTERED_PROTOCOLS[i];
      }, v.bj = function(i, e) {
        const n = {};
        for (let u = 0; u < i.length; u++) {
          const f = e && e[i[u].id] || Yl(i[u]);
          e && (e[i[u].id] = f);
          let m = n[f];
          m || (m = n[f] = []), m.push(i[u]);
        }
        const o = [];
        for (const u in n) o.push(n[u]);
        return o;
      }, v.bk = Fe, v.bl = rp, v.bm = sp, v.bn = Fd, v.bo = function(i) {
        i.bucket.createArrays(), i.bucket.tilePixelRatio = tr / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
        const e = i.bucket.layers[0], n = e.layout, o = e._unevaluatedLayout._values, u = { layoutIconSize: o["icon-size"].possiblyEvaluate(new Vi(i.bucket.zoom + 1), i.canonical), layoutTextSize: o["text-size"].possiblyEvaluate(new Vi(i.bucket.zoom + 1), i.canonical), textMaxSize: o["text-size"].possiblyEvaluate(new Vi(18)) };
        if (i.bucket.textSizeData.kind === "composite") {
          const { minZoom: E, maxZoom: D } = i.bucket.textSizeData;
          u.compositeTextSizes = [o["text-size"].possiblyEvaluate(new Vi(E), i.canonical), o["text-size"].possiblyEvaluate(new Vi(D), i.canonical)];
        }
        if (i.bucket.iconSizeData.kind === "composite") {
          const { minZoom: E, maxZoom: D } = i.bucket.iconSizeData;
          u.compositeIconSizes = [o["icon-size"].possiblyEvaluate(new Vi(E), i.canonical), o["icon-size"].possiblyEvaluate(new Vi(D), i.canonical)];
        }
        const f = n.get("text-line-height") * Br, m = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", S = n.get("text-keep-upright"), I = n.get("text-size");
        for (const E of i.bucket.features) {
          const D = n.get("text-font").evaluate(E, {}, i.canonical).join(","), N = I.evaluate(E, {}, i.canonical), j = u.layoutTextSize.evaluate(E, {}, i.canonical), H = u.layoutIconSize.evaluate(E, {}, i.canonical), et = { horizontal: {}, vertical: void 0 }, rt = E.text;
          let dt, vt = [0, 0];
          if (rt) {
            const zt = rt.toString(), Xt = n.get("text-letter-spacing").evaluate(E, {}, i.canonical) * Br, me = Nc(zt) ? Xt : 0, Ee = n.get("text-anchor").evaluate(E, {}, i.canonical), ti = yp(e, E, i.canonical);
            if (!ti) {
              const Oe = n.get("text-radial-offset").evaluate(E, {}, i.canonical);
              vt = Oe ? gp(Ee, [Oe * Br, xu]) : n.get("text-offset").evaluate(E, {}, i.canonical).map((Be) => Be * Br);
            }
            let Ie = m ? "center" : n.get("text-justify").evaluate(E, {}, i.canonical);
            const Se = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(E, {}, i.canonical) * Br : 1 / 0, qe = () => {
              i.bucket.allowVerticalPlacement && El(zt) && (et.vertical = Sh(rt, i.glyphMap, i.glyphPositions, i.imagePositions, D, Se, f, Ee, "left", me, vt, v.ah.vertical, !0, j, N));
            };
            if (!m && ti) {
              const Oe = /* @__PURE__ */ new Set();
              if (Ie === "auto") for (let ae = 0; ae < ti.values.length; ae += 2) Oe.add(bu(ti.values[ae]));
              else Oe.add(Ie);
              let Be = !1;
              for (const ae of Oe) if (!et.horizontal[ae]) if (Be) et.horizontal[ae] = et.horizontal[0];
              else {
                const Ze = Sh(rt, i.glyphMap, i.glyphPositions, i.imagePositions, D, Se, f, "center", ae, me, vt, v.ah.horizontal, !1, j, N);
                Ze && (et.horizontal[ae] = Ze, Be = Ze.positionedLines.length === 1);
              }
              qe();
            } else {
              Ie === "auto" && (Ie = bu(Ee));
              const Oe = Sh(rt, i.glyphMap, i.glyphPositions, i.imagePositions, D, Se, f, Ee, Ie, me, vt, v.ah.horizontal, !1, j, N);
              Oe && (et.horizontal[Ie] = Oe), qe(), El(zt) && m && S && (et.vertical = Sh(rt, i.glyphMap, i.glyphPositions, i.imagePositions, D, Se, f, Ee, Ie, me, vt, v.ah.vertical, !1, j, N));
            }
          }
          let Nt = !1;
          if (E.icon && E.icon.name) {
            const zt = i.imageMap[E.icon.name];
            zt && (dt = Tm(i.imagePositions[E.icon.name], n.get("icon-offset").evaluate(E, {}, i.canonical), n.get("icon-anchor").evaluate(E, {}, i.canonical)), Nt = !!zt.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Nt : i.bucket.sdfIcons !== Nt && Pt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (zt.pixelRatio !== i.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0));
          }
          const kt = vp(et.horizontal) || et.vertical;
          i.bucket.iconsInText = !!kt && kt.iconsInText, (kt || dt) && $m(i.bucket, E, et, dt, i.imageMap, u, j, H, vt, Nt, i.canonical);
        }
        i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers();
      }, v.bp = su, v.bq = iu, v.br = nu, v.bs = ml, v.bt = ou, v.bu = class {
        constructor(i) {
          this._marks = { start: [i.url, "start"].join("#"), end: [i.url, "end"].join("#"), measure: i.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let i = performance.getEntriesByName(this._marks.measure);
          return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i;
        }
      }, v.bv = function(i, e, n, o, u) {
        return l(this, void 0, void 0, function* () {
          if (gt()) try {
            return yield se(i, e, n, o, u);
          } catch {
          }
          return function(f, m, S, I, E) {
            const D = f.width, N = f.height;
            ee && be || (ee = new OffscreenCanvas(D, N), be = ee.getContext("2d", { willReadFrequently: !0 })), ee.width = D, ee.height = N, be.drawImage(f, 0, 0, D, N);
            const j = be.getImageData(m, S, I, E);
            return be.clearRect(0, 0, D, N), j.data;
          }(i, e, n, o, u);
        });
      }, v.bw = ip, v.bx = M, v.by = B, v.bz = kd, v.c = pt, v.d = (i) => l(void 0, void 0, void 0, function* () {
        if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
        const e = new Blob([new Uint8Array(i)], { type: "image/png" });
        try {
          return createImageBitmap(e);
        } catch (n) {
          throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), v.e = jt, v.f = (i) => new Promise((e, n) => {
        const o = new Image();
        o.onload = () => {
          e(o), URL.revokeObjectURL(o.src), o.onload = null, window.requestAnimationFrame(() => {
            o.src = Ut;
          });
        }, o.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const u = new Blob([new Uint8Array(i)], { type: "image/png" });
        o.src = i.byteLength ? URL.createObjectURL(u) : Ut;
      }), v.g = Ct, v.h = (i, e) => Wt(jt(i, { type: "json" }), e), v.i = Jt, v.j = Je, v.k = ze, v.l = (i, e) => Wt(jt(i, { type: "arrayBuffer" }), e), v.m = Wt, v.n = function(i) {
        return new ou(i).readFields(bm, []);
      }, v.o = Zc, v.p = Nd, v.q = h, v.r = aa, v.s = xe, v.t = tc, v.u = Fs, v.v = K, v.w = Pt, v.x = function([i, e, n]) {
        return e += 90, e *= Math.PI / 180, n *= Math.PI / 180, { x: i * Math.cos(e) * Math.sin(n), y: i * Math.sin(e) * Math.sin(n), z: i * Math.cos(n) };
      }, v.y = Zr, v.z = Vi;
    }), P("worker", ["./shared"], function(v) {
      class l {
        constructor(O) {
          this.keyCache = {}, O && this.replace(O);
        }
        replace(O) {
          this._layerConfigs = {}, this._layers = {}, this.update(O, []);
        }
        update(O, V) {
          for (const ct of O) {
            this._layerConfigs[ct.id] = ct;
            const At = this._layers[ct.id] = v.aA(ct);
            At._featureFilter = v.a7(At.filter), this.keyCache[ct.id] && delete this.keyCache[ct.id];
          }
          for (const ct of V) delete this.keyCache[ct], delete this._layerConfigs[ct], delete this._layers[ct];
          this.familiesBySource = {};
          const it = v.bj(Object.values(this._layerConfigs), this.keyCache);
          for (const ct of it) {
            const At = ct.map((Rt) => this._layers[Rt.id]), Et = At[0];
            if (Et.visibility === "none") continue;
            const wt = Et.source || "";
            let xt = this.familiesBySource[wt];
            xt || (xt = this.familiesBySource[wt] = {});
            const $t = Et.sourceLayer || "_geojsonTileLayer";
            let re = xt[$t];
            re || (re = xt[$t] = []), re.push(At);
          }
        }
      }
      class M {
        constructor(O) {
          const V = {}, it = [];
          for (const wt in O) {
            const xt = O[wt], $t = V[wt] = {};
            for (const re in xt) {
              const Rt = xt[+re];
              if (!Rt || Rt.bitmap.width === 0 || Rt.bitmap.height === 0) continue;
              const fe = { x: 0, y: 0, w: Rt.bitmap.width + 2, h: Rt.bitmap.height + 2 };
              it.push(fe), $t[re] = { rect: fe, metrics: Rt.metrics };
            }
          }
          const { w: ct, h: At } = v.p(it), Et = new v.o({ width: ct || 1, height: At || 1 });
          for (const wt in O) {
            const xt = O[wt];
            for (const $t in xt) {
              const re = xt[+$t];
              if (!re || re.bitmap.width === 0 || re.bitmap.height === 0) continue;
              const Rt = V[wt][$t].rect;
              v.o.copy(re.bitmap, Et, { x: 0, y: 0 }, { x: Rt.x + 1, y: Rt.y + 1 }, re.bitmap);
            }
          }
          this.image = Et, this.positions = V;
        }
      }
      v.bk("GlyphAtlas", M);
      class B {
        constructor(O) {
          this.tileID = new v.S(O.tileID.overscaledZ, O.tileID.wrap, O.tileID.canonical.z, O.tileID.canonical.x, O.tileID.canonical.y), this.uid = O.uid, this.zoom = O.zoom, this.pixelRatio = O.pixelRatio, this.tileSize = O.tileSize, this.source = O.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = O.showCollisionBoxes, this.collectResourceTiming = !!O.collectResourceTiming, this.returnDependencies = !!O.returnDependencies, this.promoteId = O.promoteId, this.inFlightDependencies = [];
        }
        parse(O, V, it, ct) {
          return v._(this, void 0, void 0, function* () {
            this.status = "parsing", this.data = O, this.collisionBoxArray = new v.a5();
            const At = new v.bl(Object.keys(O.layers).sort()), Et = new v.bm(this.tileID, this.promoteId);
            Et.bucketLayerIDs = [];
            const wt = {}, xt = { featureIndex: Et, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: it }, $t = V.familiesBySource[this.source];
            for (const oi in $t) {
              const Ci = O.layers[oi];
              if (!Ci) continue;
              Ci.version === 1 && v.w(`Vector tile source "${this.source}" layer "${oi}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const Ui = At.encode(oi), rr = [];
              for (let pr = 0; pr < Ci.length; pr++) {
                const fr = Ci.feature(pr), $s = Et.getId(fr, oi);
                rr.push({ feature: fr, id: $s, index: pr, sourceLayerIndex: Ui });
              }
              for (const pr of $t[oi]) {
                const fr = pr[0];
                fr.source !== this.source && v.w(`layer.source = ${fr.source} does not equal this.source = ${this.source}`), fr.minzoom && this.zoom < Math.floor(fr.minzoom) || fr.maxzoom && this.zoom >= fr.maxzoom || fr.visibility !== "none" && ($(pr, this.zoom, it), (wt[fr.id] = fr.createBucket({ index: Et.bucketLayerIDs.length, layers: pr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Ui, sourceID: this.source })).populate(rr, xt, this.tileID.canonical), Et.bucketLayerIDs.push(pr.map(($s) => $s.id)));
              }
            }
            const re = v.aF(xt.glyphDependencies, (oi) => Object.keys(oi).map(Number));
            this.inFlightDependencies.forEach((oi) => oi == null ? void 0 : oi.abort()), this.inFlightDependencies = [];
            let Rt = Promise.resolve({});
            if (Object.keys(re).length) {
              const oi = new AbortController();
              this.inFlightDependencies.push(oi), Rt = ct.sendAsync({ type: "GG", data: { stacks: re, source: this.source, tileID: this.tileID, type: "glyphs" } }, oi);
            }
            const fe = Object.keys(xt.iconDependencies);
            let Ne = Promise.resolve({});
            if (fe.length) {
              const oi = new AbortController();
              this.inFlightDependencies.push(oi), Ne = ct.sendAsync({ type: "GI", data: { icons: fe, source: this.source, tileID: this.tileID, type: "icons" } }, oi);
            }
            const Ve = Object.keys(xt.patternDependencies);
            let ei = Promise.resolve({});
            if (Ve.length) {
              const oi = new AbortController();
              this.inFlightDependencies.push(oi), ei = ct.sendAsync({ type: "GI", data: { icons: Ve, source: this.source, tileID: this.tileID, type: "patterns" } }, oi);
            }
            const [mi, He, Ti] = yield Promise.all([Rt, Ne, ei]), Di = new M(mi), Oi = new v.bn(He, Ti);
            for (const oi in wt) {
              const Ci = wt[oi];
              Ci instanceof v.a6 ? ($(Ci.layers, this.zoom, it), v.bo({ bucket: Ci, glyphMap: mi, glyphPositions: Di.positions, imageMap: He, imagePositions: Oi.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : Ci.hasPattern && (Ci instanceof v.bp || Ci instanceof v.bq || Ci instanceof v.br) && ($(Ci.layers, this.zoom, it), Ci.addFeatures(xt, this.tileID.canonical, Oi.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(wt).filter((oi) => !oi.isEmpty()), featureIndex: Et, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Di.image, imageAtlas: Oi, glyphMap: this.returnDependencies ? mi : null, iconMap: this.returnDependencies ? He : null, glyphPositions: this.returnDependencies ? Di.positions : null };
          });
        }
      }
      function $(ht, O, V) {
        const it = new v.z(O);
        for (const ct of ht) ct.recalculate(it, V);
      }
      class q {
        constructor(O, V, it) {
          this.actor = O, this.layerIndex = V, this.availableImages = it, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(O, V) {
          return v._(this, void 0, void 0, function* () {
            const it = yield v.l(O.request, V);
            try {
              return { vectorTile: new v.bs.VectorTile(new v.bt(it.data)), rawData: it.data, cacheControl: it.cacheControl, expires: it.expires };
            } catch (ct) {
              const At = new Uint8Array(it.data);
              let Et = `Unable to parse the tile at ${O.request.url}, `;
              throw Et += At[0] === 31 && At[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ct.message}`, new Error(Et);
            }
          });
        }
        loadTile(O) {
          return v._(this, void 0, void 0, function* () {
            const V = O.uid, it = !!(O && O.request && O.request.collectResourceTiming) && new v.bu(O.request), ct = new B(O);
            this.loading[V] = ct;
            const At = new AbortController();
            ct.abort = At;
            try {
              const Et = yield this.loadVectorTile(O, At);
              if (delete this.loading[V], !Et) return null;
              const wt = Et.rawData, xt = {};
              Et.expires && (xt.expires = Et.expires), Et.cacheControl && (xt.cacheControl = Et.cacheControl);
              const $t = {};
              if (it) {
                const Rt = it.finish();
                Rt && ($t.resourceTiming = JSON.parse(JSON.stringify(Rt)));
              }
              ct.vectorTile = Et.vectorTile;
              const re = ct.parse(Et.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[V] = ct, this.fetching[V] = { rawTileData: wt, cacheControl: xt, resourceTiming: $t };
              try {
                const Rt = yield re;
                return v.e({ rawTileData: wt.slice(0) }, Rt, xt, $t);
              } finally {
                delete this.fetching[V];
              }
            } catch (Et) {
              throw delete this.loading[V], ct.status = "done", this.loaded[V] = ct, Et;
            }
          });
        }
        reloadTile(O) {
          return v._(this, void 0, void 0, function* () {
            const V = O.uid;
            if (!this.loaded || !this.loaded[V]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const it = this.loaded[V];
            if (it.showCollisionBoxes = O.showCollisionBoxes, it.status === "parsing") {
              const ct = yield it.parse(it.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let At;
              if (this.fetching[V]) {
                const { rawTileData: Et, cacheControl: wt, resourceTiming: xt } = this.fetching[V];
                delete this.fetching[V], At = v.e({ rawTileData: Et.slice(0) }, ct, wt, xt);
              } else At = ct;
              return At;
            }
            if (it.status === "done" && it.vectorTile) return it.parse(it.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile(O) {
          return v._(this, void 0, void 0, function* () {
            const V = this.loading, it = O.uid;
            V && V[it] && V[it].abort && (V[it].abort.abort(), delete V[it]);
          });
        }
        removeTile(O) {
          return v._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[O.uid] && delete this.loaded[O.uid];
          });
        }
      }
      class U {
        constructor() {
          this.loaded = {};
        }
        loadTile(O) {
          return v._(this, void 0, void 0, function* () {
            const { uid: V, encoding: it, rawImageData: ct, redFactor: At, greenFactor: Et, blueFactor: wt, baseShift: xt } = O, $t = ct.width + 2, re = ct.height + 2, Rt = v.b(ct) ? new v.R({ width: $t, height: re }, yield v.bv(ct, -1, -1, $t, re)) : ct, fe = new v.bw(V, Rt, it, At, Et, wt, xt);
            return this.loaded = this.loaded || {}, this.loaded[V] = fe, fe;
          });
        }
        removeTile(O) {
          const V = this.loaded, it = O.uid;
          V && V[it] && delete V[it];
        }
      }
      function F(ht, O) {
        if (ht.length !== 0) {
          mt(ht[0], O);
          for (var V = 1; V < ht.length; V++) mt(ht[V], !O);
        }
      }
      function mt(ht, O) {
        for (var V = 0, it = 0, ct = 0, At = ht.length, Et = At - 1; ct < At; Et = ct++) {
          var wt = (ht[ct][0] - ht[Et][0]) * (ht[Et][1] + ht[ct][1]), xt = V + wt;
          it += Math.abs(V) >= Math.abs(wt) ? V - xt + wt : wt - xt + V, V = xt;
        }
        V + it >= 0 != !!O && ht.reverse();
      }
      var ot = v.bx(function ht(O, V) {
        var it, ct = O && O.type;
        if (ct === "FeatureCollection") for (it = 0; it < O.features.length; it++) ht(O.features[it], V);
        else if (ct === "GeometryCollection") for (it = 0; it < O.geometries.length; it++) ht(O.geometries[it], V);
        else if (ct === "Feature") ht(O.geometry, V);
        else if (ct === "Polygon") F(O.coordinates, V);
        else if (ct === "MultiPolygon") for (it = 0; it < O.coordinates.length; it++) F(O.coordinates[it], V);
        return O;
      });
      const yt = v.bs.VectorTileFeature.prototype.toGeoJSON;
      var st = { exports: {} }, gt = v.by, Mt = v.bs.VectorTileFeature, Qt = Ht;
      function Ht(ht, O) {
        this.options = O || {}, this.features = ht, this.length = ht.length;
      }
      function pe(ht, O) {
        this.id = typeof ht.id == "number" ? ht.id : void 0, this.type = ht.type, this.rawGeometry = ht.type === 1 ? [ht.geometry] : ht.geometry, this.properties = ht.tags, this.extent = O || 4096;
      }
      Ht.prototype.feature = function(ht) {
        return new pe(this.features[ht], this.options.extent);
      }, pe.prototype.loadGeometry = function() {
        var ht = this.rawGeometry;
        this.geometry = [];
        for (var O = 0; O < ht.length; O++) {
          for (var V = ht[O], it = [], ct = 0; ct < V.length; ct++) it.push(new gt(V[ct][0], V[ct][1]));
          this.geometry.push(it);
        }
        return this.geometry;
      }, pe.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var ht = this.geometry, O = 1 / 0, V = -1 / 0, it = 1 / 0, ct = -1 / 0, At = 0; At < ht.length; At++) for (var Et = ht[At], wt = 0; wt < Et.length; wt++) {
          var xt = Et[wt];
          O = Math.min(O, xt.x), V = Math.max(V, xt.x), it = Math.min(it, xt.y), ct = Math.max(ct, xt.y);
        }
        return [O, it, V, ct];
      }, pe.prototype.toGeoJSON = Mt.prototype.toGeoJSON;
      var jt = v.bz, Tt = Qt;
      function le(ht) {
        var O = new jt();
        return function(V, it) {
          for (var ct in V.layers) it.writeMessage(3, ne, V.layers[ct]);
        }(ht, O), O.finish();
      }
      function ne(ht, O) {
        var V;
        O.writeVarintField(15, ht.version || 1), O.writeStringField(1, ht.name || ""), O.writeVarintField(5, ht.extent || 4096);
        var it = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (V = 0; V < ht.length; V++) it.feature = ht.feature(V), O.writeMessage(2, at, it);
        var ct = it.keys;
        for (V = 0; V < ct.length; V++) O.writeStringField(3, ct[V]);
        var At = it.values;
        for (V = 0; V < At.length; V++) O.writeMessage(4, Yt, At[V]);
      }
      function at(ht, O) {
        var V = ht.feature;
        V.id !== void 0 && O.writeVarintField(1, V.id), O.writeMessage(2, lt, ht), O.writeVarintField(3, V.type), O.writeMessage(4, Jt, V);
      }
      function lt(ht, O) {
        var V = ht.feature, it = ht.keys, ct = ht.values, At = ht.keycache, Et = ht.valuecache;
        for (var wt in V.properties) {
          var xt = V.properties[wt], $t = At[wt];
          if (xt !== null) {
            $t === void 0 && (it.push(wt), At[wt] = $t = it.length - 1), O.writeVarint($t);
            var re = typeof xt;
            re !== "string" && re !== "boolean" && re !== "number" && (xt = JSON.stringify(xt));
            var Rt = re + ":" + xt, fe = Et[Rt];
            fe === void 0 && (ct.push(xt), Et[Rt] = fe = ct.length - 1), O.writeVarint(fe);
          }
        }
      }
      function Pt(ht, O) {
        return (O << 3) + (7 & ht);
      }
      function bt(ht) {
        return ht << 1 ^ ht >> 31;
      }
      function Jt(ht, O) {
        for (var V = ht.loadGeometry(), it = ht.type, ct = 0, At = 0, Et = V.length, wt = 0; wt < Et; wt++) {
          var xt = V[wt], $t = 1;
          it === 1 && ($t = xt.length), O.writeVarint(Pt(1, $t));
          for (var re = it === 3 ? xt.length - 1 : xt.length, Rt = 0; Rt < re; Rt++) {
            Rt === 1 && it !== 1 && O.writeVarint(Pt(2, re - 1));
            var fe = xt[Rt].x - ct, Ne = xt[Rt].y - At;
            O.writeVarint(bt(fe)), O.writeVarint(bt(Ne)), ct += fe, At += Ne;
          }
          it === 3 && O.writeVarint(Pt(7, 1));
        }
      }
      function Yt(ht, O) {
        var V = typeof ht;
        V === "string" ? O.writeStringField(1, ht) : V === "boolean" ? O.writeBooleanField(7, ht) : V === "number" && (ht % 1 != 0 ? O.writeDoubleField(3, ht) : ht < 0 ? O.writeSVarintField(6, ht) : O.writeVarintField(5, ht));
      }
      st.exports = le, st.exports.fromVectorTileJs = le, st.exports.fromGeojsonVt = function(ht, O) {
        O = O || {};
        var V = {};
        for (var it in ht) V[it] = new Tt(ht[it].features, O), V[it].name = it, V[it].version = O.version, V[it].extent = O.extent;
        return le({ layers: V });
      }, st.exports.GeoJSONWrapper = Tt;
      var te = v.bx(st.exports);
      const Ut = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (ht) => ht }, se = Math.fround || (ee = new Float32Array(1), (ht) => (ee[0] = +ht, ee[0]));
      var ee;
      const be = 3, Q = 5, pt = 6;
      class _t {
        constructor(O) {
          this.options = Object.assign(Object.create(Ut), O), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(O) {
          const { log: V, minZoom: it, maxZoom: ct } = this.options;
          V && console.time("total time");
          const At = `prepare ${O.length} points`;
          V && console.time(At), this.points = O;
          const Et = [];
          for (let xt = 0; xt < O.length; xt++) {
            const $t = O[xt];
            if (!$t.geometry) continue;
            const [re, Rt] = $t.geometry.coordinates, fe = se(Ot(re)), Ne = se(Vt(Rt));
            Et.push(fe, Ne, 1 / 0, xt, -1, 1), this.options.reduce && Et.push(0);
          }
          let wt = this.trees[ct + 1] = this._createTree(Et);
          V && console.timeEnd(At);
          for (let xt = ct; xt >= it; xt--) {
            const $t = +Date.now();
            wt = this.trees[xt] = this._createTree(this._cluster(wt, xt)), V && console.log("z%d: %d clusters in %dms", xt, wt.numItems, +Date.now() - $t);
          }
          return V && console.timeEnd("total time"), this;
        }
        getClusters(O, V) {
          let it = ((O[0] + 180) % 360 + 360) % 360 - 180;
          const ct = Math.max(-90, Math.min(90, O[1]));
          let At = O[2] === 180 ? 180 : ((O[2] + 180) % 360 + 360) % 360 - 180;
          const Et = Math.max(-90, Math.min(90, O[3]));
          if (O[2] - O[0] >= 360) it = -180, At = 180;
          else if (it > At) {
            const Rt = this.getClusters([it, ct, 180, Et], V), fe = this.getClusters([-180, ct, At, Et], V);
            return Rt.concat(fe);
          }
          const wt = this.trees[this._limitZoom(V)], xt = wt.range(Ot(it), Vt(Et), Ot(At), Vt(ct)), $t = wt.data, re = [];
          for (const Rt of xt) {
            const fe = this.stride * Rt;
            re.push($t[fe + Q] > 1 ? Ct($t, fe, this.clusterProps) : this.points[$t[fe + be]]);
          }
          return re;
        }
        getChildren(O) {
          const V = this._getOriginId(O), it = this._getOriginZoom(O), ct = "No cluster with the specified id.", At = this.trees[it];
          if (!At) throw new Error(ct);
          const Et = At.data;
          if (V * this.stride >= Et.length) throw new Error(ct);
          const wt = this.options.radius / (this.options.extent * Math.pow(2, it - 1)), xt = At.within(Et[V * this.stride], Et[V * this.stride + 1], wt), $t = [];
          for (const re of xt) {
            const Rt = re * this.stride;
            Et[Rt + 4] === O && $t.push(Et[Rt + Q] > 1 ? Ct(Et, Rt, this.clusterProps) : this.points[Et[Rt + be]]);
          }
          if ($t.length === 0) throw new Error(ct);
          return $t;
        }
        getLeaves(O, V, it) {
          const ct = [];
          return this._appendLeaves(ct, O, V = V || 10, it = it || 0, 0), ct;
        }
        getTile(O, V, it) {
          const ct = this.trees[this._limitZoom(O)], At = Math.pow(2, O), { extent: Et, radius: wt } = this.options, xt = wt / Et, $t = (it - xt) / At, re = (it + 1 + xt) / At, Rt = { features: [] };
          return this._addTileFeatures(ct.range((V - xt) / At, $t, (V + 1 + xt) / At, re), ct.data, V, it, At, Rt), V === 0 && this._addTileFeatures(ct.range(1 - xt / At, $t, 1, re), ct.data, At, it, At, Rt), V === At - 1 && this._addTileFeatures(ct.range(0, $t, xt / At, re), ct.data, -1, it, At, Rt), Rt.features.length ? Rt : null;
        }
        getClusterExpansionZoom(O) {
          let V = this._getOriginZoom(O) - 1;
          for (; V <= this.options.maxZoom; ) {
            const it = this.getChildren(O);
            if (V++, it.length !== 1) break;
            O = it[0].properties.cluster_id;
          }
          return V;
        }
        _appendLeaves(O, V, it, ct, At) {
          const Et = this.getChildren(V);
          for (const wt of Et) {
            const xt = wt.properties;
            if (xt && xt.cluster ? At + xt.point_count <= ct ? At += xt.point_count : At = this._appendLeaves(O, xt.cluster_id, it, ct, At) : At < ct ? At++ : O.push(wt), O.length === it) break;
          }
          return At;
        }
        _createTree(O) {
          const V = new v.av(O.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let it = 0; it < O.length; it += this.stride) V.add(O[it], O[it + 1]);
          return V.finish(), V.data = O, V;
        }
        _addTileFeatures(O, V, it, ct, At, Et) {
          for (const wt of O) {
            const xt = wt * this.stride, $t = V[xt + Q] > 1;
            let re, Rt, fe;
            if ($t) re = Dt(V, xt, this.clusterProps), Rt = V[xt], fe = V[xt + 1];
            else {
              const ei = this.points[V[xt + be]];
              re = ei.properties;
              const [mi, He] = ei.geometry.coordinates;
              Rt = Ot(mi), fe = Vt(He);
            }
            const Ne = { type: 1, geometry: [[Math.round(this.options.extent * (Rt * At - it)), Math.round(this.options.extent * (fe * At - ct))]], tags: re };
            let Ve;
            Ve = $t || this.options.generateId ? V[xt + be] : this.points[V[xt + be]].id, Ve !== void 0 && (Ne.id = Ve), Et.features.push(Ne);
          }
        }
        _limitZoom(O) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+O), this.options.maxZoom + 1));
        }
        _cluster(O, V) {
          const { radius: it, extent: ct, reduce: At, minPoints: Et } = this.options, wt = it / (ct * Math.pow(2, V)), xt = O.data, $t = [], re = this.stride;
          for (let Rt = 0; Rt < xt.length; Rt += re) {
            if (xt[Rt + 2] <= V) continue;
            xt[Rt + 2] = V;
            const fe = xt[Rt], Ne = xt[Rt + 1], Ve = O.within(xt[Rt], xt[Rt + 1], wt), ei = xt[Rt + Q];
            let mi = ei;
            for (const He of Ve) {
              const Ti = He * re;
              xt[Ti + 2] > V && (mi += xt[Ti + Q]);
            }
            if (mi > ei && mi >= Et) {
              let He, Ti = fe * ei, Di = Ne * ei, Oi = -1;
              const oi = ((Rt / re | 0) << 5) + (V + 1) + this.points.length;
              for (const Ci of Ve) {
                const Ui = Ci * re;
                if (xt[Ui + 2] <= V) continue;
                xt[Ui + 2] = V;
                const rr = xt[Ui + Q];
                Ti += xt[Ui] * rr, Di += xt[Ui + 1] * rr, xt[Ui + 4] = oi, At && (He || (He = this._map(xt, Rt, !0), Oi = this.clusterProps.length, this.clusterProps.push(He)), At(He, this._map(xt, Ui)));
              }
              xt[Rt + 4] = oi, $t.push(Ti / mi, Di / mi, 1 / 0, oi, -1, mi), At && $t.push(Oi);
            } else {
              for (let He = 0; He < re; He++) $t.push(xt[Rt + He]);
              if (mi > 1) for (const He of Ve) {
                const Ti = He * re;
                if (!(xt[Ti + 2] <= V)) {
                  xt[Ti + 2] = V;
                  for (let Di = 0; Di < re; Di++) $t.push(xt[Ti + Di]);
                }
              }
            }
          }
          return $t;
        }
        _getOriginId(O) {
          return O - this.points.length >> 5;
        }
        _getOriginZoom(O) {
          return (O - this.points.length) % 32;
        }
        _map(O, V, it) {
          if (O[V + Q] > 1) {
            const Et = this.clusterProps[O[V + pt]];
            return it ? Object.assign({}, Et) : Et;
          }
          const ct = this.points[O[V + be]].properties, At = this.options.map(ct);
          return it && At === ct ? Object.assign({}, At) : At;
        }
      }
      function Ct(ht, O, V) {
        return { type: "Feature", id: ht[O + be], properties: Dt(ht, O, V), geometry: { type: "Point", coordinates: [(it = ht[O], 360 * (it - 0.5)), Wt(ht[O + 1])] } };
        var it;
      }
      function Dt(ht, O, V) {
        const it = ht[O + Q], ct = it >= 1e4 ? `${Math.round(it / 1e3)}k` : it >= 1e3 ? Math.round(it / 100) / 10 + "k" : it, At = ht[O + pt], Et = At === -1 ? {} : Object.assign({}, V[At]);
        return Object.assign(Et, { cluster: !0, cluster_id: ht[O + be], point_count: it, point_count_abbreviated: ct });
      }
      function Ot(ht) {
        return ht / 360 + 0.5;
      }
      function Vt(ht) {
        const O = Math.sin(ht * Math.PI / 180), V = 0.5 - 0.25 * Math.log((1 + O) / (1 - O)) / Math.PI;
        return V < 0 ? 0 : V > 1 ? 1 : V;
      }
      function Wt(ht) {
        const O = (180 - 360 * ht) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(O)) / Math.PI - 90;
      }
      function xe(ht, O, V, it) {
        let ct = it;
        const At = O + (V - O >> 1);
        let Et, wt = V - O;
        const xt = ht[O], $t = ht[O + 1], re = ht[V], Rt = ht[V + 1];
        for (let fe = O + 3; fe < V; fe += 3) {
          const Ne = ve(ht[fe], ht[fe + 1], xt, $t, re, Rt);
          if (Ne > ct) Et = fe, ct = Ne;
          else if (Ne === ct) {
            const Ve = Math.abs(fe - At);
            Ve < wt && (Et = fe, wt = Ve);
          }
        }
        ct > it && (Et - O > 3 && xe(ht, O, Et, it), ht[Et + 2] = ct, V - Et > 3 && xe(ht, Et, V, it));
      }
      function ve(ht, O, V, it, ct, At) {
        let Et = ct - V, wt = At - it;
        if (Et !== 0 || wt !== 0) {
          const xt = ((ht - V) * Et + (O - it) * wt) / (Et * Et + wt * wt);
          xt > 1 ? (V = ct, it = At) : xt > 0 && (V += Et * xt, it += wt * xt);
        }
        return Et = ht - V, wt = O - it, Et * Et + wt * wt;
      }
      function ke(ht, O, V, it) {
        const ct = { id: ht ?? null, type: O, geometry: V, tags: it, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (O === "Point" || O === "MultiPoint" || O === "LineString") ze(ct, V);
        else if (O === "Polygon") ze(ct, V[0]);
        else if (O === "MultiLineString") for (const At of V) ze(ct, At);
        else if (O === "MultiPolygon") for (const At of V) ze(ct, At[0]);
        return ct;
      }
      function ze(ht, O) {
        for (let V = 0; V < O.length; V += 3) ht.minX = Math.min(ht.minX, O[V]), ht.minY = Math.min(ht.minY, O[V + 1]), ht.maxX = Math.max(ht.maxX, O[V]), ht.maxY = Math.max(ht.maxY, O[V + 1]);
      }
      function Je(ht, O, V, it) {
        if (!O.geometry) return;
        const ct = O.geometry.coordinates;
        if (ct && ct.length === 0) return;
        const At = O.geometry.type, Et = Math.pow(V.tolerance / ((1 << V.maxZoom) * V.extent), 2);
        let wt = [], xt = O.id;
        if (V.promoteId ? xt = O.properties[V.promoteId] : V.generateId && (xt = it || 0), At === "Point") ie(ct, wt);
        else if (At === "MultiPoint") for (const $t of ct) ie($t, wt);
        else if (At === "LineString") K(ct, wt, Et, !1);
        else if (At === "MultiLineString") {
          if (V.lineMetrics) {
            for (const $t of ct) wt = [], K($t, wt, Et, !1), ht.push(ke(xt, "LineString", wt, O.properties));
            return;
          }
          ci(ct, wt, Et, !1);
        } else if (At === "Polygon") ci(ct, wt, Et, !0);
        else {
          if (At !== "MultiPolygon") {
            if (At === "GeometryCollection") {
              for (const $t of O.geometry.geometries) Je(ht, { id: xt, geometry: $t, properties: O.properties }, V, it);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const $t of ct) {
            const re = [];
            ci($t, re, Et, !0), wt.push(re);
          }
        }
        ht.push(ke(xt, At, wt, O.properties));
      }
      function ie(ht, O) {
        O.push(Ue(ht[0]), oe(ht[1]), 0);
      }
      function K(ht, O, V, it) {
        let ct, At, Et = 0;
        for (let xt = 0; xt < ht.length; xt++) {
          const $t = Ue(ht[xt][0]), re = oe(ht[xt][1]);
          O.push($t, re, 0), xt > 0 && (Et += it ? (ct * re - $t * At) / 2 : Math.sqrt(Math.pow($t - ct, 2) + Math.pow(re - At, 2))), ct = $t, At = re;
        }
        const wt = O.length - 3;
        O[2] = 1, xe(O, 0, wt, V), O[wt + 2] = 1, O.size = Math.abs(Et), O.start = 0, O.end = O.size;
      }
      function ci(ht, O, V, it) {
        for (let ct = 0; ct < ht.length; ct++) {
          const At = [];
          K(ht[ct], At, V, it), O.push(At);
        }
      }
      function Ue(ht) {
        return ht / 360 + 0.5;
      }
      function oe(ht) {
        const O = Math.sin(ht * Math.PI / 180), V = 0.5 - 0.25 * Math.log((1 + O) / (1 - O)) / Math.PI;
        return V < 0 ? 0 : V > 1 ? 1 : V;
      }
      function ye(ht, O, V, it, ct, At, Et, wt) {
        if (it /= O, At >= (V /= O) && Et < it) return ht;
        if (Et < V || At >= it) return null;
        const xt = [];
        for (const $t of ht) {
          const re = $t.geometry;
          let Rt = $t.type;
          const fe = ct === 0 ? $t.minX : $t.minY, Ne = ct === 0 ? $t.maxX : $t.maxY;
          if (fe >= V && Ne < it) {
            xt.push($t);
            continue;
          }
          if (Ne < V || fe >= it) continue;
          let Ve = [];
          if (Rt === "Point" || Rt === "MultiPoint") De(re, Ve, V, it, ct);
          else if (Rt === "LineString") Ae(re, Ve, V, it, ct, !1, wt.lineMetrics);
          else if (Rt === "MultiLineString") hi(re, Ve, V, it, ct, !1);
          else if (Rt === "Polygon") hi(re, Ve, V, it, ct, !0);
          else if (Rt === "MultiPolygon") for (const ei of re) {
            const mi = [];
            hi(ei, mi, V, it, ct, !0), mi.length && Ve.push(mi);
          }
          if (Ve.length) {
            if (wt.lineMetrics && Rt === "LineString") {
              for (const ei of Ve) xt.push(ke($t.id, Rt, ei, $t.tags));
              continue;
            }
            Rt !== "LineString" && Rt !== "MultiLineString" || (Ve.length === 1 ? (Rt = "LineString", Ve = Ve[0]) : Rt = "MultiLineString"), Rt !== "Point" && Rt !== "MultiPoint" || (Rt = Ve.length === 3 ? "Point" : "MultiPoint"), xt.push(ke($t.id, Rt, Ve, $t.tags));
          }
        }
        return xt.length ? xt : null;
      }
      function De(ht, O, V, it, ct) {
        for (let At = 0; At < ht.length; At += 3) {
          const Et = ht[At + ct];
          Et >= V && Et <= it && si(O, ht[At], ht[At + 1], ht[At + 2]);
        }
      }
      function Ae(ht, O, V, it, ct, At, Et) {
        let wt = $e(ht);
        const xt = ct === 0 ? _i : Ii;
        let $t, re, Rt = ht.start;
        for (let mi = 0; mi < ht.length - 3; mi += 3) {
          const He = ht[mi], Ti = ht[mi + 1], Di = ht[mi + 2], Oi = ht[mi + 3], oi = ht[mi + 4], Ci = ct === 0 ? He : Ti, Ui = ct === 0 ? Oi : oi;
          let rr = !1;
          Et && ($t = Math.sqrt(Math.pow(He - Oi, 2) + Math.pow(Ti - oi, 2))), Ci < V ? Ui > V && (re = xt(wt, He, Ti, Oi, oi, V), Et && (wt.start = Rt + $t * re)) : Ci > it ? Ui < it && (re = xt(wt, He, Ti, Oi, oi, it), Et && (wt.start = Rt + $t * re)) : si(wt, He, Ti, Di), Ui < V && Ci >= V && (re = xt(wt, He, Ti, Oi, oi, V), rr = !0), Ui > it && Ci <= it && (re = xt(wt, He, Ti, Oi, oi, it), rr = !0), !At && rr && (Et && (wt.end = Rt + $t * re), O.push(wt), wt = $e(ht)), Et && (Rt += $t);
        }
        let fe = ht.length - 3;
        const Ne = ht[fe], Ve = ht[fe + 1], ei = ct === 0 ? Ne : Ve;
        ei >= V && ei <= it && si(wt, Ne, Ve, ht[fe + 2]), fe = wt.length - 3, At && fe >= 3 && (wt[fe] !== wt[0] || wt[fe + 1] !== wt[1]) && si(wt, wt[0], wt[1], wt[2]), wt.length && O.push(wt);
      }
      function $e(ht) {
        const O = [];
        return O.size = ht.size, O.start = ht.start, O.end = ht.end, O;
      }
      function hi(ht, O, V, it, ct, At) {
        for (const Et of ht) Ae(Et, O, V, it, ct, At, !1);
      }
      function si(ht, O, V, it) {
        ht.push(O, V, it);
      }
      function _i(ht, O, V, it, ct, At) {
        const Et = (At - O) / (it - O);
        return si(ht, At, V + (ct - V) * Et, 1), Et;
      }
      function Ii(ht, O, V, it, ct, At) {
        const Et = (At - V) / (ct - V);
        return si(ht, O + (it - O) * Et, At, 1), Et;
      }
      function he(ht, O) {
        const V = [];
        for (let it = 0; it < ht.length; it++) {
          const ct = ht[it], At = ct.type;
          let Et;
          if (At === "Point" || At === "MultiPoint" || At === "LineString") Et = Ke(ct.geometry, O);
          else if (At === "MultiLineString" || At === "Polygon") {
            Et = [];
            for (const wt of ct.geometry) Et.push(Ke(wt, O));
          } else if (At === "MultiPolygon") {
            Et = [];
            for (const wt of ct.geometry) {
              const xt = [];
              for (const $t of wt) xt.push(Ke($t, O));
              Et.push(xt);
            }
          }
          V.push(ke(ct.id, At, Et, ct.tags));
        }
        return V;
      }
      function Ke(ht, O) {
        const V = [];
        V.size = ht.size, ht.start !== void 0 && (V.start = ht.start, V.end = ht.end);
        for (let it = 0; it < ht.length; it += 3) V.push(ht[it] + O, ht[it + 1], ht[it + 2]);
        return V;
      }
      function ai(ht, O) {
        if (ht.transformed) return ht;
        const V = 1 << ht.z, it = ht.x, ct = ht.y;
        for (const At of ht.features) {
          const Et = At.geometry, wt = At.type;
          if (At.geometry = [], wt === 1) for (let xt = 0; xt < Et.length; xt += 2) At.geometry.push(Pe(Et[xt], Et[xt + 1], O, V, it, ct));
          else for (let xt = 0; xt < Et.length; xt++) {
            const $t = [];
            for (let re = 0; re < Et[xt].length; re += 2) $t.push(Pe(Et[xt][re], Et[xt][re + 1], O, V, it, ct));
            At.geometry.push($t);
          }
        }
        return ht.transformed = !0, ht;
      }
      function Pe(ht, O, V, it, ct, At) {
        return [Math.round(V * (ht * it - ct)), Math.round(V * (O * it - At))];
      }
      function lr(ht, O, V, it, ct) {
        const At = O === ct.maxZoom ? 0 : ct.tolerance / ((1 << O) * ct.extent), Et = { features: [], numPoints: 0, numSimplified: 0, numFeatures: ht.length, source: null, x: V, y: it, z: O, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const wt of ht) ue(Et, wt, At, ct);
        return Et;
      }
      function ue(ht, O, V, it) {
        const ct = O.geometry, At = O.type, Et = [];
        if (ht.minX = Math.min(ht.minX, O.minX), ht.minY = Math.min(ht.minY, O.minY), ht.maxX = Math.max(ht.maxX, O.maxX), ht.maxY = Math.max(ht.maxY, O.maxY), At === "Point" || At === "MultiPoint") for (let wt = 0; wt < ct.length; wt += 3) Et.push(ct[wt], ct[wt + 1]), ht.numPoints++, ht.numSimplified++;
        else if (At === "LineString") ni(Et, ct, ht, V, !1, !1);
        else if (At === "MultiLineString" || At === "Polygon") for (let wt = 0; wt < ct.length; wt++) ni(Et, ct[wt], ht, V, At === "Polygon", wt === 0);
        else if (At === "MultiPolygon") for (let wt = 0; wt < ct.length; wt++) {
          const xt = ct[wt];
          for (let $t = 0; $t < xt.length; $t++) ni(Et, xt[$t], ht, V, !0, $t === 0);
        }
        if (Et.length) {
          let wt = O.tags || null;
          if (At === "LineString" && it.lineMetrics) {
            wt = {};
            for (const $t in O.tags) wt[$t] = O.tags[$t];
            wt.mapbox_clip_start = ct.start / ct.size, wt.mapbox_clip_end = ct.end / ct.size;
          }
          const xt = { geometry: Et, type: At === "Polygon" || At === "MultiPolygon" ? 3 : At === "LineString" || At === "MultiLineString" ? 2 : 1, tags: wt };
          O.id !== null && (xt.id = O.id), ht.features.push(xt);
        }
      }
      function ni(ht, O, V, it, ct, At) {
        const Et = it * it;
        if (it > 0 && O.size < (ct ? Et : it)) return void (V.numPoints += O.length / 3);
        const wt = [];
        for (let xt = 0; xt < O.length; xt += 3) (it === 0 || O[xt + 2] > Et) && (V.numSimplified++, wt.push(O[xt], O[xt + 1])), V.numPoints++;
        ct && function(xt, $t) {
          let re = 0;
          for (let Rt = 0, fe = xt.length, Ne = fe - 2; Rt < fe; Ne = Rt, Rt += 2) re += (xt[Rt] - xt[Ne]) * (xt[Rt + 1] + xt[Ne + 1]);
          if (re > 0 === $t) for (let Rt = 0, fe = xt.length; Rt < fe / 2; Rt += 2) {
            const Ne = xt[Rt], Ve = xt[Rt + 1];
            xt[Rt] = xt[fe - 2 - Rt], xt[Rt + 1] = xt[fe - 1 - Rt], xt[fe - 2 - Rt] = Ne, xt[fe - 1 - Rt] = Ve;
          }
        }(wt, At), ht.push(wt);
      }
      const Te = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class ki {
        constructor(O, V) {
          const it = (V = this.options = function(At, Et) {
            for (const wt in Et) At[wt] = Et[wt];
            return At;
          }(Object.create(Te), V)).debug;
          if (it && console.time("preprocess data"), V.maxZoom < 0 || V.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (V.promoteId && V.generateId) throw new Error("promoteId and generateId cannot be used together.");
          let ct = function(At, Et) {
            const wt = [];
            if (At.type === "FeatureCollection") for (let xt = 0; xt < At.features.length; xt++) Je(wt, At.features[xt], Et, xt);
            else Je(wt, At.type === "Feature" ? At : { geometry: At }, Et);
            return wt;
          }(O, V);
          this.tiles = {}, this.tileCoords = [], it && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", V.indexMaxZoom, V.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ct = function(At, Et) {
            const wt = Et.buffer / Et.extent;
            let xt = At;
            const $t = ye(At, 1, -1 - wt, wt, 0, -1, 2, Et), re = ye(At, 1, 1 - wt, 2 + wt, 0, -1, 2, Et);
            return ($t || re) && (xt = ye(At, 1, -wt, 1 + wt, 0, -1, 2, Et) || [], $t && (xt = he($t, 1).concat(xt)), re && (xt = xt.concat(he(re, -1)))), xt;
          }(ct, V), ct.length && this.splitTile(ct, 0, 0, 0), it && (ct.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(O, V, it, ct, At, Et, wt) {
          const xt = [O, V, it, ct], $t = this.options, re = $t.debug;
          for (; xt.length; ) {
            ct = xt.pop(), it = xt.pop(), V = xt.pop(), O = xt.pop();
            const Rt = 1 << V, fe = vr(V, it, ct);
            let Ne = this.tiles[fe];
            if (!Ne && (re > 1 && console.time("creation"), Ne = this.tiles[fe] = lr(O, V, it, ct, $t), this.tileCoords.push({ z: V, x: it, y: ct }), re)) {
              re > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", V, it, ct, Ne.numFeatures, Ne.numPoints, Ne.numSimplified), console.timeEnd("creation"));
              const rr = `z${V}`;
              this.stats[rr] = (this.stats[rr] || 0) + 1, this.total++;
            }
            if (Ne.source = O, At == null) {
              if (V === $t.indexMaxZoom || Ne.numPoints <= $t.indexMaxPoints) continue;
            } else {
              if (V === $t.maxZoom || V === At) continue;
              if (At != null) {
                const rr = At - V;
                if (it !== Et >> rr || ct !== wt >> rr) continue;
              }
            }
            if (Ne.source = null, O.length === 0) continue;
            re > 1 && console.time("clipping");
            const Ve = 0.5 * $t.buffer / $t.extent, ei = 0.5 - Ve, mi = 0.5 + Ve, He = 1 + Ve;
            let Ti = null, Di = null, Oi = null, oi = null, Ci = ye(O, Rt, it - Ve, it + mi, 0, Ne.minX, Ne.maxX, $t), Ui = ye(O, Rt, it + ei, it + He, 0, Ne.minX, Ne.maxX, $t);
            O = null, Ci && (Ti = ye(Ci, Rt, ct - Ve, ct + mi, 1, Ne.minY, Ne.maxY, $t), Di = ye(Ci, Rt, ct + ei, ct + He, 1, Ne.minY, Ne.maxY, $t), Ci = null), Ui && (Oi = ye(Ui, Rt, ct - Ve, ct + mi, 1, Ne.minY, Ne.maxY, $t), oi = ye(Ui, Rt, ct + ei, ct + He, 1, Ne.minY, Ne.maxY, $t), Ui = null), re > 1 && console.timeEnd("clipping"), xt.push(Ti || [], V + 1, 2 * it, 2 * ct), xt.push(Di || [], V + 1, 2 * it, 2 * ct + 1), xt.push(Oi || [], V + 1, 2 * it + 1, 2 * ct), xt.push(oi || [], V + 1, 2 * it + 1, 2 * ct + 1);
          }
        }
        getTile(O, V, it) {
          O = +O, V = +V, it = +it;
          const ct = this.options, { extent: At, debug: Et } = ct;
          if (O < 0 || O > 24) return null;
          const wt = 1 << O, xt = vr(O, V = V + wt & wt - 1, it);
          if (this.tiles[xt]) return ai(this.tiles[xt], At);
          Et > 1 && console.log("drilling down to z%d-%d-%d", O, V, it);
          let $t, re = O, Rt = V, fe = it;
          for (; !$t && re > 0; ) re--, Rt >>= 1, fe >>= 1, $t = this.tiles[vr(re, Rt, fe)];
          return $t && $t.source ? (Et > 1 && (console.log("found parent tile z%d-%d-%d", re, Rt, fe), console.time("drilling down")), this.splitTile($t.source, re, Rt, fe, O, V, it), Et > 1 && console.timeEnd("drilling down"), this.tiles[xt] ? ai(this.tiles[xt], At) : null) : null;
        }
      }
      function vr(ht, O, V) {
        return 32 * ((1 << ht) * V + O) + ht;
      }
      function Me(ht, O) {
        return O ? ht.properties[O] : ht.id;
      }
      function Ur(ht, O) {
        if (ht == null) return !0;
        if (ht.type === "Feature") return Me(ht, O) != null;
        if (ht.type === "FeatureCollection") {
          const V = /* @__PURE__ */ new Set();
          for (const it of ht.features) {
            const ct = Me(it, O);
            if (ct == null || V.has(ct)) return !1;
            V.add(ct);
          }
          return !0;
        }
        return !1;
      }
      function qi(ht, O) {
        const V = /* @__PURE__ */ new Map();
        if (ht != null) if (ht.type === "Feature") V.set(Me(ht, O), ht);
        else for (const it of ht.features) V.set(Me(it, O), it);
        return V;
      }
      class Ir extends q {
        constructor() {
          super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
        }
        loadVectorTile(O, V) {
          return v._(this, void 0, void 0, function* () {
            const it = O.tileID.canonical;
            if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
            const ct = this._geoJSONIndex.getTile(it.z, it.x, it.y);
            if (!ct) return null;
            const At = new class {
              constructor(wt) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = v.X, this.length = wt.length, this._features = wt;
              }
              feature(wt) {
                return new class {
                  constructor(xt) {
                    this._feature = xt, this.extent = v.X, this.type = xt.type, this.properties = xt.tags, "id" in xt && !isNaN(xt.id) && (this.id = parseInt(xt.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const xt = [];
                      for (const $t of this._feature.geometry) xt.push([new v.P($t[0], $t[1])]);
                      return xt;
                    }
                    {
                      const xt = [];
                      for (const $t of this._feature.geometry) {
                        const re = [];
                        for (const Rt of $t) re.push(new v.P(Rt[0], Rt[1]));
                        xt.push(re);
                      }
                      return xt;
                    }
                  }
                  toGeoJSON(xt, $t, re) {
                    return yt.call(this, xt, $t, re);
                  }
                }(this._features[wt]);
              }
            }(ct.features);
            let Et = te(At);
            return Et.byteOffset === 0 && Et.byteLength === Et.buffer.byteLength || (Et = new Uint8Array(Et)), { vectorTile: At, rawData: Et.buffer };
          });
        }
        loadData(O) {
          return v._(this, void 0, void 0, function* () {
            var V;
            (V = this._pendingRequest) === null || V === void 0 || V.abort();
            const it = !!(O && O.request && O.request.collectResourceTiming) && new v.bu(O.request);
            this._pendingRequest = new AbortController();
            try {
              this._pendingData = this.loadAndProcessGeoJSON(O, this._pendingRequest), this._geoJSONIndex = O.cluster ? new _t(function({ superclusterOptions: Et, clusterProperties: wt }) {
                if (!wt || !Et) return Et;
                const xt = {}, $t = {}, re = { accumulated: null, zoom: 0 }, Rt = { properties: null }, fe = Object.keys(wt);
                for (const Ne of fe) {
                  const [Ve, ei] = wt[Ne], mi = v.bB(ei), He = v.bB(typeof Ve == "string" ? [Ve, ["accumulated"], ["get", Ne]] : Ve);
                  xt[Ne] = mi.value, $t[Ne] = He.value;
                }
                return Et.map = (Ne) => {
                  Rt.properties = Ne;
                  const Ve = {};
                  for (const ei of fe) Ve[ei] = xt[ei].evaluate(re, Rt);
                  return Ve;
                }, Et.reduce = (Ne, Ve) => {
                  Rt.properties = Ve;
                  for (const ei of fe) re.accumulated = Ne[ei], Ne[ei] = $t[ei].evaluate(re, Rt);
                }, Et;
              }(O)).load((yield this._pendingData).features) : (ct = yield this._pendingData, new ki(ct, O.geojsonVtOptions)), this.loaded = {};
              const At = {};
              if (it) {
                const Et = it.finish();
                Et && (At.resourceTiming = {}, At.resourceTiming[O.source] = JSON.parse(JSON.stringify(Et)));
              }
              return At;
            } catch (At) {
              if (delete this._pendingRequest, v.bA(At)) return { abandoned: !0 };
              throw At;
            }
            var ct;
          });
        }
        getData() {
          return v._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile(O) {
          const V = this.loaded;
          return V && V[O.uid] ? super.reloadTile(O) : this.loadTile(O);
        }
        loadAndProcessGeoJSON(O, V) {
          return v._(this, void 0, void 0, function* () {
            let it = yield this.loadGeoJSON(O, V);
            if (delete this._pendingRequest, typeof it != "object") throw new Error(`Input data given to '${O.source}' is not a valid GeoJSON object.`);
            if (ot(it, !0), O.filter) {
              const ct = v.bB(O.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
              if (ct.result === "error") throw new Error(ct.value.map((Et) => `${Et.key}: ${Et.message}`).join(", "));
              it = { type: "FeatureCollection", features: it.features.filter((Et) => ct.value.evaluate({ zoom: 0 }, Et)) };
            }
            return it;
          });
        }
        loadGeoJSON(O, V) {
          return v._(this, void 0, void 0, function* () {
            const { promoteId: it } = O;
            if (O.request) {
              const ct = yield v.h(O.request, V);
              return this._dataUpdateable = Ur(ct.data, it) ? qi(ct.data, it) : void 0, ct.data;
            }
            if (typeof O.data == "string") try {
              const ct = JSON.parse(O.data);
              return this._dataUpdateable = Ur(ct, it) ? qi(ct, it) : void 0, ct;
            } catch {
              throw new Error(`Input data given to '${O.source}' is not a valid GeoJSON object.`);
            }
            if (!O.dataDiff) throw new Error(`Input data given to '${O.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${O.source}`);
            return function(ct, At, Et) {
              var wt, xt, $t, re;
              if (At.removeAll && ct.clear(), At.remove) for (const Rt of At.remove) ct.delete(Rt);
              if (At.add) for (const Rt of At.add) {
                const fe = Me(Rt, Et);
                fe != null && ct.set(fe, Rt);
              }
              if (At.update) for (const Rt of At.update) {
                let fe = ct.get(Rt.id);
                if (fe == null) continue;
                const Ne = !Rt.removeAllProperties && (((wt = Rt.removeProperties) === null || wt === void 0 ? void 0 : wt.length) > 0 || ((xt = Rt.addOrUpdateProperties) === null || xt === void 0 ? void 0 : xt.length) > 0);
                if ((Rt.newGeometry || Rt.removeAllProperties || Ne) && (fe = Object.assign({}, fe), ct.set(Rt.id, fe), Ne && (fe.properties = Object.assign({}, fe.properties))), Rt.newGeometry && (fe.geometry = Rt.newGeometry), Rt.removeAllProperties) fe.properties = {};
                else if ((($t = Rt.removeProperties) === null || $t === void 0 ? void 0 : $t.length) > 0) for (const Ve of Rt.removeProperties) Object.prototype.hasOwnProperty.call(fe.properties, Ve) && delete fe.properties[Ve];
                if (((re = Rt.addOrUpdateProperties) === null || re === void 0 ? void 0 : re.length) > 0) for (const { key: Ve, value: ei } of Rt.addOrUpdateProperties) fe.properties[Ve] = ei;
              }
            }(this._dataUpdateable, O.dataDiff, it), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(O) {
          return v._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(O) {
          return this._geoJSONIndex.getClusterExpansionZoom(O.clusterId);
        }
        getClusterChildren(O) {
          return this._geoJSONIndex.getChildren(O.clusterId);
        }
        getClusterLeaves(O) {
          return this._geoJSONIndex.getLeaves(O.clusterId, O.limit, O.offset);
        }
      }
      class kr {
        constructor(O) {
          this.self = O, this.actor = new v.F(O), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (V, it) => {
            if (this.externalWorkerSourceTypes[V]) throw new Error(`Worker source with name "${V}" already registered.`);
            this.externalWorkerSourceTypes[V] = it;
          }, this.self.addProtocol = v.bh, this.self.removeProtocol = v.bi, this.self.registerRTLTextPlugin = (V) => {
            if (v.bC.isParsed()) throw new Error("RTL text plugin already registered.");
            v.bC.setMethods(V);
          }, this.actor.registerMessageHandler("LDT", (V, it) => this._getDEMWorkerSource(V, it.source).loadTile(it)), this.actor.registerMessageHandler("RDT", (V, it) => v._(this, void 0, void 0, function* () {
            this._getDEMWorkerSource(V, it.source).removeTile(it);
          })), this.actor.registerMessageHandler("GCEZ", (V, it) => v._(this, void 0, void 0, function* () {
            return this._getWorkerSource(V, it.type, it.source).getClusterExpansionZoom(it);
          })), this.actor.registerMessageHandler("GCC", (V, it) => v._(this, void 0, void 0, function* () {
            return this._getWorkerSource(V, it.type, it.source).getClusterChildren(it);
          })), this.actor.registerMessageHandler("GCL", (V, it) => v._(this, void 0, void 0, function* () {
            return this._getWorkerSource(V, it.type, it.source).getClusterLeaves(it);
          })), this.actor.registerMessageHandler("LD", (V, it) => this._getWorkerSource(V, it.type, it.source).loadData(it)), this.actor.registerMessageHandler("GD", (V, it) => this._getWorkerSource(V, it.type, it.source).getData()), this.actor.registerMessageHandler("LT", (V, it) => this._getWorkerSource(V, it.type, it.source).loadTile(it)), this.actor.registerMessageHandler("RT", (V, it) => this._getWorkerSource(V, it.type, it.source).reloadTile(it)), this.actor.registerMessageHandler("AT", (V, it) => this._getWorkerSource(V, it.type, it.source).abortTile(it)), this.actor.registerMessageHandler("RMT", (V, it) => this._getWorkerSource(V, it.type, it.source).removeTile(it)), this.actor.registerMessageHandler("RS", (V, it) => v._(this, void 0, void 0, function* () {
            if (!this.workerSources[V] || !this.workerSources[V][it.type] || !this.workerSources[V][it.type][it.source]) return;
            const ct = this.workerSources[V][it.type][it.source];
            delete this.workerSources[V][it.type][it.source], ct.removeSource !== void 0 && ct.removeSource(it);
          })), this.actor.registerMessageHandler("RM", (V) => v._(this, void 0, void 0, function* () {
            delete this.layerIndexes[V], delete this.availableImages[V], delete this.workerSources[V], delete this.demWorkerSources[V];
          })), this.actor.registerMessageHandler("SR", (V, it) => v._(this, void 0, void 0, function* () {
            this.referrer = it;
          })), this.actor.registerMessageHandler("SRPS", (V, it) => this._syncRTLPluginState(V, it)), this.actor.registerMessageHandler("IS", (V, it) => v._(this, void 0, void 0, function* () {
            this.self.importScripts(it);
          })), this.actor.registerMessageHandler("SI", (V, it) => this._setImages(V, it)), this.actor.registerMessageHandler("UL", (V, it) => v._(this, void 0, void 0, function* () {
            this._getLayerIndex(V).update(it.layers, it.removedIds);
          })), this.actor.registerMessageHandler("SL", (V, it) => v._(this, void 0, void 0, function* () {
            this._getLayerIndex(V).replace(it);
          }));
        }
        _setImages(O, V) {
          return v._(this, void 0, void 0, function* () {
            this.availableImages[O] = V;
            for (const it in this.workerSources[O]) {
              const ct = this.workerSources[O][it];
              for (const At in ct) ct[At].availableImages = V;
            }
          });
        }
        _syncRTLPluginState(O, V) {
          return v._(this, void 0, void 0, function* () {
            if (v.bC.isParsed()) return v.bC.getState();
            if (V.pluginStatus !== "loading") return v.bC.setState(V), V;
            const it = V.pluginURL;
            if (this.self.importScripts(it), v.bC.isParsed()) {
              const ct = { pluginStatus: "loaded", pluginURL: it };
              return v.bC.setState(ct), ct;
            }
            throw v.bC.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${it}`);
          });
        }
        _getAvailableImages(O) {
          let V = this.availableImages[O];
          return V || (V = []), V;
        }
        _getLayerIndex(O) {
          let V = this.layerIndexes[O];
          return V || (V = this.layerIndexes[O] = new l()), V;
        }
        _getWorkerSource(O, V, it) {
          if (this.workerSources[O] || (this.workerSources[O] = {}), this.workerSources[O][V] || (this.workerSources[O][V] = {}), !this.workerSources[O][V][it]) {
            const ct = { sendAsync: (At, Et) => (At.targetMapId = O, this.actor.sendAsync(At, Et)) };
            switch (V) {
              case "vector":
                this.workerSources[O][V][it] = new q(ct, this._getLayerIndex(O), this._getAvailableImages(O));
                break;
              case "geojson":
                this.workerSources[O][V][it] = new Ir(ct, this._getLayerIndex(O), this._getAvailableImages(O));
                break;
              default:
                this.workerSources[O][V][it] = new this.externalWorkerSourceTypes[V](ct, this._getLayerIndex(O), this._getAvailableImages(O));
            }
          }
          return this.workerSources[O][V][it];
        }
        _getDEMWorkerSource(O, V) {
          return this.demWorkerSources[O] || (this.demWorkerSources[O] = {}), this.demWorkerSources[O][V] || (this.demWorkerSources[O][V] = new U()), this.demWorkerSources[O][V];
        }
      }
      return v.i(self) && (self.worker = new kr(self)), kr;
    }), P("index", ["exports", "./shared"], function(v, l) {
      var M = "4.6.0";
      let B, $;
      const q = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (p) => new Promise((t, s) => {
        const c = requestAnimationFrame(t);
        p.signal.addEventListener("abort", () => {
          cancelAnimationFrame(c), s(l.c());
        });
      }), getImageData(p, t = 0) {
        return this.getImageCanvasContext(p).getImageData(-t, -t, p.width + 2 * t, p.height + 2 * t);
      }, getImageCanvasContext(p) {
        const t = window.document.createElement("canvas"), s = t.getContext("2d", { willReadFrequently: !0 });
        if (!s) throw new Error("failed to create canvas 2d context");
        return t.width = p.width, t.height = p.height, s.drawImage(p, 0, 0, p.width, p.height), s;
      }, resolveURL: (p) => (B || (B = document.createElement("a")), B.href = p, B.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && ($ == null && ($ = matchMedia("(prefers-reduced-motion: reduce)")), $.matches);
      } };
      class U {
        static testProp(t) {
          if (!U.docStyle) return t[0];
          for (let s = 0; s < t.length; s++) if (t[s] in U.docStyle) return t[s];
          return t[0];
        }
        static create(t, s, c) {
          const r = window.document.createElement(t);
          return s !== void 0 && (r.className = s), c && c.appendChild(r), r;
        }
        static createNS(t, s) {
          return window.document.createElementNS(t, s);
        }
        static disableDrag() {
          U.docStyle && U.selectProp && (U.userSelect = U.docStyle[U.selectProp], U.docStyle[U.selectProp] = "none");
        }
        static enableDrag() {
          U.docStyle && U.selectProp && (U.docStyle[U.selectProp] = U.userSelect);
        }
        static setTransform(t, s) {
          t.style[U.transformProp] = s;
        }
        static addEventListener(t, s, c, r = {}) {
          t.addEventListener(s, c, "passive" in r ? r : r.capture);
        }
        static removeEventListener(t, s, c, r = {}) {
          t.removeEventListener(s, c, "passive" in r ? r : r.capture);
        }
        static suppressClickInternal(t) {
          t.preventDefault(), t.stopPropagation(), window.removeEventListener("click", U.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", U.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", U.suppressClickInternal, !0);
          }, 0);
        }
        static getScale(t) {
          const s = t.getBoundingClientRect();
          return { x: s.width / t.offsetWidth || 1, y: s.height / t.offsetHeight || 1, boundingClientRect: s };
        }
        static getPoint(t, s, c) {
          const r = s.boundingClientRect;
          return new l.P((c.clientX - r.left) / s.x - t.clientLeft, (c.clientY - r.top) / s.y - t.clientTop);
        }
        static mousePos(t, s) {
          const c = U.getScale(t);
          return U.getPoint(t, c, s);
        }
        static touchPos(t, s) {
          const c = [], r = U.getScale(t);
          for (let a = 0; a < s.length; a++) c.push(U.getPoint(t, r, s[a]));
          return c;
        }
        static mouseButton(t) {
          return t.button;
        }
        static remove(t) {
          t.parentNode && t.parentNode.removeChild(t);
        }
      }
      U.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, U.selectProp = U.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), U.transformProp = U.testProp(["transform", "WebkitTransform"]);
      const F = { supported: !1, testSupport: function(p) {
        !yt && ot && (st ? gt(p) : mt = p);
      } };
      let mt, ot, yt = !1, st = !1;
      function gt(p) {
        const t = p.createTexture();
        p.bindTexture(p.TEXTURE_2D, t);
        try {
          if (p.texImage2D(p.TEXTURE_2D, 0, p.RGBA, p.RGBA, p.UNSIGNED_BYTE, ot), p.isContextLost()) return;
          F.supported = !0;
        } catch {
        }
        p.deleteTexture(t), yt = !0;
      }
      var Mt;
      typeof document < "u" && (ot = document.createElement("img"), ot.onload = () => {
        mt && gt(mt), mt = null, st = !0;
      }, ot.onerror = () => {
        yt = !0, mt = null;
      }, ot.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(p) {
        let t, s, c, r;
        p.resetRequestQueue = () => {
          t = [], s = 0, c = 0, r = {};
        }, p.addThrottleControl = (_) => {
          const w = c++;
          return r[w] = _, w;
        }, p.removeThrottleControl = (_) => {
          delete r[_], h();
        }, p.getImage = (_, w, k = !0) => new Promise((T, C) => {
          F.supported && (_.headers || (_.headers = {}), _.headers.accept = "image/webp,*/*"), l.e(_, { type: "image" }), t.push({ abortController: w, requestParameters: _, supportImageRefresh: k, state: "queued", onError: (z) => {
            C(z);
          }, onSuccess: (z) => {
            T(z);
          } }), h();
        });
        const a = (_) => l._(this, void 0, void 0, function* () {
          _.state = "running";
          const { requestParameters: w, supportImageRefresh: k, onError: T, onSuccess: C, abortController: z } = _, R = k === !1 && !l.i(self) && !l.g(w.url) && (!w.headers || Object.keys(w.headers).reduce((G, nt) => G && nt === "accept", !0));
          s++;
          const W = R ? d(w, z) : l.m(w, z);
          try {
            const G = yield W;
            delete _.abortController, _.state = "completed", G.data instanceof HTMLImageElement || l.b(G.data) ? C(G) : G.data && C({ data: yield (Z = G.data, typeof createImageBitmap == "function" ? l.d(Z) : l.f(Z)), cacheControl: G.cacheControl, expires: G.expires });
          } catch (G) {
            delete _.abortController, T(G);
          } finally {
            s--, h();
          }
          var Z;
        }), h = () => {
          const _ = (() => {
            for (const w of Object.keys(r)) if (r[w]()) return !0;
            return !1;
          })() ? l.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : l.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let w = s; w < _ && t.length > 0; w++) {
            const k = t.shift();
            k.abortController.signal.aborted ? w-- : a(k);
          }
        }, d = (_, w) => new Promise((k, T) => {
          const C = new Image(), z = _.url, R = _.credentials;
          R && R === "include" ? C.crossOrigin = "use-credentials" : (R && R === "same-origin" || !l.s(z)) && (C.crossOrigin = "anonymous"), w.signal.addEventListener("abort", () => {
            C.src = "", T(l.c());
          }), C.fetchPriority = "high", C.onload = () => {
            C.onerror = C.onload = null, k({ data: C });
          }, C.onerror = () => {
            C.onerror = C.onload = null, w.signal.aborted || T(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, C.src = z;
        });
      }(Mt || (Mt = {})), Mt.resetRequestQueue();
      class Qt {
        constructor(t) {
          this._transformRequestFn = t;
        }
        transformRequest(t, s) {
          return this._transformRequestFn && this._transformRequestFn(t, s) || { url: t };
        }
        setTransformRequest(t) {
          this._transformRequestFn = t;
        }
      }
      function Ht(p) {
        var t = new l.A(3);
        return t[0] = p[0], t[1] = p[1], t[2] = p[2], t;
      }
      var pe, jt = function(p, t, s) {
        return p[0] = t[0] - s[0], p[1] = t[1] - s[1], p[2] = t[2] - s[2], p;
      };
      pe = new l.A(3), l.A != Float32Array && (pe[0] = 0, pe[1] = 0, pe[2] = 0);
      var Tt = function(p) {
        var t = p[0], s = p[1];
        return t * t + s * s;
      };
      function le(p) {
        const t = [];
        if (typeof p == "string") t.push({ id: "default", url: p });
        else if (p && p.length > 0) {
          const s = [];
          for (const { id: c, url: r } of p) {
            const a = `${c}${r}`;
            s.indexOf(a) === -1 && (s.push(a), t.push({ id: c, url: r }));
          }
        }
        return t;
      }
      function ne(p, t, s) {
        const c = p.split("?");
        return c[0] += `${t}${s}`, c.join("?");
      }
      (function() {
        var p = new l.A(2);
        l.A != Float32Array && (p[0] = 0, p[1] = 0);
      })();
      class at {
        constructor(t, s, c, r) {
          this.context = t, this.format = c, this.texture = t.gl.createTexture(), this.update(s, r);
        }
        update(t, s, c) {
          const { width: r, height: a } = t, h = !(this.size && this.size[0] === r && this.size[1] === a || c), { context: d } = this, { gl: _ } = d;
          if (this.useMipmap = !!(s && s.useMipmap), _.bindTexture(_.TEXTURE_2D, this.texture), d.pixelStoreUnpackFlipY.set(!1), d.pixelStoreUnpack.set(1), d.pixelStoreUnpackPremultiplyAlpha.set(this.format === _.RGBA && (!s || s.premultiply !== !1)), h) this.size = [r, a], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || l.b(t) ? _.texImage2D(_.TEXTURE_2D, 0, this.format, this.format, _.UNSIGNED_BYTE, t) : _.texImage2D(_.TEXTURE_2D, 0, this.format, r, a, 0, this.format, _.UNSIGNED_BYTE, t.data);
          else {
            const { x: w, y: k } = c || { x: 0, y: 0 };
            t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || l.b(t) ? _.texSubImage2D(_.TEXTURE_2D, 0, w, k, _.RGBA, _.UNSIGNED_BYTE, t) : _.texSubImage2D(_.TEXTURE_2D, 0, w, k, r, a, _.RGBA, _.UNSIGNED_BYTE, t.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && _.generateMipmap(_.TEXTURE_2D);
        }
        bind(t, s, c) {
          const { context: r } = this, { gl: a } = r;
          a.bindTexture(a.TEXTURE_2D, this.texture), c !== a.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (c = a.LINEAR), t !== this.filter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, t), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, c || t), this.filter = t), s !== this.wrap && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, s), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, s), this.wrap = s);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: t } = this.context;
          t.deleteTexture(this.texture), this.texture = null;
        }
      }
      function lt(p) {
        const { userImage: t } = p;
        return !!(t && t.render && t.render()) && (p.data.replace(new Uint8Array(t.data.buffer)), !0);
      }
      class Pt extends l.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new l.R({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(t) {
          if (this.loaded !== t && (this.loaded = t, t)) {
            for (const { ids: s, promiseResolve: c } of this.requestors) c(this._getImagesForIds(s));
            this.requestors = [];
          }
        }
        getImage(t) {
          const s = this.images[t];
          if (s && !s.data && s.spriteData) {
            const c = s.spriteData;
            s.data = new l.R({ width: c.width, height: c.height }, c.context.getImageData(c.x, c.y, c.width, c.height).data), s.spriteData = null;
          }
          return s;
        }
        addImage(t, s) {
          if (this.images[t]) throw new Error(`Image id ${t} already exist, use updateImage instead`);
          this._validate(t, s) && (this.images[t] = s);
        }
        _validate(t, s) {
          let c = !0;
          const r = s.data || s.spriteData;
          return this._validateStretch(s.stretchX, r && r.width) || (this.fire(new l.j(new Error(`Image "${t}" has invalid "stretchX" value`))), c = !1), this._validateStretch(s.stretchY, r && r.height) || (this.fire(new l.j(new Error(`Image "${t}" has invalid "stretchY" value`))), c = !1), this._validateContent(s.content, s) || (this.fire(new l.j(new Error(`Image "${t}" has invalid "content" value`))), c = !1), c;
        }
        _validateStretch(t, s) {
          if (!t) return !0;
          let c = 0;
          for (const r of t) {
            if (r[0] < c || r[1] < r[0] || s < r[1]) return !1;
            c = r[1];
          }
          return !0;
        }
        _validateContent(t, s) {
          if (!t) return !0;
          if (t.length !== 4) return !1;
          const c = s.spriteData, r = c && c.width || s.data.width, a = c && c.height || s.data.height;
          return !(t[0] < 0 || r < t[0] || t[1] < 0 || a < t[1] || t[2] < 0 || r < t[2] || t[3] < 0 || a < t[3] || t[2] < t[0] || t[3] < t[1]);
        }
        updateImage(t, s, c = !0) {
          const r = this.getImage(t);
          if (c && (r.data.width !== s.data.width || r.data.height !== s.data.height)) throw new Error(`size mismatch between old image (${r.data.width}x${r.data.height}) and new image (${s.data.width}x${s.data.height}).`);
          s.version = r.version + 1, this.images[t] = s, this.updatedImages[t] = !0;
        }
        removeImage(t) {
          const s = this.images[t];
          delete this.images[t], delete this.patterns[t], s.userImage && s.userImage.onRemove && s.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(t) {
          return new Promise((s, c) => {
            let r = !0;
            if (!this.isLoaded()) for (const a of t) this.images[a] || (r = !1);
            this.isLoaded() || r ? s(this._getImagesForIds(t)) : this.requestors.push({ ids: t, promiseResolve: s });
          });
        }
        _getImagesForIds(t) {
          const s = {};
          for (const c of t) {
            let r = this.getImage(c);
            r || (this.fire(new l.k("styleimagemissing", { id: c })), r = this.getImage(c)), r ? s[c] = { data: r.data.clone(), pixelRatio: r.pixelRatio, sdf: r.sdf, version: r.version, stretchX: r.stretchX, stretchY: r.stretchY, content: r.content, textFitWidth: r.textFitWidth, textFitHeight: r.textFitHeight, hasRenderCallback: !!(r.userImage && r.userImage.render) } : l.w(`Image "${c}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return s;
        }
        getPixelSize() {
          const { width: t, height: s } = this.atlasImage;
          return { width: t, height: s };
        }
        getPattern(t) {
          const s = this.patterns[t], c = this.getImage(t);
          if (!c) return null;
          if (s && s.position.version === c.version) return s.position;
          if (s) s.position.version = c.version;
          else {
            const r = { w: c.data.width + 2, h: c.data.height + 2, x: 0, y: 0 }, a = new l.I(r, c);
            this.patterns[t] = { bin: r, position: a };
          }
          return this._updatePatternAtlas(), this.patterns[t].position;
        }
        bind(t) {
          const s = t.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new at(t, this.atlasImage, s.RGBA), this.atlasTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const t = [];
          for (const a in this.patterns) t.push(this.patterns[a].bin);
          const { w: s, h: c } = l.p(t), r = this.atlasImage;
          r.resize({ width: s || 1, height: c || 1 });
          for (const a in this.patterns) {
            const { bin: h } = this.patterns[a], d = h.x + 1, _ = h.y + 1, w = this.getImage(a).data, k = w.width, T = w.height;
            l.R.copy(w, r, { x: 0, y: 0 }, { x: d, y: _ }, { width: k, height: T }), l.R.copy(w, r, { x: 0, y: T - 1 }, { x: d, y: _ - 1 }, { width: k, height: 1 }), l.R.copy(w, r, { x: 0, y: 0 }, { x: d, y: _ + T }, { width: k, height: 1 }), l.R.copy(w, r, { x: k - 1, y: 0 }, { x: d - 1, y: _ }, { width: 1, height: T }), l.R.copy(w, r, { x: 0, y: 0 }, { x: d + k, y: _ }, { width: 1, height: T });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(t) {
          for (const s of t) {
            if (this.callbackDispatchedThisFrame[s]) continue;
            this.callbackDispatchedThisFrame[s] = !0;
            const c = this.getImage(s);
            c || l.w(`Image with ID: "${s}" was not found`), lt(c) && this.updateImage(s, c);
          }
        }
      }
      const bt = 1e20;
      function Jt(p, t, s, c, r, a, h, d, _) {
        for (let w = t; w < t + c; w++) Yt(p, s * a + w, a, r, h, d, _);
        for (let w = s; w < s + r; w++) Yt(p, w * a + t, 1, c, h, d, _);
      }
      function Yt(p, t, s, c, r, a, h) {
        a[0] = 0, h[0] = -bt, h[1] = bt, r[0] = p[t];
        for (let d = 1, _ = 0, w = 0; d < c; d++) {
          r[d] = p[t + d * s];
          const k = d * d;
          do {
            const T = a[_];
            w = (r[d] - r[T] + k - T * T) / (d - T) / 2;
          } while (w <= h[_] && --_ > -1);
          _++, a[_] = d, h[_] = w, h[_ + 1] = bt;
        }
        for (let d = 0, _ = 0; d < c; d++) {
          for (; h[_ + 1] < d; ) _++;
          const w = a[_], k = d - w;
          p[t + d * s] = r[w] + k * k;
        }
      }
      class te {
        constructor(t, s) {
          this.requestManager = t, this.localIdeographFontFamily = s, this.entries = {};
        }
        setURL(t) {
          this.url = t;
        }
        getGlyphs(t) {
          return l._(this, void 0, void 0, function* () {
            const s = [];
            for (const a in t) for (const h of t[a]) s.push(this._getAndCacheGlyphsPromise(a, h));
            const c = yield Promise.all(s), r = {};
            for (const { stack: a, id: h, glyph: d } of c) r[a] || (r[a] = {}), r[a][h] = d && { id: d.id, bitmap: d.bitmap.clone(), metrics: d.metrics };
            return r;
          });
        }
        _getAndCacheGlyphsPromise(t, s) {
          return l._(this, void 0, void 0, function* () {
            let c = this.entries[t];
            c || (c = this.entries[t] = { glyphs: {}, requests: {}, ranges: {} });
            let r = c.glyphs[s];
            if (r !== void 0) return { stack: t, id: s, glyph: r };
            if (r = this._tinySDF(c, t, s), r) return c.glyphs[s] = r, { stack: t, id: s, glyph: r };
            const a = Math.floor(s / 256);
            if (256 * a > 65535) throw new Error("glyphs > 65535 not supported");
            if (c.ranges[a]) return { stack: t, id: s, glyph: r };
            if (!this.url) throw new Error("glyphsUrl is not set");
            if (!c.requests[a]) {
              const d = te.loadGlyphRange(t, a, this.url, this.requestManager);
              c.requests[a] = d;
            }
            const h = yield c.requests[a];
            for (const d in h) this._doesCharSupportLocalGlyph(+d) || (c.glyphs[+d] = h[+d]);
            return c.ranges[a] = !0, { stack: t, id: s, glyph: h[s] || null };
          });
        }
        _doesCharSupportLocalGlyph(t) {
          return !!this.localIdeographFontFamily && new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(t));
        }
        _tinySDF(t, s, c) {
          const r = this.localIdeographFontFamily;
          if (!r || !this._doesCharSupportLocalGlyph(c)) return;
          let a = t.tinySDF;
          if (!a) {
            let d = "400";
            /bold/i.test(s) ? d = "900" : /medium/i.test(s) ? d = "500" : /light/i.test(s) && (d = "200"), a = t.tinySDF = new te.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: r, fontWeight: d });
          }
          const h = a.draw(String.fromCharCode(c));
          return { id: c, bitmap: new l.o({ width: h.width || 60, height: h.height || 60 }, h.data), metrics: { width: h.glyphWidth / 2 || 24, height: h.glyphHeight / 2 || 24, left: h.glyphLeft / 2 + 0.5 || 0, top: h.glyphTop / 2 - 27.5 || -8, advance: h.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
        }
      }
      te.loadGlyphRange = function(p, t, s, c) {
        return l._(this, void 0, void 0, function* () {
          const r = 256 * t, a = r + 255, h = c.transformRequest(s.replace("{fontstack}", p).replace("{range}", `${r}-${a}`), "Glyphs"), d = yield l.l(h, new AbortController());
          if (!d || !d.data) throw new Error(`Could not load glyph range. range: ${t}, ${r}-${a}`);
          const _ = {};
          for (const w of l.n(d.data)) _[w.id] = w;
          return _;
        });
      }, te.TinySDF = class {
        constructor({ fontSize: p = 24, buffer: t = 3, radius: s = 8, cutoff: c = 0.25, fontFamily: r = "sans-serif", fontWeight: a = "normal", fontStyle: h = "normal" } = {}) {
          this.buffer = t, this.cutoff = c, this.radius = s;
          const d = this.size = p + 4 * t, _ = this._createCanvas(d), w = this.ctx = _.getContext("2d", { willReadFrequently: !0 });
          w.font = `${h} ${a} ${p}px ${r}`, w.textBaseline = "alphabetic", w.textAlign = "left", w.fillStyle = "black", this.gridOuter = new Float64Array(d * d), this.gridInner = new Float64Array(d * d), this.f = new Float64Array(d), this.z = new Float64Array(d + 1), this.v = new Uint16Array(d);
        }
        _createCanvas(p) {
          const t = document.createElement("canvas");
          return t.width = t.height = p, t;
        }
        draw(p) {
          const { width: t, actualBoundingBoxAscent: s, actualBoundingBoxDescent: c, actualBoundingBoxLeft: r, actualBoundingBoxRight: a } = this.ctx.measureText(p), h = Math.ceil(s), d = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a - r))), _ = Math.min(this.size - this.buffer, h + Math.ceil(c)), w = d + 2 * this.buffer, k = _ + 2 * this.buffer, T = Math.max(w * k, 0), C = new Uint8ClampedArray(T), z = { data: C, width: w, height: k, glyphWidth: d, glyphHeight: _, glyphTop: h, glyphLeft: 0, glyphAdvance: t };
          if (d === 0 || _ === 0) return z;
          const { ctx: R, buffer: W, gridInner: Z, gridOuter: G } = this;
          R.clearRect(W, W, d, _), R.fillText(p, W, W + h);
          const nt = R.getImageData(W, W, d, _);
          G.fill(bt, 0, T), Z.fill(0, 0, T);
          for (let Y = 0; Y < _; Y++) for (let J = 0; J < d; J++) {
            const tt = nt.data[4 * (Y * d + J) + 3] / 255;
            if (tt === 0) continue;
            const ut = (Y + W) * w + J + W;
            if (tt === 1) G[ut] = 0, Z[ut] = bt;
            else {
              const St = 0.5 - tt;
              G[ut] = St > 0 ? St * St : 0, Z[ut] = St < 0 ? St * St : 0;
            }
          }
          Jt(G, 0, 0, w, k, w, this.f, this.v, this.z), Jt(Z, W, W, d, _, w, this.f, this.v, this.z);
          for (let Y = 0; Y < T; Y++) {
            const J = Math.sqrt(G[Y]) - Math.sqrt(Z[Y]);
            C[Y] = Math.round(255 - 255 * (J / this.radius + this.cutoff));
          }
          return z;
        }
      };
      class Ut {
        constructor() {
          this.specification = l.v.light.position;
        }
        possiblyEvaluate(t, s) {
          return l.x(t.expression.evaluate(s));
        }
        interpolate(t, s, c) {
          return { x: l.y.number(t.x, s.x, c), y: l.y.number(t.y, s.y, c), z: l.y.number(t.z, s.z, c) };
        }
      }
      let se;
      class ee extends l.E {
        constructor(t) {
          super(), se = se || new l.q({ anchor: new l.D(l.v.light.anchor), position: new Ut(), color: new l.D(l.v.light.color), intensity: new l.D(l.v.light.intensity) }), this._transitionable = new l.T(se), this.setLight(t), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t, s = {}) {
          if (!this._validate(l.r, t, s)) for (const c in t) {
            const r = t[c];
            c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), r) : this._transitionable.setValue(c, r);
          }
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, s, c) {
          return (!c || c.validate !== !1) && l.t(this, t.call(l.u, { value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: l.v }));
        }
      }
      const be = new l.q({ "sky-color": new l.D(l.v.sky["sky-color"]), "horizon-color": new l.D(l.v.sky["horizon-color"]), "fog-color": new l.D(l.v.sky["fog-color"]), "fog-ground-blend": new l.D(l.v.sky["fog-ground-blend"]), "horizon-fog-blend": new l.D(l.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new l.D(l.v.sky["sky-horizon-blend"]), "atmosphere-blend": new l.D(l.v.sky["atmosphere-blend"]) });
      class Q extends l.E {
        constructor(t) {
          super(), this._transitionable = new l.T(be), this.setSky(t), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new l.z(0));
        }
        setSky(t, s = {}) {
          if (!this._validate(l.B, t, s)) {
            t || (t = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent" });
            for (const c in t) {
              const r = t[c];
              c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), r) : this._transitionable.setValue(c, r);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, s, c = {}) {
          return (c == null ? void 0 : c.validate) !== !1 && l.t(this, t.call(l.u, l.e({ value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: l.v })));
        }
        calculateFogBlendOpacity(t) {
          return t < 60 ? 0 : t < 70 ? (t - 60) / 10 : 1;
        }
      }
      class pt {
        constructor(t, s) {
          this.width = t, this.height = s, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(t, s) {
          const c = t.join(",") + String(s);
          return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(t, s)), this.dashEntry[c];
        }
        getDashRanges(t, s, c) {
          const r = [];
          let a = t.length % 2 == 1 ? -t[t.length - 1] * c : 0, h = t[0] * c, d = !0;
          r.push({ left: a, right: h, isDash: d, zeroLength: t[0] === 0 });
          let _ = t[0];
          for (let w = 1; w < t.length; w++) {
            d = !d;
            const k = t[w];
            a = _ * c, _ += k, h = _ * c, r.push({ left: a, right: h, isDash: d, zeroLength: k === 0 });
          }
          return r;
        }
        addRoundDash(t, s, c) {
          const r = s / 2;
          for (let a = -c; a <= c; a++) {
            const h = this.width * (this.nextRow + c + a);
            let d = 0, _ = t[d];
            for (let w = 0; w < this.width; w++) {
              w / _.right > 1 && (_ = t[++d]);
              const k = Math.abs(w - _.left), T = Math.abs(w - _.right), C = Math.min(k, T);
              let z;
              const R = a / c * (r + 1);
              if (_.isDash) {
                const W = r - Math.abs(R);
                z = Math.sqrt(C * C + W * W);
              } else z = r - Math.sqrt(C * C + R * R);
              this.data[h + w] = Math.max(0, Math.min(255, z + 128));
            }
          }
        }
        addRegularDash(t) {
          for (let d = t.length - 1; d >= 0; --d) {
            const _ = t[d], w = t[d + 1];
            _.zeroLength ? t.splice(d, 1) : w && w.isDash === _.isDash && (w.left = _.left, t.splice(d, 1));
          }
          const s = t[0], c = t[t.length - 1];
          s.isDash === c.isDash && (s.left = c.left - this.width, c.right = s.right + this.width);
          const r = this.width * this.nextRow;
          let a = 0, h = t[a];
          for (let d = 0; d < this.width; d++) {
            d / h.right > 1 && (h = t[++a]);
            const _ = Math.abs(d - h.left), w = Math.abs(d - h.right), k = Math.min(_, w);
            this.data[r + d] = Math.max(0, Math.min(255, (h.isDash ? k : -k) + 128));
          }
        }
        addDash(t, s) {
          const c = s ? 7 : 0, r = 2 * c + 1;
          if (this.nextRow + r > this.height) return l.w("LineAtlas out of space"), null;
          let a = 0;
          for (let d = 0; d < t.length; d++) a += t[d];
          if (a !== 0) {
            const d = this.width / a, _ = this.getDashRanges(t, this.width, d);
            s ? this.addRoundDash(_, d, c) : this.addRegularDash(_);
          }
          const h = { y: (this.nextRow + c + 0.5) / this.height, height: 2 * c / this.height, width: a };
          return this.nextRow += r, this.dirty = !0, h;
        }
        bind(t) {
          const s = t.gl;
          this.texture ? (s.bindTexture(s.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, this.width, this.height, s.ALPHA, s.UNSIGNED_BYTE, this.data))) : (this.texture = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this.texture), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.REPEAT), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.REPEAT), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), s.texImage2D(s.TEXTURE_2D, 0, s.ALPHA, this.width, this.height, 0, s.ALPHA, s.UNSIGNED_BYTE, this.data));
        }
      }
      const _t = "maplibre_preloaded_worker_pool";
      class Ct {
        constructor() {
          this.active = {};
        }
        acquire(t) {
          if (!this.workers) for (this.workers = []; this.workers.length < Ct.workerCount; ) this.workers.push(new Worker(l.a.WORKER_URL));
          return this.active[t] = !0, this.workers.slice();
        }
        release(t) {
          delete this.active[t], this.numActive() === 0 && (this.workers.forEach((s) => {
            s.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[_t];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const Dt = Math.floor(q.hardwareConcurrency / 2);
      let Ot, Vt;
      function Wt() {
        return Ot || (Ot = new Ct()), Ot;
      }
      Ct.workerCount = l.C(globalThis) ? Math.max(Math.min(Dt, 3), 1) : 1;
      class xe {
        constructor(t, s) {
          this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = s;
          const c = this.workerPool.acquire(s);
          for (let r = 0; r < c.length; r++) {
            const a = new l.F(c[r], s);
            a.name = `Worker ${r}`, this.actors.push(a);
          }
          if (!this.actors.length) throw new Error("No actors found");
        }
        broadcast(t, s) {
          const c = [];
          for (const r of this.actors) c.push(r.sendAsync({ type: t, data: s }));
          return Promise.all(c);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(t = !0) {
          this.actors.forEach((s) => {
            s.remove();
          }), this.actors = [], t && this.workerPool.release(this.id);
        }
        registerMessageHandler(t, s) {
          for (const c of this.actors) c.registerMessageHandler(t, s);
        }
      }
      function ve() {
        return Vt || (Vt = new xe(Wt(), l.G), Vt.registerMessageHandler("GR", (p, t, s) => l.m(t, s))), Vt;
      }
      function ke(p, t) {
        const s = l.H();
        return l.J(s, s, [1, 1, 0]), l.K(s, s, [0.5 * p.width, 0.5 * p.height, 1]), l.L(s, s, p.calculatePosMatrix(t.toUnwrapped()));
      }
      function ze(p, t, s, c, r, a) {
        const h = function(T, C, z) {
          if (T) for (const R of T) {
            const W = C[R];
            if (W && W.source === z && W.type === "fill-extrusion") return !0;
          }
          else for (const R in C) {
            const W = C[R];
            if (W.source === z && W.type === "fill-extrusion") return !0;
          }
          return !1;
        }(r && r.layers, t, p.id), d = a.maxPitchScaleFactor(), _ = p.tilesIn(c, d, h);
        _.sort(Je);
        const w = [];
        for (const T of _) w.push({ wrappedTileID: T.tileID.wrapped().key, queryResults: T.tile.queryRenderedFeatures(t, s, p._state, T.queryGeometry, T.cameraQueryGeometry, T.scale, r, a, d, ke(p.transform, T.tileID)) });
        const k = function(T) {
          const C = {}, z = {};
          for (const R of T) {
            const W = R.queryResults, Z = R.wrappedTileID, G = z[Z] = z[Z] || {};
            for (const nt in W) {
              const Y = W[nt], J = G[nt] = G[nt] || {}, tt = C[nt] = C[nt] || [];
              for (const ut of Y) J[ut.featureIndex] || (J[ut.featureIndex] = !0, tt.push(ut));
            }
          }
          return C;
        }(w);
        for (const T in k) k[T].forEach((C) => {
          const z = C.feature, R = p.getFeatureState(z.layer["source-layer"], z.id);
          z.source = z.layer.source, z.layer["source-layer"] && (z.sourceLayer = z.layer["source-layer"]), z.state = R;
        });
        return k;
      }
      function Je(p, t) {
        const s = p.tileID, c = t.tileID;
        return s.overscaledZ - c.overscaledZ || s.canonical.y - c.canonical.y || s.wrap - c.wrap || s.canonical.x - c.canonical.x;
      }
      function ie(p, t, s) {
        return l._(this, void 0, void 0, function* () {
          let c = p;
          if (p.url ? c = (yield l.h(t.transformRequest(p.url, "Source"), s)).data : yield q.frameAsync(s), !c) return null;
          const r = l.M(l.e(c, p), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in c && c.vector_layers && (r.vectorLayerIds = c.vector_layers.map((a) => a.id)), r;
        });
      }
      class K {
        constructor(t, s) {
          t && (s ? this.setSouthWest(t).setNorthEast(s) : Array.isArray(t) && (t.length === 4 ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1])));
        }
        setNorthEast(t) {
          return this._ne = t instanceof l.N ? new l.N(t.lng, t.lat) : l.N.convert(t), this;
        }
        setSouthWest(t) {
          return this._sw = t instanceof l.N ? new l.N(t.lng, t.lat) : l.N.convert(t), this;
        }
        extend(t) {
          const s = this._sw, c = this._ne;
          let r, a;
          if (t instanceof l.N) r = t, a = t;
          else {
            if (!(t instanceof K)) return Array.isArray(t) ? t.length === 4 || t.every(Array.isArray) ? this.extend(K.convert(t)) : this.extend(l.N.convert(t)) : t && ("lng" in t || "lon" in t) && "lat" in t ? this.extend(l.N.convert(t)) : this;
            if (r = t._sw, a = t._ne, !r || !a) return this;
          }
          return s || c ? (s.lng = Math.min(r.lng, s.lng), s.lat = Math.min(r.lat, s.lat), c.lng = Math.max(a.lng, c.lng), c.lat = Math.max(a.lat, c.lat)) : (this._sw = new l.N(r.lng, r.lat), this._ne = new l.N(a.lng, a.lat)), this;
        }
        getCenter() {
          return new l.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new l.N(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new l.N(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t) {
          const { lng: s, lat: c } = l.N.convert(t);
          let r = this._sw.lng <= s && s <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (r = this._sw.lng >= s && s >= this._ne.lng), this._sw.lat <= c && c <= this._ne.lat && r;
        }
        static convert(t) {
          return t instanceof K ? t : t && new K(t);
        }
        static fromLngLat(t, s = 0) {
          const c = 360 * s / 40075017, r = c / Math.cos(Math.PI / 180 * t.lat);
          return new K(new l.N(t.lng - r, t.lat - c), new l.N(t.lng + r, t.lat + c));
        }
      }
      class ci {
        constructor(t, s, c) {
          this.bounds = K.convert(this.validateBounds(t)), this.minzoom = s || 0, this.maxzoom = c || 24;
        }
        validateBounds(t) {
          return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
        }
        contains(t) {
          const s = Math.pow(2, t.z), c = Math.floor(l.O(this.bounds.getWest()) * s), r = Math.floor(l.Q(this.bounds.getNorth()) * s), a = Math.ceil(l.O(this.bounds.getEast()) * s), h = Math.ceil(l.Q(this.bounds.getSouth()) * s);
          return t.x >= c && t.x < a && t.y >= r && t.y < h;
        }
      }
      class Ue extends l.E {
        constructor(t, s, c, r) {
          if (super(), this.id = t, this.dispatcher = c, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, l.e(this, l.M(s, ["url", "scheme", "tileSize", "promoteId"])), this._options = l.e({ type: "vector" }, s), this._collectResourceTiming = s.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(r);
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new l.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const t = yield ie(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), t && (l.e(this, t), t.bounds && (this.tileBounds = new ci(t.bounds, this.minzoom, this.maxzoom)), this.fire(new l.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new l.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (t) {
              this._tileJSONRequest = null, this.fire(new l.j(t));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        setSourceProperty(t) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), t(), this.load();
        }
        setTiles(t) {
          return this.setSourceProperty(() => {
            this._options.tiles = t;
          }), this;
        }
        setUrl(t) {
          return this.setSourceProperty(() => {
            this.url = t, this._options.url = t;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return l.e({}, this._options);
        }
        loadTile(t) {
          return l._(this, void 0, void 0, function* () {
            const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = { request: this.map._requestManager.transformRequest(s, "Tile"), uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            c.request.collectResourceTiming = this._collectResourceTiming;
            let r = "RT";
            if (t.actor && t.state !== "expired") {
              if (t.state === "loading") return new Promise((a, h) => {
                t.reloadPromise = { resolve: a, reject: h };
              });
            } else t.actor = this.dispatcher.getActor(), r = "LT";
            t.abortController = new AbortController();
            try {
              const a = yield t.actor.sendAsync({ type: r, data: c }, t.abortController);
              if (delete t.abortController, t.aborted) return;
              this._afterTileLoadWorkerResponse(t, a);
            } catch (a) {
              if (delete t.abortController, t.aborted) return;
              if (a && a.status !== 404) throw a;
              this._afterTileLoadWorkerResponse(t, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(t, s) {
          if (s && s.resourceTiming && (t.resourceTiming = s.resourceTiming), s && this.map._refreshExpiredTiles && t.setExpiryData(s), t.loadVectorData(s, this.map.painter), t.reloadPromise) {
            const c = t.reloadPromise;
            t.reloadPromise = null, this.loadTile(t).then(c.resolve).catch(c.reject);
          }
        }
        abortTile(t) {
          return l._(this, void 0, void 0, function* () {
            t.abortController && (t.abortController.abort(), delete t.abortController), t.actor && (yield t.actor.sendAsync({ type: "AT", data: { uid: t.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(t) {
          return l._(this, void 0, void 0, function* () {
            t.unloadVectorData(), t.actor && (yield t.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class oe extends l.E {
        constructor(t, s, c, r) {
          super(), this.id = t, this.dispatcher = c, this.setEventedParent(r), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = l.e({ type: "raster" }, s), l.e(this, l.M(s, ["url", "scheme", "tileSize"]));
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new l.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const t = yield ie(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, t && (l.e(this, t), t.bounds && (this.tileBounds = new ci(t.bounds, this.minzoom, this.maxzoom)), this.fire(new l.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new l.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (t) {
              this._tileJSONRequest = null, this.fire(new l.j(t));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(t) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t(), this.load();
        }
        setTiles(t) {
          return this.setSourceProperty(() => {
            this._options.tiles = t;
          }), this;
        }
        setUrl(t) {
          return this.setSourceProperty(() => {
            this.url = t, this._options.url = t;
          }), this;
        }
        serialize() {
          return l.e({}, this._options);
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        loadTile(t) {
          return l._(this, void 0, void 0, function* () {
            const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            t.abortController = new AbortController();
            try {
              const c = yield Mt.getImage(this.map._requestManager.transformRequest(s, "Tile"), t.abortController, this.map._refreshExpiredTiles);
              if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
              if (c && c.data) {
                this.map._refreshExpiredTiles && c.cacheControl && c.expires && t.setExpiryData({ cacheControl: c.cacheControl, expires: c.expires });
                const r = this.map.painter.context, a = r.gl, h = c.data;
                t.texture = this.map.painter.getTileTexture(h.width), t.texture ? t.texture.update(h, { useMipmap: !0 }) : (t.texture = new at(r, h, a.RGBA, { useMipmap: !0 }), t.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST)), t.state = "loaded";
              }
            } catch (c) {
              if (delete t.abortController, t.aborted) t.state = "unloaded";
              else if (c) throw t.state = "errored", c;
            }
          });
        }
        abortTile(t) {
          return l._(this, void 0, void 0, function* () {
            t.abortController && (t.abortController.abort(), delete t.abortController);
          });
        }
        unloadTile(t) {
          return l._(this, void 0, void 0, function* () {
            t.texture && this.map.painter.saveTileTexture(t.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class ye extends oe {
        constructor(t, s, c, r) {
          super(t, s, c, r), this.type = "raster-dem", this.maxzoom = 22, this._options = l.e({ type: "raster-dem" }, s), this.encoding = s.encoding || "mapbox", this.redFactor = s.redFactor, this.greenFactor = s.greenFactor, this.blueFactor = s.blueFactor, this.baseShift = s.baseShift;
        }
        loadTile(t) {
          return l._(this, void 0, void 0, function* () {
            const s = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = this.map._requestManager.transformRequest(s, "Tile");
            t.neighboringTiles = this._getNeighboringTiles(t.tileID), t.abortController = new AbortController();
            try {
              const r = yield Mt.getImage(c, t.abortController, this.map._refreshExpiredTiles);
              if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
              if (r && r.data) {
                const a = r.data;
                this.map._refreshExpiredTiles && r.cacheControl && r.expires && t.setExpiryData({ cacheControl: r.cacheControl, expires: r.expires });
                const h = l.b(a) && l.U() ? a : yield this.readImageNow(a), d = { type: this.type, uid: t.uid, source: this.id, rawImageData: h, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!t.actor || t.state === "expired") {
                  t.actor = this.dispatcher.getActor();
                  const _ = yield t.actor.sendAsync({ type: "LDT", data: d });
                  t.dem = _, t.needsHillshadePrepare = !0, t.needsTerrainPrepare = !0, t.state = "loaded";
                }
              }
            } catch (r) {
              if (delete t.abortController, t.aborted) t.state = "unloaded";
              else if (r) throw t.state = "errored", r;
            }
          });
        }
        readImageNow(t) {
          return l._(this, void 0, void 0, function* () {
            if (typeof VideoFrame < "u" && l.V()) {
              const s = t.width + 2, c = t.height + 2;
              try {
                return new l.R({ width: s, height: c }, yield l.W(t, -1, -1, s, c));
              } catch {
              }
            }
            return q.getImageData(t, 1);
          });
        }
        _getNeighboringTiles(t) {
          const s = t.canonical, c = Math.pow(2, s.z), r = (s.x - 1 + c) % c, a = s.x === 0 ? t.wrap - 1 : t.wrap, h = (s.x + 1 + c) % c, d = s.x + 1 === c ? t.wrap + 1 : t.wrap, _ = {};
          return _[new l.S(t.overscaledZ, a, s.z, r, s.y).key] = { backfilled: !1 }, _[new l.S(t.overscaledZ, d, s.z, h, s.y).key] = { backfilled: !1 }, s.y > 0 && (_[new l.S(t.overscaledZ, a, s.z, r, s.y - 1).key] = { backfilled: !1 }, _[new l.S(t.overscaledZ, t.wrap, s.z, s.x, s.y - 1).key] = { backfilled: !1 }, _[new l.S(t.overscaledZ, d, s.z, h, s.y - 1).key] = { backfilled: !1 }), s.y + 1 < c && (_[new l.S(t.overscaledZ, a, s.z, r, s.y + 1).key] = { backfilled: !1 }, _[new l.S(t.overscaledZ, t.wrap, s.z, s.x, s.y + 1).key] = { backfilled: !1 }, _[new l.S(t.overscaledZ, d, s.z, h, s.y + 1).key] = { backfilled: !1 }), _;
        }
        unloadTile(t) {
          return l._(this, void 0, void 0, function* () {
            t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && (yield t.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: t.uid, source: this.id } }));
          });
        }
      }
      class De extends l.E {
        constructor(t, s, c, r) {
          super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = c.getActor(), this.setEventedParent(r), this._data = s.data, this._options = l.e({}, s), this._collectResourceTiming = s.collectResourceTiming, s.maxzoom !== void 0 && (this.maxzoom = s.maxzoom), s.type && (this.type = s.type), s.attribution && (this.attribution = s.attribution), this.promoteId = s.promoteId;
          const a = l.X / this.tileSize;
          this.workerOptions = l.e({ source: this.id, cluster: s.cluster || !1, geojsonVtOptions: { buffer: (s.buffer !== void 0 ? s.buffer : 128) * a, tolerance: (s.tolerance !== void 0 ? s.tolerance : 0.375) * a, extent: l.X, maxZoom: this.maxzoom, lineMetrics: s.lineMetrics || !1, generateId: s.generateId || !1 }, superclusterOptions: { maxZoom: s.clusterMaxZoom !== void 0 ? s.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, s.clusterMinPoints || 2), extent: l.X, radius: (s.clusterRadius || 50) * a, log: !1, generateId: s.generateId || !1 }, clusterProperties: s.clusterProperties, filter: s.filter }, s.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        setData(t) {
          return this._data = t, this._updateWorkerData(), this;
        }
        updateData(t) {
          return this._updateWorkerData(t), this;
        }
        getData() {
          return l._(this, void 0, void 0, function* () {
            const t = l.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: t });
          });
        }
        setClusterOptions(t) {
          return this.workerOptions.cluster = t.cluster, t && (t.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = t.clusterRadius), t.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = t.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(t) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: t, source: this.id } });
        }
        getClusterChildren(t) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: t, source: this.id } });
        }
        getClusterLeaves(t, s, c) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: t, limit: s, offset: c } });
        }
        _updateWorkerData(t) {
          return l._(this, void 0, void 0, function* () {
            const s = l.e({ type: this.type }, this.workerOptions);
            t ? s.dataDiff = t : typeof this._data == "string" ? (s.request = this.map._requestManager.transformRequest(q.resolveURL(this._data), "Source"), s.request.collectResourceTiming = this._collectResourceTiming) : s.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new l.k("dataloading", { dataType: "source" }));
            try {
              const c = yield this.actor.sendAsync({ type: "LD", data: s });
              if (this._pendingLoads--, this._removed || c.abandoned) return void this.fire(new l.k("dataabort", { dataType: "source" }));
              let r = null;
              c.resourceTiming && c.resourceTiming[this.id] && (r = c.resourceTiming[this.id].slice(0));
              const a = { dataType: "source" };
              this._collectResourceTiming && r && r.length > 0 && l.e(a, { resourceTiming: r }), this.fire(new l.k("data", Object.assign(Object.assign({}, a), { sourceDataType: "metadata" }))), this.fire(new l.k("data", Object.assign(Object.assign({}, a), { sourceDataType: "content" })));
            } catch (c) {
              if (this._pendingLoads--, this._removed) return void this.fire(new l.k("dataabort", { dataType: "source" }));
              this.fire(new l.j(c));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(t) {
          return l._(this, void 0, void 0, function* () {
            const s = t.actor ? "RT" : "LT";
            t.actor = this.actor;
            const c = { type: this.type, uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            t.abortController = new AbortController();
            const r = yield this.actor.sendAsync({ type: s, data: c }, t.abortController);
            delete t.abortController, t.unloadVectorData(), t.aborted || t.loadVectorData(r, this.map.painter, s === "RT");
          });
        }
        abortTile(t) {
          return l._(this, void 0, void 0, function* () {
            t.abortController && (t.abortController.abort(), delete t.abortController), t.aborted = !0;
          });
        }
        unloadTile(t) {
          return l._(this, void 0, void 0, function* () {
            t.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return l.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      var Ae = l.Y([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class $e extends l.E {
        constructor(t, s, c, r) {
          super(), this.id = t, this.dispatcher = c, this.coordinates = s.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(r), this.options = s;
        }
        load(t) {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new l.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
            try {
              const s = yield Mt.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = !0, s && s.data && (this.image = s.data, t && (this.coordinates = t), this._finishLoading());
            } catch (s) {
              this._request = null, this._loaded = !0, this.fire(new l.j(s));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t) {
          return t.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t.url, this.load(t.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new l.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(t) {
          this.coordinates = t;
          const s = t.map(l.Z.fromLngLat);
          this.tileID = function(r) {
            let a = 1 / 0, h = 1 / 0, d = -1 / 0, _ = -1 / 0;
            for (const C of r) a = Math.min(a, C.x), h = Math.min(h, C.y), d = Math.max(d, C.x), _ = Math.max(_, C.y);
            const w = Math.max(d - a, _ - h), k = Math.max(0, Math.floor(-Math.log(w) / Math.LN2)), T = Math.pow(2, k);
            return new l.a1(k, Math.floor((a + d) / 2 * T), Math.floor((h + _) / 2 * T));
          }(s), this.minzoom = this.maxzoom = this.tileID.z;
          const c = s.map((r) => this.tileID.getTilePoint(r)._round());
          return this._boundsArray = new l.$(), this._boundsArray.emplaceBack(c[0].x, c[0].y, 0, 0), this._boundsArray.emplaceBack(c[1].x, c[1].y, l.X, 0), this._boundsArray.emplaceBack(c[3].x, c[3].y, 0, l.X), this._boundsArray.emplaceBack(c[2].x, c[2].y, l.X, l.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new l.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          const t = this.map.painter.context, s = t.gl;
          this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, Ae.members)), this.boundsSegments || (this.boundsSegments = l.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new at(t, this.image, s.RGBA), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));
          let c = !1;
          for (const r in this.tiles) {
            const a = this.tiles[r];
            a.state !== "loaded" && (a.state = "loaded", a.texture = this.texture, c = !0);
          }
          c && this.fire(new l.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(t) {
          return l._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}) : t.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class hi extends $e {
        constructor(t, s, c, r) {
          super(t, s, c, r), this.roundZoom = !0, this.type = "video", this.options = s;
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const t = this.options;
            this.urls = [];
            for (const s of t.urls) this.urls.push(this.map._requestManager.transformRequest(s, "Source").url);
            try {
              const s = yield l.a3(this.urls);
              if (this._loaded = !0, !s) return;
              this.video = s, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (s) {
              this.fire(new l.j(s));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t) {
          if (this.video) {
            const s = this.video.seekable;
            t < s.start(0) || t > s.end(0) ? this.fire(new l.j(new l.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${s.start(0)} and ${s.end(0)}-second mark.`))) : this.video.currentTime = t;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(t) {
          this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          const t = this.map.painter.context, s = t.gl;
          this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, Ae.members)), this.boundsSegments || (this.boundsSegments = l.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE), s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, s.RGBA, s.UNSIGNED_BYTE, this.video)) : (this.texture = new at(t, this.video, s.RGBA), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));
          let c = !1;
          for (const r in this.tiles) {
            const a = this.tiles[r];
            a.state !== "loaded" && (a.state = "loaded", a.texture = this.texture, c = !0);
          }
          c && this.fire(new l.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class si extends $e {
        constructor(t, s, c, r) {
          super(t, s, c, r), s.coordinates ? Array.isArray(s.coordinates) && s.coordinates.length === 4 && !s.coordinates.some((a) => !Array.isArray(a) || a.length !== 2 || a.some((h) => typeof h != "number")) || this.fire(new l.j(new l.a2(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new l.j(new l.a2(`sources.${t}`, null, 'missing required property "coordinates"'))), s.animate && typeof s.animate != "boolean" && this.fire(new l.j(new l.a2(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), s.canvas ? typeof s.canvas == "string" || s.canvas instanceof HTMLCanvasElement || this.fire(new l.j(new l.a2(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new l.j(new l.a2(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = s, this.animate = s.animate === void 0 || s.animate;
        }
        load() {
          return l._(this, void 0, void 0, function* () {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new l.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(t) {
          this.map = t, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let t = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          const s = this.map.painter.context, c = s.gl;
          this.boundsBuffer || (this.boundsBuffer = s.createVertexBuffer(this._boundsArray, Ae.members)), this.boundsSegments || (this.boundsSegments = l.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (t || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new at(s, this.canvas, c.RGBA, { premultiply: !0 });
          let r = !1;
          for (const a in this.tiles) {
            const h = this.tiles[a];
            h.state !== "loaded" && (h.state = "loaded", h.texture = this.texture, r = !0);
          }
          r && this.fire(new l.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const t of [this.canvas.width, this.canvas.height]) if (isNaN(t) || t <= 0) return !0;
          return !1;
        }
      }
      const _i = {}, Ii = (p) => {
        switch (p) {
          case "geojson":
            return De;
          case "image":
            return $e;
          case "raster":
            return oe;
          case "raster-dem":
            return ye;
          case "vector":
            return Ue;
          case "video":
            return hi;
          case "canvas":
            return si;
        }
        return _i[p];
      }, he = "RTLPluginLoaded";
      class Ke extends l.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = ve();
        }
        _syncState(t) {
          return this.status = t, this.dispatcher.broadcast("SRPS", { pluginStatus: t, pluginURL: this.url }).catch((s) => {
            throw this.status = "error", s;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(t) {
          return l._(this, arguments, void 0, function* (s, c = !1) {
            if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            if (this.url = q.resolveURL(s), !this.url) throw new Error(`requested url ${s} is invalid`);
            if (this.status === "unavailable") {
              if (!c) return this._requestImport();
              this.status = "deferred", this._syncState(this.status);
            } else if (this.status === "requested") return this._requestImport();
          });
        }
        _requestImport() {
          return l._(this, void 0, void 0, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new l.k(he));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let ai = null;
      function Pe() {
        return ai || (ai = new Ke()), ai;
      }
      class lr {
        constructor(t, s) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = t, this.uid = l.a4(), this.uses = 0, this.tileSize = s, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(t) {
          const s = t + this.timeAdded;
          s < this.fadeEndTime || (this.fadeEndTime = s);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(t) {
          this.demTexture && t.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(t, s, c) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) {
            t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function(r, a) {
              const h = {};
              if (!a) return h;
              for (const d of r) {
                const _ = d.layerIds.map((w) => a.getLayer(w)).filter(Boolean);
                if (_.length !== 0) {
                  d.layers = _, d.stateDependentLayerIds && (d.stateDependentLayers = d.stateDependentLayerIds.map((w) => _.filter((k) => k.id === w)[0]));
                  for (const w of _) h[w.id] = d;
                }
              }
              return h;
            }(t.buckets, s.style), this.hasSymbolBuckets = !1;
            for (const r in this.buckets) {
              const a = this.buckets[r];
              if (a instanceof l.a6) {
                if (this.hasSymbolBuckets = !0, !c) break;
                a.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const r in this.buckets) {
              const a = this.buckets[r];
              if (a instanceof l.a6 && a.hasRTLText) {
                this.hasRTLText = !0, Pe().lazyLoad();
                break;
              }
            }
            this.queryPadding = 0;
            for (const r in this.buckets) {
              const a = this.buckets[r];
              this.queryPadding = Math.max(this.queryPadding, s.style.getLayer(r).queryRadius(a));
            }
            t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage);
          } else this.collisionBoxArray = new l.a5();
        }
        unloadVectorData() {
          for (const t in this.buckets) this.buckets[t].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(t) {
          return this.buckets[t.id];
        }
        upload(t) {
          for (const c in this.buckets) {
            const r = this.buckets[c];
            r.uploadPending() && r.upload(t);
          }
          const s = t.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new at(t, this.imageAtlas.image, s.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new at(t, this.glyphAtlasImage, s.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(t) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
        }
        queryRenderedFeatures(t, s, c, r, a, h, d, _, w, k) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: r, cameraQueryGeometry: a, scale: h, tileSize: this.tileSize, pixelPosMatrix: k, transform: _, params: d, queryPadding: this.queryPadding * w }, t, s, c) : {};
        }
        querySourceFeatures(t, s) {
          const c = this.latestFeatureIndex;
          if (!c || !c.rawTileData) return;
          const r = c.loadVTLayers(), a = s && s.sourceLayer ? s.sourceLayer : "", h = r._geojsonTileLayer || r[a];
          if (!h) return;
          const d = l.a7(s && s.filter), { z: _, x: w, y: k } = this.tileID.canonical, T = { z: _, x: w, y: k };
          for (let C = 0; C < h.length; C++) {
            const z = h.feature(C);
            if (d.needGeometry) {
              const Z = l.a8(z, !0);
              if (!d.filter(new l.z(this.tileID.overscaledZ), Z, this.tileID.canonical)) continue;
            } else if (!d.filter(new l.z(this.tileID.overscaledZ), z)) continue;
            const R = c.getId(z, a), W = new l.a9(z, _, w, k, R);
            W.tile = T, t.push(W);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t) {
          const s = this.expirationTime;
          if (t.cacheControl) {
            const c = l.aa(t.cacheControl);
            c["max-age"] && (this.expirationTime = Date.now() + 1e3 * c["max-age"]);
          } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
          if (this.expirationTime) {
            const c = Date.now();
            let r = !1;
            if (this.expirationTime > c) r = !1;
            else if (s) if (this.expirationTime < s) r = !0;
            else {
              const a = this.expirationTime - s;
              a ? this.expirationTime = c + Math.max(a, 3e4) : r = !0;
            }
            else r = !0;
            r ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t, s) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t).length === 0) return;
          const c = this.latestFeatureIndex.loadVTLayers();
          for (const r in this.buckets) {
            if (!s.style.hasLayer(r)) continue;
            const a = this.buckets[r], h = a.layers[0].sourceLayer || "_geojsonTileLayer", d = c[h], _ = t[h];
            if (!d || !_ || Object.keys(_).length === 0) continue;
            a.update(_, d, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const w = s && s.style && s.style.getLayer(r);
            w && (this.queryPadding = Math.max(this.queryPadding, w.queryRadius(a)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < q.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t) {
          this.symbolFadeHoldUntil = q.now() + t;
        }
        setDependencies(t, s) {
          const c = {};
          for (const r of s) c[r] = !0;
          this.dependencies[t] = c;
        }
        hasDependency(t, s) {
          for (const c of t) {
            const r = this.dependencies[c];
            if (r) {
              for (const a of s) if (r[a]) return !0;
            }
          }
          return !1;
        }
      }
      class ue {
        constructor(t, s) {
          this.max = t, this.onRemove = s, this.reset();
        }
        reset() {
          for (const t in this.data) for (const s of this.data[t]) s.timeout && clearTimeout(s.timeout), this.onRemove(s.value);
          return this.data = {}, this.order = [], this;
        }
        add(t, s, c) {
          const r = t.wrapped().key;
          this.data[r] === void 0 && (this.data[r] = []);
          const a = { value: s, timeout: void 0 };
          if (c !== void 0 && (a.timeout = setTimeout(() => {
            this.remove(t, a);
          }, c)), this.data[r].push(a), this.order.push(r), this.order.length > this.max) {
            const h = this._getAndRemoveByKey(this.order[0]);
            h && this.onRemove(h);
          }
          return this;
        }
        has(t) {
          return t.wrapped().key in this.data;
        }
        getAndRemove(t) {
          return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
        }
        _getAndRemoveByKey(t) {
          const s = this.data[t].shift();
          return s.timeout && clearTimeout(s.timeout), this.data[t].length === 0 && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), s.value;
        }
        getByKey(t) {
          const s = this.data[t];
          return s ? s[0].value : null;
        }
        get(t) {
          return this.has(t) ? this.data[t.wrapped().key][0].value : null;
        }
        remove(t, s) {
          if (!this.has(t)) return this;
          const c = t.wrapped().key, r = s === void 0 ? 0 : this.data[c].indexOf(s), a = this.data[c][r];
          return this.data[c].splice(r, 1), a.timeout && clearTimeout(a.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(a.value), this.order.splice(this.order.indexOf(c), 1), this;
        }
        setMaxSize(t) {
          for (this.max = t; this.order.length > this.max; ) {
            const s = this._getAndRemoveByKey(this.order[0]);
            s && this.onRemove(s);
          }
          return this;
        }
        filter(t) {
          const s = [];
          for (const c in this.data) for (const r of this.data[c]) t(r.value) || s.push(r);
          for (const c of s) this.remove(c.value.tileID, c);
        }
      }
      class ni {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t, s, c) {
          const r = String(s);
          if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][r] = this.stateChanges[t][r] || {}, l.e(this.stateChanges[t][r], c), this.deletedStates[t] === null) {
            this.deletedStates[t] = {};
            for (const a in this.state[t]) a !== r && (this.deletedStates[t][a] = null);
          } else if (this.deletedStates[t] && this.deletedStates[t][r] === null) {
            this.deletedStates[t][r] = {};
            for (const a in this.state[t][r]) c[a] || (this.deletedStates[t][r][a] = null);
          } else for (const a in c) this.deletedStates[t] && this.deletedStates[t][r] && this.deletedStates[t][r][a] === null && delete this.deletedStates[t][r][a];
        }
        removeFeatureState(t, s, c) {
          if (this.deletedStates[t] === null) return;
          const r = String(s);
          if (this.deletedStates[t] = this.deletedStates[t] || {}, c && s !== void 0) this.deletedStates[t][r] !== null && (this.deletedStates[t][r] = this.deletedStates[t][r] || {}, this.deletedStates[t][r][c] = null);
          else if (s !== void 0) if (this.stateChanges[t] && this.stateChanges[t][r]) for (c in this.deletedStates[t][r] = {}, this.stateChanges[t][r]) this.deletedStates[t][r][c] = null;
          else this.deletedStates[t][r] = null;
          else this.deletedStates[t] = null;
        }
        getState(t, s) {
          const c = String(s), r = l.e({}, (this.state[t] || {})[c], (this.stateChanges[t] || {})[c]);
          if (this.deletedStates[t] === null) return {};
          if (this.deletedStates[t]) {
            const a = this.deletedStates[t][s];
            if (a === null) return {};
            for (const h in a) delete r[h];
          }
          return r;
        }
        initializeTileState(t, s) {
          t.setFeatureState(this.state, s);
        }
        coalesceChanges(t, s) {
          const c = {};
          for (const r in this.stateChanges) {
            this.state[r] = this.state[r] || {};
            const a = {};
            for (const h in this.stateChanges[r]) this.state[r][h] || (this.state[r][h] = {}), l.e(this.state[r][h], this.stateChanges[r][h]), a[h] = this.state[r][h];
            c[r] = a;
          }
          for (const r in this.deletedStates) {
            this.state[r] = this.state[r] || {};
            const a = {};
            if (this.deletedStates[r] === null) for (const h in this.state[r]) a[h] = {}, this.state[r][h] = {};
            else for (const h in this.deletedStates[r]) {
              if (this.deletedStates[r][h] === null) this.state[r][h] = {};
              else for (const d of Object.keys(this.deletedStates[r][h])) delete this.state[r][h][d];
              a[h] = this.state[r][h];
            }
            c[r] = c[r] || {}, l.e(c[r], a);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(c).length !== 0) for (const r in t) t[r].setFeatureState(c, s);
        }
      }
      class Te extends l.E {
        constructor(t, s, c) {
          super(), this.id = t, this.dispatcher = c, this.on("data", (r) => this._dataHandler(r)), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((r, a, h, d) => {
            const _ = new (Ii(a.type))(r, a, h, d);
            if (_.id !== r) throw new Error(`Expected Source id to be ${r} instead of ${_.id}`);
            return _;
          })(t, s, c, this), this._tiles = {}, this._cache = new ue(0, (r) => this._unloadTile(r)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ni(), this._didEmitContent = !1, this._updated = !1;
        }
        onAdd(t) {
          this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t ? t._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t);
        }
        onRemove(t) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
          if (!this._updated) return !1;
          for (const t in this._tiles) {
            const s = this._tiles[t];
            if (s.state !== "loaded" && s.state !== "errored") return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const t = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(t, s, c) {
          return l._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(t), this._tileLoaded(t, s, c);
            } catch (r) {
              t.state = "errored", r.status !== 404 ? this._source.fire(new l.j(r, { tile: t })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(t) {
          this._source.unloadTile && this._source.unloadTile(t);
        }
        _abortTile(t) {
          this._source.abortTile && this._source.abortTile(t), this._source.fire(new l.k("dataabort", { tile: t, coord: t.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const s in this._tiles) {
            const c = this._tiles[s];
            c.upload(t), c.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((t) => t.tileID).sort(ki).map((t) => t.key);
        }
        getRenderableIds(t) {
          const s = [];
          for (const c in this._tiles) this._isIdRenderable(c, t) && s.push(this._tiles[c]);
          return t ? s.sort((c, r) => {
            const a = c.tileID, h = r.tileID, d = new l.P(a.canonical.x, a.canonical.y)._rotate(this.transform.angle), _ = new l.P(h.canonical.x, h.canonical.y)._rotate(this.transform.angle);
            return a.overscaledZ - h.overscaledZ || _.y - d.y || _.x - d.x;
          }).map((c) => c.tileID.key) : s.map((c) => c.tileID).sort(ki).map((c) => c.key);
        }
        hasRenderableParent(t) {
          const s = this.findLoadedParent(t, 0);
          return !!s && this._isIdRenderable(s.tileID.key);
        }
        _isIdRenderable(t, s) {
          return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (s || !this._tiles[t].holdingForFade());
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const t in this._tiles) this._tiles[t].state !== "errored" && this._reloadTile(t, "reloading");
          }
        }
        _reloadTile(t, s) {
          return l._(this, void 0, void 0, function* () {
            const c = this._tiles[t];
            c && (c.state !== "loading" && (c.state = s), yield this._loadTile(c, t, s));
          });
        }
        _tileLoaded(t, s, c) {
          t.timeAdded = q.now(), c === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(s, t), this.getSource().type === "raster-dem" && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), t.aborted || this._source.fire(new l.k("data", { dataType: "source", tile: t, coord: t.tileID }));
        }
        _backfillDEM(t) {
          const s = this.getRenderableIds();
          for (let r = 0; r < s.length; r++) {
            const a = s[r];
            if (t.neighboringTiles && t.neighboringTiles[a]) {
              const h = this.getTileByID(a);
              c(t, h), c(h, t);
            }
          }
          function c(r, a) {
            r.needsHillshadePrepare = !0, r.needsTerrainPrepare = !0;
            let h = a.tileID.canonical.x - r.tileID.canonical.x;
            const d = a.tileID.canonical.y - r.tileID.canonical.y, _ = Math.pow(2, r.tileID.canonical.z), w = a.tileID.key;
            h === 0 && d === 0 || Math.abs(d) > 1 || (Math.abs(h) > 1 && (Math.abs(h + _) === 1 ? h += _ : Math.abs(h - _) === 1 && (h -= _)), a.dem && r.dem && (r.dem.backfillBorder(a.dem, h, d), r.neighboringTiles && r.neighboringTiles[w] && (r.neighboringTiles[w].backfilled = !0)));
          }
        }
        getTile(t) {
          return this.getTileByID(t.key);
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        _retainLoadedChildren(t, s, c, r) {
          for (const a in this._tiles) {
            let h = this._tiles[a];
            if (r[a] || !h.hasData() || h.tileID.overscaledZ <= s || h.tileID.overscaledZ > c) continue;
            let d = h.tileID;
            for (; h && h.tileID.overscaledZ > s + 1; ) {
              const w = h.tileID.scaledTo(h.tileID.overscaledZ - 1);
              h = this._tiles[w.key], h && h.hasData() && (d = w);
            }
            let _ = d;
            for (; _.overscaledZ > s; ) if (_ = _.scaledTo(_.overscaledZ - 1), t[_.key]) {
              r[d.key] = d;
              break;
            }
          }
        }
        findLoadedParent(t, s) {
          if (t.key in this._loadedParentTiles) {
            const c = this._loadedParentTiles[t.key];
            return c && c.tileID.overscaledZ >= s ? c : null;
          }
          for (let c = t.overscaledZ - 1; c >= s; c--) {
            const r = t.scaledTo(c), a = this._getLoadedTile(r);
            if (a) return a;
          }
        }
        findLoadedSibling(t) {
          return this._getLoadedTile(t);
        }
        _getLoadedTile(t) {
          const s = this._tiles[t.key];
          return s && s.hasData() ? s : this._cache.getByKey(t.wrapped().key);
        }
        updateCacheSize(t) {
          const s = Math.ceil(t.width / this._source.tileSize) + 1, c = Math.ceil(t.height / this._source.tileSize) + 1, r = Math.floor(s * c * (this._maxTileCacheZoomLevels === null ? l.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), a = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, r) : r;
          this._cache.setMaxSize(a);
        }
        handleWrapJump(t) {
          const s = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
          if (this._prevLng = t, s) {
            const c = {};
            for (const r in this._tiles) {
              const a = this._tiles[r];
              a.tileID = a.tileID.unwrapTo(a.tileID.wrap + s), c[a.tileID.key] = a;
            }
            this._tiles = c;
            for (const r in this._timers) clearTimeout(this._timers[r]), delete this._timers[r];
            for (const r in this._tiles) this._setTileReloadTimer(r, this._tiles[r]);
          }
        }
        _updateCoveredAndRetainedTiles(t, s, c, r, a, h) {
          const d = {}, _ = {}, w = Object.keys(t), k = q.now();
          for (const T of w) {
            const C = t[T], z = this._tiles[T];
            if (!z || z.fadeEndTime !== 0 && z.fadeEndTime <= k) continue;
            const R = this.findLoadedParent(C, s), W = this.findLoadedSibling(C), Z = R || W || null;
            Z && (this._addTile(Z.tileID), d[Z.tileID.key] = Z.tileID), _[T] = C;
          }
          this._retainLoadedChildren(_, r, c, t);
          for (const T in d) t[T] || (this._coveredTiles[T] = !0, t[T] = d[T]);
          if (h) {
            const T = {}, C = {};
            for (const z of a) this._tiles[z.key].hasData() ? T[z.key] = z : C[z.key] = z;
            for (const z in C) {
              const R = C[z].children(this._source.maxzoom);
              this._tiles[R[0].key] && this._tiles[R[1].key] && this._tiles[R[2].key] && this._tiles[R[3].key] && (T[R[0].key] = t[R[0].key] = R[0], T[R[1].key] = t[R[1].key] = R[1], T[R[2].key] = t[R[2].key] = R[2], T[R[3].key] = t[R[3].key] = R[3], delete C[z]);
            }
            for (const z in C) {
              const R = C[z], W = this.findLoadedParent(R, this._source.minzoom), Z = this.findLoadedSibling(R), G = W || Z || null;
              if (G) {
                T[G.tileID.key] = t[G.tileID.key] = G.tileID;
                for (const nt in T) T[nt].isChildOf(G.tileID) && delete T[nt];
              }
            }
            for (const z in this._tiles) T[z] || (this._coveredTiles[z] = !0);
          }
        }
        update(t, s) {
          if (!this._sourceLoaded || this._paused) return;
          let c;
          this.transform = t, this.terrain = s, this.updateCacheSize(t), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? c = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((k) => new l.S(k.canonical.z, k.wrap, k.canonical.z, k.canonical.x, k.canonical.y)) : (c = t.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: s }), this._source.hasTile && (c = c.filter((k) => this._source.hasTile(k)))) : c = [];
          const r = t.coveringZoomLevel(this._source), a = Math.max(r - Te.maxOverzooming, this._source.minzoom), h = Math.max(r + Te.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const k = {};
            for (const T of c) if (T.canonical.z > this._source.minzoom) {
              const C = T.scaledTo(T.canonical.z - 1);
              k[C.key] = C;
              const z = T.scaledTo(Math.max(this._source.minzoom, Math.min(T.canonical.z, 5)));
              k[z.key] = z;
            }
            c = c.concat(Object.values(k));
          }
          const d = c.length === 0 && !this._updated && this._didEmitContent;
          this._updated = !0, d && this.fire(new l.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const _ = this._updateRetainedTiles(c, r);
          vr(this._source.type) && this._updateCoveredAndRetainedTiles(_, a, h, r, c, s);
          for (const k in _) this._tiles[k].clearFadeHold();
          const w = l.ab(this._tiles, _);
          for (const k of w) {
            const T = this._tiles[k];
            T.hasSymbolBuckets && !T.holdingForFade() ? T.setHoldDuration(this.map._fadeDuration) : T.hasSymbolBuckets && !T.symbolFadeFinished() || this._removeTile(k);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(t);
        }
        _updateRetainedTiles(t, s) {
          var c;
          const r = {}, a = {}, h = Math.max(s - Te.maxOverzooming, this._source.minzoom), d = Math.max(s + Te.maxUnderzooming, this._source.minzoom), _ = {};
          for (const w of t) {
            const k = this._addTile(w);
            r[w.key] = w, k.hasData() || s < this._source.maxzoom && (_[w.key] = w);
          }
          this._retainLoadedChildren(_, s, d, r);
          for (const w of t) {
            let k = this._tiles[w.key];
            if (k.hasData()) continue;
            if (s + 1 > this._source.maxzoom) {
              const C = w.children(this._source.maxzoom)[0], z = this.getTile(C);
              if (z && z.hasData()) {
                r[C.key] = C;
                continue;
              }
            } else {
              const C = w.children(this._source.maxzoom);
              if (r[C[0].key] && r[C[1].key] && r[C[2].key] && r[C[3].key]) continue;
            }
            let T = k.wasRequested();
            for (let C = w.overscaledZ - 1; C >= h; --C) {
              const z = w.scaledTo(C);
              if (a[z.key]) break;
              if (a[z.key] = !0, k = this.getTile(z), !k && T && (k = this._addTile(z)), k) {
                const R = k.hasData();
                if ((R || !(!((c = this.map) === null || c === void 0) && c.cancelPendingTileRequestsWhileZooming) || T) && (r[z.key] = z), T = k.wasRequested(), R) break;
              }
            }
          }
          return r;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t in this._tiles) {
            const s = [];
            let c, r = this._tiles[t].tileID;
            for (; r.overscaledZ > 0; ) {
              if (r.key in this._loadedParentTiles) {
                c = this._loadedParentTiles[r.key];
                break;
              }
              s.push(r.key);
              const a = r.scaledTo(r.overscaledZ - 1);
              if (c = this._getLoadedTile(a), c) break;
              r = a;
            }
            for (const a of s) this._loadedParentTiles[a] = c;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const t in this._tiles) {
            const s = this._tiles[t].tileID, c = this._getLoadedTile(s);
            this._loadedSiblingTiles[s.key] = c;
          }
        }
        _addTile(t) {
          let s = this._tiles[t.key];
          if (s) return s;
          s = this._cache.getAndRemove(t), s && (this._setTileReloadTimer(t.key, s), s.tileID = t, this._state.initializeTileState(s, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, s)));
          const c = s;
          return s || (s = new lr(t, this._source.tileSize * t.overscaleFactor()), this._loadTile(s, t.key, s.state)), s.uses++, this._tiles[t.key] = s, c || this._source.fire(new l.k("dataloading", { tile: s, coord: s.tileID, dataType: "source" })), s;
        }
        _setTileReloadTimer(t, s) {
          t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
          const c = s.getExpiryTimeout();
          c && (this._timers[t] = setTimeout(() => {
            this._reloadTile(t, "expired"), delete this._timers[t];
          }, c));
        }
        _removeTile(t) {
          const s = this._tiles[t];
          s && (s.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), s.uses > 0 || (s.hasData() && s.state !== "reloading" ? this._cache.add(s.tileID, s, s.getExpiryTimeout()) : (s.aborted = !0, this._abortTile(s), this._unloadTile(s))));
        }
        _dataHandler(t) {
          const s = t.sourceDataType;
          t.dataType === "source" && s === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && t.dataType === "source" && s === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const t in this._tiles) this._removeTile(t);
          this._cache.reset();
        }
        tilesIn(t, s, c) {
          const r = [], a = this.transform;
          if (!a) return r;
          const h = c ? a.getCameraQueryGeometry(t) : t, d = t.map((R) => a.pointCoordinate(R, this.terrain)), _ = h.map((R) => a.pointCoordinate(R, this.terrain)), w = this.getIds();
          let k = 1 / 0, T = 1 / 0, C = -1 / 0, z = -1 / 0;
          for (const R of _) k = Math.min(k, R.x), T = Math.min(T, R.y), C = Math.max(C, R.x), z = Math.max(z, R.y);
          for (let R = 0; R < w.length; R++) {
            const W = this._tiles[w[R]];
            if (W.holdingForFade()) continue;
            const Z = W.tileID, G = Math.pow(2, a.zoom - W.tileID.overscaledZ), nt = s * W.queryPadding * l.X / W.tileSize / G, Y = [Z.getTilePoint(new l.Z(k, T)), Z.getTilePoint(new l.Z(C, z))];
            if (Y[0].x - nt < l.X && Y[0].y - nt < l.X && Y[1].x + nt >= 0 && Y[1].y + nt >= 0) {
              const J = d.map((ut) => Z.getTilePoint(ut)), tt = _.map((ut) => Z.getTilePoint(ut));
              r.push({ tile: W, tileID: Z, queryGeometry: J, cameraQueryGeometry: tt, scale: G });
            }
          }
          return r;
        }
        getVisibleCoordinates(t) {
          const s = this.getRenderableIds(t).map((c) => this._tiles[c].tileID);
          for (const c of s) c.posMatrix = this.transform.calculatePosMatrix(c.toUnwrapped());
          return s;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (vr(this._source.type)) {
            const t = q.now();
            for (const s in this._tiles) if (this._tiles[s].fadeEndTime >= t) return !0;
          }
          return !1;
        }
        setFeatureState(t, s, c) {
          this._state.updateState(t = t || "_geojsonTileLayer", s, c);
        }
        removeFeatureState(t, s, c) {
          this._state.removeFeatureState(t = t || "_geojsonTileLayer", s, c);
        }
        getFeatureState(t, s) {
          return this._state.getState(t = t || "_geojsonTileLayer", s);
        }
        setDependencies(t, s, c) {
          const r = this._tiles[t];
          r && r.setDependencies(s, c);
        }
        reloadTilesForDependencies(t, s) {
          for (const c in this._tiles) this._tiles[c].hasDependency(t, s) && this._reloadTile(c, "reloading");
          this._cache.filter((c) => !c.hasDependency(t, s));
        }
      }
      function ki(p, t) {
        const s = Math.abs(2 * p.wrap) - +(p.wrap < 0), c = Math.abs(2 * t.wrap) - +(t.wrap < 0);
        return p.overscaledZ - t.overscaledZ || c - s || t.canonical.y - p.canonical.y || t.canonical.x - p.canonical.x;
      }
      function vr(p) {
        return p === "raster" || p === "image" || p === "video";
      }
      Te.maxOverzooming = 10, Te.maxUnderzooming = 3;
      class Me {
        constructor(t, s) {
          this.reset(t, s);
        }
        reset(t, s) {
          this.points = t || [], this._distances = [0];
          for (let c = 1; c < this.points.length; c++) this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(s || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t) {
          if (this.points.length === 1) return this.points[0];
          t = l.ac(t, 0, 1);
          let s = 1, c = this._distances[s];
          const r = t * this.paddedLength + this.padding;
          for (; c < r && s < this._distances.length; ) c = this._distances[++s];
          const a = s - 1, h = this._distances[a], d = c - h, _ = d > 0 ? (r - h) / d : 0;
          return this.points[a].mult(1 - _).add(this.points[s].mult(_));
        }
      }
      function Ur(p, t) {
        let s = !0;
        return p === "always" || p !== "never" && t !== "never" || (s = !1), s;
      }
      class qi {
        constructor(t, s, c) {
          const r = this.boxCells = [], a = this.circleCells = [];
          this.xCellCount = Math.ceil(t / c), this.yCellCount = Math.ceil(s / c);
          for (let h = 0; h < this.xCellCount * this.yCellCount; h++) r.push([]), a.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = s, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / s, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(t, s, c, r, a) {
          this._forEachCell(s, c, r, a, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(s), this.bboxes.push(c), this.bboxes.push(r), this.bboxes.push(a);
        }
        insertCircle(t, s, c, r) {
          this._forEachCell(s - r, c - r, s + r, c + r, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(s), this.circles.push(c), this.circles.push(r);
        }
        _insertBoxCell(t, s, c, r, a, h) {
          this.boxCells[a].push(h);
        }
        _insertCircleCell(t, s, c, r, a, h) {
          this.circleCells[a].push(h);
        }
        _query(t, s, c, r, a, h, d) {
          if (c < 0 || t > this.width || r < 0 || s > this.height) return [];
          const _ = [];
          if (t <= 0 && s <= 0 && this.width <= c && this.height <= r) {
            if (a) return [{ key: null, x1: t, y1: s, x2: c, y2: r }];
            for (let w = 0; w < this.boxKeys.length; w++) _.push({ key: this.boxKeys[w], x1: this.bboxes[4 * w], y1: this.bboxes[4 * w + 1], x2: this.bboxes[4 * w + 2], y2: this.bboxes[4 * w + 3] });
            for (let w = 0; w < this.circleKeys.length; w++) {
              const k = this.circles[3 * w], T = this.circles[3 * w + 1], C = this.circles[3 * w + 2];
              _.push({ key: this.circleKeys[w], x1: k - C, y1: T - C, x2: k + C, y2: T + C });
            }
          } else this._forEachCell(t, s, c, r, this._queryCell, _, { hitTest: a, overlapMode: h, seenUids: { box: {}, circle: {} } }, d);
          return _;
        }
        query(t, s, c, r) {
          return this._query(t, s, c, r, !1, null);
        }
        hitTest(t, s, c, r, a, h) {
          return this._query(t, s, c, r, !0, a, h).length > 0;
        }
        hitTestCircle(t, s, c, r, a) {
          const h = t - c, d = t + c, _ = s - c, w = s + c;
          if (d < 0 || h > this.width || w < 0 || _ > this.height) return !1;
          const k = [];
          return this._forEachCell(h, _, d, w, this._queryCellCircle, k, { hitTest: !0, overlapMode: r, circle: { x: t, y: s, radius: c }, seenUids: { box: {}, circle: {} } }, a), k.length > 0;
        }
        _queryCell(t, s, c, r, a, h, d, _) {
          const { seenUids: w, hitTest: k, overlapMode: T } = d, C = this.boxCells[a];
          if (C !== null) {
            const R = this.bboxes;
            for (const W of C) if (!w.box[W]) {
              w.box[W] = !0;
              const Z = 4 * W, G = this.boxKeys[W];
              if (t <= R[Z + 2] && s <= R[Z + 3] && c >= R[Z + 0] && r >= R[Z + 1] && (!_ || _(G)) && (!k || !Ur(T, G.overlapMode)) && (h.push({ key: G, x1: R[Z], y1: R[Z + 1], x2: R[Z + 2], y2: R[Z + 3] }), k)) return !0;
            }
          }
          const z = this.circleCells[a];
          if (z !== null) {
            const R = this.circles;
            for (const W of z) if (!w.circle[W]) {
              w.circle[W] = !0;
              const Z = 3 * W, G = this.circleKeys[W];
              if (this._circleAndRectCollide(R[Z], R[Z + 1], R[Z + 2], t, s, c, r) && (!_ || _(G)) && (!k || !Ur(T, G.overlapMode))) {
                const nt = R[Z], Y = R[Z + 1], J = R[Z + 2];
                if (h.push({ key: G, x1: nt - J, y1: Y - J, x2: nt + J, y2: Y + J }), k) return !0;
              }
            }
          }
          return !1;
        }
        _queryCellCircle(t, s, c, r, a, h, d, _) {
          const { circle: w, seenUids: k, overlapMode: T } = d, C = this.boxCells[a];
          if (C !== null) {
            const R = this.bboxes;
            for (const W of C) if (!k.box[W]) {
              k.box[W] = !0;
              const Z = 4 * W, G = this.boxKeys[W];
              if (this._circleAndRectCollide(w.x, w.y, w.radius, R[Z + 0], R[Z + 1], R[Z + 2], R[Z + 3]) && (!_ || _(G)) && !Ur(T, G.overlapMode)) return h.push(!0), !0;
            }
          }
          const z = this.circleCells[a];
          if (z !== null) {
            const R = this.circles;
            for (const W of z) if (!k.circle[W]) {
              k.circle[W] = !0;
              const Z = 3 * W, G = this.circleKeys[W];
              if (this._circlesCollide(R[Z], R[Z + 1], R[Z + 2], w.x, w.y, w.radius) && (!_ || _(G)) && !Ur(T, G.overlapMode)) return h.push(!0), !0;
            }
          }
        }
        _forEachCell(t, s, c, r, a, h, d, _) {
          const w = this._convertToXCellCoord(t), k = this._convertToYCellCoord(s), T = this._convertToXCellCoord(c), C = this._convertToYCellCoord(r);
          for (let z = w; z <= T; z++) for (let R = k; R <= C; R++) if (a.call(this, t, s, c, r, this.xCellCount * R + z, h, d, _)) return;
        }
        _convertToXCellCoord(t) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
        }
        _convertToYCellCoord(t) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
        }
        _circlesCollide(t, s, c, r, a, h) {
          const d = r - t, _ = a - s, w = c + h;
          return w * w > d * d + _ * _;
        }
        _circleAndRectCollide(t, s, c, r, a, h, d) {
          const _ = (h - r) / 2, w = Math.abs(t - (r + _));
          if (w > _ + c) return !1;
          const k = (d - a) / 2, T = Math.abs(s - (a + k));
          if (T > k + c) return !1;
          if (w <= _ || T <= k) return !0;
          const C = w - _, z = T - k;
          return C * C + z * z <= c * c;
        }
      }
      function Ir(p, t, s, c, r) {
        const a = l.H();
        return t ? (l.K(a, a, [1 / r, 1 / r, 1]), s || l.ad(a, a, c.angle)) : l.L(a, c.labelPlaneMatrix, p), a;
      }
      function kr(p, t, s, c, r) {
        if (t) {
          const a = l.ae(p);
          return l.K(a, a, [r, r, 1]), s || l.ad(a, a, -c.angle), a;
        }
        return c.glCoordMatrix;
      }
      function ht(p, t, s) {
        let c;
        s ? (c = [p.x, p.y, s(p.x, p.y), 1], l.af(c, c, t)) : (c = [p.x, p.y, 0, 1], function(a, h, d) {
          const _ = h[0], w = h[1];
          a[0] = d[0] * _ + d[4] * w + d[12], a[1] = d[1] * _ + d[5] * w + d[13], a[3] = d[3] * _ + d[7] * w + d[15];
        }(c, c, t));
        const r = c[3];
        return { point: new l.P(c[0] / r, c[1] / r), signedDistanceFromCamera: r, isOccluded: !1 };
      }
      function O(p, t) {
        return 0.5 + p / t * 0.5;
      }
      function V(p, t) {
        return p.x >= -t[0] && p.x <= t[0] && p.y >= -t[1] && p.y <= t[1];
      }
      function it(p, t, s, c, r, a, h, d, _, w, k, T, C, z, R) {
        const W = c ? p.textSizeData : p.iconSizeData, Z = l.ag(W, s.transform.zoom), G = [256 / s.width * 2 + 1, 256 / s.height * 2 + 1], nt = c ? p.text.dynamicLayoutVertexArray : p.icon.dynamicLayoutVertexArray;
        nt.clear();
        const Y = p.lineVertexArray, J = c ? p.text.placedSymbolArray : p.icon.placedSymbolArray, tt = s.transform.width / s.transform.height;
        let ut = !1;
        for (let St = 0; St < J.length; St++) {
          const It = J.get(St);
          if (It.hidden || It.writingMode === l.ah.vertical && !ut) {
            Ve(It.numGlyphs, nt);
            continue;
          }
          ut = !1;
          const Gt = ht(new l.P(It.anchorX, It.anchorY), t, R);
          if (!V(Gt.point, G)) {
            Ve(It.numGlyphs, nt);
            continue;
          }
          const qt = O(s.transform.cameraToCenterDistance, Gt.signedDistanceFromCamera), Zt = l.ai(W, Z, It), Bt = h ? Zt / qt : Zt * qt, ge = { getElevation: R, labelPlaneMatrix: r, lineVertexArray: Y, pitchWithMap: h, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: w, tileAnchorPoint: new l.P(It.anchorX, It.anchorY), unwrappedTileID: k, width: T, height: C, translation: z }, Le = Et(ge, It, Bt, !1, d, t, a, p.glyphOffsetArray, nt, tt, _);
          ut = Le.useVertical, (Le.notEnoughRoom || ut || Le.needsFlipping && Et(ge, It, Bt, !0, d, t, a, p.glyphOffsetArray, nt, tt, _).notEnoughRoom) && Ve(It.numGlyphs, nt);
        }
        c ? p.text.dynamicLayoutVertexBuffer.updateData(nt) : p.icon.dynamicLayoutVertexBuffer.updateData(nt);
      }
      function ct(p, t, s, c, r, a, h, d) {
        const _ = a.glyphStartIndex + a.numGlyphs, w = a.lineStartIndex, k = a.lineStartIndex + a.lineLength, T = t.getoffsetX(a.glyphStartIndex), C = t.getoffsetX(_ - 1), z = fe(p * T, s, c, r, a.segment, w, k, d, h);
        if (!z) return null;
        const R = fe(p * C, s, c, r, a.segment, w, k, d, h);
        return R ? d.projectionCache.anyProjectionOccluded ? null : { first: z, last: R } : null;
      }
      function At(p, t, s, c) {
        return p === l.ah.horizontal && Math.abs(s.y - t.y) > Math.abs(s.x - t.x) * c ? { useVertical: !0 } : (p === l.ah.vertical ? t.y < s.y : t.x > s.x) ? { needsFlipping: !0 } : null;
      }
      function Et(p, t, s, c, r, a, h, d, _, w, k) {
        const T = s / 24, C = t.lineOffsetX * T, z = t.lineOffsetY * T;
        let R;
        if (t.numGlyphs > 1) {
          const W = t.glyphStartIndex + t.numGlyphs, Z = t.lineStartIndex, G = t.lineStartIndex + t.lineLength, nt = ct(T, d, C, z, c, t, k, p);
          if (!nt) return { notEnoughRoom: !0 };
          const Y = ht(nt.first.point, h, p.getElevation).point, J = ht(nt.last.point, h, p.getElevation).point;
          if (r && !c) {
            const tt = At(t.writingMode, Y, J, w);
            if (tt) return tt;
          }
          R = [nt.first];
          for (let tt = t.glyphStartIndex + 1; tt < W - 1; tt++) R.push(fe(T * d.getoffsetX(tt), C, z, c, t.segment, Z, G, p, k));
          R.push(nt.last);
        } else {
          if (r && !c) {
            const Z = ht(p.tileAnchorPoint, a, p.getElevation).point, G = t.lineStartIndex + t.segment + 1, nt = new l.P(p.lineVertexArray.getx(G), p.lineVertexArray.gety(G)), Y = ht(nt, a, p.getElevation), J = Y.signedDistanceFromCamera > 0 ? Y.point : function(ut, St, It, Gt, qt, Zt) {
              return wt(ut, St, It, 1, qt, Zt);
            }(p.tileAnchorPoint, nt, Z, 0, a, p), tt = At(t.writingMode, Z, J, w);
            if (tt) return tt;
          }
          const W = fe(T * d.getoffsetX(t.glyphStartIndex), C, z, c, t.segment, t.lineStartIndex, t.lineStartIndex + t.lineLength, p, k);
          if (!W || p.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
          R = [W];
        }
        for (const W of R) l.aj(_, W.point, W.angle);
        return {};
      }
      function wt(p, t, s, c, r, a) {
        const h = p.add(p.sub(t)._unit()), d = r !== void 0 ? ht(h, r, a.getElevation).point : $t(h.x, h.y, a).point, _ = s.sub(d);
        return s.add(_._mult(c / _.mag()));
      }
      function xt(p, t, s) {
        const c = t.projectionCache;
        if (c.projections[p]) return c.projections[p];
        const r = new l.P(t.lineVertexArray.getx(p), t.lineVertexArray.gety(p)), a = $t(r.x, r.y, t);
        if (a.signedDistanceFromCamera > 0) return c.projections[p] = a.point, c.anyProjectionOccluded = c.anyProjectionOccluded || a.isOccluded, a.point;
        const h = p - s.direction;
        return function(d, _, w, k, T) {
          return wt(d, _, w, k, void 0, T);
        }(s.distanceFromAnchor === 0 ? t.tileAnchorPoint : new l.P(t.lineVertexArray.getx(h), t.lineVertexArray.gety(h)), r, s.previousVertex, s.absOffsetX - s.distanceFromAnchor + 1, t);
      }
      function $t(p, t, s) {
        const c = p + s.translation[0], r = t + s.translation[1];
        let a;
        return !s.pitchWithMap && s.projection.useSpecialProjectionForSymbols ? (a = s.projection.projectTileCoordinates(c, r, s.unwrappedTileID, s.getElevation), a.point.x = (0.5 * a.point.x + 0.5) * s.width, a.point.y = (0.5 * -a.point.y + 0.5) * s.height) : (a = ht(new l.P(c, r), s.labelPlaneMatrix, s.getElevation), a.isOccluded = !1), a;
      }
      function re(p, t, s) {
        return p._unit()._perp()._mult(t * s);
      }
      function Rt(p, t, s, c, r, a, h, d, _) {
        if (d.projectionCache.offsets[p]) return d.projectionCache.offsets[p];
        const w = s.add(t);
        if (p + _.direction < c || p + _.direction >= r) return d.projectionCache.offsets[p] = w, w;
        const k = xt(p + _.direction, d, _), T = re(k.sub(s), h, _.direction), C = s.add(T), z = k.add(T);
        return d.projectionCache.offsets[p] = l.ak(a, w, C, z) || w, d.projectionCache.offsets[p];
      }
      function fe(p, t, s, c, r, a, h, d, _) {
        const w = c ? p - t : p + t;
        let k = w > 0 ? 1 : -1, T = 0;
        c && (k *= -1, T = Math.PI), k < 0 && (T += Math.PI);
        let C, z = k > 0 ? a + r : a + r + 1;
        d.projectionCache.cachedAnchorPoint ? C = d.projectionCache.cachedAnchorPoint : (C = $t(d.tileAnchorPoint.x, d.tileAnchorPoint.y, d).point, d.projectionCache.cachedAnchorPoint = C);
        let R, W, Z = C, G = C, nt = 0, Y = 0;
        const J = Math.abs(w), tt = [];
        let ut;
        for (; nt + Y <= J; ) {
          if (z += k, z < a || z >= h) return null;
          nt += Y, G = Z, W = R;
          const Gt = { absOffsetX: J, direction: k, distanceFromAnchor: nt, previousVertex: G };
          if (Z = xt(z, d, Gt), s === 0) tt.push(G), ut = Z.sub(G);
          else {
            let qt;
            const Zt = Z.sub(G);
            qt = Zt.mag() === 0 ? re(xt(z + k, d, Gt).sub(Z), s, k) : re(Zt, s, k), W || (W = G.add(qt)), R = Rt(z, qt, Z, a, h, W, s, d, Gt), tt.push(W), ut = R.sub(W);
          }
          Y = ut.mag();
        }
        const St = ut._mult((J - nt) / Y)._add(W || G), It = T + Math.atan2(Z.y - G.y, Z.x - G.x);
        return tt.push(St), { point: St, angle: _ ? It : 0, path: tt };
      }
      const Ne = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Ve(p, t) {
        for (let s = 0; s < p; s++) {
          const c = t.length;
          t.resize(c + 4), t.float32.set(Ne, 3 * c);
        }
      }
      const ei = 100;
      class mi {
        constructor(t, s, c = new qi(t.width + 200, t.height + 200, 25), r = new qi(t.width + 200, t.height + 200, 25)) {
          this.transform = t, this.mapProjection = s, this.grid = c, this.ignoredGrid = r, this.pitchFactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + ei, this.screenBottomBoundary = t.height + ei, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(t, s, c, r, a, h, d, _, w, k, T) {
          const C = t.anchorPointX + _[0], z = t.anchorPointY + _[1], R = this.projectAndGetPerspectiveRatio(r, C, z, a, k), W = this._projectCollisionBox(t, c, r, a, h, d, _, R, k, T), [Z, G, nt, Y] = W.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (h ? W.allPointsOccluded : this.mapProjection.isOccluded(C, z, a)) || R.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(Z, G, nt, Y) || s !== "always" && this.grid.hitTest(Z, G, nt, Y, s, w) ? { box: [Z, G, nt, Y], placeable: !1, offscreen: !1 } : { box: [Z, G, nt, Y], placeable: !0, offscreen: this.isOffscreen(Z, G, nt, Y) };
        }
        placeCollisionCircles(t, s, c, r, a, h, d, _, w, k, T, C, z, R, W, Z) {
          const G = [], nt = new l.P(s.anchorX, s.anchorY), Y = this.getPerspectiveRatio(h, nt.x, nt.y, d, Z), J = (T ? a / Y : a * Y) / l.ap, tt = { getElevation: Z, labelPlaneMatrix: _, lineVertexArray: c, pitchWithMap: T, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: this.mapProjection, tileAnchorPoint: nt, unwrappedTileID: d, width: this.transform.width, height: this.transform.height, translation: W }, ut = ct(J, r, s.lineOffsetX * J, s.lineOffsetY * J, !1, s, !1, tt);
          let St = !1, It = !1, Gt = !0;
          if (ut) {
            const qt = 0.5 * z * Y + R, Zt = new l.P(-100, -100), Bt = new l.P(this.screenRightBoundary, this.screenBottomBoundary), ge = new Me(), Le = ut.first, ce = ut.last;
            let de = [];
            for (let we = Le.path.length - 1; we >= 1; we--) de.push(Le.path[we]);
            for (let we = 1; we < ce.path.length; we++) de.push(ce.path[we]);
            const Ce = 2.5 * qt;
            if (w) {
              const we = this.projectPathToScreenSpace(de, tt, w);
              de = we.some((We) => We.signedDistanceFromCamera <= 0) ? [] : we.map((We) => We.point);
            }
            let ii = [];
            if (de.length > 0) {
              const we = de[0].clone(), We = de[0].clone();
              for (let Ai = 1; Ai < de.length; Ai++) we.x = Math.min(we.x, de[Ai].x), we.y = Math.min(we.y, de[Ai].y), We.x = Math.max(We.x, de[Ai].x), We.y = Math.max(We.y, de[Ai].y);
              ii = we.x >= Zt.x && We.x <= Bt.x && we.y >= Zt.y && We.y <= Bt.y ? [de] : We.x < Zt.x || we.x > Bt.x || We.y < Zt.y || we.y > Bt.y ? [] : l.al([de], Zt.x, Zt.y, Bt.x, Bt.y);
            }
            for (const we of ii) {
              ge.reset(we, 0.25 * qt);
              let We = 0;
              We = ge.length <= 0.5 * qt ? 1 : Math.ceil(ge.paddedLength / Ce) + 1;
              for (let Ai = 0; Ai < We; Ai++) {
                const Mi = Ai / Math.max(We - 1, 1), sr = ge.lerp(Mi), ri = sr.x + ei, Xi = sr.y + ei;
                G.push(ri, Xi, qt, 0);
                const Gi = ri - qt, zi = Xi - qt, Fi = ri + qt, Qi = Xi + qt;
                if (Gt = Gt && this.isOffscreen(Gi, zi, Fi, Qi), It = It || this.isInsideGrid(Gi, zi, Fi, Qi), t !== "always" && this.grid.hitTestCircle(ri, Xi, qt, t, C) && (St = !0, !k)) return { circles: [], offscreen: !1, collisionDetected: St };
              }
            }
          }
          return { circles: !k && St || !It || Y < this.perspectiveRatioCutoff ? [] : G, offscreen: Gt, collisionDetected: St };
        }
        projectPathToScreenSpace(t, s, c) {
          return t.map((r) => ht(r, c, s.getElevation));
        }
        queryRenderedSymbols(t) {
          if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          const s = [];
          let c = 1 / 0, r = 1 / 0, a = -1 / 0, h = -1 / 0;
          for (const k of t) {
            const T = new l.P(k.x + ei, k.y + ei);
            c = Math.min(c, T.x), r = Math.min(r, T.y), a = Math.max(a, T.x), h = Math.max(h, T.y), s.push(T);
          }
          const d = this.grid.query(c, r, a, h).concat(this.ignoredGrid.query(c, r, a, h)), _ = {}, w = {};
          for (const k of d) {
            const T = k.key;
            if (_[T.bucketInstanceId] === void 0 && (_[T.bucketInstanceId] = {}), _[T.bucketInstanceId][T.featureIndex]) continue;
            const C = [new l.P(k.x1, k.y1), new l.P(k.x2, k.y1), new l.P(k.x2, k.y2), new l.P(k.x1, k.y2)];
            l.am(s, C) && (_[T.bucketInstanceId][T.featureIndex] = !0, w[T.bucketInstanceId] === void 0 && (w[T.bucketInstanceId] = []), w[T.bucketInstanceId].push(T.featureIndex));
          }
          return w;
        }
        insertCollisionBox(t, s, c, r, a, h) {
          (c ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: r, featureIndex: a, collisionGroupID: h, overlapMode: s }, t[0], t[1], t[2], t[3]);
        }
        insertCollisionCircles(t, s, c, r, a, h) {
          const d = c ? this.ignoredGrid : this.grid, _ = { bucketInstanceId: r, featureIndex: a, collisionGroupID: h, overlapMode: s };
          for (let w = 0; w < t.length; w += 4) d.insertCircle(_, t[w], t[w + 1], t[w + 2]);
        }
        projectAndGetPerspectiveRatio(t, s, c, r, a) {
          const h = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(s, c, r, a) : ht(new l.P(s, c), t, a);
          return { point: new l.P((h.point.x + 1) / 2 * this.transform.width + ei, (1 - h.point.y) / 2 * this.transform.height + ei), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / h.signedDistanceFromCamera * 0.5, isOccluded: h.isOccluded, signedDistanceFromCamera: h.signedDistanceFromCamera };
        }
        getPerspectiveRatio(t, s, c, r, a) {
          const h = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(s, c, r, a) : ht(new l.P(s, c), t, a);
          return 0.5 + this.transform.cameraToCenterDistance / h.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(t, s, c, r) {
          return c < ei || t >= this.screenRightBoundary || r < ei || s > this.screenBottomBoundary;
        }
        isInsideGrid(t, s, c, r) {
          return c >= 0 && t < this.gridRightBoundary && r >= 0 && s < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t = l.an([]);
          return l.J(t, t, [-100, -100, 0]), t;
        }
        _projectCollisionBox(t, s, c, r, a, h, d, _, w, k) {
          const T = s * _.perspectiveRatio;
          let C = new l.P(1, 0), z = new l.P(0, 1);
          const R = new l.P(t.anchorPointX + d[0], t.anchorPointY + d[1]);
          if (h && !a) {
            const qt = this.projectAndGetPerspectiveRatio(c, R.x + 1, R.y, r, w).point.sub(_.point).unit(), Zt = Math.atan(qt.y / qt.x) + (qt.x < 0 ? Math.PI : 0), Bt = Math.sin(Zt), ge = Math.cos(Zt);
            C = new l.P(ge, Bt), z = new l.P(-Bt, ge);
          } else if (!h && a) {
            const qt = -this.transform.angle, Zt = Math.sin(qt), Bt = Math.cos(qt);
            C = new l.P(Bt, Zt), z = new l.P(-Zt, Bt);
          }
          let W = _.point, Z = T;
          if (a) {
            W = R;
            const qt = this.transform.zoom - Math.floor(this.transform.zoom);
            Z = Math.pow(2, -qt), Z *= this.mapProjection.getPitchedTextCorrection(this.transform, R, r), k || (Z *= l.ac(0.5 + _.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          k && (W = W.add(C.mult(k.x * Z)).add(z.mult(k.y * Z)));
          const G = t.x1 * Z, nt = t.x2 * Z, Y = (G + nt) / 2, J = t.y1 * Z, tt = t.y2 * Z, ut = (J + tt) / 2, St = [{ offsetX: G, offsetY: J }, { offsetX: Y, offsetY: J }, { offsetX: nt, offsetY: J }, { offsetX: nt, offsetY: ut }, { offsetX: nt, offsetY: tt }, { offsetX: Y, offsetY: tt }, { offsetX: G, offsetY: tt }, { offsetX: G, offsetY: ut }];
          let It = [];
          for (const { offsetX: qt, offsetY: Zt } of St) It.push(new l.P(W.x + C.x * qt + z.x * Zt, W.y + C.y * qt + z.y * Zt));
          let Gt = !1;
          if (a) {
            const qt = It.map((Zt) => this.projectAndGetPerspectiveRatio(c, Zt.x, Zt.y, r, w));
            Gt = qt.some((Zt) => !Zt.isOccluded), It = qt.map((Zt) => Zt.point);
          } else Gt = !0;
          return { box: l.ao(It), allPointsOccluded: !Gt };
        }
      }
      function He(p, t, s) {
        return t * (l.X / (p.tileSize * Math.pow(2, s - p.tileID.overscaledZ)));
      }
      class Ti {
        constructor(t, s, c, r) {
          this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? s : -s))) : r && c ? 1 : 0, this.placed = c;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Di {
        constructor(t, s, c, r, a) {
          this.text = new Ti(t ? t.text : null, s, c, a), this.icon = new Ti(t ? t.icon : null, s, r, a);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Oi {
        constructor(t, s, c) {
          this.text = t, this.icon = s, this.skipFade = c;
        }
      }
      class oi {
        constructor() {
          this.invProjMatrix = l.H(), this.viewportMatrix = l.H(), this.circles = [];
        }
      }
      class Ci {
        constructor(t, s, c, r, a) {
          this.bucketInstanceId = t, this.featureIndex = s, this.sourceLayerIndex = c, this.bucketIndex = r, this.tileID = a;
        }
      }
      class Ui {
        constructor(t) {
          this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(t) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[t]) {
            const s = ++this.maxGroupID;
            this.collisionGroups[t] = { ID: s, predicate: (c) => c.collisionGroupID === s };
          }
          return this.collisionGroups[t];
        }
      }
      function rr(p, t, s, c, r) {
        const { horizontalAlign: a, verticalAlign: h } = l.au(p);
        return new l.P(-(a - 0.5) * t + c[0] * r, -(h - 0.5) * s + c[1] * r);
      }
      class pr {
        constructor(t, s, c, r, a, h) {
          this.transform = t.clone(), this.terrain = c, this.collisionIndex = new mi(this.transform, s), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = r, this.retainedQueryData = {}, this.collisionGroups = new Ui(a), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = h, h && (h.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(t) {
          const s = this.terrain;
          return s ? (c, r) => s.getElevation(t, c, r) : null;
        }
        getBucketParts(t, s, c, r) {
          const a = c.getBucket(s), h = c.latestFeatureIndex;
          if (!a || !h || s.id !== a.layerIds[0]) return;
          const d = c.collisionBoxArray, _ = a.layers[0].layout, w = a.layers[0].paint, k = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), T = c.tileSize / l.X, C = c.tileID.toUnwrapped(), z = this.transform.calculatePosMatrix(C), R = _.get("text-pitch-alignment") === "map", W = _.get("text-rotation-alignment") === "map", Z = He(c, 1, this.transform.zoom), G = this.collisionIndex.mapProjection.translatePosition(this.transform, c, w.get("text-translate"), w.get("text-translate-anchor")), nt = this.collisionIndex.mapProjection.translatePosition(this.transform, c, w.get("icon-translate"), w.get("icon-translate-anchor")), Y = Ir(z, R, W, this.transform, Z);
          let J = null;
          if (R) {
            const ut = kr(z, R, W, this.transform, Z);
            J = l.L([], this.transform.labelPlaneMatrix, ut);
          }
          this.retainedQueryData[a.bucketInstanceId] = new Ci(a.bucketInstanceId, h, a.sourceLayerIndex, a.index, c.tileID);
          const tt = { bucket: a, layout: _, translationText: G, translationIcon: nt, posMatrix: z, unwrappedTileID: C, textLabelPlaneMatrix: Y, labelToScreenMatrix: J, scale: k, textPixelRatio: T, holdingForFade: c.holdingForFade(), collisionBoxArray: d, partiallyEvaluatedTextSize: l.ag(a.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a.sourceID) };
          if (r) for (const ut of a.sortKeyRanges) {
            const { sortKey: St, symbolInstanceStart: It, symbolInstanceEnd: Gt } = ut;
            t.push({ sortKey: St, symbolInstanceStart: It, symbolInstanceEnd: Gt, parameters: tt });
          }
          else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: a.symbolInstances.length, parameters: tt });
        }
        attemptAnchorPlacement(t, s, c, r, a, h, d, _, w, k, T, C, z, R, W, Z, G, nt, Y) {
          const J = l.aq[t.textAnchor], tt = [t.textOffset0, t.textOffset1], ut = rr(J, c, r, tt, a), St = this.collisionIndex.placeCollisionBox(s, C, _, w, k, d, h, Z, T.predicate, Y, ut);
          if ((!nt || this.collisionIndex.placeCollisionBox(nt, C, _, w, k, d, h, G, T.predicate, Y, ut).placeable) && St.placeable) {
            let It;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[z.crossTileID] && this.prevPlacement.placements[z.crossTileID] && this.prevPlacement.placements[z.crossTileID].text && (It = this.prevPlacement.variableOffsets[z.crossTileID].anchor), z.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[z.crossTileID] = { textOffset: tt, width: c, height: r, anchor: J, textBoxScale: a, prevAnchor: It }, this.markUsedJustification(R, J, z, W), R.allowVerticalPlacement && (this.markUsedOrientation(R, W, z), this.placedOrientations[z.crossTileID] = W), { shift: ut, placedGlyphBoxes: St };
          }
        }
        placeLayerBucketPart(t, s, c) {
          const { bucket: r, layout: a, translationText: h, translationIcon: d, posMatrix: _, unwrappedTileID: w, textLabelPlaneMatrix: k, labelToScreenMatrix: T, textPixelRatio: C, holdingForFade: z, collisionBoxArray: R, partiallyEvaluatedTextSize: W, collisionGroup: Z } = t.parameters, G = a.get("text-optional"), nt = a.get("icon-optional"), Y = l.ar(a, "text-overlap", "text-allow-overlap"), J = Y === "always", tt = l.ar(a, "icon-overlap", "icon-allow-overlap"), ut = tt === "always", St = a.get("text-rotation-alignment") === "map", It = a.get("text-pitch-alignment") === "map", Gt = a.get("icon-text-fit") !== "none", qt = a.get("symbol-z-order") === "viewport-y", Zt = J && (ut || !r.hasIconData() || nt), Bt = ut && (J || !r.hasTextData() || G);
          !r.collisionArrays && R && r.deserializeCollisionBoxes(R);
          const ge = this._getTerrainElevationFunc(this.retainedQueryData[r.bucketInstanceId].tileID), Le = (ce, de, Ce) => {
            var ii, we;
            if (s[ce.crossTileID]) return;
            if (z) return void (this.placements[ce.crossTileID] = new Oi(!1, !1, !1));
            let We = !1, Ai = !1, Mi = !0, sr = null, ri = { box: null, placeable: !1, offscreen: null }, Xi = { box: null, placeable: !1, offscreen: null }, Gi = null, zi = null, Fi = null, Qi = 0, Mr = 0, fn = 0;
            de.textFeatureIndex ? Qi = de.textFeatureIndex : ce.useRuntimeCollisionCircles && (Qi = ce.featureIndex), de.verticalTextFeatureIndex && (Mr = de.verticalTextFeatureIndex);
            const ar = de.textBox;
            if (ar) {
              const Sr = (Xr) => {
                let Ar = l.ah.horizontal;
                if (r.allowVerticalPlacement && !Xr && this.prevPlacement) {
                  const Rr = this.prevPlacement.placedOrientations[ce.crossTileID];
                  Rr && (this.placedOrientations[ce.crossTileID] = Rr, Ar = Rr, this.markUsedOrientation(r, Ar, ce));
                }
                return Ar;
              }, Ri = (Xr, Ar) => {
                if (r.allowVerticalPlacement && ce.numVerticalGlyphVertices > 0 && de.verticalTextBox) {
                  for (const Rr of r.writingModes) if (Rr === l.ah.vertical ? (ri = Ar(), Xi = ri) : ri = Xr(), ri && ri.placeable) break;
                } else ri = Xr();
              }, Ss = ce.textAnchorOffsetStartIndex, Nn = ce.textAnchorOffsetEndIndex;
              if (Nn === Ss) {
                const Xr = (Ar, Rr) => {
                  const Yi = this.collisionIndex.placeCollisionBox(Ar, Y, C, _, w, It, St, h, Z.predicate, ge);
                  return Yi && Yi.placeable && (this.markUsedOrientation(r, Rr, ce), this.placedOrientations[ce.crossTileID] = Rr), Yi;
                };
                Ri(() => Xr(ar, l.ah.horizontal), () => {
                  const Ar = de.verticalTextBox;
                  return r.allowVerticalPlacement && ce.numVerticalGlyphVertices > 0 && Ar ? Xr(Ar, l.ah.vertical) : { box: null, offscreen: null };
                }), Sr(ri && ri.placeable);
              } else {
                let Xr = l.aq[(we = (ii = this.prevPlacement) === null || ii === void 0 ? void 0 : ii.variableOffsets[ce.crossTileID]) === null || we === void 0 ? void 0 : we.anchor];
                const Ar = (Yi, Yr, Pn) => {
                  const As = Yi.x2 - Yi.x1, ac = Yi.y2 - Yi.y1, fl = ce.textBoxScale, zr = Gt && tt === "never" ? Yr : null;
                  let is = null, za = Y === "never" ? 1 : 2, la = "never";
                  Xr && za++;
                  for (let Da = 0; Da < za; Da++) {
                    for (let Dl = Ss; Dl < Nn; Dl++) {
                      const Nl = r.textAnchorOffsets.get(Dl);
                      if (Xr && Nl.textAnchor !== Xr) continue;
                      const _o = this.attemptAnchorPlacement(Nl, Yi, As, ac, fl, St, It, C, _, w, Z, la, ce, r, Pn, h, d, zr, ge);
                      if (_o && (is = _o.placedGlyphBoxes, is && is.placeable)) return We = !0, sr = _o.shift, is;
                    }
                    Xr ? Xr = null : la = Y;
                  }
                  return c && !is && (is = { box: this.collisionIndex.placeCollisionBox(ar, "always", C, _, w, It, St, h, Z.predicate, ge, new l.P(0, 0)).box, offscreen: !1, placeable: !1 }), is;
                };
                Ri(() => Ar(ar, de.iconBox, l.ah.horizontal), () => {
                  const Yi = de.verticalTextBox;
                  return r.allowVerticalPlacement && (!ri || !ri.placeable) && ce.numVerticalGlyphVertices > 0 && Yi ? Ar(Yi, de.verticalIconBox, l.ah.vertical) : { box: null, occluded: !0, offscreen: null };
                }), ri && (We = ri.placeable, Mi = ri.offscreen);
                const Rr = Sr(ri && ri.placeable);
                if (!We && this.prevPlacement) {
                  const Yi = this.prevPlacement.variableOffsets[ce.crossTileID];
                  Yi && (this.variableOffsets[ce.crossTileID] = Yi, this.markUsedJustification(r, Yi.anchor, ce, Rr));
                }
              }
            }
            if (Gi = ri, We = Gi && Gi.placeable, Mi = Gi && Gi.offscreen, ce.useRuntimeCollisionCircles) {
              const Sr = r.text.placedSymbolArray.get(ce.centerJustifiedTextSymbolIndex), Ri = l.ai(r.textSizeData, W, Sr), Ss = a.get("text-padding");
              zi = this.collisionIndex.placeCollisionCircles(Y, Sr, r.lineVertexArray, r.glyphOffsetArray, Ri, _, w, k, T, c, It, Z.predicate, ce.collisionCircleDiameter, Ss, h, ge), zi.circles.length && zi.collisionDetected && !c && l.w("Collisions detected, but collision boxes are not shown"), We = J || zi.circles.length > 0 && !zi.collisionDetected, Mi = Mi && zi.offscreen;
            }
            if (de.iconFeatureIndex && (fn = de.iconFeatureIndex), de.iconBox) {
              const Sr = (Ri) => this.collisionIndex.placeCollisionBox(Ri, tt, C, _, w, It, St, d, Z.predicate, ge, Gt && sr ? sr : void 0);
              Xi && Xi.placeable && de.verticalIconBox ? (Fi = Sr(de.verticalIconBox), Ai = Fi.placeable) : (Fi = Sr(de.iconBox), Ai = Fi.placeable), Mi = Mi && Fi.offscreen;
            }
            const Hr = G || ce.numHorizontalGlyphVertices === 0 && ce.numVerticalGlyphVertices === 0, ws = nt || ce.numIconVertices === 0;
            Hr || ws ? ws ? Hr || (Ai = Ai && We) : We = Ai && We : Ai = We = Ai && We;
            const oa = Ai && Fi.placeable;
            if (We && Gi.placeable && this.collisionIndex.insertCollisionBox(Gi.box, Y, a.get("text-ignore-placement"), r.bucketInstanceId, Xi && Xi.placeable && Mr ? Mr : Qi, Z.ID), oa && this.collisionIndex.insertCollisionBox(Fi.box, tt, a.get("icon-ignore-placement"), r.bucketInstanceId, fn, Z.ID), zi && We && this.collisionIndex.insertCollisionCircles(zi.circles, Y, a.get("text-ignore-placement"), r.bucketInstanceId, Qi, Z.ID), c && this.storeCollisionData(r.bucketInstanceId, Ce, de, Gi, Fi, zi), ce.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            if (r.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[ce.crossTileID] = new Oi(We || Zt, Ai || Bt, Mi || r.justReloaded), s[ce.crossTileID] = !0;
          };
          if (qt) {
            if (t.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
            const ce = r.getSortedSymbolIndexes(this.transform.angle);
            for (let de = ce.length - 1; de >= 0; --de) {
              const Ce = ce[de];
              Le(r.symbolInstances.get(Ce), r.collisionArrays[Ce], Ce);
            }
          } else for (let ce = t.symbolInstanceStart; ce < t.symbolInstanceEnd; ce++) Le(r.symbolInstances.get(ce), r.collisionArrays[ce], ce);
          if (c && r.bucketInstanceId in this.collisionCircleArrays) {
            const ce = this.collisionCircleArrays[r.bucketInstanceId];
            l.as(ce.invProjMatrix, _), ce.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          r.justReloaded = !1;
        }
        storeCollisionData(t, s, c, r, a, h) {
          if (c.textBox || c.iconBox) {
            let d, _;
            this.collisionBoxArrays.has(t) ? d = this.collisionBoxArrays.get(t) : (d = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(t, d)), d.has(s) ? _ = d.get(s) : (_ = { text: null, icon: null }, d.set(s, _)), c.textBox && (_.text = r.box), c.iconBox && (_.icon = a.box);
          }
          if (h) {
            let d = this.collisionCircleArrays[t];
            d === void 0 && (d = this.collisionCircleArrays[t] = new oi());
            for (let _ = 0; _ < h.circles.length; _ += 4) d.circles.push(h.circles[_ + 0]), d.circles.push(h.circles[_ + 1]), d.circles.push(h.circles[_ + 2]), d.circles.push(h.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(t, s, c, r) {
          let a;
          a = r === l.ah.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[l.at(s)];
          const h = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex];
          for (const d of h) d >= 0 && (t.text.placedSymbolArray.get(d).crossTileID = a >= 0 && d !== a ? 0 : c.crossTileID);
        }
        markUsedOrientation(t, s, c) {
          const r = s === l.ah.horizontal || s === l.ah.horizontalOnly ? s : 0, a = s === l.ah.vertical ? s : 0, h = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex];
          for (const d of h) t.text.placedSymbolArray.get(d).placedOrientation = r;
          c.verticalPlacedTextSymbolIndex && (t.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = a);
        }
        commit(t) {
          this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const s = this.prevPlacement;
          let c = !1;
          this.prevZoomAdjustment = s ? s.zoomAdjustment(this.transform.zoom) : 0;
          const r = s ? s.symbolFadeChange(t) : 1, a = s ? s.opacities : {}, h = s ? s.variableOffsets : {}, d = s ? s.placedOrientations : {};
          for (const _ in this.placements) {
            const w = this.placements[_], k = a[_];
            k ? (this.opacities[_] = new Di(k, r, w.text, w.icon), c = c || w.text !== k.text.placed || w.icon !== k.icon.placed) : (this.opacities[_] = new Di(null, r, w.text, w.icon, w.skipFade), c = c || w.text || w.icon);
          }
          for (const _ in a) {
            const w = a[_];
            if (!this.opacities[_]) {
              const k = new Di(w, r, !1, !1);
              k.isHidden() || (this.opacities[_] = k, c = c || w.text.placed || w.icon.placed);
            }
          }
          for (const _ in h) this.variableOffsets[_] || !this.opacities[_] || this.opacities[_].isHidden() || (this.variableOffsets[_] = h[_]);
          for (const _ in d) this.placedOrientations[_] || !this.opacities[_] || this.opacities[_].isHidden() || (this.placedOrientations[_] = d[_]);
          if (s && s.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
          c ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = s ? s.lastPlacementChangeTime : t);
        }
        updateLayerOpacities(t, s) {
          const c = {};
          for (const r of s) {
            const a = r.getBucket(t);
            a && r.latestFeatureIndex && t.id === a.layerIds[0] && this.updateBucketOpacities(a, r.tileID, c, r.collisionBoxArray);
          }
        }
        updateBucketOpacities(t, s, c, r) {
          t.hasTextData() && (t.text.opacityVertexArray.clear(), t.text.hasVisibleVertices = !1), t.hasIconData() && (t.icon.opacityVertexArray.clear(), t.icon.hasVisibleVertices = !1), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
          const a = t.layers[0], h = a.layout, d = new Di(null, 0, !1, !1, !0), _ = h.get("text-allow-overlap"), w = h.get("icon-allow-overlap"), k = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset"), T = h.get("text-rotation-alignment") === "map", C = h.get("text-pitch-alignment") === "map", z = h.get("icon-text-fit") !== "none", R = new Di(null, 0, _ && (w || !t.hasIconData() || h.get("icon-optional")), w && (_ || !t.hasTextData() || h.get("text-optional")), !0);
          !t.collisionArrays && r && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(r);
          const W = (G, nt, Y) => {
            for (let J = 0; J < nt / 4; J++) G.opacityVertexArray.emplaceBack(Y);
            G.hasVisibleVertices = G.hasVisibleVertices || Y !== br;
          }, Z = this.collisionBoxArrays.get(t.bucketInstanceId);
          for (let G = 0; G < t.symbolInstances.length; G++) {
            const nt = t.symbolInstances.get(G), { numHorizontalGlyphVertices: Y, numVerticalGlyphVertices: J, crossTileID: tt } = nt;
            let ut = this.opacities[tt];
            c[tt] ? ut = d : ut || (ut = R, this.opacities[tt] = ut), c[tt] = !0;
            const St = nt.numIconVertices > 0, It = this.placedOrientations[nt.crossTileID], Gt = It === l.ah.vertical, qt = It === l.ah.horizontal || It === l.ah.horizontalOnly;
            if (Y > 0 || J > 0) {
              const Bt = en(ut.text);
              W(t.text, Y, Gt ? br : Bt), W(t.text, J, qt ? br : Bt);
              const ge = ut.text.isHidden();
              [nt.rightJustifiedTextSymbolIndex, nt.centerJustifiedTextSymbolIndex, nt.leftJustifiedTextSymbolIndex].forEach((de) => {
                de >= 0 && (t.text.placedSymbolArray.get(de).hidden = ge || Gt ? 1 : 0);
              }), nt.verticalPlacedTextSymbolIndex >= 0 && (t.text.placedSymbolArray.get(nt.verticalPlacedTextSymbolIndex).hidden = ge || qt ? 1 : 0);
              const Le = this.variableOffsets[nt.crossTileID];
              Le && this.markUsedJustification(t, Le.anchor, nt, It);
              const ce = this.placedOrientations[nt.crossTileID];
              ce && (this.markUsedJustification(t, "left", nt, ce), this.markUsedOrientation(t, ce, nt));
            }
            if (St) {
              const Bt = en(ut.icon), ge = !(z && nt.verticalPlacedIconSymbolIndex && Gt);
              nt.placedIconSymbolIndex >= 0 && (W(t.icon, nt.numIconVertices, ge ? Bt : br), t.icon.placedSymbolArray.get(nt.placedIconSymbolIndex).hidden = ut.icon.isHidden()), nt.verticalPlacedIconSymbolIndex >= 0 && (W(t.icon, nt.numVerticalIconVertices, ge ? br : Bt), t.icon.placedSymbolArray.get(nt.verticalPlacedIconSymbolIndex).hidden = ut.icon.isHidden());
            }
            const Zt = Z && Z.has(G) ? Z.get(G) : { text: null, icon: null };
            if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
              const Bt = t.collisionArrays[G];
              if (Bt) {
                let ge = new l.P(0, 0);
                if (Bt.textBox || Bt.verticalTextBox) {
                  let Le = !0;
                  if (k) {
                    const ce = this.variableOffsets[tt];
                    ce ? (ge = rr(ce.anchor, ce.width, ce.height, ce.textOffset, ce.textBoxScale), T && ge._rotate(C ? this.transform.angle : -this.transform.angle)) : Le = !1;
                  }
                  if (Bt.textBox || Bt.verticalTextBox) {
                    let ce;
                    Bt.textBox && (ce = Gt), Bt.verticalTextBox && (ce = qt), fr(t.textCollisionBox.collisionVertexArray, ut.text.placed, !Le || ce, Zt.text, ge.x, ge.y);
                  }
                }
                if (Bt.iconBox || Bt.verticalIconBox) {
                  const Le = !!(!qt && Bt.verticalIconBox);
                  let ce;
                  Bt.iconBox && (ce = Le), Bt.verticalIconBox && (ce = !Le), fr(t.iconCollisionBox.collisionVertexArray, ut.icon.placed, ce, Zt.icon, z ? ge.x : 0, z ? ge.y : 0);
                }
              }
            }
          }
          if (t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.text.opacityVertexArray.length !== t.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${t.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t.text.layoutVertexArray.length}) / 4`);
          if (t.icon.opacityVertexArray.length !== t.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${t.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t.icon.layoutVertexArray.length}) / 4`);
          if (t.bucketInstanceId in this.collisionCircleArrays) {
            const G = this.collisionCircleArrays[t.bucketInstanceId];
            t.placementInvProjMatrix = G.invProjMatrix, t.placementViewportMatrix = G.viewportMatrix, t.collisionCircleArray = G.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
          }
        }
        symbolFadeChange(t) {
          return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(t) {
          return Math.max(0, (this.transform.zoom - t) / 1.5);
        }
        hasTransitions(t) {
          return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(t, s) {
          const c = this.zoomAtLastRecencyCheck === s ? 1 - this.zoomAdjustment(s) : 1;
          return this.zoomAtLastRecencyCheck = s, this.commitTime + this.fadeDuration * c > t;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function fr(p, t, s, c, r, a) {
        c && c.length !== 0 || (c = [0, 0, 0, 0]);
        const h = c[0] - ei, d = c[1] - ei, _ = c[2] - ei, w = c[3] - ei;
        p.emplaceBack(t ? 1 : 0, s ? 1 : 0, r || 0, a || 0, h, d), p.emplaceBack(t ? 1 : 0, s ? 1 : 0, r || 0, a || 0, _, d), p.emplaceBack(t ? 1 : 0, s ? 1 : 0, r || 0, a || 0, _, w), p.emplaceBack(t ? 1 : 0, s ? 1 : 0, r || 0, a || 0, h, w);
      }
      const $s = Math.pow(2, 25), Ni = Math.pow(2, 24), zo = Math.pow(2, 17), Zs = Math.pow(2, 16), Vr = Math.pow(2, 9), tn = Math.pow(2, 8), Do = Math.pow(2, 1);
      function en(p) {
        if (p.opacity === 0 && !p.placed) return 0;
        if (p.opacity === 1 && p.placed) return 4294967295;
        const t = p.placed ? 1 : 0, s = Math.floor(127 * p.opacity);
        return s * $s + t * Ni + s * zo + t * Zs + s * Vr + t * tn + s * Do + t;
      }
      const br = 0;
      function Ua() {
        return { isOccluded: (p, t, s) => !1, getPitchedTextCorrection: (p, t, s) => 1, get useSpecialProjectionForSymbols() {
          return !1;
        }, projectTileCoordinates(p, t, s, c) {
          throw new Error("Not implemented.");
        }, translatePosition: (p, t, s, c) => function(r, a, h, d, _ = !1) {
          if (!h[0] && !h[1]) return [0, 0];
          const w = _ ? d === "map" ? r.angle : 0 : d === "viewport" ? -r.angle : 0;
          if (w) {
            const k = Math.sin(w), T = Math.cos(w);
            h = [h[0] * T - h[1] * k, h[0] * k + h[1] * T];
          }
          return [_ ? h[0] : He(a, h[0], r.zoom), _ ? h[1] : He(a, h[1], r.zoom)];
        }(p, t, s, c), getCircleRadiusCorrection: (p) => 1 };
      }
      class os {
        constructor(t) {
          this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && !t.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(t, s, c, r, a) {
          const h = this._bucketParts;
          for (; this._currentTileIndex < t.length; ) if (s.getBucketParts(h, r, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, h.sort((d, _) => d.sortKey - _.sortKey)); this._currentPartIndex < h.length; ) if (s.placeLayerBucketPart(h[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, a()) return !0;
          return !1;
        }
      }
      class dr {
        constructor(t, s, c, r, a, h, d, _) {
          this.placement = new pr(t, Ua(), s, h, d, _), this._currentPlacementIndex = c.length - 1, this._forceFullPlacement = r, this._showCollisionBoxes = a, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t, s, c) {
          const r = q.now(), a = () => !this._forceFullPlacement && q.now() - r > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const h = s[t[this._currentPlacementIndex]], d = this.placement.collisionIndex.transform.zoom;
            if (h.type === "symbol" && (!h.minzoom || h.minzoom <= d) && (!h.maxzoom || h.maxzoom > d)) {
              if (this._inProgressLayer || (this._inProgressLayer = new os(h)), this._inProgressLayer.continuePlacement(c[h.source], this.placement, this._showCollisionBoxes, h, a)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(t) {
          return this.placement.commit(t), this.placement;
        }
      }
      const $i = 512 / l.X / 2;
      class ls {
        constructor(t, s, c) {
          this.tileID = t, this.bucketInstanceId = c, this._symbolsByKey = {};
          const r = /* @__PURE__ */ new Map();
          for (let a = 0; a < s.length; a++) {
            const h = s.get(a), d = h.key, _ = r.get(d);
            _ ? _.push(h) : r.set(d, [h]);
          }
          for (const [a, h] of r) {
            const d = { positions: h.map((_) => ({ x: Math.floor(_.anchorX * $i), y: Math.floor(_.anchorY * $i) })), crossTileIDs: h.map((_) => _.crossTileID) };
            if (d.positions.length > 128) {
              const _ = new l.av(d.positions.length, 16, Uint16Array);
              for (const { x: w, y: k } of d.positions) _.add(w, k);
              _.finish(), delete d.positions, d.index = _;
            }
            this._symbolsByKey[a] = d;
          }
        }
        getScaledCoordinates(t, s) {
          const { x: c, y: r, z: a } = this.tileID.canonical, { x: h, y: d, z: _ } = s.canonical, w = $i / Math.pow(2, _ - a), k = (d * l.X + t.anchorY) * w, T = r * l.X * $i;
          return { x: Math.floor((h * l.X + t.anchorX) * w - c * l.X * $i), y: Math.floor(k - T) };
        }
        findMatches(t, s, c) {
          const r = this.tileID.canonical.z < s.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - s.canonical.z);
          for (let a = 0; a < t.length; a++) {
            const h = t.get(a);
            if (h.crossTileID) continue;
            const d = this._symbolsByKey[h.key];
            if (!d) continue;
            const _ = this.getScaledCoordinates(h, s);
            if (d.index) {
              const w = d.index.range(_.x - r, _.y - r, _.x + r, _.y + r).sort();
              for (const k of w) {
                const T = d.crossTileIDs[k];
                if (!c[T]) {
                  c[T] = !0, h.crossTileID = T;
                  break;
                }
              }
            } else if (d.positions) for (let w = 0; w < d.positions.length; w++) {
              const k = d.positions[w], T = d.crossTileIDs[w];
              if (Math.abs(k.x - _.x) <= r && Math.abs(k.y - _.y) <= r && !c[T]) {
                c[T] = !0, h.crossTileID = T;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: t }) => t);
        }
      }
      class nr {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class fa {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(t) {
          const s = Math.round((t - this.lng) / 360);
          if (s !== 0) for (const c in this.indexes) {
            const r = this.indexes[c], a = {};
            for (const h in r) {
              const d = r[h];
              d.tileID = d.tileID.unwrapTo(d.tileID.wrap + s), a[d.tileID.key] = d;
            }
            this.indexes[c] = a;
          }
          this.lng = t;
        }
        addBucket(t, s, c) {
          if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
            if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === s.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
          }
          for (let a = 0; a < s.symbolInstances.length; a++) s.symbolInstances.get(a).crossTileID = 0;
          this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});
          const r = this.usedCrossTileIDs[t.overscaledZ];
          for (const a in this.indexes) {
            const h = this.indexes[a];
            if (Number(a) > t.overscaledZ) for (const d in h) {
              const _ = h[d];
              _.tileID.isChildOf(t) && _.findMatches(s.symbolInstances, t, r);
            }
            else {
              const d = h[t.scaledTo(Number(a)).key];
              d && d.findMatches(s.symbolInstances, t, r);
            }
          }
          for (let a = 0; a < s.symbolInstances.length; a++) {
            const h = s.symbolInstances.get(a);
            h.crossTileID || (h.crossTileID = c.generate(), r[h.crossTileID] = !0);
          }
          return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new ls(t, s.symbolInstances, s.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(t, s) {
          for (const c of s.getCrossTileIDsLists()) for (const r of c) delete this.usedCrossTileIDs[t][r];
        }
        removeStaleBuckets(t) {
          let s = !1;
          for (const c in this.indexes) {
            const r = this.indexes[c];
            for (const a in r) t[r[a].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, r[a]), delete r[a], s = !0);
          }
          return s;
        }
      }
      class $r {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new nr(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(t, s, c) {
          let r = this.layerIndexes[t.id];
          r === void 0 && (r = this.layerIndexes[t.id] = new fa());
          let a = !1;
          const h = {};
          r.handleWrapJump(c);
          for (const d of s) {
            const _ = d.getBucket(t);
            _ && t.id === _.layerIds[0] && (_.bucketInstanceId || (_.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(d.tileID, _, this.crossTileIDs) && (a = !0), h[_.bucketInstanceId] = !0);
          }
          return r.removeStaleBuckets(h) && (a = !0), a;
        }
        pruneUnusedLayers(t) {
          const s = {};
          t.forEach((c) => {
            s[c] = !0;
          });
          for (const c in this.layerIndexes) s[c] || delete this.layerIndexes[c];
        }
      }
      const ma = (p, t) => l.t(p, t && t.filter((s) => s.identifier !== "source.canvas")), Tr = l.aw();
      class Gs extends l.E {
        constructor(t, s = {}) {
          super(), this._rtlPluginLoaded = () => {
            for (const c in this.sourceCaches) {
              const r = this.sourceCaches[c].getSource().type;
              r !== "vector" && r !== "geojson" || this.sourceCaches[c].reload();
            }
          }, this.map = t, this.dispatcher = new xe(Wt(), t._getMapId()), this.dispatcher.registerMessageHandler("GG", (c, r) => this.getGlyphs(c, r)), this.dispatcher.registerMessageHandler("GI", (c, r) => this.getImages(c, r)), this.imageManager = new Pt(), this.imageManager.setEventedParent(this), this.glyphManager = new te(t._requestManager, s.localIdeographFontFamily), this.lineAtlas = new pt(256, 512), this.crossTileSymbolIndex = new $r(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new l.ax(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", l.ay()), Pe().on(he, this._rtlPluginLoaded), this.on("data", (c) => {
            if (c.dataType !== "source" || c.sourceDataType !== "metadata") return;
            const r = this.sourceCaches[c.sourceId];
            if (!r) return;
            const a = r.getSource();
            if (a && a.vectorLayerIds) for (const h in this._layers) {
              const d = this._layers[h];
              d.source === a.id && this._validateLayer(d);
            }
          });
        }
        loadURL(t, s = {}, c) {
          this.fire(new l.k("dataloading", { dataType: "style" })), s.validate = typeof s.validate != "boolean" || s.validate;
          const r = this.map._requestManager.transformRequest(t, "Style");
          this._loadStyleRequest = new AbortController();
          const a = this._loadStyleRequest;
          l.h(r, this._loadStyleRequest).then((h) => {
            this._loadStyleRequest = null, this._load(h.data, s, c);
          }).catch((h) => {
            this._loadStyleRequest = null, h && !a.signal.aborted && this.fire(new l.j(h));
          });
        }
        loadJSON(t, s = {}, c) {
          this.fire(new l.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), q.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, s.validate = s.validate !== !1, this._load(t, s, c);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new l.k("dataloading", { dataType: "style" })), this._load(Tr, { validate: !1 });
        }
        _load(t, s, c) {
          var r;
          const a = s.transformStyle ? s.transformStyle(c, t) : t;
          if (!s.validate || !ma(this, l.u(a))) {
            this._loaded = !0, this.stylesheet = a;
            for (const h in a.sources) this.addSource(h, a.sources[h], { validate: !1 });
            a.sprite ? this._loadSprite(a.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(a.glyphs), this._createLayers(), this.light = new ee(this.stylesheet.light), this.sky = new Q(this.stylesheet.sky), this.map.setTerrain((r = this.stylesheet.terrain) !== null && r !== void 0 ? r : null), this.fire(new l.k("data", { dataType: "style" })), this.fire(new l.k("style.load"));
          }
        }
        _createLayers() {
          const t = l.az(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", t), this._order = t.map((s) => s.id), this._layers = {}, this._serializedLayers = null;
          for (const s of t) {
            const c = l.aA(s);
            c.setEventedParent(this, { layer: { id: s.id } }), this._layers[s.id] = c;
          }
        }
        _loadSprite(t, s = !1, c = void 0) {
          let r;
          this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(a, h, d, _) {
            return l._(this, void 0, void 0, function* () {
              const w = le(a), k = d > 1 ? "@2x" : "", T = {}, C = {};
              for (const { id: z, url: R } of w) {
                const W = h.transformRequest(ne(R, k, ".json"), "SpriteJSON");
                T[z] = l.h(W, _);
                const Z = h.transformRequest(ne(R, k, ".png"), "SpriteImage");
                C[z] = Mt.getImage(Z, _);
              }
              return yield Promise.all([...Object.values(T), ...Object.values(C)]), function(z, R) {
                return l._(this, void 0, void 0, function* () {
                  const W = {};
                  for (const Z in z) {
                    W[Z] = {};
                    const G = q.getImageCanvasContext((yield R[Z]).data), nt = (yield z[Z]).data;
                    for (const Y in nt) {
                      const { width: J, height: tt, x: ut, y: St, sdf: It, pixelRatio: Gt, stretchX: qt, stretchY: Zt, content: Bt, textFitWidth: ge, textFitHeight: Le } = nt[Y];
                      W[Z][Y] = { data: null, pixelRatio: Gt, sdf: It, stretchX: qt, stretchY: Zt, content: Bt, textFitWidth: ge, textFitHeight: Le, spriteData: { width: J, height: tt, x: ut, y: St, context: G } };
                    }
                  }
                  return W;
                });
              }(T, C);
            });
          }(t, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((a) => {
            if (this._spriteRequest = null, a) for (const h in a) {
              this._spritesImagesIds[h] = [];
              const d = this._spritesImagesIds[h] ? this._spritesImagesIds[h].filter((_) => !(_ in a)) : [];
              for (const _ of d) this.imageManager.removeImage(_), this._changedImages[_] = !0;
              for (const _ in a[h]) {
                const w = h === "default" ? _ : `${h}:${_}`;
                this._spritesImagesIds[h].push(w), w in this.imageManager.images ? this.imageManager.updateImage(w, a[h][_], !1) : this.imageManager.addImage(w, a[h][_]), s && (this._changedImages[w] = !0);
              }
            }
          }).catch((a) => {
            this._spriteRequest = null, r = a, this.fire(new l.j(r));
          }).finally(() => {
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), s && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" })), c && c(r);
          });
        }
        _unloadSprite() {
          for (const t of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t), this._changedImages[t] = !0;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" }));
        }
        _validateLayer(t) {
          const s = this.sourceCaches[t.source];
          if (!s) return;
          const c = t.sourceLayer;
          if (!c) return;
          const r = s.getSource();
          (r.type === "geojson" || r.vectorLayerIds && r.vectorLayerIds.indexOf(c) === -1) && this.fire(new l.j(new Error(`Source layer "${c}" does not exist on source "${r.id}" as specified by style layer "${t.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
          for (const t in this.sourceCaches) if (!this.sourceCaches[t].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(t, s = !1) {
          const c = this._serializedAllLayers();
          if (!t || t.length === 0) return Object.values(s ? l.aB(c) : c);
          const r = [];
          for (const a of t) if (c[a]) {
            const h = s ? l.aB(c[a]) : c[a];
            r.push(h);
          }
          return r;
        }
        _serializedAllLayers() {
          let t = this._serializedLayers;
          if (t) return t;
          t = this._serializedLayers = {};
          const s = Object.keys(this._layers);
          for (const c of s) {
            const r = this._layers[c];
            r.type !== "custom" && (t[c] = r.serialize());
          }
          return t;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition() || this.sky && this.sky.hasTransition()) return !0;
          for (const t in this.sourceCaches) if (this.sourceCaches[t].hasTransition()) return !0;
          for (const t in this._layers) if (this._layers[t].hasTransition()) return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading.");
        }
        update(t) {
          if (!this._loaded) return;
          const s = this._changed;
          if (s) {
            const r = Object.keys(this._updatedLayers), a = Object.keys(this._removedLayers);
            (r.length || a.length) && this._updateWorkerLayers(r, a);
            for (const h in this._updatedSources) {
              const d = this._updatedSources[h];
              if (d === "reload") this._reloadSource(h);
              else {
                if (d !== "clear") throw new Error(`Invalid action ${d}`);
                this._clearSource(h);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const h in this._updatedPaintProps) this._layers[h].updateTransitions(t);
            this.light.updateTransitions(t), this.sky.updateTransitions(t), this._resetUpdates();
          }
          const c = {};
          for (const r in this.sourceCaches) {
            const a = this.sourceCaches[r];
            c[r] = a.used, a.used = !1;
          }
          for (const r of this._order) {
            const a = this._layers[r];
            a.recalculate(t, this._availableImages), !a.isHidden(t.zoom) && a.source && (this.sourceCaches[a.source].used = !0);
          }
          for (const r in c) {
            const a = this.sourceCaches[r];
            !!c[r] != !!a.used && a.fire(new l.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: r }));
          }
          this.light.recalculate(t), this.sky.recalculate(t), this.z = t.zoom, s && this.fire(new l.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const t = Object.keys(this._changedImages);
          if (t.length) {
            for (const s in this.sourceCaches) this.sourceCaches[s].reloadTilesForDependencies(["icons", "patterns"], t);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const t in this.sourceCaches) this.sourceCaches[t].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(t, s) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t, !1), removedIds: s });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
        }
        setState(t, s = {}) {
          var c;
          this._checkLoaded();
          const r = this.serialize();
          if (t = s.transformStyle ? s.transformStyle(r, t) : t, ((c = s.validate) === null || c === void 0 || c) && ma(this, l.u(t))) return !1;
          (t = l.aB(t)).layers = l.az(t.layers);
          const a = l.aC(r, t), h = this._getOperationsToPerform(a);
          if (h.unimplemented.length > 0) throw new Error(`Unimplemented: ${h.unimplemented.join(", ")}.`);
          if (h.operations.length === 0) return !1;
          for (const d of h.operations) d();
          return this.stylesheet = t, this._serializedLayers = null, !0;
        }
        _getOperationsToPerform(t) {
          const s = [], c = [];
          for (const r of t) switch (r.command) {
            case "setCenter":
            case "setZoom":
            case "setBearing":
            case "setPitch":
              continue;
            case "addLayer":
              s.push(() => this.addLayer.apply(this, r.args));
              break;
            case "removeLayer":
              s.push(() => this.removeLayer.apply(this, r.args));
              break;
            case "setPaintProperty":
              s.push(() => this.setPaintProperty.apply(this, r.args));
              break;
            case "setLayoutProperty":
              s.push(() => this.setLayoutProperty.apply(this, r.args));
              break;
            case "setFilter":
              s.push(() => this.setFilter.apply(this, r.args));
              break;
            case "addSource":
              s.push(() => this.addSource.apply(this, r.args));
              break;
            case "removeSource":
              s.push(() => this.removeSource.apply(this, r.args));
              break;
            case "setLayerZoomRange":
              s.push(() => this.setLayerZoomRange.apply(this, r.args));
              break;
            case "setLight":
              s.push(() => this.setLight.apply(this, r.args));
              break;
            case "setGeoJSONSourceData":
              s.push(() => this.setGeoJSONSourceData.apply(this, r.args));
              break;
            case "setGlyphs":
              s.push(() => this.setGlyphs.apply(this, r.args));
              break;
            case "setSprite":
              s.push(() => this.setSprite.apply(this, r.args));
              break;
            case "setSky":
              s.push(() => this.setSky.apply(this, r.args));
              break;
            case "setTerrain":
              s.push(() => this.map.setTerrain.apply(this, r.args));
              break;
            case "setTransition":
              s.push(() => {
              });
              break;
            default:
              c.push(r.command);
          }
          return { operations: s, unimplemented: c };
        }
        addImage(t, s) {
          if (this.getImage(t)) return this.fire(new l.j(new Error(`An image named "${t}" already exists.`)));
          this.imageManager.addImage(t, s), this._afterImageUpdated(t);
        }
        updateImage(t, s) {
          this.imageManager.updateImage(t, s);
        }
        getImage(t) {
          return this.imageManager.getImage(t);
        }
        removeImage(t) {
          if (!this.getImage(t)) return this.fire(new l.j(new Error(`An image named "${t}" does not exist.`)));
          this.imageManager.removeImage(t), this._afterImageUpdated(t);
        }
        _afterImageUpdated(t) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(t, s, c = {}) {
          if (this._checkLoaded(), this.sourceCaches[t] !== void 0) throw new Error(`Source "${t}" already exists.`);
          if (!s.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(s).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(s.type) >= 0 && this._validate(l.u.source, `sources.${t}`, s, null, c)) return;
          this.map && this.map._collectResourceTiming && (s.collectResourceTiming = !0);
          const r = this.sourceCaches[t] = new Te(t, s, this.dispatcher);
          r.style = this, r.setEventedParent(this, () => ({ isSourceLoaded: r.loaded(), source: r.serialize(), sourceId: t })), r.onAdd(this.map), this._changed = !0;
        }
        removeSource(t) {
          if (this._checkLoaded(), this.sourceCaches[t] === void 0) throw new Error("There is no source with this ID");
          for (const c in this._layers) if (this._layers[c].source === t) return this.fire(new l.j(new Error(`Source "${t}" cannot be removed while layer "${c}" is using it.`)));
          const s = this.sourceCaches[t];
          delete this.sourceCaches[t], delete this._updatedSources[t], s.fire(new l.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: t })), s.setEventedParent(null), s.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(t, s) {
          if (this._checkLoaded(), this.sourceCaches[t] === void 0) throw new Error(`There is no source with this ID=${t}`);
          const c = this.sourceCaches[t].getSource();
          if (c.type !== "geojson") throw new Error(`geojsonSource.type is ${c.type}, which is !== 'geojson`);
          c.setData(s), this._changed = !0;
        }
        getSource(t) {
          return this.sourceCaches[t] && this.sourceCaches[t].getSource();
        }
        addLayer(t, s, c = {}) {
          this._checkLoaded();
          const r = t.id;
          if (this.getLayer(r)) return void this.fire(new l.j(new Error(`Layer "${r}" already exists on this map.`)));
          let a;
          if (t.type === "custom") {
            if (ma(this, l.aD(t))) return;
            a = l.aA(t);
          } else {
            if ("source" in t && typeof t.source == "object" && (this.addSource(r, t.source), t = l.aB(t), t = l.e(t, { source: r })), this._validate(l.u.layer, `layers.${r}`, t, { arrayIndex: -1 }, c)) return;
            a = l.aA(t), this._validateLayer(a), a.setEventedParent(this, { layer: { id: r } });
          }
          const h = s ? this._order.indexOf(s) : this._order.length;
          if (s && h === -1) this.fire(new l.j(new Error(`Cannot add layer "${r}" before non-existing layer "${s}".`)));
          else {
            if (this._order.splice(h, 0, r), this._layerOrderChanged = !0, this._layers[r] = a, this._removedLayers[r] && a.source && a.type !== "custom") {
              const d = this._removedLayers[r];
              delete this._removedLayers[r], d.type !== a.type ? this._updatedSources[a.source] = "clear" : (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause());
            }
            this._updateLayer(a), a.onAdd && a.onAdd(this.map);
          }
        }
        moveLayer(t, s) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new l.j(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));
          if (t === s) return;
          const c = this._order.indexOf(t);
          this._order.splice(c, 1);
          const r = s ? this._order.indexOf(s) : this._order.length;
          s && r === -1 ? this.fire(new l.j(new Error(`Cannot move layer "${t}" before non-existing layer "${s}".`))) : (this._order.splice(r, 0, t), this._layerOrderChanged = !0);
        }
        removeLayer(t) {
          this._checkLoaded();
          const s = this._layers[t];
          if (!s) return void this.fire(new l.j(new Error(`Cannot remove non-existing layer "${t}".`)));
          s.setEventedParent(null);
          const c = this._order.indexOf(t);
          this._order.splice(c, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = s, delete this._layers[t], this._serializedLayers && delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], s.onRemove && s.onRemove(this.map);
        }
        getLayer(t) {
          return this._layers[t];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(t) {
          return t in this._layers;
        }
        setLayerZoomRange(t, s, c) {
          this._checkLoaded();
          const r = this.getLayer(t);
          r ? r.minzoom === s && r.maxzoom === c || (s != null && (r.minzoom = s), c != null && (r.maxzoom = c), this._updateLayer(r)) : this.fire(new l.j(new Error(`Cannot set the zoom range of non-existing layer "${t}".`)));
        }
        setFilter(t, s, c = {}) {
          this._checkLoaded();
          const r = this.getLayer(t);
          if (r) {
            if (!l.aE(r.filter, s)) return s == null ? (r.filter = void 0, void this._updateLayer(r)) : void (this._validate(l.u.filter, `layers.${r.id}.filter`, s, null, c) || (r.filter = l.aB(s), this._updateLayer(r)));
          } else this.fire(new l.j(new Error(`Cannot filter non-existing layer "${t}".`)));
        }
        getFilter(t) {
          return l.aB(this.getLayer(t).filter);
        }
        setLayoutProperty(t, s, c, r = {}) {
          this._checkLoaded();
          const a = this.getLayer(t);
          a ? l.aE(a.getLayoutProperty(s), c) || (a.setLayoutProperty(s, c, r), this._updateLayer(a)) : this.fire(new l.j(new Error(`Cannot style non-existing layer "${t}".`)));
        }
        getLayoutProperty(t, s) {
          const c = this.getLayer(t);
          if (c) return c.getLayoutProperty(s);
          this.fire(new l.j(new Error(`Cannot get style of non-existing layer "${t}".`)));
        }
        setPaintProperty(t, s, c, r = {}) {
          this._checkLoaded();
          const a = this.getLayer(t);
          a ? l.aE(a.getPaintProperty(s), c) || (a.setPaintProperty(s, c, r) && this._updateLayer(a), this._changed = !0, this._updatedPaintProps[t] = !0, this._serializedLayers = null) : this.fire(new l.j(new Error(`Cannot style non-existing layer "${t}".`)));
        }
        getPaintProperty(t, s) {
          return this.getLayer(t).getPaintProperty(s);
        }
        setFeatureState(t, s) {
          this._checkLoaded();
          const c = t.source, r = t.sourceLayer, a = this.sourceCaches[c];
          if (a === void 0) return void this.fire(new l.j(new Error(`The source '${c}' does not exist in the map's style.`)));
          const h = a.getSource().type;
          h === "geojson" && r ? this.fire(new l.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : h !== "vector" || r ? (t.id === void 0 && this.fire(new l.j(new Error("The feature id parameter must be provided."))), a.setFeatureState(r, t.id, s)) : this.fire(new l.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(t, s) {
          this._checkLoaded();
          const c = t.source, r = this.sourceCaches[c];
          if (r === void 0) return void this.fire(new l.j(new Error(`The source '${c}' does not exist in the map's style.`)));
          const a = r.getSource().type, h = a === "vector" ? t.sourceLayer : void 0;
          a !== "vector" || h ? s && typeof t.id != "string" && typeof t.id != "number" ? this.fire(new l.j(new Error("A feature id is required to remove its specific state property."))) : r.removeFeatureState(h, t.id, s) : this.fire(new l.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(t) {
          this._checkLoaded();
          const s = t.source, c = t.sourceLayer, r = this.sourceCaches[s];
          if (r !== void 0) return r.getSource().type !== "vector" || c ? (t.id === void 0 && this.fire(new l.j(new Error("The feature id parameter must be provided."))), r.getFeatureState(c, t.id)) : void this.fire(new l.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new l.j(new Error(`The source '${s}' does not exist in the map's style.`)));
        }
        getTransition() {
          return l.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          const t = l.aF(this.sourceCaches, (a) => a.serialize()), s = this._serializeByIds(this._order, !0), c = this.map.getTerrain() || void 0, r = this.stylesheet;
          return l.aG({ version: r.version, name: r.name, metadata: r.metadata, light: r.light, sky: r.sky, center: r.center, zoom: r.zoom, bearing: r.bearing, pitch: r.pitch, sprite: r.sprite, glyphs: r.glyphs, transition: r.transition, sources: t, layers: s, terrain: c }, (a) => a !== void 0);
        }
        _updateLayer(t) {
          this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && this.sourceCaches[t.source].getSource().type !== "raster" && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._serializedLayers = null, this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(t) {
          const s = (h) => this._layers[h].type === "fill-extrusion", c = {}, r = [];
          for (let h = this._order.length - 1; h >= 0; h--) {
            const d = this._order[h];
            if (s(d)) {
              c[d] = h;
              for (const _ of t) {
                const w = _[d];
                if (w) for (const k of w) r.push(k);
              }
            }
          }
          r.sort((h, d) => d.intersectionZ - h.intersectionZ);
          const a = [];
          for (let h = this._order.length - 1; h >= 0; h--) {
            const d = this._order[h];
            if (s(d)) for (let _ = r.length - 1; _ >= 0; _--) {
              const w = r[_].feature;
              if (c[w.layer.id] < h) break;
              a.push(w), r.pop();
            }
            else for (const _ of t) {
              const w = _[d];
              if (w) for (const k of w) a.push(k.feature);
            }
          }
          return a;
        }
        queryRenderedFeatures(t, s, c) {
          s && s.filter && this._validate(l.u.filter, "queryRenderedFeatures.filter", s.filter, null, s);
          const r = {};
          if (s && s.layers) {
            if (!Array.isArray(s.layers)) return this.fire(new l.j(new Error("parameters.layers must be an Array."))), [];
            for (const d of s.layers) {
              const _ = this._layers[d];
              if (!_) return this.fire(new l.j(new Error(`The layer '${d}' does not exist in the map's style and cannot be queried for features.`))), [];
              r[_.source] = !0;
            }
          }
          const a = [];
          s.availableImages = this._availableImages;
          const h = this._serializedAllLayers();
          for (const d in this.sourceCaches) s.layers && !r[d] || a.push(ze(this.sourceCaches[d], this._layers, h, t, s, c));
          return this.placement && a.push(function(d, _, w, k, T, C, z) {
            const R = {}, W = C.queryRenderedSymbols(k), Z = [];
            for (const G of Object.keys(W).map(Number)) Z.push(z[G]);
            Z.sort(Je);
            for (const G of Z) {
              const nt = G.featureIndex.lookupSymbolFeatures(W[G.bucketInstanceId], _, G.bucketIndex, G.sourceLayerIndex, T.filter, T.layers, T.availableImages, d);
              for (const Y in nt) {
                const J = R[Y] = R[Y] || [], tt = nt[Y];
                tt.sort((ut, St) => {
                  const It = G.featureSortOrder;
                  if (It) {
                    const Gt = It.indexOf(ut.featureIndex);
                    return It.indexOf(St.featureIndex) - Gt;
                  }
                  return St.featureIndex - ut.featureIndex;
                });
                for (const ut of tt) J.push(ut);
              }
            }
            for (const G in R) R[G].forEach((nt) => {
              const Y = nt.feature, J = w[d[G].source].getFeatureState(Y.layer["source-layer"], Y.id);
              Y.source = Y.layer.source, Y.layer["source-layer"] && (Y.sourceLayer = Y.layer["source-layer"]), Y.state = J;
            });
            return R;
          }(this._layers, h, this.sourceCaches, t, s, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a);
        }
        querySourceFeatures(t, s) {
          s && s.filter && this._validate(l.u.filter, "querySourceFeatures.filter", s.filter, null, s);
          const c = this.sourceCaches[t];
          return c ? function(r, a) {
            const h = r.getRenderableIds().map((w) => r.getTileByID(w)), d = [], _ = {};
            for (let w = 0; w < h.length; w++) {
              const k = h[w], T = k.tileID.canonical.key;
              _[T] || (_[T] = !0, k.querySourceFeatures(d, a));
            }
            return d;
          }(c, s) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(t, s = {}) {
          this._checkLoaded();
          const c = this.light.getLight();
          let r = !1;
          for (const h in t) if (!l.aE(t[h], c[h])) {
            r = !0;
            break;
          }
          if (!r) return;
          const a = { now: q.now(), transition: l.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(t, s), this.light.updateTransitions(a);
        }
        getSky() {
          var t;
          return (t = this.stylesheet) === null || t === void 0 ? void 0 : t.sky;
        }
        setSky(t, s = {}) {
          const c = this.getSky();
          let r = !1;
          if (!t && !c) return;
          if (t && !c) r = !0;
          else if (!t && c) r = !0;
          else for (const h in t) if (!l.aE(t[h], c[h])) {
            r = !0;
            break;
          }
          if (!r) return;
          const a = { now: q.now(), transition: l.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = t, this.sky.setSky(t, s), this.sky.updateTransitions(a);
        }
        _validate(t, s, c, r, a = {}) {
          return (!a || a.validate !== !1) && ma(this, t.call(l.u, l.e({ key: s, style: this.serialize(), value: c, styleSpec: l.v }, r)));
        }
        _remove(t = !0) {
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Pe().off(he, this._rtlPluginLoaded);
          for (const s in this._layers) this._layers[s].setEventedParent(null);
          for (const s in this.sourceCaches) {
            const c = this.sourceCaches[s];
            c.setEventedParent(null), c.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), t && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t);
        }
        _clearSource(t) {
          this.sourceCaches[t].clearTiles();
        }
        _reloadSource(t) {
          this.sourceCaches[t].resume(), this.sourceCaches[t].reload();
        }
        _updateSources(t) {
          for (const s in this.sourceCaches) this.sourceCaches[s].update(t, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const t in this.sourceCaches) this._reloadSource(t);
        }
        _updatePlacement(t, s, c, r, a = !1) {
          let h = !1, d = !1;
          const _ = {};
          for (const w of this._order) {
            const k = this._layers[w];
            if (k.type !== "symbol") continue;
            if (!_[k.source]) {
              const C = this.sourceCaches[k.source];
              _[k.source] = C.getRenderableIds(!0).map((z) => C.getTileByID(z)).sort((z, R) => R.tileID.overscaledZ - z.tileID.overscaledZ || (z.tileID.isLessThan(R.tileID) ? -1 : 1));
            }
            const T = this.crossTileSymbolIndex.addLayer(k, _[k.source], t.center.lng);
            h = h || T;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a = a || this._layerOrderChanged || c === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(q.now(), t.zoom)) && (this.pauseablePlacement = new dr(t, this.map.terrain, this._order, a, s, c, r, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, _), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(q.now()), d = !0), h && this.pauseablePlacement.placement.setStale()), d || h) for (const w of this._order) {
            const k = this._layers[w];
            k.type === "symbol" && this.placement.updateLayerOpacities(k, _[k.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(q.now());
        }
        _releaseSymbolFadeTiles() {
          for (const t in this.sourceCaches) this.sourceCaches[t].releaseSymbolFadeTiles();
        }
        getImages(t, s) {
          return l._(this, void 0, void 0, function* () {
            const c = yield this.imageManager.getImages(s.icons);
            this._updateTilesForChangedImages();
            const r = this.sourceCaches[s.source];
            return r && r.setDependencies(s.tileID.key, s.type, s.icons), c;
          });
        }
        getGlyphs(t, s) {
          return l._(this, void 0, void 0, function* () {
            const c = yield this.glyphManager.getGlyphs(s.stacks), r = this.sourceCaches[s.source];
            return r && r.setDependencies(s.tileID.key, s.type, [""]), c;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(t, s = {}) {
          this._checkLoaded(), t && this._validate(l.u.glyphs, "glyphs", t, null, s) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = t, this.glyphManager.entries = {}, this.glyphManager.setURL(t));
        }
        addSprite(t, s, c = {}, r) {
          this._checkLoaded();
          const a = [{ id: t, url: s }], h = [...le(this.stylesheet.sprite), ...a];
          this._validate(l.u.sprite, "sprite", h, null, c) || (this.stylesheet.sprite = h, this._loadSprite(a, !0, r));
        }
        removeSprite(t) {
          this._checkLoaded();
          const s = le(this.stylesheet.sprite);
          if (s.find((c) => c.id === t)) {
            if (this._spritesImagesIds[t]) for (const c of this._spritesImagesIds[t]) this.imageManager.removeImage(c), this._changedImages[c] = !0;
            s.splice(s.findIndex((c) => c.id === t), 1), this.stylesheet.sprite = s.length > 0 ? s : void 0, delete this._spritesImagesIds[t], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new l.k("data", { dataType: "style" }));
          } else this.fire(new l.j(new Error(`Sprite "${t}" doesn't exists on this map.`)));
        }
        getSprite() {
          return le(this.stylesheet.sprite);
        }
        setSprite(t, s = {}, c) {
          this._checkLoaded(), t && this._validate(l.u.sprite, "sprite", t, null, s) || (this.stylesheet.sprite = t, t ? this._loadSprite(t, !0, c) : (this._unloadSprite(), c && c(null)));
        }
      }
      var Lr = l.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
      const Ln = { prelude: Ei(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: Ei(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: Ei(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Ei(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Ei("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ei(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}`), heatmapTexture: Ei(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Ei("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Ei("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Ei("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: Ei(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: Ei(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: Ei(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: Ei(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Ei(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Ei(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Ei(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ei(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: Ei(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Ei(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Ei(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Ei(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Ei(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Ei(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Ei(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Ei(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Ei("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Ei("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Ei("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"), sky: Ei("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function Ei(p, t) {
        const s = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, c = t.match(/attribute ([\w]+) ([\w]+)/g), r = p.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), h = a ? a.concat(r) : r, d = {};
        return { fragmentSource: p = p.replace(s, (_, w, k, T, C) => (d[C] = !0, w === "define" ? `
#ifndef HAS_UNIFORM_u_${C}
varying ${k} ${T} ${C};
#else
uniform ${k} ${T} u_${C};
#endif
` : `
#ifdef HAS_UNIFORM_u_${C}
    ${k} ${T} ${C} = u_${C};
#endif
`)), vertexSource: t = t.replace(s, (_, w, k, T, C) => {
          const z = T === "float" ? "vec2" : "vec4", R = C.match(/color/) ? "color" : z;
          return d[C] ? w === "define" ? `
#ifndef HAS_UNIFORM_u_${C}
uniform lowp float u_${C}_t;
attribute ${k} ${z} a_${C};
varying ${k} ${T} ${C};
#else
uniform ${k} ${T} u_${C};
#endif
` : R === "vec4" ? `
#ifndef HAS_UNIFORM_u_${C}
    ${C} = a_${C};
#else
    ${k} ${T} ${C} = u_${C};
#endif
` : `
#ifndef HAS_UNIFORM_u_${C}
    ${C} = unpack_mix_${R}(a_${C}, u_${C}_t);
#else
    ${k} ${T} ${C} = u_${C};
#endif
` : w === "define" ? `
#ifndef HAS_UNIFORM_u_${C}
uniform lowp float u_${C}_t;
attribute ${k} ${z} a_${C};
#else
uniform ${k} ${T} u_${C};
#endif
` : R === "vec4" ? `
#ifndef HAS_UNIFORM_u_${C}
    ${k} ${T} ${C} = a_${C};
#else
    ${k} ${T} ${C} = u_${C};
#endif
` : `
#ifndef HAS_UNIFORM_u_${C}
    ${k} ${T} ${C} = unpack_mix_${R}(a_${C}, u_${C}_t);
#else
    ${k} ${T} ${C} = u_${C};
#endif
`;
        }), staticAttributes: c, staticUniforms: h };
      }
      class Va {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(t, s, c, r, a, h, d, _, w) {
          this.context = t;
          let k = this.boundPaintVertexBuffers.length !== r.length;
          for (let T = 0; !k && T < r.length; T++) this.boundPaintVertexBuffers[T] !== r[T] && (k = !0);
          !this.vao || this.boundProgram !== s || this.boundLayoutVertexBuffer !== c || k || this.boundIndexBuffer !== a || this.boundVertexOffset !== h || this.boundDynamicVertexBuffer !== d || this.boundDynamicVertexBuffer2 !== _ || this.boundDynamicVertexBuffer3 !== w ? this.freshBind(s, c, r, a, h, d, _, w) : (t.bindVertexArray.set(this.vao), d && d.bind(), a && a.dynamicDraw && a.bind(), _ && _.bind(), w && w.bind());
        }
        freshBind(t, s, c, r, a, h, d, _) {
          const w = t.numAttributes, k = this.context, T = k.gl;
          this.vao && this.destroy(), this.vao = k.createVertexArray(), k.bindVertexArray.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = s, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = r, this.boundVertexOffset = a, this.boundDynamicVertexBuffer = h, this.boundDynamicVertexBuffer2 = d, this.boundDynamicVertexBuffer3 = _, s.enableAttributes(T, t);
          for (const C of c) C.enableAttributes(T, t);
          h && h.enableAttributes(T, t), d && d.enableAttributes(T, t), _ && _.enableAttributes(T, t), s.bind(), s.setVertexAttribPointers(T, t, a);
          for (const C of c) C.bind(), C.setVertexAttribPointers(T, t, a);
          h && (h.bind(), h.setVertexAttribPointers(T, t, a)), r && r.bind(), d && (d.bind(), d.setVertexAttribPointers(T, t, a)), _ && (_.bind(), _.setVertexAttribPointers(T, t, a)), k.currentNumAttributes = w;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const $a = (p, t, s, c, r) => ({ u_matrix: p, u_texture: 0, u_ele_delta: t, u_fog_matrix: s, u_fog_color: c ? c.properties.get("fog-color") : l.aM.white, u_fog_ground_blend: c ? c.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: c ? c.calculateFogBlendOpacity(r) : 0, u_horizon_color: c ? c.properties.get("horizon-color") : l.aM.white, u_horizon_fog_blend: c ? c.properties.get("horizon-fog-blend") : 1 });
      function ga(p) {
        const t = [];
        for (let s = 0; s < p.length; s++) {
          if (p[s] === null) continue;
          const c = p[s].split(" ");
          t.push(c.pop());
        }
        return t;
      }
      class ya {
        constructor(t, s, c, r, a, h) {
          const d = t.gl;
          this.program = d.createProgram();
          const _ = ga(s.staticAttributes), w = c ? c.getBinderAttributes() : [], k = _.concat(w), T = Ln.prelude.staticUniforms ? ga(Ln.prelude.staticUniforms) : [], C = s.staticUniforms ? ga(s.staticUniforms) : [], z = c ? c.getBinderUniforms() : [], R = T.concat(C).concat(z), W = [];
          for (const ut of R) W.indexOf(ut) < 0 && W.push(ut);
          const Z = c ? c.defines() : [];
          a && Z.push("#define OVERDRAW_INSPECTOR;"), h && Z.push("#define TERRAIN3D;");
          const G = Z.concat(Ln.prelude.fragmentSource, s.fragmentSource).join(`
`), nt = Z.concat(Ln.prelude.vertexSource, s.vertexSource).join(`
`), Y = d.createShader(d.FRAGMENT_SHADER);
          if (d.isContextLost()) return void (this.failedToCreate = !0);
          if (d.shaderSource(Y, G), d.compileShader(Y), !d.getShaderParameter(Y, d.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${d.getShaderInfoLog(Y)}`);
          d.attachShader(this.program, Y);
          const J = d.createShader(d.VERTEX_SHADER);
          if (d.isContextLost()) return void (this.failedToCreate = !0);
          if (d.shaderSource(J, nt), d.compileShader(J), !d.getShaderParameter(J, d.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${d.getShaderInfoLog(J)}`);
          d.attachShader(this.program, J), this.attributes = {};
          const tt = {};
          this.numAttributes = k.length;
          for (let ut = 0; ut < this.numAttributes; ut++) k[ut] && (d.bindAttribLocation(this.program, ut, k[ut]), this.attributes[k[ut]] = ut);
          if (d.linkProgram(this.program), !d.getProgramParameter(this.program, d.LINK_STATUS)) throw new Error(`Program failed to link: ${d.getProgramInfoLog(this.program)}`);
          d.deleteShader(J), d.deleteShader(Y);
          for (let ut = 0; ut < W.length; ut++) {
            const St = W[ut];
            if (St && !tt[St]) {
              const It = d.getUniformLocation(this.program, St);
              It && (tt[St] = It);
            }
          }
          this.fixedUniforms = r(t, tt), this.terrainUniforms = ((ut, St) => ({ u_depth: new l.aH(ut, St.u_depth), u_terrain: new l.aH(ut, St.u_terrain), u_terrain_dim: new l.aI(ut, St.u_terrain_dim), u_terrain_matrix: new l.aJ(ut, St.u_terrain_matrix), u_terrain_unpack: new l.aK(ut, St.u_terrain_unpack), u_terrain_exaggeration: new l.aI(ut, St.u_terrain_exaggeration) }))(t, tt), this.binderUniforms = c ? c.getUniforms(t, tt) : [];
        }
        draw(t, s, c, r, a, h, d, _, w, k, T, C, z, R, W, Z, G, nt) {
          const Y = t.gl;
          if (this.failedToCreate) return;
          if (t.program.set(this.program), t.setDepthMode(c), t.setStencilMode(r), t.setColorMode(a), t.setCullFace(h), _) {
            t.activeTexture.set(Y.TEXTURE2), Y.bindTexture(Y.TEXTURE_2D, _.depthTexture), t.activeTexture.set(Y.TEXTURE3), Y.bindTexture(Y.TEXTURE_2D, _.texture);
            for (const tt in this.terrainUniforms) this.terrainUniforms[tt].set(_[tt]);
          }
          for (const tt in this.fixedUniforms) this.fixedUniforms[tt].set(d[tt]);
          W && W.setUniforms(t, this.binderUniforms, z, { zoom: R });
          let J = 0;
          switch (s) {
            case Y.LINES:
              J = 2;
              break;
            case Y.TRIANGLES:
              J = 3;
              break;
            case Y.LINE_STRIP:
              J = 1;
          }
          for (const tt of C.get()) {
            const ut = tt.vaos || (tt.vaos = {});
            (ut[w] || (ut[w] = new Va())).bind(t, this, k, W ? W.getPaintVertexBuffers() : [], T, tt.vertexOffset, Z, G, nt), Y.drawElements(s, tt.primitiveLength * J, Y.UNSIGNED_SHORT, tt.primitiveOffset * J * 2);
          }
        }
      }
      function Za(p, t, s) {
        const c = 1 / He(s, 1, t.transform.tileZoom), r = Math.pow(2, s.tileID.overscaledZ), a = s.tileSize * Math.pow(2, t.transform.tileZoom) / r, h = a * (s.tileID.canonical.x + s.tileID.wrap * r), d = a * s.tileID.canonical.y;
        return { u_image: 0, u_texsize: s.imageAtlasTexture.size, u_scale: [c, p.fromScale, p.toScale], u_fade: p.t, u_pixel_coord_upper: [h >> 16, d >> 16], u_pixel_coord_lower: [65535 & h, 65535 & d] };
      }
      const Ws = (p, t, s, c) => {
        const r = t.style.light, a = r.properties.get("position"), h = [a.x, a.y, a.z], d = function() {
          var w = new l.A(9);
          return l.A != Float32Array && (w[1] = 0, w[2] = 0, w[3] = 0, w[5] = 0, w[6] = 0, w[7] = 0), w[0] = 1, w[4] = 1, w[8] = 1, w;
        }();
        r.properties.get("anchor") === "viewport" && function(w, k) {
          var T = Math.sin(k), C = Math.cos(k);
          w[0] = C, w[1] = T, w[2] = 0, w[3] = -T, w[4] = C, w[5] = 0, w[6] = 0, w[7] = 0, w[8] = 1;
        }(d, -t.transform.angle), function(w, k, T) {
          var C = k[0], z = k[1], R = k[2];
          w[0] = C * T[0] + z * T[3] + R * T[6], w[1] = C * T[1] + z * T[4] + R * T[7], w[2] = C * T[2] + z * T[5] + R * T[8];
        }(h, h, d);
        const _ = r.properties.get("color");
        return { u_matrix: p, u_lightpos: h, u_lightintensity: r.properties.get("intensity"), u_lightcolor: [_.r, _.g, _.b], u_vertical_gradient: +s, u_opacity: c };
      }, Ga = (p, t, s, c, r, a, h) => l.e(Ws(p, t, s, c), Za(a, t, h), { u_height_factor: -Math.pow(2, r.overscaledZ) / h.tileSize / 8 }), _a = (p) => ({ u_matrix: p }), Hs = (p, t, s, c) => l.e(_a(p), Za(s, t, c)), Ts = (p, t) => ({ u_matrix: p, u_world: t }), Wa = (p, t, s, c, r) => l.e(Hs(p, t, s, c), { u_world: r }), va = (p, t, s, c) => {
        const r = p.transform;
        let a, h;
        if (c.paint.get("circle-pitch-alignment") === "map") {
          const d = He(s, 1, r.zoom);
          a = !0, h = [d, d];
        } else a = !1, h = r.pixelsToGLUnits;
        return { u_camera_to_center_distance: r.cameraToCenterDistance, u_scale_with_map: +(c.paint.get("circle-pitch-scale") === "map"), u_matrix: p.translatePosMatrix(t.posMatrix, s, c.paint.get("circle-translate"), c.paint.get("circle-translate-anchor")), u_pitch_with_map: +a, u_device_pixel_ratio: p.pixelRatio, u_extrude_scale: h };
      }, sl = (p, t, s) => ({ u_matrix: p, u_inv_matrix: t, u_camera_to_center_distance: s.cameraToCenterDistance, u_viewport_size: [s.width, s.height] }), cr = (p, t, s = 1) => ({ u_matrix: p, u_color: t, u_overlay: 0, u_overlay_scale: s }), xa = (p) => ({ u_matrix: p }), Zr = (p, t, s, c) => ({ u_matrix: p, u_extrude_scale: He(t, 1, s), u_intensity: c });
      function Ye(p, t) {
        const s = Math.pow(2, t.canonical.z), c = t.canonical.y;
        return [new l.Z(0, c / s).toLngLat().lat, new l.Z(0, (c + 1) / s).toLngLat().lat];
      }
      const ba = (p, t, s, c) => {
        const r = p.transform;
        return { u_matrix: wa(p, t, s, c), u_ratio: 1 / He(t, 1, r.zoom), u_device_pixel_ratio: p.pixelRatio, u_units_to_pixels: [1 / r.pixelsToGLUnits[0], 1 / r.pixelsToGLUnits[1]] };
      }, Ha = (p, t, s, c, r) => l.e(ba(p, t, s, r), { u_image: 0, u_image_height: c }), Zn = (p, t, s, c, r) => {
        const a = p.transform, h = cs(t, a);
        return { u_matrix: wa(p, t, s, r), u_texsize: t.imageAtlasTexture.size, u_ratio: 1 / He(t, 1, a.zoom), u_device_pixel_ratio: p.pixelRatio, u_image: 0, u_scale: [h, c.fromScale, c.toScale], u_fade: c.t, u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]] };
      }, No = (p, t, s, c, r, a) => {
        const h = p.lineAtlas, d = cs(t, p.transform), _ = s.layout.get("line-cap") === "round", w = h.getDash(c.from, _), k = h.getDash(c.to, _), T = w.width * r.fromScale, C = k.width * r.toScale;
        return l.e(ba(p, t, s, a), { u_patternscale_a: [d / T, -w.height / 2], u_patternscale_b: [d / C, -k.height / 2], u_sdfgamma: h.width / (256 * Math.min(T, C) * p.pixelRatio) / 2, u_image: 0, u_tex_y_a: w.y, u_tex_y_b: k.y, u_mix: r.t });
      };
      function cs(p, t) {
        return 1 / He(p, 1, t.tileZoom);
      }
      function wa(p, t, s, c) {
        return p.translatePosMatrix(c ? c.posMatrix : t.tileID.posMatrix, t, s.paint.get("line-translate"), s.paint.get("line-translate-anchor"));
      }
      const Fo = (p, t, s, c, r) => {
        return { u_matrix: p, u_tl_parent: t, u_scale_parent: s, u_buffer_scale: 1, u_fade_t: c.mix, u_opacity: c.opacity * r.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r.paint.get("raster-brightness-min"), u_brightness_high: r.paint.get("raster-brightness-max"), u_saturation_factor: (h = r.paint.get("raster-saturation"), h > 0 ? 1 - 1 / (1.001 - h) : -h), u_contrast_factor: (a = r.paint.get("raster-contrast"), a > 0 ? 1 / (1 - a) : 1 + a), u_spin_weights: Il(r.paint.get("raster-hue-rotate")) };
        var a, h;
      };
      function Il(p) {
        p *= Math.PI / 180;
        const t = Math.sin(p), s = Math.cos(p);
        return [(2 * s + 1) / 3, (-Math.sqrt(3) * t - s + 1) / 3, (Math.sqrt(3) * t - s + 1) / 3];
      }
      const al = (p, t, s, c, r, a, h, d, _, w, k, T, C, z) => {
        const R = h.transform;
        return { u_is_size_zoom_constant: +(p === "constant" || p === "source"), u_is_size_feature_constant: +(p === "constant" || p === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: R.cameraToCenterDistance, u_pitch: R.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +s, u_aspect_ratio: R.width / R.height, u_fade_change: h.options.fadeDuration ? h.symbolFadeChange : 1, u_matrix: d, u_label_plane_matrix: _, u_coord_matrix: w, u_is_text: +T, u_pitch_with_map: +c, u_is_along_line: r, u_is_variable_anchor: a, u_texsize: C, u_texture: 0, u_translation: k, u_pitched_scale: z };
      }, ol = (p, t, s, c, r, a, h, d, _, w, k, T, C, z, R) => {
        const W = h.transform;
        return l.e(al(p, t, s, c, r, a, h, d, _, w, k, T, C, R), { u_gamma_scale: c ? Math.cos(W._pitch) * W.cameraToCenterDistance : 1, u_device_pixel_ratio: h.pixelRatio, u_is_halo: +z });
      }, Ro = (p, t, s, c, r, a, h, d, _, w, k, T, C, z) => l.e(ol(p, t, s, c, r, a, h, d, _, w, k, !0, T, !0, z), { u_texsize_icon: C, u_texture_icon: 1 }), hs = (p, t, s) => ({ u_matrix: p, u_opacity: t, u_color: s }), us = (p, t, s, c, r, a) => l.e(function(h, d, _, w) {
        const k = _.imageManager.getPattern(h.from.toString()), T = _.imageManager.getPattern(h.to.toString()), { width: C, height: z } = _.imageManager.getPixelSize(), R = Math.pow(2, w.tileID.overscaledZ), W = w.tileSize * Math.pow(2, _.transform.tileZoom) / R, Z = W * (w.tileID.canonical.x + w.tileID.wrap * R), G = W * w.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: k.tl, u_pattern_br_a: k.br, u_pattern_tl_b: T.tl, u_pattern_br_b: T.br, u_texsize: [C, z], u_mix: d.t, u_pattern_size_a: k.displaySize, u_pattern_size_b: T.displaySize, u_scale_a: d.fromScale, u_scale_b: d.toScale, u_tile_units_to_pixels: 1 / He(w, 1, _.transform.tileZoom), u_pixel_coord_upper: [Z >> 16, G >> 16], u_pixel_coord_lower: [65535 & Z, 65535 & G] };
      }(c, a, s, r), { u_matrix: p, u_opacity: t }), Xa = { fillExtrusion: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_lightpos: new l.aN(p, t.u_lightpos), u_lightintensity: new l.aI(p, t.u_lightintensity), u_lightcolor: new l.aN(p, t.u_lightcolor), u_vertical_gradient: new l.aI(p, t.u_vertical_gradient), u_opacity: new l.aI(p, t.u_opacity) }), fillExtrusionPattern: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_lightpos: new l.aN(p, t.u_lightpos), u_lightintensity: new l.aI(p, t.u_lightintensity), u_lightcolor: new l.aN(p, t.u_lightcolor), u_vertical_gradient: new l.aI(p, t.u_vertical_gradient), u_height_factor: new l.aI(p, t.u_height_factor), u_image: new l.aH(p, t.u_image), u_texsize: new l.aO(p, t.u_texsize), u_pixel_coord_upper: new l.aO(p, t.u_pixel_coord_upper), u_pixel_coord_lower: new l.aO(p, t.u_pixel_coord_lower), u_scale: new l.aN(p, t.u_scale), u_fade: new l.aI(p, t.u_fade), u_opacity: new l.aI(p, t.u_opacity) }), fill: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix) }), fillPattern: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_image: new l.aH(p, t.u_image), u_texsize: new l.aO(p, t.u_texsize), u_pixel_coord_upper: new l.aO(p, t.u_pixel_coord_upper), u_pixel_coord_lower: new l.aO(p, t.u_pixel_coord_lower), u_scale: new l.aN(p, t.u_scale), u_fade: new l.aI(p, t.u_fade) }), fillOutline: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_world: new l.aO(p, t.u_world) }), fillOutlinePattern: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_world: new l.aO(p, t.u_world), u_image: new l.aH(p, t.u_image), u_texsize: new l.aO(p, t.u_texsize), u_pixel_coord_upper: new l.aO(p, t.u_pixel_coord_upper), u_pixel_coord_lower: new l.aO(p, t.u_pixel_coord_lower), u_scale: new l.aN(p, t.u_scale), u_fade: new l.aI(p, t.u_fade) }), circle: (p, t) => ({ u_camera_to_center_distance: new l.aI(p, t.u_camera_to_center_distance), u_scale_with_map: new l.aH(p, t.u_scale_with_map), u_pitch_with_map: new l.aH(p, t.u_pitch_with_map), u_extrude_scale: new l.aO(p, t.u_extrude_scale), u_device_pixel_ratio: new l.aI(p, t.u_device_pixel_ratio), u_matrix: new l.aJ(p, t.u_matrix) }), collisionBox: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_pixel_extrude_scale: new l.aO(p, t.u_pixel_extrude_scale) }), collisionCircle: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_inv_matrix: new l.aJ(p, t.u_inv_matrix), u_camera_to_center_distance: new l.aI(p, t.u_camera_to_center_distance), u_viewport_size: new l.aO(p, t.u_viewport_size) }), debug: (p, t) => ({ u_color: new l.aL(p, t.u_color), u_matrix: new l.aJ(p, t.u_matrix), u_overlay: new l.aH(p, t.u_overlay), u_overlay_scale: new l.aI(p, t.u_overlay_scale) }), clippingMask: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix) }), heatmap: (p, t) => ({ u_extrude_scale: new l.aI(p, t.u_extrude_scale), u_intensity: new l.aI(p, t.u_intensity), u_matrix: new l.aJ(p, t.u_matrix) }), heatmapTexture: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_world: new l.aO(p, t.u_world), u_image: new l.aH(p, t.u_image), u_color_ramp: new l.aH(p, t.u_color_ramp), u_opacity: new l.aI(p, t.u_opacity) }), hillshade: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_image: new l.aH(p, t.u_image), u_latrange: new l.aO(p, t.u_latrange), u_light: new l.aO(p, t.u_light), u_shadow: new l.aL(p, t.u_shadow), u_highlight: new l.aL(p, t.u_highlight), u_accent: new l.aL(p, t.u_accent) }), hillshadePrepare: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_image: new l.aH(p, t.u_image), u_dimension: new l.aO(p, t.u_dimension), u_zoom: new l.aI(p, t.u_zoom), u_unpack: new l.aK(p, t.u_unpack) }), line: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_ratio: new l.aI(p, t.u_ratio), u_device_pixel_ratio: new l.aI(p, t.u_device_pixel_ratio), u_units_to_pixels: new l.aO(p, t.u_units_to_pixels) }), lineGradient: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_ratio: new l.aI(p, t.u_ratio), u_device_pixel_ratio: new l.aI(p, t.u_device_pixel_ratio), u_units_to_pixels: new l.aO(p, t.u_units_to_pixels), u_image: new l.aH(p, t.u_image), u_image_height: new l.aI(p, t.u_image_height) }), linePattern: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_texsize: new l.aO(p, t.u_texsize), u_ratio: new l.aI(p, t.u_ratio), u_device_pixel_ratio: new l.aI(p, t.u_device_pixel_ratio), u_image: new l.aH(p, t.u_image), u_units_to_pixels: new l.aO(p, t.u_units_to_pixels), u_scale: new l.aN(p, t.u_scale), u_fade: new l.aI(p, t.u_fade) }), lineSDF: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_ratio: new l.aI(p, t.u_ratio), u_device_pixel_ratio: new l.aI(p, t.u_device_pixel_ratio), u_units_to_pixels: new l.aO(p, t.u_units_to_pixels), u_patternscale_a: new l.aO(p, t.u_patternscale_a), u_patternscale_b: new l.aO(p, t.u_patternscale_b), u_sdfgamma: new l.aI(p, t.u_sdfgamma), u_image: new l.aH(p, t.u_image), u_tex_y_a: new l.aI(p, t.u_tex_y_a), u_tex_y_b: new l.aI(p, t.u_tex_y_b), u_mix: new l.aI(p, t.u_mix) }), raster: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_tl_parent: new l.aO(p, t.u_tl_parent), u_scale_parent: new l.aI(p, t.u_scale_parent), u_buffer_scale: new l.aI(p, t.u_buffer_scale), u_fade_t: new l.aI(p, t.u_fade_t), u_opacity: new l.aI(p, t.u_opacity), u_image0: new l.aH(p, t.u_image0), u_image1: new l.aH(p, t.u_image1), u_brightness_low: new l.aI(p, t.u_brightness_low), u_brightness_high: new l.aI(p, t.u_brightness_high), u_saturation_factor: new l.aI(p, t.u_saturation_factor), u_contrast_factor: new l.aI(p, t.u_contrast_factor), u_spin_weights: new l.aN(p, t.u_spin_weights) }), symbolIcon: (p, t) => ({ u_is_size_zoom_constant: new l.aH(p, t.u_is_size_zoom_constant), u_is_size_feature_constant: new l.aH(p, t.u_is_size_feature_constant), u_size_t: new l.aI(p, t.u_size_t), u_size: new l.aI(p, t.u_size), u_camera_to_center_distance: new l.aI(p, t.u_camera_to_center_distance), u_pitch: new l.aI(p, t.u_pitch), u_rotate_symbol: new l.aH(p, t.u_rotate_symbol), u_aspect_ratio: new l.aI(p, t.u_aspect_ratio), u_fade_change: new l.aI(p, t.u_fade_change), u_matrix: new l.aJ(p, t.u_matrix), u_label_plane_matrix: new l.aJ(p, t.u_label_plane_matrix), u_coord_matrix: new l.aJ(p, t.u_coord_matrix), u_is_text: new l.aH(p, t.u_is_text), u_pitch_with_map: new l.aH(p, t.u_pitch_with_map), u_is_along_line: new l.aH(p, t.u_is_along_line), u_is_variable_anchor: new l.aH(p, t.u_is_variable_anchor), u_texsize: new l.aO(p, t.u_texsize), u_texture: new l.aH(p, t.u_texture), u_translation: new l.aO(p, t.u_translation), u_pitched_scale: new l.aI(p, t.u_pitched_scale) }), symbolSDF: (p, t) => ({ u_is_size_zoom_constant: new l.aH(p, t.u_is_size_zoom_constant), u_is_size_feature_constant: new l.aH(p, t.u_is_size_feature_constant), u_size_t: new l.aI(p, t.u_size_t), u_size: new l.aI(p, t.u_size), u_camera_to_center_distance: new l.aI(p, t.u_camera_to_center_distance), u_pitch: new l.aI(p, t.u_pitch), u_rotate_symbol: new l.aH(p, t.u_rotate_symbol), u_aspect_ratio: new l.aI(p, t.u_aspect_ratio), u_fade_change: new l.aI(p, t.u_fade_change), u_matrix: new l.aJ(p, t.u_matrix), u_label_plane_matrix: new l.aJ(p, t.u_label_plane_matrix), u_coord_matrix: new l.aJ(p, t.u_coord_matrix), u_is_text: new l.aH(p, t.u_is_text), u_pitch_with_map: new l.aH(p, t.u_pitch_with_map), u_is_along_line: new l.aH(p, t.u_is_along_line), u_is_variable_anchor: new l.aH(p, t.u_is_variable_anchor), u_texsize: new l.aO(p, t.u_texsize), u_texture: new l.aH(p, t.u_texture), u_gamma_scale: new l.aI(p, t.u_gamma_scale), u_device_pixel_ratio: new l.aI(p, t.u_device_pixel_ratio), u_is_halo: new l.aH(p, t.u_is_halo), u_translation: new l.aO(p, t.u_translation), u_pitched_scale: new l.aI(p, t.u_pitched_scale) }), symbolTextAndIcon: (p, t) => ({ u_is_size_zoom_constant: new l.aH(p, t.u_is_size_zoom_constant), u_is_size_feature_constant: new l.aH(p, t.u_is_size_feature_constant), u_size_t: new l.aI(p, t.u_size_t), u_size: new l.aI(p, t.u_size), u_camera_to_center_distance: new l.aI(p, t.u_camera_to_center_distance), u_pitch: new l.aI(p, t.u_pitch), u_rotate_symbol: new l.aH(p, t.u_rotate_symbol), u_aspect_ratio: new l.aI(p, t.u_aspect_ratio), u_fade_change: new l.aI(p, t.u_fade_change), u_matrix: new l.aJ(p, t.u_matrix), u_label_plane_matrix: new l.aJ(p, t.u_label_plane_matrix), u_coord_matrix: new l.aJ(p, t.u_coord_matrix), u_is_text: new l.aH(p, t.u_is_text), u_pitch_with_map: new l.aH(p, t.u_pitch_with_map), u_is_along_line: new l.aH(p, t.u_is_along_line), u_is_variable_anchor: new l.aH(p, t.u_is_variable_anchor), u_texsize: new l.aO(p, t.u_texsize), u_texsize_icon: new l.aO(p, t.u_texsize_icon), u_texture: new l.aH(p, t.u_texture), u_texture_icon: new l.aH(p, t.u_texture_icon), u_gamma_scale: new l.aI(p, t.u_gamma_scale), u_device_pixel_ratio: new l.aI(p, t.u_device_pixel_ratio), u_is_halo: new l.aH(p, t.u_is_halo), u_translation: new l.aO(p, t.u_translation), u_pitched_scale: new l.aI(p, t.u_pitched_scale) }), background: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_opacity: new l.aI(p, t.u_opacity), u_color: new l.aL(p, t.u_color) }), backgroundPattern: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_opacity: new l.aI(p, t.u_opacity), u_image: new l.aH(p, t.u_image), u_pattern_tl_a: new l.aO(p, t.u_pattern_tl_a), u_pattern_br_a: new l.aO(p, t.u_pattern_br_a), u_pattern_tl_b: new l.aO(p, t.u_pattern_tl_b), u_pattern_br_b: new l.aO(p, t.u_pattern_br_b), u_texsize: new l.aO(p, t.u_texsize), u_mix: new l.aI(p, t.u_mix), u_pattern_size_a: new l.aO(p, t.u_pattern_size_a), u_pattern_size_b: new l.aO(p, t.u_pattern_size_b), u_scale_a: new l.aI(p, t.u_scale_a), u_scale_b: new l.aI(p, t.u_scale_b), u_pixel_coord_upper: new l.aO(p, t.u_pixel_coord_upper), u_pixel_coord_lower: new l.aO(p, t.u_pixel_coord_lower), u_tile_units_to_pixels: new l.aI(p, t.u_tile_units_to_pixels) }), terrain: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_texture: new l.aH(p, t.u_texture), u_ele_delta: new l.aI(p, t.u_ele_delta), u_fog_matrix: new l.aJ(p, t.u_fog_matrix), u_fog_color: new l.aL(p, t.u_fog_color), u_fog_ground_blend: new l.aI(p, t.u_fog_ground_blend), u_fog_ground_blend_opacity: new l.aI(p, t.u_fog_ground_blend_opacity), u_horizon_color: new l.aL(p, t.u_horizon_color), u_horizon_fog_blend: new l.aI(p, t.u_horizon_fog_blend) }), terrainDepth: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_ele_delta: new l.aI(p, t.u_ele_delta) }), terrainCoords: (p, t) => ({ u_matrix: new l.aJ(p, t.u_matrix), u_texture: new l.aH(p, t.u_texture), u_terrain_coords_id: new l.aI(p, t.u_terrain_coords_id), u_ele_delta: new l.aI(p, t.u_ele_delta) }), sky: (p, t) => ({ u_sky_color: new l.aL(p, t.u_sky_color), u_horizon_color: new l.aL(p, t.u_horizon_color), u_horizon: new l.aI(p, t.u_horizon), u_sky_horizon_blend: new l.aI(p, t.u_sky_horizon_blend) }) };
      class Ls {
        constructor(t, s, c) {
          this.context = t;
          const r = t.gl;
          this.buffer = r.createBuffer(), this.dynamicDraw = !!c, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), r.bufferData(r.ELEMENT_ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || delete s.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t) {
          const s = this.context.gl;
          if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), s.bufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Sa = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class rn {
        constructor(t, s, c, r) {
          this.length = s.length, this.attributes = c, this.itemSize = s.bytesPerElement, this.dynamicDraw = r, this.context = t;
          const a = t.gl;
          this.buffer = a.createBuffer(), t.bindVertexBuffer.set(this.buffer), a.bufferData(a.ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? a.DYNAMIC_DRAW : a.STATIC_DRAW), this.dynamicDraw || delete s.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(t) {
          if (t.length !== this.length) throw new Error(`Length of new data is ${t.length}, which doesn't match current length of ${this.length}`);
          const s = this.context.gl;
          this.bind(), s.bufferSubData(s.ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        enableAttributes(t, s) {
          for (let c = 0; c < this.attributes.length; c++) {
            const r = s.attributes[this.attributes[c].name];
            r !== void 0 && t.enableVertexAttribArray(r);
          }
        }
        setVertexAttribPointers(t, s, c) {
          for (let r = 0; r < this.attributes.length; r++) {
            const a = this.attributes[r], h = s.attributes[a.name];
            h !== void 0 && t.vertexAttribPointer(h, a.components, t[Sa[a.type]], !1, this.itemSize, a.offset + this.itemSize * (c || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Ya = /* @__PURE__ */ new WeakMap();
      function Cs(p) {
        var t;
        if (Ya.has(p)) return Ya.get(p);
        {
          const s = (t = p.getParameter(p.VERSION)) === null || t === void 0 ? void 0 : t.startsWith("WebGL 2.0");
          return Ya.set(p, s), s;
        }
      }
      class Si {
        constructor(t) {
          this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(t) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class Xs extends Si {
        getDefault() {
          return l.aM.transparent;
        }
        set(t) {
          const s = this.current;
          (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
        }
      }
      class Es extends Si {
        getDefault() {
          return 1;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);
        }
      }
      class Gn extends Si {
        getDefault() {
          return 0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);
        }
      }
      class kl extends Si {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class xn extends Si {
        getDefault() {
          return !0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);
        }
      }
      class Wn extends Si {
        getDefault() {
          return 255;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);
        }
      }
      class Ja extends Si {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(t) {
          const s = this.current;
          (t.func !== s.func || t.ref !== s.ref || t.mask !== s.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);
        }
      }
      class Aa extends Si {
        getDefault() {
          const t = this.gl;
          return [t.KEEP, t.KEEP, t.KEEP];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);
        }
      }
      class ll extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          t ? s.enable(s.STENCIL_TEST) : s.disable(s.STENCIL_TEST), this.current = t, this.dirty = !1;
        }
      }
      class Ys extends Si {
        getDefault() {
          return [0, 1];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);
        }
      }
      class cl extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          t ? s.enable(s.DEPTH_TEST) : s.disable(s.DEPTH_TEST), this.current = t, this.dirty = !1;
        }
      }
      class Ka extends Si {
        getDefault() {
          return this.gl.LESS;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);
        }
      }
      class Qa extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          t ? s.enable(s.BLEND) : s.disable(s.BLEND), this.current = t, this.dirty = !1;
        }
      }
      class Bo extends Si {
        getDefault() {
          const t = this.gl;
          return [t.ONE, t.ZERO];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1);
        }
      }
      class Cn extends Si {
        getDefault() {
          return l.aM.transparent;
        }
        set(t) {
          const s = this.current;
          (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
        }
      }
      class to extends Si {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1);
        }
      }
      class Oo extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          t ? s.enable(s.CULL_FACE) : s.disable(s.CULL_FACE), this.current = t, this.dirty = !1;
        }
      }
      class jo extends Si {
        getDefault() {
          return this.gl.BACK;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);
        }
      }
      class Pa extends Si {
        getDefault() {
          return this.gl.CCW;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);
        }
      }
      class eo extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1);
        }
      }
      class ds extends Si {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);
        }
      }
      class qo extends Si {
        getDefault() {
          const t = this.gl;
          return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class Js extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          s.bindFramebuffer(s.FRAMEBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class io extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          s.bindRenderbuffer(s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class L extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          s.bindTexture(s.TEXTURE_2D, t), this.current = t, this.dirty = !1;
        }
      }
      class X extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          s.bindBuffer(s.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class ft extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          const s = this.gl;
          s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class Lt extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          var s;
          if (t === this.current && !this.dirty) return;
          const c = this.gl;
          Cs(c) ? c.bindVertexArray(t) : (s = c.getExtension("OES_vertex_array_object")) === null || s === void 0 || s.bindVertexArrayOES(t), this.current = t, this.dirty = !1;
        }
      }
      class Ft extends Si {
        getDefault() {
          return 4;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          s.pixelStorei(s.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;
        }
      }
      class Kt extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;
        }
      }
      class _e extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;
        }
      }
      class Re extends Si {
        constructor(t, s) {
          super(t), this.context = t, this.parent = s;
        }
        getDefault() {
          return null;
        }
      }
      class Qe extends Re {
        setDirty() {
          this.dirty = !0;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const s = this.gl;
          s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
        }
      }
      class gi extends Re {
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const s = this.gl;
          s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class vi extends Re {
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const s = this.gl;
          s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class bi {
        constructor(t, s, c, r, a) {
          this.context = t, this.width = s, this.height = c;
          const h = t.gl, d = this.framebuffer = h.createFramebuffer();
          if (this.colorAttachment = new Qe(t, d), r) this.depthAttachment = a ? new vi(t, d) : new gi(t, d);
          else if (a) throw new Error("Stencil cannot be set without depth");
          if (h.checkFramebufferStatus(h.FRAMEBUFFER) !== h.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const t = this.context.gl, s = this.colorAttachment.get();
          if (s && t.deleteTexture(s), this.depthAttachment) {
            const c = this.depthAttachment.get();
            c && t.deleteRenderbuffer(c);
          }
          t.deleteFramebuffer(this.framebuffer);
        }
      }
      class di {
        constructor(t, s, c) {
          this.blendFunction = t, this.blendColor = s, this.mask = c;
        }
      }
      di.Replace = [1, 0], di.disabled = new di(di.Replace, l.aM.transparent, [!1, !1, !1, !1]), di.unblended = new di(di.Replace, l.aM.transparent, [!0, !0, !0, !0]), di.alphaBlended = new di([1, 771], l.aM.transparent, [!0, !0, !0, !0]);
      class mr {
        constructor(t) {
          var s, c;
          if (this.gl = t, this.clearColor = new Xs(this), this.clearDepth = new Es(this), this.clearStencil = new Gn(this), this.colorMask = new kl(this), this.depthMask = new xn(this), this.stencilMask = new Wn(this), this.stencilFunc = new Ja(this), this.stencilOp = new Aa(this), this.stencilTest = new ll(this), this.depthRange = new Ys(this), this.depthTest = new cl(this), this.depthFunc = new Ka(this), this.blend = new Qa(this), this.blendFunc = new Bo(this), this.blendColor = new Cn(this), this.blendEquation = new to(this), this.cullFace = new Oo(this), this.cullFaceSide = new jo(this), this.frontFace = new Pa(this), this.program = new eo(this), this.activeTexture = new ds(this), this.viewport = new qo(this), this.bindFramebuffer = new Js(this), this.bindRenderbuffer = new io(this), this.bindTexture = new L(this), this.bindVertexBuffer = new X(this), this.bindElementBuffer = new ft(this), this.bindVertexArray = new Lt(this), this.pixelStoreUnpack = new Ft(this), this.pixelStoreUnpackPremultiplyAlpha = new Kt(this), this.pixelStoreUnpackFlipY = new _e(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), Cs(t)) {
            this.HALF_FLOAT = t.HALF_FLOAT;
            const r = t.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (s = t.RGBA16F) !== null && s !== void 0 ? s : r == null ? void 0 : r.RGBA16F_EXT, this.RGB16F = (c = t.RGB16F) !== null && c !== void 0 ? c : r == null ? void 0 : r.RGB16F_EXT, t.getExtension("EXT_color_buffer_float");
          } else {
            t.getExtension("EXT_color_buffer_half_float"), t.getExtension("OES_texture_half_float_linear");
            const r = t.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = r == null ? void 0 : r.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(t, s) {
          return new Ls(this, t, s);
        }
        createVertexBuffer(t, s, c) {
          return new rn(this, t, s, c);
        }
        createRenderbuffer(t, s, c) {
          const r = this.gl, a = r.createRenderbuffer();
          return this.bindRenderbuffer.set(a), r.renderbufferStorage(r.RENDERBUFFER, t, s, c), this.bindRenderbuffer.set(null), a;
        }
        createFramebuffer(t, s, c, r) {
          return new bi(this, t, s, c, r);
        }
        clear({ color: t, depth: s, stencil: c }) {
          const r = this.gl;
          let a = 0;
          t && (a |= r.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set([!0, !0, !0, !0])), s !== void 0 && (a |= r.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(s), this.depthMask.set(!0)), c !== void 0 && (a |= r.STENCIL_BUFFER_BIT, this.clearStencil.set(c), this.stencilMask.set(255)), r.clear(a);
        }
        setCullFace(t) {
          t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
        }
        setDepthMode(t) {
          t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);
        }
        setStencilMode(t) {
          t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(t) {
          l.aE(t.blendFunction, di.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask);
        }
        createVertexArray() {
          var t;
          return Cs(this.gl) ? this.gl.createVertexArray() : (t = this.gl.getExtension("OES_vertex_array_object")) === null || t === void 0 ? void 0 : t.createVertexArrayOES();
        }
        deleteVertexArray(t) {
          var s;
          return Cs(this.gl) ? this.gl.deleteVertexArray(t) : (s = this.gl.getExtension("OES_vertex_array_object")) === null || s === void 0 ? void 0 : s.deleteVertexArrayOES(t);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      class Xe {
        constructor(t, s, c) {
          this.func = t, this.mask = s, this.range = c;
        }
      }
      Xe.ReadOnly = !1, Xe.ReadWrite = !0, Xe.disabled = new Xe(519, Xe.ReadOnly, [0, 1]);
      const Cr = 7680;
      class xi {
        constructor(t, s, c, r, a, h) {
          this.test = t, this.ref = s, this.mask = c, this.fail = r, this.depthFail = a, this.pass = h;
        }
      }
      xi.disabled = new xi({ func: 519, mask: 0 }, 0, 0, Cr, Cr, Cr);
      class Li {
        constructor(t, s, c) {
          this.enable = t, this.mode = s, this.frontFace = c;
        }
      }
      let nn;
      function Hn(p, t, s, c, r) {
        const a = p.context, h = a.gl, d = p.useProgram("collisionBox"), _ = [];
        let w = 0, k = 0;
        for (let G = 0; G < c.length; G++) {
          const nt = c[G], Y = t.getTile(nt).getBucket(s);
          if (!Y) continue;
          const J = r ? Y.textCollisionBox : Y.iconCollisionBox, tt = Y.collisionCircleArray;
          if (tt.length > 0) {
            const ut = l.H();
            l.aQ(ut, Y.placementInvProjMatrix, p.transform.glCoordMatrix), l.aQ(ut, ut, Y.placementViewportMatrix), _.push({ circleArray: tt, circleOffset: k, transform: nt.posMatrix, invTransform: ut, coord: nt }), w += tt.length / 4, k = w;
          }
          J && d.draw(a, h.LINES, Xe.disabled, xi.disabled, p.colorModeForRenderPass(), Li.disabled, { u_matrix: nt.posMatrix, u_pixel_extrude_scale: [1 / (T = p.transform).width, 1 / T.height] }, p.style.map.terrain && p.style.map.terrain.getTerrainData(nt), s.id, J.layoutVertexBuffer, J.indexBuffer, J.segments, null, p.transform.zoom, null, null, J.collisionVertexBuffer);
        }
        var T;
        if (!r || !_.length) return;
        const C = p.useProgram("collisionCircle"), z = new l.aR();
        z.resize(4 * w), z._trim();
        let R = 0;
        for (const G of _) for (let nt = 0; nt < G.circleArray.length / 4; nt++) {
          const Y = 4 * nt, J = G.circleArray[Y + 0], tt = G.circleArray[Y + 1], ut = G.circleArray[Y + 2], St = G.circleArray[Y + 3];
          z.emplace(R++, J, tt, ut, St, 0), z.emplace(R++, J, tt, ut, St, 1), z.emplace(R++, J, tt, ut, St, 2), z.emplace(R++, J, tt, ut, St, 3);
        }
        (!nn || nn.length < 2 * w) && (nn = function(G) {
          const nt = 2 * G, Y = new l.aT();
          Y.resize(nt), Y._trim();
          for (let J = 0; J < nt; J++) {
            const tt = 6 * J;
            Y.uint16[tt + 0] = 4 * J + 0, Y.uint16[tt + 1] = 4 * J + 1, Y.uint16[tt + 2] = 4 * J + 2, Y.uint16[tt + 3] = 4 * J + 2, Y.uint16[tt + 4] = 4 * J + 3, Y.uint16[tt + 5] = 4 * J + 0;
          }
          return Y;
        }(w));
        const W = a.createIndexBuffer(nn, !0), Z = a.createVertexBuffer(z, l.aS.members, !0);
        for (const G of _) {
          const nt = sl(G.transform, G.invTransform, p.transform);
          C.draw(a, h.TRIANGLES, Xe.disabled, xi.disabled, p.colorModeForRenderPass(), Li.disabled, nt, p.style.map.terrain && p.style.map.terrain.getTerrainData(G.coord), s.id, Z, W, l.a0.simpleSegment(0, 2 * G.circleOffset, G.circleArray.length, G.circleArray.length / 2), null, p.transform.zoom, null, null, null);
        }
        Z.destroy(), W.destroy();
      }
      Li.disabled = new Li(!1, 1029, 2305), Li.backCCW = new Li(!0, 1029, 2305);
      const Ks = l.an(new Float32Array(16));
      function Qs(p, t, s, c, r, a) {
        const { horizontalAlign: h, verticalAlign: d } = l.au(p);
        return new l.P((-(h - 0.5) * t / r + c[0]) * a, (-(d - 0.5) * s / r + c[1]) * a);
      }
      function ta(p, t, s, c, r, a) {
        const h = t.tileAnchorPoint.add(new l.P(t.translation[0], t.translation[1]));
        if (t.pitchWithMap) {
          let d = c.mult(a);
          return s || (d = d.rotate(-r)), ht(h.add(d), t.labelPlaneMatrix, t.getElevation).point;
        }
        if (s) {
          const d = $t(t.tileAnchorPoint.x + 1, t.tileAnchorPoint.y, t).point.sub(p), _ = Math.atan(d.y / d.x) + (d.x < 0 ? Math.PI : 0);
          return p.add(c.rotate(_));
        }
        return p.add(c);
      }
      function ea(p, t, s, c, r, a, h, d, _, w, k, T, C, z) {
        const R = p.text.placedSymbolArray, W = p.text.dynamicLayoutVertexArray, Z = p.icon.dynamicLayoutVertexArray, G = {};
        W.clear();
        for (let nt = 0; nt < R.length; nt++) {
          const Y = R.get(nt), J = Y.hidden || !Y.crossTileID || p.allowVerticalPlacement && !Y.placedOrientation ? null : c[Y.crossTileID];
          if (J) {
            const tt = new l.P(Y.anchorX, Y.anchorY), ut = { getElevation: z, width: r.width, height: r.height, labelPlaneMatrix: a, lineVertexArray: null, pitchWithMap: s, projection: k, projectionCache: null, tileAnchorPoint: tt, translation: T, unwrappedTileID: C }, St = s ? ht(tt, h, z) : $t(tt.x, tt.y, ut), It = O(r.cameraToCenterDistance, St.signedDistanceFromCamera);
            let Gt = l.ai(p.textSizeData, _, Y) * It / l.ap;
            s && (Gt *= p.tilePixelRatio / d);
            const { width: qt, height: Zt, anchor: Bt, textOffset: ge, textBoxScale: Le } = J, ce = Qs(Bt, qt, Zt, ge, Le, Gt), de = k.getPitchedTextCorrection(r, tt.add(new l.P(T[0], T[1])), C), Ce = ta(St.point, ut, t, ce, r.angle, de), ii = p.allowVerticalPlacement && Y.placedOrientation === l.ah.vertical ? Math.PI / 2 : 0;
            for (let we = 0; we < Y.numGlyphs; we++) l.aj(W, Ce, ii);
            w && Y.associatedIconIndex >= 0 && (G[Y.associatedIconIndex] = { shiftedAnchor: Ce, angle: ii });
          } else Ve(Y.numGlyphs, W);
        }
        if (w) {
          Z.clear();
          const nt = p.icon.placedSymbolArray;
          for (let Y = 0; Y < nt.length; Y++) {
            const J = nt.get(Y);
            if (J.hidden) Ve(J.numGlyphs, Z);
            else {
              const tt = G[Y];
              if (tt) for (let ut = 0; ut < J.numGlyphs; ut++) l.aj(Z, tt.shiftedAnchor, tt.angle);
              else Ve(J.numGlyphs, Z);
            }
          }
          p.icon.dynamicLayoutVertexBuffer.updateData(Z);
        }
        p.text.dynamicLayoutVertexBuffer.updateData(W);
      }
      function Xn(p, t, s) {
        return s.iconsInText && t ? "symbolTextAndIcon" : p ? "symbolSDF" : "symbolIcon";
      }
      function Yn(p, t, s, c, r, a, h, d, _, w, k, T) {
        const C = p.context, z = C.gl, R = p.transform, W = Ua(), Z = d === "map", G = _ === "map", nt = d !== "viewport" && s.layout.get("symbol-placement") !== "point", Y = Z && !G && !nt, J = !G && nt, tt = !s.layout.get("symbol-sort-key").isConstant();
        let ut = !1;
        const St = p.depthModeForSublayer(0, Xe.ReadOnly), It = s._unevaluatedLayout.hasValue("text-variable-anchor") || s._unevaluatedLayout.hasValue("text-variable-anchor-offset"), Gt = [], qt = W.getCircleRadiusCorrection(R);
        for (const Zt of c) {
          const Bt = t.getTile(Zt), ge = Bt.getBucket(s);
          if (!ge) continue;
          const Le = r ? ge.text : ge.icon;
          if (!Le || !Le.segments.get().length || !Le.hasVisibleVertices) continue;
          const ce = Le.programConfigurations.get(s.id), de = r || ge.sdfIcons, Ce = r ? ge.textSizeData : ge.iconSizeData, ii = G || R.pitch !== 0, we = p.useProgram(Xn(de, r, ge), ce), We = l.ag(Ce, R.zoom), Ai = p.style.map.terrain && p.style.map.terrain.getTerrainData(Zt);
          let Mi, sr, ri, Xi, Gi = [0, 0], zi = null;
          if (r) sr = Bt.glyphAtlasTexture, ri = z.LINEAR, Mi = Bt.glyphAtlasTexture.size, ge.iconsInText && (Gi = Bt.imageAtlasTexture.size, zi = Bt.imageAtlasTexture, Xi = ii || p.options.rotating || p.options.zooming || Ce.kind === "composite" || Ce.kind === "camera" ? z.LINEAR : z.NEAREST);
          else {
            const Yi = s.layout.get("icon-size").constantOr(0) !== 1 || ge.iconsNeedLinear;
            sr = Bt.imageAtlasTexture, ri = de || p.options.rotating || p.options.zooming || Yi || ii ? z.LINEAR : z.NEAREST, Mi = Bt.imageAtlasTexture.size;
          }
          const Fi = He(Bt, 1, p.transform.zoom), Qi = J ? Zt.posMatrix : Ks, Mr = Ir(Qi, G, Z, p.transform, Fi), fn = kr(Qi, G, Z, p.transform, Fi), ar = kr(Zt.posMatrix, G, Z, p.transform, Fi), Hr = W.translatePosition(p.transform, Bt, a, h), ws = It && ge.hasTextData(), oa = s.layout.get("icon-text-fit") !== "none" && ws && ge.hasIconData();
          if (nt) {
            const Yi = p.style.map.terrain ? (Pn, As) => p.style.map.terrain.getElevation(Zt, Pn, As) : null, Yr = s.layout.get("text-rotation-alignment") === "map";
            it(ge, Zt.posMatrix, p, r, Mr, ar, G, w, Yr, W, Zt.toUnwrapped(), R.width, R.height, Hr, Yi);
          }
          const Sr = Zt.posMatrix, Ri = r && It || oa, Ss = nt || Ri ? Ks : Mr, Nn = fn, Xr = de && s.paint.get(r ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let Ar;
          Ar = de ? ge.iconsInText ? Ro(Ce.kind, We, Y, G, nt, Ri, p, Sr, Ss, Nn, Hr, Mi, Gi, qt) : ol(Ce.kind, We, Y, G, nt, Ri, p, Sr, Ss, Nn, Hr, r, Mi, !0, qt) : al(Ce.kind, We, Y, G, nt, Ri, p, Sr, Ss, Nn, Hr, r, Mi, qt);
          const Rr = { program: we, buffers: Le, uniformValues: Ar, atlasTexture: sr, atlasTextureIcon: zi, atlasInterpolation: ri, atlasInterpolationIcon: Xi, isSDF: de, hasHalo: Xr };
          if (tt && ge.canOverlap) {
            ut = !0;
            const Yi = Le.segments.get();
            for (const Yr of Yi) Gt.push({ segments: new l.a0([Yr]), sortKey: Yr.sortKey, state: Rr, terrainData: Ai });
          } else Gt.push({ segments: Le.segments, sortKey: 0, state: Rr, terrainData: Ai });
        }
        ut && Gt.sort((Zt, Bt) => Zt.sortKey - Bt.sortKey);
        for (const Zt of Gt) {
          const Bt = Zt.state;
          if (C.activeTexture.set(z.TEXTURE0), Bt.atlasTexture.bind(Bt.atlasInterpolation, z.CLAMP_TO_EDGE), Bt.atlasTextureIcon && (C.activeTexture.set(z.TEXTURE1), Bt.atlasTextureIcon && Bt.atlasTextureIcon.bind(Bt.atlasInterpolationIcon, z.CLAMP_TO_EDGE)), Bt.isSDF) {
            const ge = Bt.uniformValues;
            Bt.hasHalo && (ge.u_is_halo = 1, Er(Bt.buffers, Zt.segments, s, p, Bt.program, St, k, T, ge, Zt.terrainData)), ge.u_is_halo = 0;
          }
          Er(Bt.buffers, Zt.segments, s, p, Bt.program, St, k, T, Bt.uniformValues, Zt.terrainData);
        }
      }
      function Er(p, t, s, c, r, a, h, d, _, w) {
        const k = c.context;
        r.draw(k, k.gl.TRIANGLES, a, h, d, Li.disabled, _, w, s.id, p.layoutVertexBuffer, p.indexBuffer, t, s.paint, c.transform.zoom, p.programConfigurations.get(s.id), p.dynamicLayoutVertexBuffer, p.opacityVertexBuffer);
      }
      function Gr(p, t, s, c, r) {
        if (!s || !c || !c.imageAtlas) return;
        const a = c.imageAtlas.patternPositions;
        let h = a[s.to.toString()], d = a[s.from.toString()];
        if (!h && d && (h = d), !d && h && (d = h), !h || !d) {
          const _ = r.getPaintProperty(t);
          h = a[_], d = a[_];
        }
        h && d && p.setConstantPatternPositions(h, d);
      }
      function ia(p, t, s, c, r, a, h) {
        const d = p.context.gl, _ = "fill-pattern", w = s.paint.get(_), k = w && w.constantOr(1), T = s.getCrossfadeParameters();
        let C, z, R, W, Z;
        h ? (z = k && !s.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", C = d.LINES) : (z = k ? "fillPattern" : "fill", C = d.TRIANGLES);
        const G = w.constantOr(null);
        for (const nt of c) {
          const Y = t.getTile(nt);
          if (k && !Y.patternsLoaded()) continue;
          const J = Y.getBucket(s);
          if (!J) continue;
          const tt = J.programConfigurations.get(s.id), ut = p.useProgram(z, tt), St = p.style.map.terrain && p.style.map.terrain.getTerrainData(nt);
          k && (p.context.activeTexture.set(d.TEXTURE0), Y.imageAtlasTexture.bind(d.LINEAR, d.CLAMP_TO_EDGE), tt.updatePaintBuffers(T)), Gr(tt, _, G, Y, s);
          const It = St ? nt : null, Gt = p.translatePosMatrix(It ? It.posMatrix : nt.posMatrix, Y, s.paint.get("fill-translate"), s.paint.get("fill-translate-anchor"));
          if (h) {
            W = J.indexBuffer2, Z = J.segments2;
            const qt = [d.drawingBufferWidth, d.drawingBufferHeight];
            R = z === "fillOutlinePattern" && k ? Wa(Gt, p, T, Y, qt) : Ts(Gt, qt);
          } else W = J.indexBuffer, Z = J.segments, R = k ? Hs(Gt, p, T, Y) : _a(Gt);
          ut.draw(p.context, C, r, p.stencilModeForClipping(nt), a, Li.disabled, R, St, s.id, J.layoutVertexBuffer, W, Z, s.paint, p.transform.zoom, tt);
        }
      }
      function ps(p, t, s, c, r, a, h) {
        const d = p.context, _ = d.gl, w = "fill-extrusion-pattern", k = s.paint.get(w), T = k.constantOr(1), C = s.getCrossfadeParameters(), z = s.paint.get("fill-extrusion-opacity"), R = k.constantOr(null);
        for (const W of c) {
          const Z = t.getTile(W), G = Z.getBucket(s);
          if (!G) continue;
          const nt = p.style.map.terrain && p.style.map.terrain.getTerrainData(W), Y = G.programConfigurations.get(s.id), J = p.useProgram(T ? "fillExtrusionPattern" : "fillExtrusion", Y);
          T && (p.context.activeTexture.set(_.TEXTURE0), Z.imageAtlasTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE), Y.updatePaintBuffers(C)), Gr(Y, w, R, Z, s);
          const tt = p.translatePosMatrix(W.posMatrix, Z, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), ut = s.paint.get("fill-extrusion-vertical-gradient"), St = T ? Ga(tt, p, ut, z, W, C, Z) : Ws(tt, p, ut, z);
          J.draw(d, d.gl.TRIANGLES, r, a, h, Li.backCCW, St, nt, s.id, G.layoutVertexBuffer, G.indexBuffer, G.segments, s.paint, p.transform.zoom, Y, p.style.map.terrain && G.centroidVertexBuffer);
        }
      }
      function En(p, t, s, c, r, a, h) {
        const d = p.context, _ = d.gl, w = s.fbo;
        if (!w) return;
        const k = p.useProgram("hillshade"), T = p.style.map.terrain && p.style.map.terrain.getTerrainData(t);
        d.activeTexture.set(_.TEXTURE0), _.bindTexture(_.TEXTURE_2D, w.colorAttachment.get()), k.draw(d, _.TRIANGLES, r, a, h, Li.disabled, ((C, z, R, W) => {
          const Z = R.paint.get("hillshade-shadow-color"), G = R.paint.get("hillshade-highlight-color"), nt = R.paint.get("hillshade-accent-color");
          let Y = R.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          R.paint.get("hillshade-illumination-anchor") === "viewport" && (Y -= C.transform.angle);
          const J = !C.options.moving;
          return { u_matrix: W ? W.posMatrix : C.transform.calculatePosMatrix(z.tileID.toUnwrapped(), J), u_image: 0, u_latrange: Ye(0, z.tileID), u_light: [R.paint.get("hillshade-exaggeration"), Y], u_shadow: Z, u_highlight: G, u_accent: nt };
        })(p, s, c, T ? t : null), T, c.id, p.rasterBoundsBuffer, p.quadTriangleIndexBuffer, p.rasterBoundsSegments);
      }
      function ra(p, t, s, c, r, a) {
        const h = p.context, d = h.gl, _ = t.dem;
        if (_ && _.data) {
          const w = _.dim, k = _.stride, T = _.getPixels();
          if (h.activeTexture.set(d.TEXTURE1), h.pixelStoreUnpackPremultiplyAlpha.set(!1), t.demTexture = t.demTexture || p.getTileTexture(k), t.demTexture) {
            const z = t.demTexture;
            z.update(T, { premultiply: !1 }), z.bind(d.NEAREST, d.CLAMP_TO_EDGE);
          } else t.demTexture = new at(h, T, d.RGBA, { premultiply: !1 }), t.demTexture.bind(d.NEAREST, d.CLAMP_TO_EDGE);
          h.activeTexture.set(d.TEXTURE0);
          let C = t.fbo;
          if (!C) {
            const z = new at(h, { width: w, height: w, data: null }, d.RGBA);
            z.bind(d.LINEAR, d.CLAMP_TO_EDGE), C = t.fbo = h.createFramebuffer(w, w, !0, !1), C.colorAttachment.set(z.texture);
          }
          h.bindFramebuffer.set(C.framebuffer), h.viewport.set([0, 0, w, w]), p.useProgram("hillshadePrepare").draw(h, d.TRIANGLES, c, r, a, Li.disabled, ((z, R) => {
            const W = R.stride, Z = l.H();
            return l.aP(Z, 0, l.X, -l.X, 0, 0, 1), l.J(Z, Z, [0, -l.X, 0]), { u_matrix: Z, u_image: 1, u_dimension: [W, W], u_zoom: z.overscaledZ, u_unpack: R.getUnpackVector() };
          })(t.tileID, _), null, s.id, p.rasterBoundsBuffer, p.quadTriangleIndexBuffer, p.rasterBoundsSegments), t.needsHillshadePrepare = !1;
        }
      }
      function Nr(p, t, s, c, r, a) {
        const h = c.paint.get("raster-fade-duration");
        if (!a && h > 0) {
          const d = q.now(), _ = (d - p.timeAdded) / h, w = t ? (d - t.timeAdded) / h : -1, k = s.getSource(), T = r.coveringZoomLevel({ tileSize: k.tileSize, roundZoom: k.roundZoom }), C = !t || Math.abs(t.tileID.overscaledZ - T) > Math.abs(p.tileID.overscaledZ - T), z = C && p.refreshedUponExpiration ? 1 : l.ac(C ? _ : 1 - w, 0, 1);
          return p.refreshedUponExpiration && _ >= 1 && (p.refreshedUponExpiration = !1), t ? { opacity: 1, mix: 1 - z } : { opacity: z, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const Ia = new l.aM(1, 0, 0, 1), na = new l.aM(0, 1, 0, 1), Uo = new l.aM(0, 0, 1, 1), Wr = new l.aM(1, 0, 1, 1), fs = new l.aM(0, 1, 1, 1);
      function Vo(p, t, s, c) {
        yi(p, 0, t + s / 2, p.transform.width, s, c);
      }
      function ro(p, t, s, c) {
        yi(p, t - s / 2, 0, s, p.transform.height, c);
      }
      function yi(p, t, s, c, r, a) {
        const h = p.context, d = h.gl;
        d.enable(d.SCISSOR_TEST), d.scissor(t * p.pixelRatio, s * p.pixelRatio, c * p.pixelRatio, r * p.pixelRatio), h.clear({ color: a }), d.disable(d.SCISSOR_TEST);
      }
      function sn(p, t, s) {
        const c = p.context, r = c.gl, a = s.posMatrix, h = p.useProgram("debug"), d = Xe.disabled, _ = xi.disabled, w = p.colorModeForRenderPass(), k = "$debug", T = p.style.map.terrain && p.style.map.terrain.getTerrainData(s);
        c.activeTexture.set(r.TEXTURE0);
        const C = t.getTileByID(s.key).latestRawTileData, z = Math.floor((C && C.byteLength || 0) / 1024), R = t.getTile(s).tileSize, W = 512 / Math.min(R, 512) * (s.overscaledZ / p.transform.zoom) * 0.5;
        let Z = s.canonical.toString();
        s.overscaledZ !== s.canonical.z && (Z += ` => ${s.overscaledZ}`), function(G, nt) {
          G.initDebugOverlayCanvas();
          const Y = G.debugOverlayCanvas, J = G.context.gl, tt = G.debugOverlayCanvas.getContext("2d");
          tt.clearRect(0, 0, Y.width, Y.height), tt.shadowColor = "white", tt.shadowBlur = 2, tt.lineWidth = 1.5, tt.strokeStyle = "white", tt.textBaseline = "top", tt.font = "bold 36px Open Sans, sans-serif", tt.fillText(nt, 5, 5), tt.strokeText(nt, 5, 5), G.debugOverlayTexture.update(Y), G.debugOverlayTexture.bind(J.LINEAR, J.CLAMP_TO_EDGE);
        }(p, `${Z} ${z}kB`), h.draw(c, r.TRIANGLES, d, _, di.alphaBlended, Li.disabled, cr(a, l.aM.transparent, W), null, k, p.debugBuffer, p.quadTriangleIndexBuffer, p.debugSegments), h.draw(c, r.LINE_STRIP, d, _, w, Li.disabled, cr(a, l.aM.red), T, k, p.debugBuffer, p.tileBorderIndexBuffer, p.debugSegments);
      }
      function Mn(p, t, s) {
        const c = p.context, r = c.gl, a = p.colorModeForRenderPass(), h = new Xe(r.LEQUAL, Xe.ReadWrite, p.depthRangeFor3D), d = p.useProgram("terrain"), _ = t.getTerrainMesh();
        c.bindFramebuffer.set(null), c.viewport.set([0, 0, p.width, p.height]);
        for (const w of s) {
          const k = p.renderToTexture.getTexture(w), T = t.getTerrainData(w.tileID);
          c.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, k.texture);
          const C = p.transform.calculatePosMatrix(w.tileID.toUnwrapped()), z = t.getMeshFrameDelta(p.transform.zoom), R = p.transform.calculateFogMatrix(w.tileID.toUnwrapped()), W = $a(C, z, R, p.style.sky, p.transform.pitch);
          d.draw(c, r.TRIANGLES, h, xi.disabled, a, Li.backCCW, W, T, "terrain", _.vertexBuffer, _.indexBuffer, _.segments);
        }
      }
      class ms {
        constructor(t, s, c) {
          this.vertexBuffer = t, this.indexBuffer = s, this.segments = c;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      class hn {
        constructor(t, s) {
          this.context = new mr(t), this.transform = s, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: l.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Te.maxUnderzooming + Te.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new $r();
        }
        resize(t, s, c) {
          if (this.width = Math.floor(t * c), this.height = Math.floor(s * c), this.pixelRatio = c, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const r of this.style._order) this.style._layers[r].resize();
        }
        setup() {
          const t = this.context, s = new l.aW();
          s.emplaceBack(0, 0), s.emplaceBack(l.X, 0), s.emplaceBack(0, l.X), s.emplaceBack(l.X, l.X), this.tileExtentBuffer = t.createVertexBuffer(s, Lr.members), this.tileExtentSegments = l.a0.simpleSegment(0, 0, 4, 2);
          const c = new l.aW();
          c.emplaceBack(0, 0), c.emplaceBack(l.X, 0), c.emplaceBack(0, l.X), c.emplaceBack(l.X, l.X), this.debugBuffer = t.createVertexBuffer(c, Lr.members), this.debugSegments = l.a0.simpleSegment(0, 0, 4, 5);
          const r = new l.$();
          r.emplaceBack(0, 0, 0, 0), r.emplaceBack(l.X, 0, l.X, 0), r.emplaceBack(0, l.X, 0, l.X), r.emplaceBack(l.X, l.X, l.X, l.X), this.rasterBoundsBuffer = t.createVertexBuffer(r, Ae.members), this.rasterBoundsSegments = l.a0.simpleSegment(0, 0, 4, 2);
          const a = new l.aW();
          a.emplaceBack(0, 0), a.emplaceBack(1, 0), a.emplaceBack(0, 1), a.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(a, Lr.members), this.viewportSegments = l.a0.simpleSegment(0, 0, 4, 2);
          const h = new l.aY();
          h.emplaceBack(0), h.emplaceBack(1), h.emplaceBack(3), h.emplaceBack(2), h.emplaceBack(0), this.tileBorderIndexBuffer = t.createIndexBuffer(h);
          const d = new l.aX();
          d.emplaceBack(0, 1, 2), d.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(d);
          const _ = this.context.gl;
          this.stencilClearMode = new xi({ func: _.ALWAYS, mask: 0 }, 0, 255, _.ZERO, _.ZERO, _.ZERO);
        }
        clearStencil() {
          const t = this.context, s = t.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const c = l.H();
          l.aP(c, 0, this.width, this.height, 0, 0, 1), l.K(c, c, [s.drawingBufferWidth, s.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(t, s.TRIANGLES, Xe.disabled, this.stencilClearMode, di.disabled, Li.disabled, xa(c), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(t, s) {
          if (this.currentStencilSource === t.source || !t.isTileClipped() || !s || !s.length) return;
          this.currentStencilSource = t.source;
          const c = this.context, r = c.gl;
          this.nextStencilID + s.length > 256 && this.clearStencil(), c.setColorMode(di.disabled), c.setDepthMode(Xe.disabled);
          const a = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const h of s) {
            const d = this._tileClippingMaskIDs[h.key] = this.nextStencilID++, _ = this.style.map.terrain && this.style.map.terrain.getTerrainData(h);
            a.draw(c, r.TRIANGLES, Xe.disabled, new xi({ func: r.ALWAYS, mask: 0 }, d, 255, r.KEEP, r.KEEP, r.REPLACE), di.disabled, Li.disabled, xa(h.posMatrix), _, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t = this.nextStencilID++, s = this.context.gl;
          return new xi({ func: s.NOTEQUAL, mask: 255 }, t, 255, s.KEEP, s.KEEP, s.REPLACE);
        }
        stencilModeForClipping(t) {
          const s = this.context.gl;
          return new xi({ func: s.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, s.KEEP, s.KEEP, s.REPLACE);
        }
        stencilConfigForOverlap(t) {
          const s = this.context.gl, c = t.sort((h, d) => d.overscaledZ - h.overscaledZ), r = c[c.length - 1].overscaledZ, a = c[0].overscaledZ - r + 1;
          if (a > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + a > 256 && this.clearStencil();
            const h = {};
            for (let d = 0; d < a; d++) h[d + r] = new xi({ func: s.GEQUAL, mask: 255 }, d + this.nextStencilID, 255, s.KEEP, s.KEEP, s.REPLACE);
            return this.nextStencilID += a, [h, c];
          }
          return [{ [r]: xi.disabled }, c];
        }
        colorModeForRenderPass() {
          const t = this.context.gl;
          return this._showOverdrawInspector ? new di([t.CONSTANT_COLOR, t.ONE], new l.aM(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? di.unblended : di.alphaBlended;
        }
        depthModeForSublayer(t, s, c) {
          if (!this.opaquePassEnabledForLayer()) return Xe.disabled;
          const r = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
          return new Xe(c || this.context.gl.LEQUAL, s, [r, r]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t, s) {
          this.style = t, this.options = s, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(q.now()), this.imageManager.beginFrame();
          const c = this.style._order, r = this.style.sourceCaches, a = {}, h = {}, d = {};
          for (const _ in r) {
            const w = r[_];
            w.used && w.prepare(this.context), a[_] = w.getVisibleCoordinates(), h[_] = a[_].slice().reverse(), d[_] = w.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let _ = 0; _ < c.length; _++) if (this.style._layers[c[_]].is3D()) {
            this.opaquePassCutoff = _;
            break;
          }
          this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const _ of c) {
            const w = this.style._layers[_];
            if (!w.hasOffscreenPass() || w.isHidden(this.transform.zoom)) continue;
            const k = h[w.source];
            (w.type === "custom" || k.length) && this.renderLayer(this, r[w.source], w, k);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: s.showOverdrawInspector ? l.aM.black : l.aM.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(_, w) {
            const k = _.context, T = k.gl, C = ((G, nt, Y) => ({ u_sky_color: G.properties.get("sky-color"), u_horizon_color: G.properties.get("horizon-color"), u_horizon: (nt.height / 2 + nt.getHorizon()) * Y, u_sky_horizon_blend: G.properties.get("sky-horizon-blend") * nt.height / 2 * Y }))(w, _.style.map.transform, _.pixelRatio), z = new Xe(T.LEQUAL, Xe.ReadWrite, [0, 1]), R = xi.disabled, W = _.colorModeForRenderPass(), Z = _.useProgram("sky");
            if (!w.mesh) {
              const G = new l.aW();
              G.emplaceBack(-1, -1), G.emplaceBack(1, -1), G.emplaceBack(1, 1), G.emplaceBack(-1, 1);
              const nt = new l.aX();
              nt.emplaceBack(0, 1, 2), nt.emplaceBack(0, 2, 3), w.mesh = new ms(k.createVertexBuffer(G, Lr.members), k.createIndexBuffer(nt), l.a0.simpleSegment(0, 0, G.length, nt.length));
            }
            Z.draw(k, T.TRIANGLES, z, R, W, Li.disabled, C, void 0, "sky", w.mesh.vertexBuffer, w.mesh.indexBuffer, w.mesh.segments);
          }(this, this.style.sky), this._showOverdrawInspector = s.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = c.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const _ = this.style._layers[c[this.currentLayer]], w = r[_.source], k = a[_.source];
            this._renderTileClippingMasks(_, k), this.renderLayer(this, w, _, k);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < c.length; this.currentLayer++) {
            const _ = this.style._layers[c[this.currentLayer]], w = r[_.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(_)) continue;
            const k = (_.type === "symbol" ? d : h)[_.source];
            this._renderTileClippingMasks(_, a[_.source]), this.renderLayer(this, w, _, k);
          }
          if (this.options.showTileBoundaries) {
            const _ = function(w, k) {
              let T = null;
              const C = Object.values(w._layers).flatMap((Z) => Z.source && !Z.isHidden(k) ? [w.sourceCaches[Z.source]] : []), z = C.filter((Z) => Z.getSource().type === "vector"), R = C.filter((Z) => Z.getSource().type !== "vector"), W = (Z) => {
                (!T || T.getSource().maxzoom < Z.getSource().maxzoom) && (T = Z);
              };
              return z.forEach((Z) => W(Z)), T || R.forEach((Z) => W(Z)), T;
            }(this.style, this.transform.zoom);
            _ && function(w, k, T) {
              for (let C = 0; C < T.length; C++) sn(w, k, T[C]);
            }(this, _, _.getVisibleCoordinates());
          }
          this.options.showPadding && function(_) {
            const w = _.transform.padding;
            Vo(_, _.transform.height - (w.top || 0), 3, Ia), Vo(_, w.bottom || 0, 3, na), ro(_, w.left || 0, 3, Uo), ro(_, _.transform.width - (w.right || 0), 3, Wr);
            const k = _.transform.centerPoint;
            (function(T, C, z, R) {
              yi(T, C - 1, z - 10, 2, 20, R), yi(T, C - 10, z - 1, 20, 2, R);
            })(_, k.x, _.transform.height - k.y, fs);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(t) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          const s = this.terrainFacilitator.matrix, c = this.transform.modelViewProjectionMatrix;
          let r = this.terrainFacilitator.dirty;
          r || (r = t ? !l.aZ(s, c) : !l.a_(s, c)), r || (r = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), r && (l.a$(s, c), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(a, h) {
            const d = a.context, _ = d.gl, w = di.unblended, k = new Xe(_.LEQUAL, Xe.ReadWrite, [0, 1]), T = h.getTerrainMesh(), C = h.sourceCache.getRenderableTiles(), z = a.useProgram("terrainDepth");
            d.bindFramebuffer.set(h.getFramebuffer("depth").framebuffer), d.viewport.set([0, 0, a.width / devicePixelRatio, a.height / devicePixelRatio]), d.clear({ color: l.aM.transparent, depth: 1 });
            for (const R of C) {
              const W = h.getTerrainData(R.tileID), Z = { u_matrix: a.transform.calculatePosMatrix(R.tileID.toUnwrapped()), u_ele_delta: h.getMeshFrameDelta(a.transform.zoom) };
              z.draw(d, _.TRIANGLES, k, xi.disabled, w, Li.backCCW, Z, W, "terrain", T.vertexBuffer, T.indexBuffer, T.segments);
            }
            d.bindFramebuffer.set(null), d.viewport.set([0, 0, a.width, a.height]);
          }(this, this.style.map.terrain), function(a, h) {
            const d = a.context, _ = d.gl, w = di.unblended, k = new Xe(_.LEQUAL, Xe.ReadWrite, [0, 1]), T = h.getTerrainMesh(), C = h.getCoordsTexture(), z = h.sourceCache.getRenderableTiles(), R = a.useProgram("terrainCoords");
            d.bindFramebuffer.set(h.getFramebuffer("coords").framebuffer), d.viewport.set([0, 0, a.width / devicePixelRatio, a.height / devicePixelRatio]), d.clear({ color: l.aM.transparent, depth: 1 }), h.coordsIndex = [];
            for (const W of z) {
              const Z = h.getTerrainData(W.tileID);
              d.activeTexture.set(_.TEXTURE0), _.bindTexture(_.TEXTURE_2D, C.texture);
              const G = { u_matrix: a.transform.calculatePosMatrix(W.tileID.toUnwrapped()), u_terrain_coords_id: (255 - h.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: h.getMeshFrameDelta(a.transform.zoom) };
              R.draw(d, _.TRIANGLES, k, xi.disabled, w, Li.backCCW, G, Z, "terrain", T.vertexBuffer, T.indexBuffer, T.segments), h.coordsIndex.push(W.tileID.key);
            }
            d.bindFramebuffer.set(null), d.viewport.set([0, 0, a.width, a.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(t, s, c, r) {
          if (!c.isHidden(this.transform.zoom) && (c.type === "background" || c.type === "custom" || (r || []).length)) switch (this.id = c.id, c.type) {
            case "symbol":
              (function(a, h, d, _, w) {
                if (a.renderPass !== "translucent") return;
                const k = xi.disabled, T = a.colorModeForRenderPass();
                (d._unevaluatedLayout.hasValue("text-variable-anchor") || d._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(C, z, R, W, Z, G, nt, Y, J) {
                  const tt = z.transform, ut = Ua(), St = Z === "map", It = G === "map";
                  for (const Gt of C) {
                    const qt = W.getTile(Gt), Zt = qt.getBucket(R);
                    if (!Zt || !Zt.text || !Zt.text.segments.get().length) continue;
                    const Bt = l.ag(Zt.textSizeData, tt.zoom), ge = He(qt, 1, z.transform.zoom), Le = Ir(Gt.posMatrix, It, St, z.transform, ge), ce = R.layout.get("icon-text-fit") !== "none" && Zt.hasIconData();
                    if (Bt) {
                      const de = Math.pow(2, tt.zoom - qt.tileID.overscaledZ), Ce = z.style.map.terrain ? (we, We) => z.style.map.terrain.getElevation(Gt, we, We) : null, ii = ut.translatePosition(tt, qt, nt, Y);
                      ea(Zt, St, It, J, tt, Le, Gt.posMatrix, de, Bt, ce, ut, ii, Gt.toUnwrapped(), Ce);
                    }
                  }
                }(_, a, d, h, d.layout.get("text-rotation-alignment"), d.layout.get("text-pitch-alignment"), d.paint.get("text-translate"), d.paint.get("text-translate-anchor"), w), d.paint.get("icon-opacity").constantOr(1) !== 0 && Yn(a, h, d, _, !1, d.paint.get("icon-translate"), d.paint.get("icon-translate-anchor"), d.layout.get("icon-rotation-alignment"), d.layout.get("icon-pitch-alignment"), d.layout.get("icon-keep-upright"), k, T), d.paint.get("text-opacity").constantOr(1) !== 0 && Yn(a, h, d, _, !0, d.paint.get("text-translate"), d.paint.get("text-translate-anchor"), d.layout.get("text-rotation-alignment"), d.layout.get("text-pitch-alignment"), d.layout.get("text-keep-upright"), k, T), h.map.showCollisionBoxes && (Hn(a, h, d, _, !0), Hn(a, h, d, _, !1));
              })(t, s, c, r, this.style.placement.variableOffsets);
              break;
            case "circle":
              (function(a, h, d, _) {
                if (a.renderPass !== "translucent") return;
                const w = d.paint.get("circle-opacity"), k = d.paint.get("circle-stroke-width"), T = d.paint.get("circle-stroke-opacity"), C = !d.layout.get("circle-sort-key").isConstant();
                if (w.constantOr(1) === 0 && (k.constantOr(1) === 0 || T.constantOr(1) === 0)) return;
                const z = a.context, R = z.gl, W = a.depthModeForSublayer(0, Xe.ReadOnly), Z = xi.disabled, G = a.colorModeForRenderPass(), nt = [];
                for (let Y = 0; Y < _.length; Y++) {
                  const J = _[Y], tt = h.getTile(J), ut = tt.getBucket(d);
                  if (!ut) continue;
                  const St = ut.programConfigurations.get(d.id), It = a.useProgram("circle", St), Gt = ut.layoutVertexBuffer, qt = ut.indexBuffer, Zt = a.style.map.terrain && a.style.map.terrain.getTerrainData(J), Bt = { programConfiguration: St, program: It, layoutVertexBuffer: Gt, indexBuffer: qt, uniformValues: va(a, J, tt, d), terrainData: Zt };
                  if (C) {
                    const ge = ut.segments.get();
                    for (const Le of ge) nt.push({ segments: new l.a0([Le]), sortKey: Le.sortKey, state: Bt });
                  } else nt.push({ segments: ut.segments, sortKey: 0, state: Bt });
                }
                C && nt.sort((Y, J) => Y.sortKey - J.sortKey);
                for (const Y of nt) {
                  const { programConfiguration: J, program: tt, layoutVertexBuffer: ut, indexBuffer: St, uniformValues: It, terrainData: Gt } = Y.state;
                  tt.draw(z, R.TRIANGLES, W, Z, G, Li.disabled, It, Gt, d.id, ut, St, Y.segments, d.paint, a.transform.zoom, J);
                }
              })(t, s, c, r);
              break;
            case "heatmap":
              (function(a, h, d, _) {
                if (d.paint.get("heatmap-opacity") !== 0) if (a.renderPass === "offscreen") {
                  const w = a.context, k = w.gl, T = xi.disabled, C = new di([k.ONE, k.ONE], l.aM.transparent, [!0, !0, !0, !0]);
                  (function(z, R, W) {
                    const Z = z.gl;
                    z.activeTexture.set(Z.TEXTURE1), z.viewport.set([0, 0, R.width / 4, R.height / 4]);
                    let G = W.heatmapFbo;
                    if (G) Z.bindTexture(Z.TEXTURE_2D, G.colorAttachment.get()), z.bindFramebuffer.set(G.framebuffer);
                    else {
                      const nt = Z.createTexture();
                      Z.bindTexture(Z.TEXTURE_2D, nt), Z.texParameteri(Z.TEXTURE_2D, Z.TEXTURE_WRAP_S, Z.CLAMP_TO_EDGE), Z.texParameteri(Z.TEXTURE_2D, Z.TEXTURE_WRAP_T, Z.CLAMP_TO_EDGE), Z.texParameteri(Z.TEXTURE_2D, Z.TEXTURE_MIN_FILTER, Z.LINEAR), Z.texParameteri(Z.TEXTURE_2D, Z.TEXTURE_MAG_FILTER, Z.LINEAR), G = W.heatmapFbo = z.createFramebuffer(R.width / 4, R.height / 4, !1, !1), function(Y, J, tt, ut) {
                        var St, It;
                        const Gt = Y.gl, qt = (St = Y.HALF_FLOAT) !== null && St !== void 0 ? St : Gt.UNSIGNED_BYTE, Zt = (It = Y.RGBA16F) !== null && It !== void 0 ? It : Gt.RGBA;
                        Gt.texImage2D(Gt.TEXTURE_2D, 0, Zt, J.width / 4, J.height / 4, 0, Gt.RGBA, qt, null), ut.colorAttachment.set(tt);
                      }(z, R, nt, G);
                    }
                  })(w, a, d), w.clear({ color: l.aM.transparent });
                  for (let z = 0; z < _.length; z++) {
                    const R = _[z];
                    if (h.hasRenderableParent(R)) continue;
                    const W = h.getTile(R), Z = W.getBucket(d);
                    if (!Z) continue;
                    const G = Z.programConfigurations.get(d.id), nt = a.useProgram("heatmap", G), { zoom: Y } = a.transform;
                    nt.draw(w, k.TRIANGLES, Xe.disabled, T, C, Li.disabled, Zr(R.posMatrix, W, Y, d.paint.get("heatmap-intensity")), null, d.id, Z.layoutVertexBuffer, Z.indexBuffer, Z.segments, d.paint, a.transform.zoom, G);
                  }
                  w.viewport.set([0, 0, a.width, a.height]);
                } else a.renderPass === "translucent" && (a.context.setColorMode(a.colorModeForRenderPass()), function(w, k) {
                  const T = w.context, C = T.gl, z = k.heatmapFbo;
                  if (!z) return;
                  T.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, z.colorAttachment.get()), T.activeTexture.set(C.TEXTURE1);
                  let R = k.colorRampTexture;
                  R || (R = k.colorRampTexture = new at(T, k.colorRamp, C.RGBA)), R.bind(C.LINEAR, C.CLAMP_TO_EDGE), w.useProgram("heatmapTexture").draw(T, C.TRIANGLES, Xe.disabled, xi.disabled, w.colorModeForRenderPass(), Li.disabled, ((W, Z, G, nt) => {
                    const Y = l.H();
                    l.aP(Y, 0, W.width, W.height, 0, 0, 1);
                    const J = W.context.gl;
                    return { u_matrix: Y, u_world: [J.drawingBufferWidth, J.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: Z.paint.get("heatmap-opacity") };
                  })(w, k), null, k.id, w.viewportBuffer, w.quadTriangleIndexBuffer, w.viewportSegments, k.paint, w.transform.zoom);
                }(a, d));
              })(t, s, c, r);
              break;
            case "line":
              (function(a, h, d, _) {
                if (a.renderPass !== "translucent") return;
                const w = d.paint.get("line-opacity"), k = d.paint.get("line-width");
                if (w.constantOr(1) === 0 || k.constantOr(1) === 0) return;
                const T = a.depthModeForSublayer(0, Xe.ReadOnly), C = a.colorModeForRenderPass(), z = d.paint.get("line-dasharray"), R = d.paint.get("line-pattern"), W = R.constantOr(1), Z = d.paint.get("line-gradient"), G = d.getCrossfadeParameters(), nt = W ? "linePattern" : z ? "lineSDF" : Z ? "lineGradient" : "line", Y = a.context, J = Y.gl;
                let tt = !0;
                for (const ut of _) {
                  const St = h.getTile(ut);
                  if (W && !St.patternsLoaded()) continue;
                  const It = St.getBucket(d);
                  if (!It) continue;
                  const Gt = It.programConfigurations.get(d.id), qt = a.context.program.get(), Zt = a.useProgram(nt, Gt), Bt = tt || Zt.program !== qt, ge = a.style.map.terrain && a.style.map.terrain.getTerrainData(ut), Le = R.constantOr(null);
                  if (Le && St.imageAtlas) {
                    const Ce = St.imageAtlas, ii = Ce.patternPositions[Le.to.toString()], we = Ce.patternPositions[Le.from.toString()];
                    ii && we && Gt.setConstantPatternPositions(ii, we);
                  }
                  const ce = ge ? ut : null, de = W ? Zn(a, St, d, G, ce) : z ? No(a, St, d, z, G, ce) : Z ? Ha(a, St, d, It.lineClipsArray.length, ce) : ba(a, St, d, ce);
                  if (W) Y.activeTexture.set(J.TEXTURE0), St.imageAtlasTexture.bind(J.LINEAR, J.CLAMP_TO_EDGE), Gt.updatePaintBuffers(G);
                  else if (z && (Bt || a.lineAtlas.dirty)) Y.activeTexture.set(J.TEXTURE0), a.lineAtlas.bind(Y);
                  else if (Z) {
                    const Ce = It.gradients[d.id];
                    let ii = Ce.texture;
                    if (d.gradientVersion !== Ce.version) {
                      let we = 256;
                      if (d.stepInterpolant) {
                        const We = h.getSource().maxzoom, Ai = ut.canonical.z === We ? Math.ceil(1 << a.transform.maxZoom - ut.canonical.z) : 1;
                        we = l.ac(l.aU(It.maxLineLength / l.X * 1024 * Ai), 256, Y.maxTextureSize);
                      }
                      Ce.gradient = l.aV({ expression: d.gradientExpression(), evaluationKey: "lineProgress", resolution: we, image: Ce.gradient || void 0, clips: It.lineClipsArray }), Ce.texture ? Ce.texture.update(Ce.gradient) : Ce.texture = new at(Y, Ce.gradient, J.RGBA), Ce.version = d.gradientVersion, ii = Ce.texture;
                    }
                    Y.activeTexture.set(J.TEXTURE0), ii.bind(d.stepInterpolant ? J.NEAREST : J.LINEAR, J.CLAMP_TO_EDGE);
                  }
                  Zt.draw(Y, J.TRIANGLES, T, a.stencilModeForClipping(ut), C, Li.disabled, de, ge, d.id, It.layoutVertexBuffer, It.indexBuffer, It.segments, d.paint, a.transform.zoom, Gt, It.layoutVertexBuffer2), tt = !1;
                }
              })(t, s, c, r);
              break;
            case "fill":
              (function(a, h, d, _) {
                const w = d.paint.get("fill-color"), k = d.paint.get("fill-opacity");
                if (k.constantOr(1) === 0) return;
                const T = a.colorModeForRenderPass(), C = d.paint.get("fill-pattern"), z = a.opaquePassEnabledForLayer() && !C.constantOr(1) && w.constantOr(l.aM.transparent).a === 1 && k.constantOr(0) === 1 ? "opaque" : "translucent";
                if (a.renderPass === z) {
                  const R = a.depthModeForSublayer(1, a.renderPass === "opaque" ? Xe.ReadWrite : Xe.ReadOnly);
                  ia(a, h, d, _, R, T, !1);
                }
                if (a.renderPass === "translucent" && d.paint.get("fill-antialias")) {
                  const R = a.depthModeForSublayer(d.getPaintProperty("fill-outline-color") ? 2 : 0, Xe.ReadOnly);
                  ia(a, h, d, _, R, T, !0);
                }
              })(t, s, c, r);
              break;
            case "fill-extrusion":
              (function(a, h, d, _) {
                const w = d.paint.get("fill-extrusion-opacity");
                if (w !== 0 && a.renderPass === "translucent") {
                  const k = new Xe(a.context.gl.LEQUAL, Xe.ReadWrite, a.depthRangeFor3D);
                  if (w !== 1 || d.paint.get("fill-extrusion-pattern").constantOr(1)) ps(a, h, d, _, k, xi.disabled, di.disabled), ps(a, h, d, _, k, a.stencilModeFor3D(), a.colorModeForRenderPass());
                  else {
                    const T = a.colorModeForRenderPass();
                    ps(a, h, d, _, k, xi.disabled, T);
                  }
                }
              })(t, s, c, r);
              break;
            case "hillshade":
              (function(a, h, d, _) {
                if (a.renderPass !== "offscreen" && a.renderPass !== "translucent") return;
                const w = a.context, k = a.depthModeForSublayer(0, Xe.ReadOnly), T = a.colorModeForRenderPass(), [C, z] = a.renderPass === "translucent" ? a.stencilConfigForOverlap(_) : [{}, _];
                for (const R of z) {
                  const W = h.getTile(R);
                  W.needsHillshadePrepare !== void 0 && W.needsHillshadePrepare && a.renderPass === "offscreen" ? ra(a, W, d, k, xi.disabled, T) : a.renderPass === "translucent" && En(a, R, W, d, k, C[R.overscaledZ], T);
                }
                w.viewport.set([0, 0, a.width, a.height]);
              })(t, s, c, r);
              break;
            case "raster":
              (function(a, h, d, _) {
                if (a.renderPass !== "translucent" || d.paint.get("raster-opacity") === 0 || !_.length) return;
                const w = a.context, k = w.gl, T = h.getSource(), C = a.useProgram("raster"), z = a.colorModeForRenderPass(), [R, W] = T instanceof $e ? [{}, _] : a.stencilConfigForOverlap(_), Z = W[W.length - 1].overscaledZ, G = !a.options.moving;
                for (const nt of W) {
                  const Y = a.depthModeForSublayer(nt.overscaledZ - Z, d.paint.get("raster-opacity") === 1 ? Xe.ReadWrite : Xe.ReadOnly, k.LESS), J = h.getTile(nt);
                  J.registerFadeDuration(d.paint.get("raster-fade-duration"));
                  const tt = h.findLoadedParent(nt, 0), ut = h.findLoadedSibling(nt), St = Nr(J, tt || ut || null, h, d, a.transform, a.style.map.terrain);
                  let It, Gt;
                  const qt = d.paint.get("raster-resampling") === "nearest" ? k.NEAREST : k.LINEAR;
                  w.activeTexture.set(k.TEXTURE0), J.texture.bind(qt, k.CLAMP_TO_EDGE, k.LINEAR_MIPMAP_NEAREST), w.activeTexture.set(k.TEXTURE1), tt ? (tt.texture.bind(qt, k.CLAMP_TO_EDGE, k.LINEAR_MIPMAP_NEAREST), It = Math.pow(2, tt.tileID.overscaledZ - J.tileID.overscaledZ), Gt = [J.tileID.canonical.x * It % 1, J.tileID.canonical.y * It % 1]) : J.texture.bind(qt, k.CLAMP_TO_EDGE, k.LINEAR_MIPMAP_NEAREST), J.texture.useMipmap && w.extTextureFilterAnisotropic && a.transform.pitch > 20 && k.texParameterf(k.TEXTURE_2D, w.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, w.extTextureFilterAnisotropicMax);
                  const Zt = a.style.map.terrain && a.style.map.terrain.getTerrainData(nt), Bt = Zt ? nt : null, ge = Bt ? Bt.posMatrix : a.transform.calculatePosMatrix(nt.toUnwrapped(), G), Le = Fo(ge, Gt || [0, 0], It || 1, St, d);
                  T instanceof $e ? C.draw(w, k.TRIANGLES, Y, xi.disabled, z, Li.disabled, Le, Zt, d.id, T.boundsBuffer, a.quadTriangleIndexBuffer, T.boundsSegments) : C.draw(w, k.TRIANGLES, Y, R[nt.overscaledZ], z, Li.disabled, Le, Zt, d.id, a.rasterBoundsBuffer, a.quadTriangleIndexBuffer, a.rasterBoundsSegments);
                }
              })(t, s, c, r);
              break;
            case "background":
              (function(a, h, d, _) {
                const w = d.paint.get("background-color"), k = d.paint.get("background-opacity");
                if (k === 0) return;
                const T = a.context, C = T.gl, z = a.transform, R = z.tileSize, W = d.paint.get("background-pattern");
                if (a.isPatternMissing(W)) return;
                const Z = !W && w.a === 1 && k === 1 && a.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (a.renderPass !== Z) return;
                const G = xi.disabled, nt = a.depthModeForSublayer(0, Z === "opaque" ? Xe.ReadWrite : Xe.ReadOnly), Y = a.colorModeForRenderPass(), J = a.useProgram(W ? "backgroundPattern" : "background"), tt = _ || z.coveringTiles({ tileSize: R, terrain: a.style.map.terrain });
                W && (T.activeTexture.set(C.TEXTURE0), a.imageManager.bind(a.context));
                const ut = d.getCrossfadeParameters();
                for (const St of tt) {
                  const It = _ ? St.posMatrix : a.transform.calculatePosMatrix(St.toUnwrapped()), Gt = W ? us(It, k, a, W, { tileID: St, tileSize: R }, ut) : hs(It, k, w), qt = a.style.map.terrain && a.style.map.terrain.getTerrainData(St);
                  J.draw(T, C.TRIANGLES, nt, G, Y, Li.disabled, Gt, qt, d.id, a.tileExtentBuffer, a.quadTriangleIndexBuffer, a.tileExtentSegments);
                }
              })(t, 0, c, r);
              break;
            case "custom":
              (function(a, h, d) {
                const _ = a.context, w = d.implementation;
                if (a.renderPass === "offscreen") {
                  const k = w.prerender;
                  k && (a.setCustomLayerDefaults(), _.setColorMode(a.colorModeForRenderPass()), k.call(w, _.gl, a.transform.customLayerMatrix()), _.setDirty(), a.setBaseState());
                } else if (a.renderPass === "translucent") {
                  a.setCustomLayerDefaults(), _.setColorMode(a.colorModeForRenderPass()), _.setStencilMode(xi.disabled);
                  const k = w.renderingMode === "3d" ? new Xe(a.context.gl.LEQUAL, Xe.ReadWrite, a.depthRangeFor3D) : a.depthModeForSublayer(0, Xe.ReadOnly);
                  _.setDepthMode(k), w.render(_.gl, a.transform.customLayerMatrix(), { farZ: a.transform.farZ, nearZ: a.transform.nearZ, fov: a.transform._fov, modelViewProjectionMatrix: a.transform.modelViewProjectionMatrix, projectionMatrix: a.transform.projectionMatrix }), _.setDirty(), a.setBaseState(), _.bindFramebuffer.set(null);
                }
              })(t, 0, c);
          }
        }
        translatePosMatrix(t, s, c, r, a) {
          if (!c[0] && !c[1]) return t;
          const h = a ? r === "map" ? this.transform.angle : 0 : r === "viewport" ? -this.transform.angle : 0;
          if (h) {
            const w = Math.sin(h), k = Math.cos(h);
            c = [c[0] * k - c[1] * w, c[0] * w + c[1] * k];
          }
          const d = [a ? c[0] : He(s, c[0], this.transform.zoom), a ? c[1] : He(s, c[1], this.transform.zoom), 0], _ = new Float32Array(16);
          return l.J(_, t, d), _;
        }
        saveTileTexture(t) {
          const s = this._tileTextures[t.size[0]];
          s ? s.push(t) : this._tileTextures[t.size[0]] = [t];
        }
        getTileTexture(t) {
          const s = this._tileTextures[t];
          return s && s.length > 0 ? s.pop() : null;
        }
        isPatternMissing(t) {
          if (!t) return !1;
          if (!t.from || !t.to) return !0;
          const s = this.imageManager.getPattern(t.from.toString()), c = this.imageManager.getPattern(t.to.toString());
          return !s || !c;
        }
        useProgram(t, s) {
          this.cache = this.cache || {};
          const c = t + (s ? s.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[c] || (this.cache[c] = new ya(this.context, Ln[t], s, Xa[t], this._showOverdrawInspector, this.style.map.terrain)), this.cache[c];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const t = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new at(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: t, drawingBufferHeight: s } = this.context.gl;
          return this.width !== t || this.height !== s;
        }
      }
      class Jn {
        constructor(t, s) {
          this.points = t, this.planes = s;
        }
        static fromInvProjectionMatrix(t, s, c) {
          const r = Math.pow(2, c), a = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((d) => {
            const _ = 1 / (d = l.af([], d, t))[3] / s * r;
            return l.b0(d, d, [_, _, 1 / d[3], _]);
          }), h = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((d) => {
            const _ = function(C, z) {
              var R = z[0], W = z[1], Z = z[2], G = R * R + W * W + Z * Z;
              return G > 0 && (G = 1 / Math.sqrt(G)), C[0] = z[0] * G, C[1] = z[1] * G, C[2] = z[2] * G, C;
            }([], function(C, z, R) {
              var W = z[0], Z = z[1], G = z[2], nt = R[0], Y = R[1], J = R[2];
              return C[0] = Z * J - G * Y, C[1] = G * nt - W * J, C[2] = W * Y - Z * nt, C;
            }([], jt([], a[d[0]], a[d[1]]), jt([], a[d[2]], a[d[1]]))), w = -((k = _)[0] * (T = a[d[1]])[0] + k[1] * T[1] + k[2] * T[2]);
            var k, T;
            return _.concat(w);
          });
          return new Jn(a, h);
        }
      }
      class Ms {
        constructor(t, s) {
          this.min = t, this.max = s, this.center = function(c, r, a) {
            return c[0] = 0.5 * r[0], c[1] = 0.5 * r[1], c[2] = 0.5 * r[2], c;
          }([], function(c, r, a) {
            return c[0] = r[0] + a[0], c[1] = r[1] + a[1], c[2] = r[2] + a[2], c;
          }([], this.min, this.max));
        }
        quadrant(t) {
          const s = [t % 2 == 0, t < 2], c = Ht(this.min), r = Ht(this.max);
          for (let a = 0; a < s.length; a++) c[a] = s[a] ? this.min[a] : this.center[a], r[a] = s[a] ? this.center[a] : this.max[a];
          return r[2] = this.max[2], new Ms(c, r);
        }
        distanceX(t) {
          return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
        }
        distanceY(t) {
          return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
        }
        intersects(t) {
          const s = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let c = !0;
          for (let r = 0; r < t.planes.length; r++) {
            const a = t.planes[r];
            let h = 0;
            for (let d = 0; d < s.length; d++) l.b1(a, s[d]) >= 0 && h++;
            if (h === 0) return 0;
            h !== s.length && (c = !1);
          }
          if (c) return 2;
          for (let r = 0; r < 3; r++) {
            let a = Number.MAX_VALUE, h = -Number.MAX_VALUE;
            for (let d = 0; d < t.points.length; d++) {
              const _ = t.points[d][r] - this.min[r];
              a = Math.min(a, _), h = Math.max(h, _);
            }
            if (h < 0 || a > this.max[r] - this.min[r]) return 0;
          }
          return 1;
        }
      }
      class an {
        constructor(t = 0, s = 0, c = 0, r = 0) {
          if (isNaN(t) || t < 0 || isNaN(s) || s < 0 || isNaN(c) || c < 0 || isNaN(r) || r < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = t, this.bottom = s, this.left = c, this.right = r;
        }
        interpolate(t, s, c) {
          return s.top != null && t.top != null && (this.top = l.y.number(t.top, s.top, c)), s.bottom != null && t.bottom != null && (this.bottom = l.y.number(t.bottom, s.bottom, c)), s.left != null && t.left != null && (this.left = l.y.number(t.left, s.left, c)), s.right != null && t.right != null && (this.right = l.y.number(t.right, s.right, c)), this;
        }
        getCenter(t, s) {
          const c = l.ac((this.left + t - this.right) / 2, 0, t), r = l.ac((this.top + s - this.bottom) / 2, 0, s);
          return new l.P(c, r);
        }
        equals(t) {
          return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
        }
        clone() {
          return new an(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const ka = 85.051129;
      class zs {
        constructor(t, s, c, r, a) {
          this.tileSize = 512, this._renderWorldCopies = a === void 0 || !!a, this._minZoom = t || 0, this._maxZoom = s || 22, this._minPitch = c ?? 0, this._maxPitch = r ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new l.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new an(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const t = new zs(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return t.apply(this), t;
        }
        apply(t) {
          this.tileSize = t.tileSize, this.latRange = t.latRange, this.width = t.width, this.height = t.height, this._center = t._center, this._elevation = t._elevation, this.minElevationForCurrentTile = t.minElevationForCurrentTile, this.zoom = t.zoom, this.angle = t.angle, this._fov = t._fov, this._pitch = t._pitch, this._unmodified = t._unmodified, this._edgeInsets = t._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(t) {
          this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(t) {
          this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(t) {
          this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(t) {
          this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(t) {
          t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new l.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(t) {
          const s = -l.b2(t, -180, 180) * Math.PI / 180;
          this.angle !== s && (this._unmodified = !1, this.angle = s, this._calcMatrices(), this.rotationMatrix = function() {
            var c = new l.A(4);
            return l.A != Float32Array && (c[1] = 0, c[2] = 0), c[0] = 1, c[3] = 1, c;
          }(), function(c, r, a) {
            var h = r[0], d = r[1], _ = r[2], w = r[3], k = Math.sin(a), T = Math.cos(a);
            c[0] = h * T + _ * k, c[1] = d * T + w * k, c[2] = h * -k + _ * T, c[3] = d * -k + w * T;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t) {
          const s = l.ac(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== s && (this._unmodified = !1, this._pitch = s, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(t) {
          t = Math.max(0.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = t / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(t) {
          const s = Math.min(Math.max(t, this.minZoom), this.maxZoom);
          this._zoom !== s && (this._unmodified = !1, this._zoom = s, this.tileZoom = Math.max(0, Math.floor(s)), this.scale = this.zoomScale(s), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(t) {
          t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(t) {
          t !== this._elevation && (this._elevation = t, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(t) {
          this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(t) {
          return this._edgeInsets.equals(t);
        }
        interpolatePadding(t, s, c) {
          this._unmodified = !1, this._edgeInsets.interpolate(t, s, c), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(t) {
          const s = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
          return Math.max(0, s);
        }
        getVisibleUnwrappedCoordinates(t) {
          const s = [new l.b3(0, t)];
          if (this._renderWorldCopies) {
            const c = this.pointCoordinate(new l.P(0, 0)), r = this.pointCoordinate(new l.P(this.width, 0)), a = this.pointCoordinate(new l.P(this.width, this.height)), h = this.pointCoordinate(new l.P(0, this.height)), d = Math.floor(Math.min(c.x, r.x, a.x, h.x)), _ = Math.floor(Math.max(c.x, r.x, a.x, h.x)), w = 1;
            for (let k = d - w; k <= _ + w; k++) k !== 0 && s.push(new l.b3(k, t));
          }
          return s;
        }
        coveringTiles(t) {
          var s, c;
          let r = this.coveringZoomLevel(t);
          const a = r;
          if (t.minzoom !== void 0 && r < t.minzoom) return [];
          t.maxzoom !== void 0 && r > t.maxzoom && (r = t.maxzoom);
          const h = this.pointCoordinate(this.getCameraPoint()), d = l.Z.fromLngLat(this.center), _ = Math.pow(2, r), w = [_ * h.x, _ * h.y, 0], k = [_ * d.x, _ * d.y, 0], T = Jn.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, r);
          let C = t.minzoom || 0;
          !t.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (C = r);
          const z = t.terrain ? 2 / Math.min(this.tileSize, t.tileSize) * this.tileSize : 3, R = (Y) => ({ aabb: new Ms([Y * _, 0, 0], [(Y + 1) * _, _, 0]), zoom: 0, x: 0, y: 0, wrap: Y, fullyVisible: !1 }), W = [], Z = [], G = r, nt = t.reparseOverscaled ? a : r;
          if (this._renderWorldCopies) for (let Y = 1; Y <= 3; Y++) W.push(R(-Y)), W.push(R(Y));
          for (W.push(R(0)); W.length > 0; ) {
            const Y = W.pop(), J = Y.x, tt = Y.y;
            let ut = Y.fullyVisible;
            if (!ut) {
              const Zt = Y.aabb.intersects(T);
              if (Zt === 0) continue;
              ut = Zt === 2;
            }
            const St = t.terrain ? w : k, It = Y.aabb.distanceX(St), Gt = Y.aabb.distanceY(St), qt = Math.max(Math.abs(It), Math.abs(Gt));
            if (Y.zoom === G || qt > z + (1 << G - Y.zoom) - 2 && Y.zoom >= C) {
              const Zt = G - Y.zoom, Bt = w[0] - 0.5 - (J << Zt), ge = w[1] - 0.5 - (tt << Zt);
              Z.push({ tileID: new l.S(Y.zoom === G ? nt : Y.zoom, Y.wrap, Y.zoom, J, tt), distanceSq: Tt([k[0] - 0.5 - J, k[1] - 0.5 - tt]), tileDistanceToCamera: Math.sqrt(Bt * Bt + ge * ge) });
            } else for (let Zt = 0; Zt < 4; Zt++) {
              const Bt = (J << 1) + Zt % 2, ge = (tt << 1) + (Zt >> 1), Le = Y.zoom + 1;
              let ce = Y.aabb.quadrant(Zt);
              if (t.terrain) {
                const de = new l.S(Le, Y.wrap, Le, Bt, ge), Ce = t.terrain.getMinMaxElevation(de), ii = (s = Ce.minElevation) !== null && s !== void 0 ? s : this.elevation, we = (c = Ce.maxElevation) !== null && c !== void 0 ? c : this.elevation;
                ce = new Ms([ce.min[0], ce.min[1], ii], [ce.max[0], ce.max[1], we]);
              }
              W.push({ aabb: ce, zoom: Le, x: Bt, y: ge, wrap: Y.wrap, fullyVisible: ut });
            }
          }
          return Z.sort((Y, J) => Y.distanceSq - J.distanceSq).map((Y) => Y.tileID);
        }
        resize(t, s) {
          this.width = t, this.height = s, this.pixelsToGLUnits = [2 / t, -2 / s], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(t) {
          return Math.pow(2, t);
        }
        scaleZoom(t) {
          return Math.log(t) / Math.LN2;
        }
        project(t) {
          const s = l.ac(t.lat, -85.051129, ka);
          return new l.P(l.O(t.lng) * this.worldSize, l.Q(s) * this.worldSize);
        }
        unproject(t) {
          return new l.Z(t.x / this.worldSize, t.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(t) {
          const s = this.elevation, c = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, r = this.pointLocation(this.centerPoint, t), a = t.getElevationForLngLatZoom(r, this.tileZoom);
          if (!(this.elevation - a)) return;
          const h = c + s - a, d = Math.cos(this._pitch) * this.cameraToCenterDistance / h / l.b4(1, r.lat), _ = this.scaleZoom(d / this.tileSize);
          this._elevation = a, this._center = r, this.zoom = _;
        }
        setLocationAtPoint(t, s) {
          const c = this.pointCoordinate(s), r = this.pointCoordinate(this.centerPoint), a = this.locationCoordinate(t), h = new l.Z(a.x - (c.x - r.x), a.y - (c.y - r.y));
          this.center = this.coordinateLocation(h), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(t, s) {
          return s ? this.coordinatePoint(this.locationCoordinate(t), s.getElevationForLngLatZoom(t, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t));
        }
        pointLocation(t, s) {
          return this.coordinateLocation(this.pointCoordinate(t, s));
        }
        locationCoordinate(t) {
          return l.Z.fromLngLat(t);
        }
        coordinateLocation(t) {
          return t && t.toLngLat();
        }
        pointCoordinate(t, s) {
          if (s) {
            const C = s.pointCoordinate(t);
            if (C != null) return C;
          }
          const c = [t.x, t.y, 0, 1], r = [t.x, t.y, 1, 1];
          l.af(c, c, this.pixelMatrixInverse), l.af(r, r, this.pixelMatrixInverse);
          const a = c[3], h = r[3], d = c[1] / a, _ = r[1] / h, w = c[2] / a, k = r[2] / h, T = w === k ? 0 : (0 - w) / (k - w);
          return new l.Z(l.y.number(c[0] / a, r[0] / h, T) / this.worldSize, l.y.number(d, _, T) / this.worldSize);
        }
        coordinatePoint(t, s = 0, c = this.pixelMatrix) {
          const r = [t.x * this.worldSize, t.y * this.worldSize, s, 1];
          return l.af(r, r, c), new l.P(r[0] / r[3], r[1] / r[3]);
        }
        getBounds() {
          const t = Math.max(0, this.height / 2 - this.getHorizon());
          return new K().extend(this.pointLocation(new l.P(0, t))).extend(this.pointLocation(new l.P(this.width, t))).extend(this.pointLocation(new l.P(this.width, this.height))).extend(this.pointLocation(new l.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new K([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(t) {
          t ? (this.lngRange = [t.getWest(), t.getEast()], this.latRange = [t.getSouth(), t.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, ka]);
        }
        calculateTileMatrix(t) {
          const s = t.canonical, c = this.worldSize / this.zoomScale(s.z), r = s.x + Math.pow(2, s.z) * t.wrap, a = l.an(new Float64Array(16));
          return l.J(a, a, [r * c, s.y * c, 0]), l.K(a, a, [c / l.X, c / l.X, 1]), a;
        }
        calculatePosMatrix(t, s = !1) {
          const c = t.key, r = s ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (r[c]) return r[c];
          const a = this.calculateTileMatrix(t);
          return l.L(a, s ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, a), r[c] = new Float32Array(a), r[c];
        }
        calculateFogMatrix(t) {
          const s = t.key, c = this._fogMatrixCache;
          if (c[s]) return c[s];
          const r = this.calculateTileMatrix(t);
          return l.L(r, this.fogMatrix, r), c[s] = new Float32Array(r), c[s];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(t, s) {
          s = l.ac(+s, this.minZoom, this.maxZoom);
          const c = { center: new l.N(t.lng, t.lat), zoom: s };
          let r = this.lngRange;
          if (!this._renderWorldCopies && r === null) {
            const Y = 179.9999999999;
            r = [-Y, Y];
          }
          const a = this.tileSize * this.zoomScale(c.zoom);
          let h = 0, d = a, _ = 0, w = a, k = 0, T = 0;
          const { x: C, y: z } = this.size;
          if (this.latRange) {
            const Y = this.latRange;
            h = l.Q(Y[1]) * a, d = l.Q(Y[0]) * a, d - h < z && (k = z / (d - h));
          }
          r && (_ = l.b2(l.O(r[0]) * a, 0, a), w = l.b2(l.O(r[1]) * a, 0, a), w < _ && (w += a), w - _ < C && (T = C / (w - _)));
          const { x: R, y: W } = this.project.call({ worldSize: a }, t);
          let Z, G;
          const nt = Math.max(T || 0, k || 0);
          if (nt) {
            const Y = new l.P(T ? (w + _) / 2 : R, k ? (d + h) / 2 : W);
            return c.center = this.unproject.call({ worldSize: a }, Y).wrap(), c.zoom += this.scaleZoom(nt), c;
          }
          if (this.latRange) {
            const Y = z / 2;
            W - Y < h && (G = h + Y), W + Y > d && (G = d - Y);
          }
          if (r) {
            const Y = (_ + w) / 2;
            let J = R;
            this._renderWorldCopies && (J = l.b2(R, Y - a / 2, Y + a / 2));
            const tt = C / 2;
            J - tt < _ && (Z = _ + tt), J + tt > w && (Z = w - tt);
          }
          if (Z !== void 0 || G !== void 0) {
            const Y = new l.P(Z ?? R, G ?? W);
            c.center = this.unproject.call({ worldSize: a }, Y).wrap();
          }
          return c;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = !0;
          const t = this._unmodified, { center: s, zoom: c } = this.getConstrained(this.center, this.zoom);
          this.center = s, this.zoom = c, this._unmodified = t, this._constraining = !1;
        }
        _calcMatrices() {
          if (!this.height) return;
          const t = this.centerOffset, s = this.point.x, c = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = l.b4(1, this.center.lat) * this.worldSize;
          let r = l.an(new Float64Array(16));
          l.K(r, r, [this.width / 2, -this.height / 2, 1]), l.J(r, r, [1, -1, 0]), this.labelPlaneMatrix = r, r = l.an(new Float64Array(16)), l.K(r, r, [1, -1, 1]), l.J(r, r, [-1, -1, 0]), l.K(r, r, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = r;
          const a = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), h = Math.min(this.elevation, this.minElevationForCurrentTile), d = a - h * this._pixelPerMeter / Math.cos(this._pitch), _ = h < 0 ? d : a, w = Math.PI / 2 + this._pitch, k = this._fov * (0.5 + t.y / this.height), T = Math.sin(k) * _ / Math.sin(l.ac(Math.PI - w - k, 0.01, Math.PI - 0.01)), C = this.getHorizon(), z = 2 * Math.atan(C / this.cameraToCenterDistance) * (0.5 + t.y / (2 * C)), R = Math.sin(z) * _ / Math.sin(l.ac(Math.PI - w - z, 0.01, Math.PI - 0.01)), W = Math.min(T, R);
          this.farZ = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * W + _), this.nearZ = this.height / 50, r = new Float64Array(16), l.b5(r, this._fov, this.width / this.height, this.nearZ, this.farZ), r[8] = 2 * -t.x / this.width, r[9] = 2 * t.y / this.height, this.projectionMatrix = l.ae(r), l.K(r, r, [1, -1, 1]), l.J(r, r, [0, 0, -this.cameraToCenterDistance]), l.b6(r, r, this._pitch), l.ad(r, r, this.angle), l.J(r, r, [-s, -c, 0]), this.mercatorMatrix = l.K([], r, [this.worldSize, this.worldSize, this.worldSize]), l.K(r, r, [1, 1, this._pixelPerMeter]), this.pixelMatrix = l.L(new Float64Array(16), this.labelPlaneMatrix, r), l.J(r, r, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = r, this.invModelViewProjectionMatrix = l.as([], r), this.fogMatrix = new Float64Array(16), l.b5(this.fogMatrix, this._fov, this.width / this.height, a, this.farZ), this.fogMatrix[8] = 2 * -t.x / this.width, this.fogMatrix[9] = 2 * t.y / this.height, l.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), l.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), l.b6(this.fogMatrix, this.fogMatrix, this._pitch), l.ad(this.fogMatrix, this.fogMatrix, this.angle), l.J(this.fogMatrix, this.fogMatrix, [-s, -c, 0]), l.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), l.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = l.L(new Float64Array(16), this.labelPlaneMatrix, r);
          const Z = this.width % 2 / 2, G = this.height % 2 / 2, nt = Math.cos(this.angle), Y = Math.sin(this.angle), J = s - Math.round(s) + nt * Z + Y * G, tt = c - Math.round(c) + nt * G + Y * Z, ut = new Float64Array(r);
          if (l.J(ut, ut, [J > 0.5 ? J - 1 : J, tt > 0.5 ? tt - 1 : tt, 0]), this.alignedModelViewProjectionMatrix = ut, r = l.as(new Float64Array(16), this.pixelMatrix), !r) throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = r, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse) return 1;
          const t = this.pointCoordinate(new l.P(0, 0)), s = [t.x * this.worldSize, t.y * this.worldSize, 0, 1];
          return l.af(s, s, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new l.P(0, t));
        }
        getCameraQueryGeometry(t) {
          const s = this.getCameraPoint();
          if (t.length === 1) return [t[0], s];
          {
            let c = s.x, r = s.y, a = s.x, h = s.y;
            for (const d of t) c = Math.min(c, d.x), r = Math.min(r, d.y), a = Math.max(a, d.x), h = Math.max(h, d.y);
            return [new l.P(c, r), new l.P(a, r), new l.P(a, h), new l.P(c, h), new l.P(c, r)];
          }
        }
        lngLatToCameraDepth(t, s) {
          const c = this.locationCoordinate(t), r = [c.x * this.worldSize, c.y * this.worldSize, s, 1];
          return l.af(r, r, this.modelViewProjectionMatrix), r[2] / r[3];
        }
      }
      function zn(p, t) {
        let s, c = !1, r = null, a = null;
        const h = () => {
          r = null, c && (p.apply(a, s), r = setTimeout(h, t), c = !1);
        };
        return (...d) => (c = !0, a = this, s = d, r || h(), r);
      }
      class on {
        constructor(t) {
          this._getCurrentHash = () => {
            const s = window.location.hash.replace("#", "");
            if (this._hashName) {
              let c;
              return s.split("&").map((r) => r.split("=")).forEach((r) => {
                r[0] === this._hashName && (c = r);
              }), (c && c[1] || "").split("/");
            }
            return s.split("/");
          }, this._onHashChange = () => {
            const s = this._getCurrentHash();
            if (s.length >= 3 && !s.some((c) => isNaN(c))) {
              const c = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(s[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+s[2], +s[1]], zoom: +s[0], bearing: c, pitch: +(s[4] || 0) }), !0;
            }
            return !1;
          }, this._updateHashUnthrottled = () => {
            const s = window.location.href.replace(/(#.+)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, s);
          }, this._removeHash = () => {
            const s = this._getCurrentHash();
            if (s.length === 0) return;
            const c = s.join("/");
            let r = c;
            r.split("&").length > 0 && (r = r.split("&")[0]), this._hashName && (r = `${this._hashName}=${c}`);
            let a = window.location.hash.replace(r, "");
            a.startsWith("#&") ? a = a.slice(0, 1) + a.slice(2) : a === "#" && (a = "");
            let h = window.location.href.replace(/(#.+)?$/, a);
            h = h.replace("&&", "&"), window.history.replaceState(window.history.state, null, h);
          }, this._updateHash = zn(this._updateHashUnthrottled, 300), this._hashName = t && encodeURIComponent(t);
        }
        addTo(t) {
          return this._map = t, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(t) {
          const s = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, r = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a = Math.pow(10, r), h = Math.round(s.lng * a) / a, d = Math.round(s.lat * a) / a, _ = this._map.getBearing(), w = this._map.getPitch();
          let k = "";
          if (k += t ? `/${h}/${d}/${c}` : `${c}/${d}/${h}`, (_ || w) && (k += "/" + Math.round(10 * _) / 10), w && (k += `/${Math.round(w)}`), this._hashName) {
            const T = this._hashName;
            let C = !1;
            const z = window.location.hash.slice(1).split("&").map((R) => {
              const W = R.split("=")[0];
              return W === T ? (C = !0, `${W}=${k}`) : R;
            }).filter((R) => R);
            return C || z.push(`${T}=${k}`), `#${z.join("&")}`;
          }
          return `#${k}`;
        }
      }
      const un = { linearity: 0.3, easing: l.b7(0, 0, 0.3, 1) }, Ds = l.e({ deceleration: 2500, maxSpeed: 1400 }, un), Ta = l.e({ deceleration: 20, maxSpeed: 1400 }, un), gs = l.e({ deceleration: 1e3, maxSpeed: 360 }, un), Kn = l.e({ deceleration: 1e3, maxSpeed: 90 }, un);
      class La {
        constructor(t) {
          this._map = t, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: q.now(), settings: t });
        }
        _drainInertiaBuffer() {
          const t = this._inertiaBuffer, s = q.now();
          for (; t.length > 0 && s - t[0].time > 160; ) t.shift();
        }
        _onMoveEnd(t) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const s = { zoom: 0, bearing: 0, pitch: 0, pan: new l.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: a } of this._inertiaBuffer) s.zoom += a.zoomDelta || 0, s.bearing += a.bearingDelta || 0, s.pitch += a.pitchDelta || 0, a.panDelta && s.pan._add(a.panDelta), a.around && (s.around = a.around), a.pinchAround && (s.pinchAround = a.pinchAround);
          const c = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r = {};
          if (s.pan.mag()) {
            const a = dn(s.pan.mag(), c, l.e({}, Ds, t || {}));
            r.offset = s.pan.mult(a.amount / s.pan.mag()), r.center = this._map.transform.center, ln(r, a);
          }
          if (s.zoom) {
            const a = dn(s.zoom, c, Ta);
            r.zoom = this._map.transform.zoom + a.amount, ln(r, a);
          }
          if (s.bearing) {
            const a = dn(s.bearing, c, gs);
            r.bearing = this._map.transform.bearing + l.ac(a.amount, -179, 179), ln(r, a);
          }
          if (s.pitch) {
            const a = dn(s.pitch, c, Kn);
            r.pitch = this._map.transform.pitch + a.amount, ln(r, a);
          }
          if (r.zoom || r.bearing) {
            const a = s.pinchAround === void 0 ? s.around : s.pinchAround;
            r.around = a ? this._map.unproject(a) : this._map.getCenter();
          }
          return this.clear(), l.e(r, { noMoveStart: !0 });
        }
      }
      function ln(p, t) {
        (!p.duration || p.duration < t.duration) && (p.duration = t.duration, p.easing = t.easing);
      }
      function dn(p, t, s) {
        const { maxSpeed: c, linearity: r, deceleration: a } = s, h = l.ac(p * r / (t / 1e3), -c, c), d = Math.abs(h) / (a * r);
        return { easing: s.easing, duration: 1e3 * d, amount: h * (d / 2) };
      }
      class Pi extends l.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, s, c, r = {}) {
          const a = U.mousePos(s.getCanvas(), c), h = s.unproject(a);
          super(t, l.e({ point: a, lngLat: h, originalEvent: c }, r)), this._defaultPrevented = !1, this.target = s;
        }
      }
      class ji extends l.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, s, c) {
          const r = t === "touchend" ? c.changedTouches : c.touches, a = U.touchPos(s.getCanvasContainer(), r), h = a.map((_) => s.unproject(_)), d = a.reduce((_, w, k, T) => _.add(w.div(T.length)), new l.P(0, 0));
          super(t, { points: a, point: d, lngLats: h, lngLat: s.unproject(d), originalEvent: c }), this._defaultPrevented = !1;
        }
      }
      class Ki extends l.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, s, c) {
          super(t, { originalEvent: c }), this._defaultPrevented = !1;
        }
      }
      class gr {
        constructor(t, s) {
          this._map = t, this._clickTolerance = s.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(t) {
          return this._firePreventable(new Ki(t.type, this._map, t));
        }
        mousedown(t, s) {
          return this._mousedownPos = s, this._firePreventable(new Pi(t.type, this._map, t));
        }
        mouseup(t) {
          this._map.fire(new Pi(t.type, this._map, t));
        }
        click(t, s) {
          this._mousedownPos && this._mousedownPos.dist(s) >= this._clickTolerance || this._map.fire(new Pi(t.type, this._map, t));
        }
        dblclick(t) {
          return this._firePreventable(new Pi(t.type, this._map, t));
        }
        mouseover(t) {
          this._map.fire(new Pi(t.type, this._map, t));
        }
        mouseout(t) {
          this._map.fire(new Pi(t.type, this._map, t));
        }
        touchstart(t) {
          return this._firePreventable(new ji(t.type, this._map, t));
        }
        touchmove(t) {
          this._map.fire(new ji(t.type, this._map, t));
        }
        touchend(t) {
          this._map.fire(new ji(t.type, this._map, t));
        }
        touchcancel(t) {
          this._map.fire(new ji(t.type, this._map, t));
        }
        _firePreventable(t) {
          if (this._map.fire(t), t.defaultPrevented) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class ys {
        constructor(t) {
          this._map = t;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(t) {
          this._map.fire(new Pi(t.type, this._map, t));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Pi("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(t) {
          this._delayContextMenu ? this._contextMenuEvent = t : this._ignoreContextMenu || this._map.fire(new Pi(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class bn {
        constructor(t) {
          this._map = t;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(t) {
          return this.transform.pointLocation(l.P.convert(t), this._map.terrain);
        }
      }
      class _s {
        constructor(t, s) {
          this._map = t, this._tr = new bn(t), this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = s.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(t, s) {
          this.isEnabled() && t.shiftKey && t.button === 0 && (U.disableDrag(), this._startPos = this._lastPos = s, this._active = !0);
        }
        mousemoveWindow(t, s) {
          if (!this._active) return;
          const c = s;
          if (this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance) return;
          const r = this._startPos;
          this._lastPos = c, this._box || (this._box = U.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t));
          const a = Math.min(r.x, c.x), h = Math.max(r.x, c.x), d = Math.min(r.y, c.y), _ = Math.max(r.y, c.y);
          U.setTransform(this._box, `translate(${a}px,${d}px)`), this._box.style.width = h - a + "px", this._box.style.height = _ - d + "px";
        }
        mouseupWindow(t, s) {
          if (!this._active || t.button !== 0) return;
          const c = this._startPos, r = s;
          if (this.reset(), U.suppressClick(), c.x !== r.x || c.y !== r.y) return this._map.fire(new l.k("boxzoomend", { originalEvent: t })), { cameraAnimation: (a) => a.fitScreenCoordinates(c, r, this._tr.bearing, { linear: !0 }) };
          this._fireEvent("boxzoomcancel", t);
        }
        keydown(t) {
          this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (U.remove(this._box), this._box = null), U.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t, s) {
          return this._map.fire(new l.k(t, { originalEvent: s }));
        }
      }
      function sa(p, t) {
        if (p.length !== t.length) throw new Error(`The number of touches and points are not equal - touches ${p.length}, points ${t.length}`);
        const s = {};
        for (let c = 0; c < p.length; c++) s[p[c].identifier] = t[c];
        return s;
      }
      class Yl {
        constructor(t) {
          this.reset(), this.numTouches = t.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(t, s, c) {
          (this.centroid || c.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = t.timeStamp), c.length === this.numTouches && (this.centroid = function(r) {
            const a = new l.P(0, 0);
            for (const h of r) a._add(h);
            return a.div(r.length);
          }(s), this.touches = sa(c, s)));
        }
        touchmove(t, s, c) {
          if (this.aborted || !this.centroid) return;
          const r = sa(c, s);
          for (const a in this.touches) {
            const h = r[a];
            (!h || h.dist(this.touches[a]) > 30) && (this.aborted = !0);
          }
        }
        touchend(t, s, c) {
          if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), c.length === 0) {
            const r = !this.aborted && this.centroid;
            if (this.reset(), r) return r;
          }
        }
      }
      class $o {
        constructor(t) {
          this.singleTap = new Yl(t), this.numTaps = t.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(t, s, c) {
          this.singleTap.touchstart(t, s, c);
        }
        touchmove(t, s, c) {
          this.singleTap.touchmove(t, s, c);
        }
        touchend(t, s, c) {
          const r = this.singleTap.touchend(t, s, c);
          if (r) {
            const a = t.timeStamp - this.lastTime < 500, h = !this.lastTap || this.lastTap.dist(r) < 30;
            if (a && h || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = r, this.count === this.numTaps) return this.reset(), r;
          }
        }
      }
      class hr {
        constructor(t) {
          this._tr = new bn(t), this._zoomIn = new $o({ numTouches: 1, numTaps: 2 }), this._zoomOut = new $o({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(t, s, c) {
          this._zoomIn.touchstart(t, s, c), this._zoomOut.touchstart(t, s, c);
        }
        touchmove(t, s, c) {
          this._zoomIn.touchmove(t, s, c), this._zoomOut.touchmove(t, s, c);
        }
        touchend(t, s, c) {
          const r = this._zoomIn.touchend(t, s, c), a = this._zoomOut.touchend(t, s, c), h = this._tr;
          return r ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (d) => d.easeTo({ duration: 300, zoom: h.zoom + 1, around: h.unproject(r) }, { originalEvent: t }) }) : a ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (d) => d.easeTo({ duration: 300, zoom: h.zoom - 1, around: h.unproject(a) }, { originalEvent: t }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Dn {
        constructor(t) {
          this._enabled = !!t.enable, this._moveStateManager = t.moveStateManager, this._clickTolerance = t.clickTolerance || 1, this._moveFunction = t.move, this._activateOnStart = !!t.activateOnStart, t.assignEvents(this), this.reset();
        }
        reset(t) {
          this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(t);
        }
        _move(...t) {
          const s = this._moveFunction(...t);
          if (s.bearingDelta || s.pitchDelta || s.around || s.panDelta) return this._active = !0, s;
        }
        dragStart(t, s) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t) && (this._moveStateManager.startMove(t), this._lastPoint = s.length ? s[0] : s, this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(t, s) {
          if (!this.isEnabled()) return;
          const c = this._lastPoint;
          if (!c) return;
          if (t.preventDefault(), !this._moveStateManager.isValidMoveEvent(t)) return void this.reset(t);
          const r = s.length ? s[0] : s;
          return !this._moved && r.dist(c) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = r, this._move(c, r));
        }
        dragEnd(t) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t) && (this._moved && U.suppressClick(), this.reset(t));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const wn = { 0: 1, 2: 2 };
      class no {
        constructor(t) {
          this._correctEvent = t.checkCorrectEvent;
        }
        startMove(t) {
          const s = U.mouseButton(t);
          this._eventButton = s;
        }
        endMove(t) {
          delete this._eventButton;
        }
        isValidStartEvent(t) {
          return this._correctEvent(t);
        }
        isValidMoveEvent(t) {
          return !function(s, c) {
            const r = wn[c];
            return s.buttons === void 0 || (s.buttons & r) !== r;
          }(t, this._eventButton);
        }
        isValidEndEvent(t) {
          return U.mouseButton(t) === this._eventButton;
        }
      }
      class so {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(t) {
          return t.targetTouches.length === 1;
        }
        _isSameTouchEvent(t) {
          return t.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(t) {
          this._firstTouch = t.targetTouches[0].identifier;
        }
        endMove(t) {
          delete this._firstTouch;
        }
        isValidStartEvent(t) {
          return this._isOneFingerTouch(t);
        }
        isValidMoveEvent(t) {
          return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
        }
        isValidEndEvent(t) {
          return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
        }
      }
      const Ca = (p) => {
        p.mousedown = p.dragStart, p.mousemoveWindow = p.dragMove, p.mouseup = p.dragEnd, p.contextmenu = (t) => {
          t.preventDefault();
        };
      }, wr = ({ enable: p, clickTolerance: t, bearingDegreesPerPixelMoved: s = 0.8 }) => {
        const c = new no({ checkCorrectEvent: (r) => U.mouseButton(r) === 0 && r.ctrlKey || U.mouseButton(r) === 2 });
        return new Dn({ clickTolerance: t, move: (r, a) => ({ bearingDelta: (a.x - r.x) * s }), moveStateManager: c, enable: p, assignEvents: Ca });
      }, Fr = ({ enable: p, clickTolerance: t, pitchDegreesPerPixelMoved: s = -0.5 }) => {
        const c = new no({ checkCorrectEvent: (r) => U.mouseButton(r) === 0 && r.ctrlKey || U.mouseButton(r) === 2 });
        return new Dn({ clickTolerance: t, move: (r, a) => ({ pitchDelta: (a.y - r.y) * s }), moveStateManager: c, enable: p, assignEvents: Ca });
      };
      class ao {
        constructor(t, s) {
          this._clickTolerance = t.clickTolerance || 1, this._map = s, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new l.P(0, 0);
        }
        _shouldBePrevented(t) {
          return t < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(t, s, c) {
          return this._calculateTransform(t, s, c);
        }
        touchmove(t, s, c) {
          if (this._active) {
            if (!this._shouldBePrevented(c.length)) return t.preventDefault(), this._calculateTransform(t, s, c);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", t);
          }
        }
        touchend(t, s, c) {
          this._calculateTransform(t, s, c), this._active && this._shouldBePrevented(c.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t, s, c) {
          c.length > 0 && (this._active = !0);
          const r = sa(c, s), a = new l.P(0, 0), h = new l.P(0, 0);
          let d = 0;
          for (const w in r) {
            const k = r[w], T = this._touches[w];
            T && (a._add(k), h._add(k.sub(T)), d++, r[w] = k);
          }
          if (this._touches = r, this._shouldBePrevented(d) || !h.mag()) return;
          const _ = h.div(d);
          return this._sum._add(_), this._sum.mag() < this._clickTolerance ? void 0 : { around: a.div(d), panDelta: _ };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ea {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        touchstart(t, s, c) {
          this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([s[0], s[1]]));
        }
        touchmove(t, s, c) {
          if (!this._firstTwoTouches) return;
          t.preventDefault();
          const [r, a] = this._firstTwoTouches, h = oo(c, s, r), d = oo(c, s, a);
          if (!h || !d) return;
          const _ = this._aroundCenter ? null : h.add(d).div(2);
          return this._move([h, d], _, t);
        }
        touchend(t, s, c) {
          if (!this._firstTwoTouches) return;
          const [r, a] = this._firstTwoTouches, h = oo(c, s, r), d = oo(c, s, a);
          h && d || (this._active && U.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(t) {
          this._enabled = !0, this._aroundCenter = !!t && t.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function oo(p, t, s) {
        for (let c = 0; c < p.length; c++) if (p[c].identifier === s) return t[c];
      }
      function lo(p, t) {
        return Math.log(p / t) / Math.LN2;
      }
      class co extends Ea {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(t) {
          this._startDistance = this._distance = t[0].dist(t[1]);
        }
        _move(t, s) {
          const c = this._distance;
          if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(lo(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: lo(this._distance, c), pinchAround: s };
        }
      }
      function Zo(p, t) {
        return 180 * p.angleWith(t) / Math.PI;
      }
      class Ns extends Ea {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(t) {
          this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);
        }
        _move(t, s, c) {
          const r = this._vector;
          if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: Zo(this._vector, r), pinchAround: s };
        }
        _isBelowThreshold(t) {
          this._minDiameter = Math.min(this._minDiameter, t.mag());
          const s = 25 / (Math.PI * this._minDiameter) * 360, c = Zo(t, this._startVector);
          return Math.abs(c) < s;
        }
      }
      function ho(p) {
        return Math.abs(p.y) > Math.abs(p.x);
      }
      class Go extends Ea {
        constructor(t) {
          super(), this._currentTouchCount = 0, this._map = t;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(t, s, c) {
          super.touchstart(t, s, c), this._currentTouchCount = c.length;
        }
        _start(t) {
          this._lastPoints = t, ho(t[0].sub(t[1])) && (this._valid = !1);
        }
        _move(t, s, c) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
          const r = t[0].sub(this._lastPoints[0]), a = t[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(r, a, c.timeStamp), this._valid ? (this._lastPoints = t, this._active = !0, { pitchDelta: (r.y + a.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(t, s, c) {
          if (this._valid !== void 0) return this._valid;
          const r = t.mag() >= 2, a = s.mag() >= 2;
          if (!r && !a) return;
          if (!r || !a) return this._firstMove === void 0 && (this._firstMove = c), c - this._firstMove < 100 && void 0;
          const h = t.y > 0 == s.y > 0;
          return ho(t) && ho(s) && h;
        }
      }
      const Wo = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Ho {
        constructor(t) {
          this._tr = new bn(t);
          const s = Wo;
          this._panStep = s.panStep, this._bearingStep = s.bearingStep, this._pitchStep = s.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(t) {
          if (t.altKey || t.ctrlKey || t.metaKey) return;
          let s = 0, c = 0, r = 0, a = 0, h = 0;
          switch (t.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              s = 1;
              break;
            case 189:
            case 109:
            case 173:
              s = -1;
              break;
            case 37:
              t.shiftKey ? c = -1 : (t.preventDefault(), a = -1);
              break;
            case 39:
              t.shiftKey ? c = 1 : (t.preventDefault(), a = 1);
              break;
            case 38:
              t.shiftKey ? r = 1 : (t.preventDefault(), h = -1);
              break;
            case 40:
              t.shiftKey ? r = -1 : (t.preventDefault(), h = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (c = 0, r = 0), { cameraAnimation: (d) => {
            const _ = this._tr;
            d.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Jl, zoom: s ? Math.round(_.zoom) + s * (t.shiftKey ? 2 : 1) : _.zoom, bearing: _.bearing + c * this._bearingStep, pitch: _.pitch + r * this._pitchStep, offset: [-a * this._panStep, -h * this._panStep], center: _.center }, { originalEvent: t });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function Jl(p) {
        return p * (2 - p);
      }
      const Tl = 4.000244140625;
      class hl {
        constructor(t, s) {
          this._onTimeout = (c) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(c);
          }, this._map = t, this._tr = new bn(t), this._triggerRenderFrame = s, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(t) {
          this._defaultZoomRate = t;
        }
        setWheelZoomRate(t) {
          this._wheelZoomRate = t;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(t) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        _shouldBePrevented(t) {
          return !!this._map.cooperativeGestures.isEnabled() && !(t.ctrlKey || this._map.cooperativeGestures.isBypassed(t));
        }
        wheel(t) {
          if (!this.isEnabled()) return;
          if (this._shouldBePrevented(t)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", t);
          let s = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
          const c = q.now(), r = c - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = c, s !== 0 && s % Tl == 0 ? this._type = "wheel" : s !== 0 && Math.abs(s) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = s, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(r * s) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, s += this._lastValue)), t.shiftKey && s && (s /= 4), this._type && (this._lastWheelEvent = t, this._delta -= s, this._active || this._start(t)), t.preventDefault();
        }
        _start(t) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const s = U.mousePos(this._map.getCanvas(), t), c = this._tr;
          this._around = s.y > c.transform.height / 2 - c.transform.getHorizon() ? l.N.convert(this._aroundCenter ? c.center : c.unproject(s)) : l.N.convert(c.center), this._aroundPoint = c.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          const t = this._tr.transform;
          if (this._delta !== 0) {
            const _ = this._type === "wheel" && Math.abs(this._delta) > Tl ? this._wheelZoomRate : this._defaultZoomRate;
            let w = 2 / (1 + Math.exp(-Math.abs(this._delta * _)));
            this._delta < 0 && w !== 0 && (w = 1 / w);
            const k = typeof this._targetZoom == "number" ? t.zoomScale(this._targetZoom) : t.scale;
            this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(k * w))), this._type === "wheel" && (this._startZoom = t.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const s = typeof this._targetZoom == "number" ? this._targetZoom : t.zoom, c = this._startZoom, r = this._easing;
          let a, h = !1;
          const d = q.now() - this._lastWheelEventTime;
          if (this._type === "wheel" && c && r && d) {
            const _ = Math.min(d / 200, 1), w = r(_);
            a = l.y.number(c, s, w), _ < 1 ? this._frameId || (this._frameId = !0) : h = !0;
          } else a = s, h = !0;
          return this._active = !0, h && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !h, zoomDelta: a - t.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t) {
          let s = l.b8;
          if (this._prevEase) {
            const c = this._prevEase, r = (q.now() - c.start) / c.duration, a = c.easing(r + 0.01) - c.easing(r), h = 0.27 / Math.sqrt(a * a + 1e-4) * 0.01, d = Math.sqrt(0.0729 - h * h);
            s = l.b7(h, d, 0.25, 1);
          }
          return this._prevEase = { start: q.now(), duration: t, easing: s }, s;
        }
        reset() {
          this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class uo {
        constructor(t, s) {
          this._clickZoom = t, this._tapZoom = s;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Kl {
        constructor(t) {
          this._tr = new bn(t), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(t, s) {
          return t.preventDefault(), { cameraAnimation: (c) => {
            c.easeTo({ duration: 300, zoom: this._tr.zoom + (t.shiftKey ? -1 : 1), around: this._tr.unproject(s) }, { originalEvent: t });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Qn {
        constructor() {
          this._tap = new $o({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(t, s, c) {
          if (!this._swipePoint) if (this._tapTime) {
            const r = s[0], a = t.timeStamp - this._tapTime < 500, h = this._tapPoint.dist(r) < 30;
            a && h ? c.length > 0 && (this._swipePoint = r, this._swipeTouch = c[0].identifier) : this.reset();
          } else this._tap.touchstart(t, s, c);
        }
        touchmove(t, s, c) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (c[0].identifier !== this._swipeTouch) return;
              const r = s[0], a = r.y - this._swipePoint.y;
              return this._swipePoint = r, t.preventDefault(), this._active = !0, { zoomDelta: a / 128 };
            }
          } else this._tap.touchmove(t, s, c);
        }
        touchend(t, s, c) {
          if (this._tapTime) this._swipePoint && c.length === 0 && this.reset();
          else {
            const r = this._tap.touchend(t, s, c);
            r && (this._tapTime = t.timeStamp, this._tapPoint = r);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ts {
        constructor(t, s, c) {
          this._el = t, this._mousePan = s, this._touchPan = c;
        }
        enable(t) {
          this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class Ll {
        constructor(t, s, c) {
          this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = s, this._mousePitch = c;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class Sn {
        constructor(t, s, c, r) {
          this._el = t, this._touchZoom = s, this._touchRotate = c, this._tapDragZoom = r, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(t) {
          this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class Fs {
        constructor(t, s) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = t, this._options = s, this._enabled = !1;
        }
        isActive() {
          return !1;
        }
        reset() {
        }
        _setupUI() {
          if (this._container) return;
          const t = this._map.getCanvasContainer();
          t.classList.add("maplibregl-cooperative-gestures"), this._container = U.create("div", "maplibregl-cooperative-gesture-screen", t);
          let s = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (s = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const c = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), r = document.createElement("div");
          r.className = "maplibregl-desktop-message", r.textContent = s, this._container.appendChild(r);
          const a = document.createElement("div");
          a.className = "maplibregl-mobile-message", a.textContent = c, this._container.appendChild(a), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (U.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(t) {
          return t[this._bypassKey];
        }
        notifyGestureBlocked(t, s) {
          this._enabled && (this._map.fire(new l.k("cooperativegestureprevented", { gestureType: t, originalEvent: s })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const aa = (p) => p.zoom || p.drag || p.pitch || p.rotate;
      class Dc extends l.k {
      }
      function Cl(p) {
        return p.panDelta && p.panDelta.mag() || p.zoomDelta || p.bearingDelta || p.pitchDelta;
      }
      class Ql {
        constructor(t, s) {
          this.handleWindowEvent = (r) => {
            this.handleEvent(r, `${r.type}Window`);
          }, this.handleEvent = (r, a) => {
            if (r.type === "blur") return void this.stop(!0);
            this._updatingCamera = !0;
            const h = r.type === "renderFrame" ? void 0 : r, d = { needsRenderFrame: !1 }, _ = {}, w = {}, k = r.touches, T = k ? this._getMapTouches(k) : void 0, C = T ? U.touchPos(this._map.getCanvas(), T) : U.mousePos(this._map.getCanvas(), r);
            for (const { handlerName: W, handler: Z, allowed: G } of this._handlers) {
              if (!Z.isEnabled()) continue;
              let nt;
              this._blockedByActive(w, G, W) ? Z.reset() : Z[a || r.type] && (nt = Z[a || r.type](r, C, T), this.mergeHandlerResult(d, _, nt, W, h), nt && nt.needsRenderFrame && this._triggerRenderFrame()), (nt || Z.isActive()) && (w[W] = Z);
            }
            const z = {};
            for (const W in this._previousActiveHandlers) w[W] || (z[W] = h);
            this._previousActiveHandlers = w, (Object.keys(z).length || Cl(d)) && (this._changes.push([d, _, z]), this._triggerRenderFrame()), (Object.keys(w).length || Cl(d)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: R } = d;
            R && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], R(this._map));
          }, this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new La(t), this._bearingSnap = s.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(s);
          const c = this._el;
          this._listeners = [[c, "touchstart", { passive: !0 }], [c, "touchmove", { passive: !1 }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: !1 }], [c, "keyup", void 0], [c, "wheel", { passive: !1 }], [c, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [r, a, h] of this._listeners) U.addEventListener(r, a, r === document ? this.handleWindowEvent : this.handleEvent, h);
        }
        destroy() {
          for (const [t, s, c] of this._listeners) U.removeEventListener(t, s, t === document ? this.handleWindowEvent : this.handleEvent, c);
        }
        _addDefaultHandlers(t) {
          const s = this._map, c = s.getCanvasContainer();
          this._add("mapEvent", new gr(s, t));
          const r = s.boxZoom = new _s(s, t);
          this._add("boxZoom", r), t.interactive && t.boxZoom && r.enable();
          const a = s.cooperativeGestures = new Fs(s, t.cooperativeGestures);
          this._add("cooperativeGestures", a), t.cooperativeGestures && a.enable();
          const h = new hr(s), d = new Kl(s);
          s.doubleClickZoom = new uo(d, h), this._add("tapZoom", h), this._add("clickZoom", d), t.interactive && t.doubleClickZoom && s.doubleClickZoom.enable();
          const _ = new Qn();
          this._add("tapDragZoom", _);
          const w = s.touchPitch = new Go(s);
          this._add("touchPitch", w), t.interactive && t.touchPitch && s.touchPitch.enable(t.touchPitch);
          const k = wr(t), T = Fr(t);
          s.dragRotate = new Ll(t, k, T), this._add("mouseRotate", k, ["mousePitch"]), this._add("mousePitch", T, ["mouseRotate"]), t.interactive && t.dragRotate && s.dragRotate.enable();
          const C = (({ enable: nt, clickTolerance: Y }) => {
            const J = new no({ checkCorrectEvent: (tt) => U.mouseButton(tt) === 0 && !tt.ctrlKey });
            return new Dn({ clickTolerance: Y, move: (tt, ut) => ({ around: ut, panDelta: ut.sub(tt) }), activateOnStart: !0, moveStateManager: J, enable: nt, assignEvents: Ca });
          })(t), z = new ao(t, s);
          s.dragPan = new ts(c, C, z), this._add("mousePan", C), this._add("touchPan", z, ["touchZoom", "touchRotate"]), t.interactive && t.dragPan && s.dragPan.enable(t.dragPan);
          const R = new Ns(), W = new co();
          s.touchZoomRotate = new Sn(c, W, R, _), this._add("touchRotate", R, ["touchPan", "touchZoom"]), this._add("touchZoom", W, ["touchPan", "touchRotate"]), t.interactive && t.touchZoomRotate && s.touchZoomRotate.enable(t.touchZoomRotate);
          const Z = s.scrollZoom = new hl(s, () => this._triggerRenderFrame());
          this._add("scrollZoom", Z, ["mousePan"]), t.interactive && t.scrollZoom && s.scrollZoom.enable(t.scrollZoom);
          const G = s.keyboard = new Ho(s);
          this._add("keyboard", G), t.interactive && t.keyboard && s.keyboard.enable(), this._add("blockableMapEvent", new ys(s));
        }
        _add(t, s, c) {
          this._handlers.push({ handlerName: t, handler: s, allowed: c }), this._handlersById[t] = s;
        }
        stop(t) {
          if (!this._updatingCamera) {
            for (const { handler: s } of this._handlers) s.reset();
            this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: t } of this._handlers) if (t.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!aa(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(t, s, c) {
          for (const r in t) if (r !== c && (!s || s.indexOf(r) < 0)) return !0;
          return !1;
        }
        _getMapTouches(t) {
          const s = [];
          for (const c of t) this._el.contains(c.target) && s.push(c);
          return s;
        }
        mergeHandlerResult(t, s, c, r, a) {
          if (!c) return;
          l.e(t, c);
          const h = { handlerName: r, originalEvent: c.originalEvent || a };
          c.zoomDelta !== void 0 && (s.zoom = h), c.panDelta !== void 0 && (s.drag = h), c.pitchDelta !== void 0 && (s.pitch = h), c.bearingDelta !== void 0 && (s.rotate = h);
        }
        _applyChanges() {
          const t = {}, s = {}, c = {};
          for (const [r, a, h] of this._changes) r.panDelta && (t.panDelta = (t.panDelta || new l.P(0, 0))._add(r.panDelta)), r.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + r.pitchDelta), r.around !== void 0 && (t.around = r.around), r.pinchAround !== void 0 && (t.pinchAround = r.pinchAround), r.noInertia && (t.noInertia = r.noInertia), l.e(s, a), l.e(c, h);
          this._updateMapTransform(t, s, c), this._changes = [];
        }
        _updateMapTransform(t, s, c) {
          const r = this._map, a = r._getTransformForUpdate(), h = r.terrain;
          if (!(Cl(t) || h && this._terrainMovement)) return this._fireEvents(s, c, !0);
          let { panDelta: d, zoomDelta: _, bearingDelta: w, pitchDelta: k, around: T, pinchAround: C } = t;
          C !== void 0 && (T = C), r._stop(!0), T = T || r.transform.centerPoint;
          const z = a.pointLocation(d ? T.sub(d) : T);
          w && (a.bearing += w), k && (a.pitch += k), _ && (a.zoom += _), h ? this._terrainMovement || !s.drag && !s.zoom ? s.drag && this._terrainMovement ? a.center = a.pointLocation(a.centerPoint.sub(d)) : a.setLocationAtPoint(z, T) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, a.setLocationAtPoint(z, T)) : a.setLocationAtPoint(z, T), r._applyUpdatedTransform(a), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(s, c, !0);
        }
        _fireEvents(t, s, c) {
          const r = aa(this._eventsInProgress), a = aa(t), h = {};
          for (const T in t) {
            const { originalEvent: C } = t[T];
            this._eventsInProgress[T] || (h[`${T}start`] = C), this._eventsInProgress[T] = t[T];
          }
          !r && a && this._fireEvent("movestart", a.originalEvent);
          for (const T in h) this._fireEvent(T, h[T]);
          a && this._fireEvent("move", a.originalEvent);
          for (const T in t) {
            const { originalEvent: C } = t[T];
            this._fireEvent(T, C);
          }
          const d = {};
          let _;
          for (const T in this._eventsInProgress) {
            const { handlerName: C, originalEvent: z } = this._eventsInProgress[T];
            this._handlersById[C].isActive() || (delete this._eventsInProgress[T], _ = s[C] || z, d[`${T}end`] = _);
          }
          for (const T in d) this._fireEvent(T, d[T]);
          const w = aa(this._eventsInProgress), k = (r || a) && !w;
          if (k && this._terrainMovement) {
            this._map._elevationFreeze = !1, this._terrainMovement = !1;
            const T = this._map._getTransformForUpdate();
            T.recalculateZoom(this._map.terrain), this._map._applyUpdatedTransform(T);
          }
          if (c && k) {
            this._updatingCamera = !0;
            const T = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), C = (z) => z !== 0 && -this._bearingSnap < z && z < this._bearingSnap;
            !T || !T.essential && q.prefersReducedMotion ? (this._map.fire(new l.k("moveend", { originalEvent: _ })), C(this._map.getBearing()) && this._map.resetNorth()) : (C(T.bearing || this._map.getBearing()) && (T.bearing = 0), T.freezeElevation = !0, this._map.easeTo(T, { originalEvent: _ })), this._updatingCamera = !1;
          }
        }
        _fireEvent(t, s) {
          this._map.fire(new l.k(t, s ? { originalEvent: s } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t) => {
            delete this._frameId, this.handleEvent(new Dc("renderFrame", { timeStamp: t })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class tc extends l.E {
        constructor(t, s) {
          super(), this._renderFrameCallback = () => {
            const c = Math.min((q.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(c)), c < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = s.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new l.N(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(t, s) {
          return this.jumpTo({ center: t }, s);
        }
        panBy(t, s, c) {
          return t = l.P.convert(t).mult(-1), this.panTo(this.transform.center, l.e({ offset: t }, s), c);
        }
        panTo(t, s, c) {
          return this.easeTo(l.e({ center: t }, s), c);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(t, s) {
          return this.jumpTo({ zoom: t }, s), this;
        }
        zoomTo(t, s, c) {
          return this.easeTo(l.e({ zoom: t }, s), c);
        }
        zoomIn(t, s) {
          return this.zoomTo(this.getZoom() + 1, t, s), this;
        }
        zoomOut(t, s) {
          return this.zoomTo(this.getZoom() - 1, t, s), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(t, s) {
          return this.jumpTo({ bearing: t }, s), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(t, s) {
          return this.jumpTo({ padding: t }, s), this;
        }
        rotateTo(t, s, c) {
          return this.easeTo(l.e({ bearing: t }, s), c);
        }
        resetNorth(t, s) {
          return this.rotateTo(0, l.e({ duration: 1e3 }, t), s), this;
        }
        resetNorthPitch(t, s) {
          return this.easeTo(l.e({ bearing: 0, pitch: 0, duration: 1e3 }, t), s), this;
        }
        snapToNorth(t, s) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, s) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(t, s) {
          return this.jumpTo({ pitch: t }, s), this;
        }
        cameraForBounds(t, s) {
          t = K.convert(t);
          const c = s && s.bearing || 0;
          return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), c, s);
        }
        _cameraForBoxAndBearing(t, s, c, r) {
          const a = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (r = l.e({ padding: a, offset: [0, 0], maxZoom: this.transform.maxZoom }, r)).padding == "number") {
            const Zt = r.padding;
            r.padding = { top: Zt, bottom: Zt, right: Zt, left: Zt };
          }
          r.padding = l.e(a, r.padding);
          const h = this.transform, d = h.padding, _ = new K(t, s), w = h.project(_.getNorthWest()), k = h.project(_.getNorthEast()), T = h.project(_.getSouthEast()), C = h.project(_.getSouthWest()), z = l.b9(-c), R = w.rotate(z), W = k.rotate(z), Z = T.rotate(z), G = C.rotate(z), nt = new l.P(Math.max(R.x, W.x, G.x, Z.x), Math.max(R.y, W.y, G.y, Z.y)), Y = new l.P(Math.min(R.x, W.x, G.x, Z.x), Math.min(R.y, W.y, G.y, Z.y)), J = nt.sub(Y), tt = (h.width - (d.left + d.right + r.padding.left + r.padding.right)) / J.x, ut = (h.height - (d.top + d.bottom + r.padding.top + r.padding.bottom)) / J.y;
          if (ut < 0 || tt < 0) return void l.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const St = Math.min(h.scaleZoom(h.scale * Math.min(tt, ut)), r.maxZoom), It = l.P.convert(r.offset), Gt = new l.P((r.padding.left - r.padding.right) / 2, (r.padding.top - r.padding.bottom) / 2).rotate(l.b9(c)), qt = It.add(Gt).mult(h.scale / h.zoomScale(St));
          return { center: h.unproject(w.add(T).div(2).sub(qt)), zoom: St, bearing: c };
        }
        fitBounds(t, s, c) {
          return this._fitInternal(this.cameraForBounds(t, s), s, c);
        }
        fitScreenCoordinates(t, s, c, r, a) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(l.P.convert(t)), this.transform.pointLocation(l.P.convert(s)), c, r), r, a);
        }
        _fitInternal(t, s, c) {
          return t ? (delete (s = l.e(t, s)).padding, s.linear ? this.easeTo(s, c) : this.flyTo(s, c)) : this;
        }
        jumpTo(t, s) {
          this.stop();
          const c = this._getTransformForUpdate();
          let r = !1, a = !1, h = !1;
          return "zoom" in t && c.zoom !== +t.zoom && (r = !0, c.zoom = +t.zoom), t.center !== void 0 && (c.center = l.N.convert(t.center)), "bearing" in t && c.bearing !== +t.bearing && (a = !0, c.bearing = +t.bearing), "pitch" in t && c.pitch !== +t.pitch && (h = !0, c.pitch = +t.pitch), t.padding == null || c.isPaddingEqual(t.padding) || (c.padding = t.padding), this._applyUpdatedTransform(c), this.fire(new l.k("movestart", s)).fire(new l.k("move", s)), r && this.fire(new l.k("zoomstart", s)).fire(new l.k("zoom", s)).fire(new l.k("zoomend", s)), a && this.fire(new l.k("rotatestart", s)).fire(new l.k("rotate", s)).fire(new l.k("rotateend", s)), h && this.fire(new l.k("pitchstart", s)).fire(new l.k("pitch", s)).fire(new l.k("pitchend", s)), this.fire(new l.k("moveend", s));
        }
        calculateCameraOptionsFromTo(t, s, c, r = 0) {
          const a = l.Z.fromLngLat(t, s), h = l.Z.fromLngLat(c, r), d = h.x - a.x, _ = h.y - a.y, w = h.z - a.z, k = Math.hypot(d, _, w);
          if (k === 0) throw new Error("Can't calculate camera options with same From and To");
          const T = Math.hypot(d, _), C = this.transform.scaleZoom(this.transform.cameraToCenterDistance / k / this.transform.tileSize), z = 180 * Math.atan2(d, -_) / Math.PI;
          let R = 180 * Math.acos(T / k) / Math.PI;
          return R = w < 0 ? 90 - R : 90 + R, { center: h.toLngLat(), zoom: C, pitch: R, bearing: z };
        }
        easeTo(t, s) {
          var c;
          this._stop(!1, t.easeId), ((t = l.e({ offset: [0, 0], duration: 500, easing: l.b8 }, t)).animate === !1 || !t.essential && q.prefersReducedMotion) && (t.duration = 0);
          const r = this._getTransformForUpdate(), a = r.zoom, h = r.bearing, d = r.pitch, _ = r.padding, w = "bearing" in t ? this._normalizeBearing(t.bearing, h) : h, k = "pitch" in t ? +t.pitch : d, T = "padding" in t ? t.padding : r.padding, C = l.P.convert(t.offset);
          let z = r.centerPoint.add(C);
          const R = r.pointLocation(z), { center: W, zoom: Z } = r.getConstrained(l.N.convert(t.center || R), (c = t.zoom) !== null && c !== void 0 ? c : a);
          this._normalizeCenter(W, r);
          const G = r.project(R), nt = r.project(W).sub(G), Y = r.zoomScale(Z - a);
          let J, tt;
          t.around && (J = l.N.convert(t.around), tt = r.locationPoint(J));
          const ut = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || Z !== a, this._rotating = this._rotating || h !== w, this._pitching = this._pitching || k !== d, this._padding = !r.isPaddingEqual(T), this._easeId = t.easeId, this._prepareEase(s, t.noMoveStart, ut), this.terrain && this._prepareElevation(W), this._ease((St) => {
            if (this._zooming && (r.zoom = l.y.number(a, Z, St)), this._rotating && (r.bearing = l.y.number(h, w, St)), this._pitching && (r.pitch = l.y.number(d, k, St)), this._padding && (r.interpolatePadding(_, T, St), z = r.centerPoint.add(C)), this.terrain && !t.freezeElevation && this._updateElevation(St), J) r.setLocationAtPoint(J, tt);
            else {
              const It = r.zoomScale(r.zoom - a), Gt = Z > a ? Math.min(2, Y) : Math.max(0.5, Y), qt = Math.pow(Gt, 1 - St), Zt = r.unproject(G.add(nt.mult(St * qt)).mult(It));
              r.setLocationAtPoint(r.renderWorldCopies ? Zt.wrap() : Zt, z);
            }
            this._applyUpdatedTransform(r), this._fireMoveEvents(s);
          }, (St) => {
            this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(s, St);
          }, t), this;
        }
        _prepareEase(t, s, c = {}) {
          this._moving = !0, s || c.moving || this.fire(new l.k("movestart", t)), this._zooming && !c.zooming && this.fire(new l.k("zoomstart", t)), this._rotating && !c.rotating && this.fire(new l.k("rotatestart", t)), this._pitching && !c.pitching && this.fire(new l.k("pitchstart", t));
        }
        _prepareElevation(t) {
          this._elevationCenter = t, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t, this.transform.tileZoom), this._elevationFreeze = !0;
        }
        _updateElevation(t) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const s = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (t < 1 && s !== this._elevationTarget) {
            const c = this._elevationTarget - this._elevationStart;
            this._elevationStart += t * (c - (s - (c * t + this._elevationStart)) / (1 - t)), this._elevationTarget = s;
          }
          this.transform.elevation = l.y.number(this._elevationStart, this._elevationTarget, t);
        }
        _finalizeElevation() {
          this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(t) {
          const s = t.getCameraPosition(), c = this.terrain.getElevationForLngLatZoom(s.lngLat, t.zoom);
          if (s.altitude < c) {
            const r = this.calculateCameraOptionsFromTo(s.lngLat, c, t.center, t.elevation);
            return { pitch: r.pitch, zoom: r.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(t) {
          const s = [];
          if (this.terrain && s.push((r) => this._elevateCameraIfInsideTerrain(r)), this.transformCameraUpdate && s.push((r) => this.transformCameraUpdate(r)), !s.length) return;
          const c = t.clone();
          for (const r of s) {
            const a = c.clone(), { center: h, zoom: d, pitch: _, bearing: w, elevation: k } = r(a);
            h && (a.center = h), d !== void 0 && (a.zoom = d), _ !== void 0 && (a.pitch = _), w !== void 0 && (a.bearing = w), k !== void 0 && (a.elevation = k), c.apply(a);
          }
          this.transform.apply(c);
        }
        _fireMoveEvents(t) {
          this.fire(new l.k("move", t)), this._zooming && this.fire(new l.k("zoom", t)), this._rotating && this.fire(new l.k("rotate", t)), this._pitching && this.fire(new l.k("pitch", t));
        }
        _afterEase(t, s) {
          if (this._easeId && s && this._easeId === s) return;
          delete this._easeId;
          const c = this._zooming, r = this._rotating, a = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, c && this.fire(new l.k("zoomend", t)), r && this.fire(new l.k("rotateend", t)), a && this.fire(new l.k("pitchend", t)), this.fire(new l.k("moveend", t));
        }
        flyTo(t, s) {
          var c;
          if (!t.essential && q.prefersReducedMotion) {
            const de = l.M(t, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(de, s);
          }
          this.stop(), t = l.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: l.b8 }, t);
          const r = this._getTransformForUpdate(), a = r.zoom, h = r.bearing, d = r.pitch, _ = r.padding, w = "bearing" in t ? this._normalizeBearing(t.bearing, h) : h, k = "pitch" in t ? +t.pitch : d, T = "padding" in t ? t.padding : r.padding, C = l.P.convert(t.offset);
          let z = r.centerPoint.add(C);
          const R = r.pointLocation(z), { center: W, zoom: Z } = r.getConstrained(l.N.convert(t.center || R), (c = t.zoom) !== null && c !== void 0 ? c : a);
          this._normalizeCenter(W, r);
          const G = r.zoomScale(Z - a), nt = r.project(R), Y = r.project(W).sub(nt);
          let J = t.curve;
          const tt = Math.max(r.width, r.height), ut = tt / G, St = Y.mag();
          if ("minZoom" in t) {
            const de = l.ac(Math.min(t.minZoom, a, Z), r.minZoom, r.maxZoom), Ce = tt / r.zoomScale(de - a);
            J = Math.sqrt(Ce / St * 2);
          }
          const It = J * J;
          function Gt(de) {
            const Ce = (ut * ut - tt * tt + (de ? -1 : 1) * It * It * St * St) / (2 * (de ? ut : tt) * It * St);
            return Math.log(Math.sqrt(Ce * Ce + 1) - Ce);
          }
          function qt(de) {
            return (Math.exp(de) - Math.exp(-de)) / 2;
          }
          function Zt(de) {
            return (Math.exp(de) + Math.exp(-de)) / 2;
          }
          const Bt = Gt(!1);
          let ge = function(de) {
            return Zt(Bt) / Zt(Bt + J * de);
          }, Le = function(de) {
            return tt * ((Zt(Bt) * (qt(Ce = Bt + J * de) / Zt(Ce)) - qt(Bt)) / It) / St;
            var Ce;
          }, ce = (Gt(!0) - Bt) / J;
          if (Math.abs(St) < 1e-6 || !isFinite(ce)) {
            if (Math.abs(tt - ut) < 1e-6) return this.easeTo(t, s);
            const de = ut < tt ? -1 : 1;
            ce = Math.abs(Math.log(ut / tt)) / J, Le = () => 0, ge = (Ce) => Math.exp(de * J * Ce);
          }
          return t.duration = "duration" in t ? +t.duration : 1e3 * ce / ("screenSpeed" in t ? +t.screenSpeed / J : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = !0, this._rotating = h !== w, this._pitching = k !== d, this._padding = !r.isPaddingEqual(T), this._prepareEase(s, !1), this.terrain && this._prepareElevation(W), this._ease((de) => {
            const Ce = de * ce, ii = 1 / ge(Ce);
            r.zoom = de === 1 ? Z : a + r.scaleZoom(ii), this._rotating && (r.bearing = l.y.number(h, w, de)), this._pitching && (r.pitch = l.y.number(d, k, de)), this._padding && (r.interpolatePadding(_, T, de), z = r.centerPoint.add(C)), this.terrain && !t.freezeElevation && this._updateElevation(de);
            const we = de === 1 ? W : r.unproject(nt.add(Y.mult(Le(Ce))).mult(ii));
            r.setLocationAtPoint(r.renderWorldCopies ? we.wrap() : we, z), this._applyUpdatedTransform(r), this._fireMoveEvents(s);
          }, () => {
            this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(s);
          }, t), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(t, s) {
          var c;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const r = this._onEaseEnd;
            delete this._onEaseEnd, r.call(this, s);
          }
          return t || (c = this.handlers) === null || c === void 0 || c.stop(!1), this;
        }
        _ease(t, s, c) {
          c.animate === !1 || c.duration === 0 ? (t(1), s()) : (this._easeStart = q.now(), this._easeOptions = c, this._onEaseFrame = t, this._onEaseEnd = s, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(t, s) {
          t = l.b2(t, -180, 180);
          const c = Math.abs(t - s);
          return Math.abs(t - 360 - s) < c && (t -= 360), Math.abs(t + 360 - s) < c && (t += 360), t;
        }
        _normalizeCenter(t, s) {
          if (!s.renderWorldCopies || s.lngRange) return;
          const c = t.lng - s.center.lng;
          t.lng += c > 180 ? -360 : c < -180 ? 360 : 0;
        }
        queryTerrainElevation(t) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(l.N.convert(t), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const po = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
      class vs {
        constructor(t = po) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (s) => {
            !s || s.sourceDataType !== "metadata" && s.sourceDataType !== "visibility" && s.dataType !== "style" && s.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = t;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(t) {
          return this._map = t, this._compact = this.options.compact, this._container = U.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = U.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = U.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          U.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(t, s) {
          const c = this._map._getUIString(`AttributionControl.${s}`);
          t.title = c, t.setAttribute("aria-label", c);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let t = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map((r) => typeof r != "string" ? "" : r)) : typeof this.options.customAttribution == "string" && t.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const r = this._map.style.stylesheet;
            this.styleOwner = r.owner, this.styleId = r.id;
          }
          const s = this._map.style.sourceCaches;
          for (const r in s) {
            const a = s[r];
            if (a.used || a.usedForTerrain) {
              const h = a.getSource();
              h.attribution && t.indexOf(h.attribution) < 0 && t.push(h.attribution);
            }
          }
          t = t.filter((r) => String(r).trim()), t.sort((r, a) => r.length - a.length), t = t.filter((r, a) => {
            for (let h = a + 1; h < t.length; h++) if (t[h].indexOf(r) >= 0) return !1;
            return !0;
          });
          const c = t.join(" | ");
          c !== this._attribHTML && (this._attribHTML = c, t.length ? (this._innerContainer.innerHTML = c, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class Fe {
        constructor(t = {}) {
          this._updateCompact = () => {
            const s = this._container.children;
            if (s.length) {
              const c = s[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && c.classList.add("maplibregl-compact") : c.classList.remove("maplibregl-compact");
            }
          }, this.options = t;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(t) {
          this._map = t, this._compact = this.options && this.options.compact, this._container = U.create("div", "maplibregl-ctrl");
          const s = U.create("a", "maplibregl-ctrl-logo");
          return s.target = "_blank", s.rel = "noopener nofollow", s.href = "https://maplibre.org/", s.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), s.setAttribute("rel", "noopener nofollow"), this._container.appendChild(s), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          U.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class Rs {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(t) {
          const s = ++this._id;
          return this._queue.push({ callback: t, id: s, cancelled: !1 }), s;
        }
        remove(t) {
          const s = this._currentlyRunning, c = s ? this._queue.concat(s) : this._queue;
          for (const r of c) if (r.id === t) return void (r.cancelled = !0);
        }
        run(t = 0) {
          if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
          const s = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const c of s) if (!c.cancelled && (c.callback(t), this._cleared)) break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      var An = l.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class xs extends l.E {
        constructor(t) {
          super(), this.sourceCache = t, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t.usedForTerrain = !0, t.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
        }
        update(t, s) {
          this.sourceCache.update(t, s), this._renderableTilesKeys = [];
          const c = {};
          for (const r of t.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: s })) c[r.key] = !0, this._renderableTilesKeys.push(r.key), this._tiles[r.key] || (r.posMatrix = new Float64Array(16), l.aP(r.posMatrix, 0, l.X, 0, l.X, 0, 1), this._tiles[r.key] = new lr(r, this.tileSize));
          for (const r in this._tiles) c[r] || delete this._tiles[r];
        }
        freeRtt(t) {
          for (const s in this._tiles) {
            const c = this._tiles[s];
            (!t || c.tileID.equals(t) || c.tileID.isChildOf(t) || t.isChildOf(c.tileID)) && (c.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((t) => this.getTileByID(t));
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        getTerrainCoords(t) {
          const s = {};
          for (const c of this._renderableTilesKeys) {
            const r = this._tiles[c].tileID;
            if (r.canonical.equals(t.canonical)) {
              const a = t.clone();
              a.posMatrix = new Float64Array(16), l.aP(a.posMatrix, 0, l.X, 0, l.X, 0, 1), s[c] = a;
            } else if (r.canonical.isChildOf(t.canonical)) {
              const a = t.clone();
              a.posMatrix = new Float64Array(16);
              const h = r.canonical.z - t.canonical.z, d = r.canonical.x - (r.canonical.x >> h << h), _ = r.canonical.y - (r.canonical.y >> h << h), w = l.X >> h;
              l.aP(a.posMatrix, 0, w, 0, w, 0, 1), l.J(a.posMatrix, a.posMatrix, [-d * w, -_ * w, 0]), s[c] = a;
            } else if (t.canonical.isChildOf(r.canonical)) {
              const a = t.clone();
              a.posMatrix = new Float64Array(16);
              const h = t.canonical.z - r.canonical.z, d = t.canonical.x - (t.canonical.x >> h << h), _ = t.canonical.y - (t.canonical.y >> h << h), w = l.X >> h;
              l.aP(a.posMatrix, 0, l.X, 0, l.X, 0, 1), l.J(a.posMatrix, a.posMatrix, [d * w, _ * w, 0]), l.K(a.posMatrix, a.posMatrix, [1 / 2 ** h, 1 / 2 ** h, 0]), s[c] = a;
            }
          }
          return s;
        }
        getSourceTile(t, s) {
          const c = this.sourceCache._source;
          let r = t.overscaledZ - this.deltaZoom;
          if (r > c.maxzoom && (r = c.maxzoom), r < c.minzoom) return null;
          this._sourceTileCache[t.key] || (this._sourceTileCache[t.key] = t.scaledTo(r).key);
          let a = this.sourceCache.getTileByID(this._sourceTileCache[t.key]);
          if ((!a || !a.dem) && s) for (; r >= c.minzoom && (!a || !a.dem); ) a = this.sourceCache.getTileByID(t.scaledTo(r--).key);
          return a;
        }
        tilesAfterTime(t = Date.now()) {
          return Object.values(this._tiles).filter((s) => s.timeAdded >= t);
        }
      }
      class Xo {
        constructor(t, s, c) {
          this.painter = t, this.sourceCache = new xs(s), this.options = c, this.exaggeration = typeof c.exaggeration == "number" ? c.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(t, s, c, r = l.X) {
          var a;
          if (!(s >= 0 && s < r && c >= 0 && c < r)) return 0;
          const h = this.getTerrainData(t), d = (a = h.tile) === null || a === void 0 ? void 0 : a.dem;
          if (!d) return 0;
          const _ = function(R, W, Z) {
            var G = W[0], nt = W[1];
            return R[0] = Z[0] * G + Z[4] * nt + Z[12], R[1] = Z[1] * G + Z[5] * nt + Z[13], R;
          }([], [s / r * l.X, c / r * l.X], h.u_terrain_matrix), w = [_[0] * d.dim, _[1] * d.dim], k = Math.floor(w[0]), T = Math.floor(w[1]), C = w[0] - k, z = w[1] - T;
          return d.get(k, T) * (1 - C) * (1 - z) + d.get(k + 1, T) * C * (1 - z) + d.get(k, T + 1) * (1 - C) * z + d.get(k + 1, T + 1) * C * z;
        }
        getElevationForLngLatZoom(t, s) {
          if (!l.ba(s, t.wrap())) return 0;
          const { tileID: c, mercatorX: r, mercatorY: a } = this._getOverscaledTileIDFromLngLatZoom(t, s);
          return this.getElevation(c, r % l.X, a % l.X, l.X);
        }
        getElevation(t, s, c, r = l.X) {
          return this.getDEMElevation(t, s, c, r) * this.exaggeration;
        }
        getTerrainData(t) {
          if (!this._emptyDemTexture) {
            const r = this.painter.context, a = new l.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new at(r, a, r.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new at(r, new l.R({ width: 1, height: 1 }), r.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(r.gl.NEAREST, r.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = l.an([]);
          }
          const s = this.sourceCache.getSourceTile(t, !0);
          if (s && s.dem && (!s.demTexture || s.needsTerrainPrepare)) {
            const r = this.painter.context;
            s.demTexture = this.painter.getTileTexture(s.dem.stride), s.demTexture ? s.demTexture.update(s.dem.getPixels(), { premultiply: !1 }) : s.demTexture = new at(r, s.dem.getPixels(), r.gl.RGBA, { premultiply: !1 }), s.demTexture.bind(r.gl.NEAREST, r.gl.CLAMP_TO_EDGE), s.needsTerrainPrepare = !1;
          }
          const c = s && s + s.tileID.key + t.key;
          if (c && !this._demMatrixCache[c]) {
            const r = this.sourceCache.sourceCache._source.maxzoom;
            let a = t.canonical.z - s.tileID.canonical.z;
            t.overscaledZ > t.canonical.z && (t.canonical.z >= r ? a = t.canonical.z - r : l.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const h = t.canonical.x - (t.canonical.x >> a << a), d = t.canonical.y - (t.canonical.y >> a << a), _ = l.bb(new Float64Array(16), [1 / (l.X << a), 1 / (l.X << a), 0]);
            l.J(_, _, [h * l.X, d * l.X, 0]), this._demMatrixCache[t.key] = { matrix: _, coord: t };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: s && s.dem && s.dem.dim || 1, u_terrain_matrix: c ? this._demMatrixCache[t.key].matrix : this._emptyDemMatrix, u_terrain_unpack: s && s.dem && s.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (s && s.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: s };
        }
        getFramebuffer(t) {
          const s = this.painter, c = s.width / devicePixelRatio, r = s.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === c && this._fbo.height === r || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new at(s.context, { width: c, height: r, data: null }, s.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(s.context.gl.NEAREST, s.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new at(s.context, { width: c, height: r, data: null }, s.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(s.context.gl.NEAREST, s.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = s.context.createFramebuffer(c, r, !0, !1), this._fbo.depthAttachment.set(s.context.createRenderbuffer(s.context.gl.DEPTH_COMPONENT16, c, r))), this._fbo.colorAttachment.set(t === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const t = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const s = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let a = 0, h = 0; a < this._coordsTextureSize; a++) for (let d = 0; d < this._coordsTextureSize; d++, h += 4) s[h + 0] = 255 & d, s[h + 1] = 255 & a, s[h + 2] = d >> 8 << 4 | a >> 8, s[h + 3] = 0;
          const c = new l.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(s.buffer)), r = new at(t, c, t.gl.RGBA, { premultiply: !1 });
          return r.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE), this._coordsTexture = r, r;
        }
        pointCoordinate(t) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const s = new Uint8Array(4), c = this.painter.context, r = c.gl, a = Math.round(t.x * this.painter.pixelRatio / devicePixelRatio), h = Math.round(t.y * this.painter.pixelRatio / devicePixelRatio), d = Math.round(this.painter.height / devicePixelRatio);
          c.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), r.readPixels(a, d - h - 1, 1, 1, r.RGBA, r.UNSIGNED_BYTE, s), c.bindFramebuffer.set(null);
          const _ = s[0] + (s[2] >> 4 << 8), w = s[1] + ((15 & s[2]) << 8), k = this.coordsIndex[255 - s[3]], T = k && this.sourceCache.getTileByID(k);
          if (!T) return null;
          const C = this._coordsTextureSize, z = (1 << T.tileID.canonical.z) * C;
          return new l.Z((T.tileID.canonical.x * C + _) / z + T.tileID.wrap, (T.tileID.canonical.y * C + w) / z, this.getElevation(T.tileID, _, w, C));
        }
        depthAtPoint(t) {
          const s = new Uint8Array(4), c = this.painter.context, r = c.gl;
          return c.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), r.readPixels(t.x, this.painter.height / devicePixelRatio - t.y - 1, 1, 1, r.RGBA, r.UNSIGNED_BYTE, s), c.bindFramebuffer.set(null), (s[0] / 16777216 + s[1] / 65536 + s[2] / 256 + s[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh) return this._mesh;
          const t = this.painter.context, s = new l.bc(), c = new l.aX(), r = this.meshSize, a = l.X / r, h = r * r;
          for (let T = 0; T <= r; T++) for (let C = 0; C <= r; C++) s.emplaceBack(C * a, T * a, 0);
          for (let T = 0; T < h; T += r + 1) for (let C = 0; C < r; C++) c.emplaceBack(C + T, r + C + T + 1, r + C + T + 2), c.emplaceBack(C + T, r + C + T + 2, C + T + 1);
          const d = s.length, _ = d + 2 * (r + 1);
          for (const T of [0, 1]) for (let C = 0; C <= r; C++) for (const z of [0, 1]) s.emplaceBack(C * a, T * l.X, z);
          for (let T = 0; T < 2 * r; T += 2) c.emplaceBack(_ + T, _ + T + 1, _ + T + 3), c.emplaceBack(_ + T, _ + T + 3, _ + T + 2), c.emplaceBack(d + T, d + T + 3, d + T + 1), c.emplaceBack(d + T, d + T + 2, d + T + 3);
          const w = s.length, k = w + 2 * (r + 1);
          for (const T of [0, 1]) for (let C = 0; C <= r; C++) for (const z of [0, 1]) s.emplaceBack(T * l.X, C * a, z);
          for (let T = 0; T < 2 * r; T += 2) c.emplaceBack(w + T, w + T + 1, w + T + 3), c.emplaceBack(w + T, w + T + 3, w + T + 2), c.emplaceBack(k + T, k + T + 3, k + T + 1), c.emplaceBack(k + T, k + T + 2, k + T + 3);
          return this._mesh = new ms(t.createVertexBuffer(s, An.members), t.createIndexBuffer(c), l.a0.simpleSegment(0, 0, s.length, c.length)), this._mesh;
        }
        getMeshFrameDelta(t) {
          return 2 * Math.PI * l.bd / Math.pow(2, t) / 5;
        }
        getMinTileElevationForLngLatZoom(t, s) {
          var c;
          const { tileID: r } = this._getOverscaledTileIDFromLngLatZoom(t, s);
          return (c = this.getMinMaxElevation(r).minElevation) !== null && c !== void 0 ? c : 0;
        }
        getMinMaxElevation(t) {
          const s = this.getTerrainData(t).tile, c = { minElevation: null, maxElevation: null };
          return s && s.dem && (c.minElevation = s.dem.min * this.exaggeration, c.maxElevation = s.dem.max * this.exaggeration), c;
        }
        _getOverscaledTileIDFromLngLatZoom(t, s) {
          const c = l.Z.fromLngLat(t.wrap()), r = (1 << s) * l.X, a = c.x * r, h = c.y * r, d = Math.floor(a / l.X), _ = Math.floor(h / l.X);
          return { tileID: new l.S(s, 0, s, d, _), mercatorX: a, mercatorY: h };
        }
      }
      class fo {
        constructor(t, s, c) {
          this._context = t, this._size = s, this._tileSize = c, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const t of this._objects) t.texture.destroy(), t.fbo.destroy();
        }
        _createObject(t) {
          const s = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), c = new at(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return c.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), s.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), s.colorAttachment.set(c.texture), { id: t, fbo: s, texture: c, stamp: -1, inUse: !1 };
        }
        getObjectForId(t) {
          return this._objects[t];
        }
        useObject(t) {
          t.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((s) => t.id !== s), this._recentlyUsed.push(t.id);
        }
        stampObject(t) {
          t.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const s of this._recentlyUsed) if (!this._objects[s].inUse) return this._objects[s];
          if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const t = this._createObject(this._objects.length);
          return this._objects.push(t), t;
        }
        freeObject(t) {
          t.inUse = !1;
        }
        freeAllObjects() {
          for (const t of this._objects) this.freeObject(t);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((t) => !t.inUse) === !1;
        }
      }
      const pn = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
      class ui {
        constructor(t, s) {
          this.painter = t, this.terrain = s, this.pool = new fo(t.context, 30, s.sourceCache.tileSize * s.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(t) {
          return this.pool.getObjectForId(t.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(t, s) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t._order.filter((c) => !t._layers[c].isHidden(s)), this._coordsDescendingInv = {};
          for (const c in t.sourceCaches) {
            this._coordsDescendingInv[c] = {};
            const r = t.sourceCaches[c].getVisibleCoordinates();
            for (const a of r) {
              const h = this.terrain.sourceCache.getTerrainCoords(a);
              for (const d in h) this._coordsDescendingInv[c][d] || (this._coordsDescendingInv[c][d] = []), this._coordsDescendingInv[c][d].push(h[d]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const c of t._order) {
            const r = t._layers[c], a = r.source;
            if (pn[r.type] && !this._coordsDescendingInvStr[a]) {
              this._coordsDescendingInvStr[a] = {};
              for (const h in this._coordsDescendingInv[a]) this._coordsDescendingInvStr[a][h] = this._coordsDescendingInv[a][h].map((d) => d.key).sort().join();
            }
          }
          for (const c of this._renderableTiles) for (const r in this._coordsDescendingInvStr) {
            const a = this._coordsDescendingInvStr[r][c.tileID.key];
            a && a !== c.rttCoords[r] && (c.rtt = []);
          }
        }
        renderLayer(t) {
          if (t.isHidden(this.painter.transform.zoom)) return !1;
          const s = t.type, c = this.painter, r = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t.id;
          if (pn[s] && (this._prevType && pn[this._prevType] || this._stacks.push([]), this._prevType = s, this._stacks[this._stacks.length - 1].push(t.id), !r)) return !0;
          if (pn[this._prevType] || pn[s] && r) {
            this._prevType = s;
            const a = this._stacks.length - 1, h = this._stacks[a] || [];
            for (const d of this._renderableTiles) {
              if (this.pool.isFull() && (Mn(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(d), d.rtt[a]) {
                const w = this.pool.getObjectForId(d.rtt[a].id);
                if (w.stamp === d.rtt[a].stamp) {
                  this.pool.useObject(w);
                  continue;
                }
              }
              const _ = this.pool.getOrCreateFreeObject();
              this.pool.useObject(_), this.pool.stampObject(_), d.rtt[a] = { id: _.id, stamp: _.stamp }, c.context.bindFramebuffer.set(_.fbo.framebuffer), c.context.clear({ color: l.aM.transparent, stencil: 0 }), c.currentStencilSource = void 0;
              for (let w = 0; w < h.length; w++) {
                const k = c.style._layers[h[w]], T = k.source ? this._coordsDescendingInv[k.source][d.tileID.key] : [d.tileID];
                c.context.viewport.set([0, 0, _.fbo.width, _.fbo.height]), c._renderTileClippingMasks(k, T), c.renderLayer(c, c.style.sourceCaches[k.source], k, T), k.source && (d.rttCoords[k.source] = this._coordsDescendingInvStr[k.source][d.tileID.key]);
              }
            }
            return Mn(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), pn[s];
          }
          return !1;
        }
      }
      const El = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Nc = M, ul = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: po, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, refreshExpiredTiles: !0, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: l.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0 }, Ml = (p) => {
        p.touchstart = p.dragStart, p.touchmoveWindow = p.dragMove, p.touchend = p.dragEnd;
      }, ec = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class zl {
        constructor(t, s, c = !1) {
          this.mousedown = (h) => {
            this.startMouse(l.e({}, h, { ctrlKey: !0, preventDefault: () => h.preventDefault() }), U.mousePos(this.element, h)), U.addEventListener(window, "mousemove", this.mousemove), U.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (h) => {
            this.moveMouse(h, U.mousePos(this.element, h));
          }, this.mouseup = (h) => {
            this.mouseRotate.dragEnd(h), this.mousePitch && this.mousePitch.dragEnd(h), this.offTemp();
          }, this.touchstart = (h) => {
            h.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = U.touchPos(this.element, h.targetTouches)[0], this.startTouch(h, this._startPos), U.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), U.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (h) => {
            h.targetTouches.length !== 1 ? this.reset() : (this._lastPos = U.touchPos(this.element, h.targetTouches)[0], this.moveTouch(h, this._lastPos));
          }, this.touchend = (h) => {
            h.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const r = t.dragRotate._mouseRotate.getClickTolerance(), a = t.dragRotate._mousePitch.getClickTolerance();
          this.element = s, this.mouseRotate = wr({ clickTolerance: r, enable: !0 }), this.touchRotate = (({ enable: h, clickTolerance: d, bearingDegreesPerPixelMoved: _ = 0.8 }) => {
            const w = new so();
            return new Dn({ clickTolerance: d, move: (k, T) => ({ bearingDelta: (T.x - k.x) * _ }), moveStateManager: w, enable: h, assignEvents: Ml });
          })({ clickTolerance: r, enable: !0 }), this.map = t, c && (this.mousePitch = Fr({ clickTolerance: a, enable: !0 }), this.touchPitch = (({ enable: h, clickTolerance: d, pitchDegreesPerPixelMoved: _ = -0.5 }) => {
            const w = new so();
            return new Dn({ clickTolerance: d, move: (k, T) => ({ pitchDelta: (T.y - k.y) * _ }), moveStateManager: w, enable: h, assignEvents: Ml });
          })({ clickTolerance: a, enable: !0 })), U.addEventListener(s, "mousedown", this.mousedown), U.addEventListener(s, "touchstart", this.touchstart, { passive: !1 }), U.addEventListener(s, "touchcancel", this.reset);
        }
        startMouse(t, s) {
          this.mouseRotate.dragStart(t, s), this.mousePitch && this.mousePitch.dragStart(t, s), U.disableDrag();
        }
        startTouch(t, s) {
          this.touchRotate.dragStart(t, s), this.touchPitch && this.touchPitch.dragStart(t, s), U.disableDrag();
        }
        moveMouse(t, s) {
          const c = this.map, { bearingDelta: r } = this.mouseRotate.dragMove(t, s) || {};
          if (r && c.setBearing(c.getBearing() + r), this.mousePitch) {
            const { pitchDelta: a } = this.mousePitch.dragMove(t, s) || {};
            a && c.setPitch(c.getPitch() + a);
          }
        }
        moveTouch(t, s) {
          const c = this.map, { bearingDelta: r } = this.touchRotate.dragMove(t, s) || {};
          if (r && c.setBearing(c.getBearing() + r), this.touchPitch) {
            const { pitchDelta: a } = this.touchPitch.dragMove(t, s) || {};
            a && c.setPitch(c.getPitch() + a);
          }
        }
        off() {
          const t = this.element;
          U.removeEventListener(t, "mousedown", this.mousedown), U.removeEventListener(t, "touchstart", this.touchstart, { passive: !1 }), U.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), U.removeEventListener(window, "touchend", this.touchend), U.removeEventListener(t, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          U.enableDrag(), U.removeEventListener(window, "mousemove", this.mousemove), U.removeEventListener(window, "mouseup", this.mouseup), U.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), U.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let Bs;
      function mo(p, t, s) {
        const c = new l.N(p.lng, p.lat);
        if (p = new l.N(p.lng, p.lat), t) {
          const r = new l.N(p.lng - 360, p.lat), a = new l.N(p.lng + 360, p.lat), h = s.locationPoint(p).distSqr(t);
          s.locationPoint(r).distSqr(t) < h ? p = r : s.locationPoint(a).distSqr(t) < h && (p = a);
        }
        for (; Math.abs(p.lng - s.center.lng) > 180; ) {
          const r = s.locationPoint(p);
          if (r.x >= 0 && r.y >= 0 && r.x <= s.width && r.y <= s.height) break;
          p.lng > s.center.lng ? p.lng -= 360 : p.lng += 360;
        }
        return p.lng !== c.lng && s.locationPoint(p).y > s.height / 2 - s.getHorizon() ? p : c;
      }
      const go = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function Ma(p, t, s) {
        const c = p.classList;
        for (const r in go) c.remove(`maplibregl-${s}-anchor-${r}`);
        c.add(`maplibregl-${s}-anchor-${t}`);
      }
      class Yo extends l.E {
        constructor(t) {
          if (super(), this._onKeyPress = (s) => {
            const c = s.code, r = s.charCode || s.keyCode;
            c !== "Space" && c !== "Enter" && r !== 32 && r !== 13 || this.togglePopup();
          }, this._onMapClick = (s) => {
            const c = s.originalEvent.target, r = this._element;
            this._popup && (c === r || r.contains(c)) && this.togglePopup();
          }, this._update = (s) => {
            var c;
            if (!this._map) return;
            const r = this._map.loaded() && !this._map.isMoving();
            ((s == null ? void 0 : s.type) === "terrain" || (s == null ? void 0 : s.type) === "render" && !r) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? mo(this._lngLat, this._flatPos, this._map.transform) : (c = this._lngLat) === null || c === void 0 ? void 0 : c.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let a = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? a = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (a = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let h = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? h = "rotateX(0deg)" : this._pitchAlignment === "map" && (h = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || s && s.type !== "moveend" || (this._pos = this._pos.round()), U.setTransform(this._element, `${go[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${h} ${a}`), q.frameAsync(new AbortController()).then(() => {
              this._updateOpacity(s && s.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (s) => {
            if (!this._isDragging) {
              const c = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = s.point.dist(this._pointerdownPos) >= c;
            }
            this._isDragging && (this._pos = s.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new l.k("dragstart"))), this.fire(new l.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new l.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (s) => {
            this._element.contains(s.originalEvent.target) && (s.preventDefault(), this._positionDelta = s.point.sub(this._pos).add(this._offset), this._pointerdownPos = s.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._subpixelPositioning = t && t.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment !== "auto" ? t.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(t == null ? void 0 : t.opacity, t == null ? void 0 : t.opacityWhenCovered), t && t.element) this._element = t.element, this._offset = l.P.convert(t && t.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = U.create("div");
            const s = U.createNS("http://www.w3.org/2000/svg", "svg"), c = 41, r = 27;
            s.setAttributeNS(null, "display", "block"), s.setAttributeNS(null, "height", `${c}px`), s.setAttributeNS(null, "width", `${r}px`), s.setAttributeNS(null, "viewBox", `0 0 ${r} ${c}`);
            const a = U.createNS("http://www.w3.org/2000/svg", "g");
            a.setAttributeNS(null, "stroke", "none"), a.setAttributeNS(null, "stroke-width", "1"), a.setAttributeNS(null, "fill", "none"), a.setAttributeNS(null, "fill-rule", "evenodd");
            const h = U.createNS("http://www.w3.org/2000/svg", "g");
            h.setAttributeNS(null, "fill-rule", "nonzero");
            const d = U.createNS("http://www.w3.org/2000/svg", "g");
            d.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), d.setAttributeNS(null, "fill", "#000000");
            const _ = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const G of _) {
              const nt = U.createNS("http://www.w3.org/2000/svg", "ellipse");
              nt.setAttributeNS(null, "opacity", "0.04"), nt.setAttributeNS(null, "cx", "10.5"), nt.setAttributeNS(null, "cy", "5.80029008"), nt.setAttributeNS(null, "rx", G.rx), nt.setAttributeNS(null, "ry", G.ry), d.appendChild(nt);
            }
            const w = U.createNS("http://www.w3.org/2000/svg", "g");
            w.setAttributeNS(null, "fill", this._color);
            const k = U.createNS("http://www.w3.org/2000/svg", "path");
            k.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), w.appendChild(k);
            const T = U.createNS("http://www.w3.org/2000/svg", "g");
            T.setAttributeNS(null, "opacity", "0.25"), T.setAttributeNS(null, "fill", "#000000");
            const C = U.createNS("http://www.w3.org/2000/svg", "path");
            C.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), T.appendChild(C);
            const z = U.createNS("http://www.w3.org/2000/svg", "g");
            z.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), z.setAttributeNS(null, "fill", "#FFFFFF");
            const R = U.createNS("http://www.w3.org/2000/svg", "g");
            R.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const W = U.createNS("http://www.w3.org/2000/svg", "circle");
            W.setAttributeNS(null, "fill", "#000000"), W.setAttributeNS(null, "opacity", "0.25"), W.setAttributeNS(null, "cx", "5.5"), W.setAttributeNS(null, "cy", "5.5"), W.setAttributeNS(null, "r", "5.4999962");
            const Z = U.createNS("http://www.w3.org/2000/svg", "circle");
            Z.setAttributeNS(null, "fill", "#FFFFFF"), Z.setAttributeNS(null, "cx", "5.5"), Z.setAttributeNS(null, "cy", "5.5"), Z.setAttributeNS(null, "r", "5.4999962"), R.appendChild(W), R.appendChild(Z), h.appendChild(d), h.appendChild(w), h.appendChild(T), h.appendChild(z), h.appendChild(R), s.appendChild(h), s.setAttributeNS(null, "height", c * this._scale + "px"), s.setAttributeNS(null, "width", r * this._scale + "px"), this._element.appendChild(s), this._offset = l.P.convert(t && t.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (s) => {
            s.preventDefault();
          }), this._element.addEventListener("mousedown", (s) => {
            s.preventDefault();
          }), Ma(this._element, this._anchor, "marker"), t && t.className) for (const s of t.className.split(" ")) this._element.classList.add(s);
          this._popup = null;
        }
        addTo(t) {
          return this.remove(), this._map = t, this._element.setAttribute("aria-label", t._getUIString("Marker.Title")), t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), t.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), U.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t) {
          return this._lngLat = l.N.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(t) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
            if (!("offset" in t.options)) {
              const r = Math.abs(13.5) / Math.SQRT2;
              t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [r, -1 * (38.1 - 13.5 + r)], "bottom-right": [-r, -1 * (38.1 - 13.5 + r)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = t, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(t) {
          return this._subpixelPositioning = t, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const t = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : t ? (t.isOpen() ? t.remove() : (t.setLngLat(this._lngLat), t.addTo(this._map)), this) : this;
        }
        _updateOpacity(t = !1) {
          var s, c;
          if (!(!((s = this._map) === null || s === void 0) && s.terrain)) return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (t) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const r = this._map, a = r.terrain.depthAtPoint(this._pos), h = r.terrain.getElevationForLngLatZoom(this._lngLat, r.transform.tileZoom);
          if (r.transform.lngLatToCameraDepth(this._lngLat, h) - a < 6e-3) return void (this._element.style.opacity = this._opacity);
          const d = -this._offset.y / r.transform._pixelPerMeter, _ = Math.sin(r.getPitch() * Math.PI / 180) * d, w = r.terrain.depthAtPoint(new l.P(this._pos.x, this._pos.y - this._offset.y)), k = r.transform.lngLatToCameraDepth(this._lngLat, h + _) - w > 6e-3;
          !((c = this._popup) === null || c === void 0) && c.isOpen() && k && this._popup.remove(), this._element.style.opacity = k ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t) {
          return this._offset = l.P.convert(t), this._update(), this;
        }
        addClassName(t) {
          this._element.classList.add(t);
        }
        removeClassName(t) {
          this._element.classList.remove(t);
        }
        toggleClassName(t) {
          return this._element.classList.toggle(t);
        }
        setDraggable(t) {
          return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(t) {
          return this._rotation = t || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(t) {
          return this._rotationAlignment = t || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(t) {
          return this._pitchAlignment = t && t !== "auto" ? t : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(t, s) {
          return t === void 0 && s === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t !== void 0 && (this._opacity = t), s !== void 0 && (this._opacityWhenCovered = s), this._map && this._updateOpacity(!0), this;
        }
      }
      const ic = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let bs = 0, Vi = !1;
      const dl = { maxWidth: 100, unit: "metric" };
      function pl(p, t, s) {
        const c = s && s.maxWidth || 100, r = p._container.clientHeight / 2, a = p.unproject([0, r]), h = p.unproject([c, r]), d = a.distanceTo(h);
        if (s && s.unit === "imperial") {
          const _ = 3.2808 * d;
          _ > 5280 ? yo(t, c, _ / 5280, p._getUIString("ScaleControl.Miles")) : yo(t, c, _, p._getUIString("ScaleControl.Feet"));
        } else s && s.unit === "nautical" ? yo(t, c, d / 1852, p._getUIString("ScaleControl.NauticalMiles")) : d >= 1e3 ? yo(t, c, d / 1e3, p._getUIString("ScaleControl.Kilometers")) : yo(t, c, d, p._getUIString("ScaleControl.Meters"));
      }
      function yo(p, t, s, c) {
        const r = function(a) {
          const h = Math.pow(10, `${Math.floor(a)}`.length - 1);
          let d = a / h;
          return d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : d >= 1 ? 1 : function(_) {
            const w = Math.pow(10, Math.ceil(-Math.log(_) / Math.LN10));
            return Math.round(_ * w) / w;
          }(d), h * d;
        }(s);
        p.style.width = t * (r / s) + "px", p.innerHTML = `${r}&nbsp;${c}`;
      }
      const rc = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, nc = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function sc(p) {
        if (p) {
          if (typeof p == "number") {
            const t = Math.round(Math.abs(p) / Math.SQRT2);
            return { center: new l.P(0, 0), top: new l.P(0, p), "top-left": new l.P(t, t), "top-right": new l.P(-t, t), bottom: new l.P(0, -p), "bottom-left": new l.P(t, -t), "bottom-right": new l.P(-t, -t), left: new l.P(p, 0), right: new l.P(-p, 0) };
          }
          if (p instanceof l.P || Array.isArray(p)) {
            const t = l.P.convert(p);
            return { center: t, top: t, "top-left": t, "top-right": t, bottom: t, "bottom-left": t, "bottom-right": t, left: t, right: t };
          }
          return { center: l.P.convert(p.center || [0, 0]), top: l.P.convert(p.top || [0, 0]), "top-left": l.P.convert(p["top-left"] || [0, 0]), "top-right": l.P.convert(p["top-right"] || [0, 0]), bottom: l.P.convert(p.bottom || [0, 0]), "bottom-left": l.P.convert(p["bottom-left"] || [0, 0]), "bottom-right": l.P.convert(p["bottom-right"] || [0, 0]), left: l.P.convert(p.left || [0, 0]), right: l.P.convert(p.right || [0, 0]) };
        }
        return sc(new l.P(0, 0));
      }
      const es = M;
      v.AJAXError = l.bg, v.Evented = l.E, v.LngLat = l.N, v.MercatorCoordinate = l.Z, v.Point = l.P, v.addProtocol = l.bh, v.config = l.a, v.removeProtocol = l.bi, v.AttributionControl = vs, v.BoxZoomHandler = _s, v.CanvasSource = si, v.CooperativeGesturesHandler = Fs, v.DoubleClickZoomHandler = uo, v.DragPanHandler = ts, v.DragRotateHandler = Ll, v.EdgeInsets = an, v.FullscreenControl = class extends l.E {
        constructor(p = {}) {
          super(), this._onFullscreenChange = () => {
            var t;
            let s = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; !((t = s == null ? void 0 : s.shadowRoot) === null || t === void 0) && t.fullscreenElement; ) s = s.shadowRoot.fullscreenElement;
            s === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = !1, p && p.container && (p.container instanceof HTMLElement ? this._container = p.container : l.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(p) {
          return this._map = p, this._container || (this._container = this._map.getContainer()), this._controlContainer = U.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          U.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const p = this._fullscreenButton = U.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          U.create("span", "maplibregl-ctrl-icon", p).setAttribute("aria-hidden", "true"), p.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const p = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", p), this._fullscreenButton.title = p;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new l.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new l.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, v.GeoJSONSource = De, v.GeolocateControl = class extends l.E {
        constructor(p) {
          super(), this._onSuccess = (t) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new l.k("outofmaxbounds", t)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new l.k("geolocate", t)), this._finish();
            }
          }, this._updateCamera = (t) => {
            const s = new l.N(t.coords.longitude, t.coords.latitude), c = t.coords.accuracy, r = this._map.getBearing(), a = l.e({ bearing: r }, this.options.fitBoundsOptions), h = K.fromLngLat(s, c);
            this._map.fitBounds(h, a, { geolocateSource: !0 });
          }, this._updateMarker = (t) => {
            if (t) {
              const s = new l.N(t.coords.longitude, t.coords.latitude);
              this._accuracyCircleMarker.setLngLat(s).addTo(this._map), this._userLocationDotMarker.setLngLat(s).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (t) => {
            if (this._map) {
              if (this.options.trackUserLocation) if (t.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const s = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (t.code === 3 && Vi) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new l.k("error", t)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this._geolocateButton = U.create("button", "maplibregl-ctrl-geolocate", this._container), U.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
          }, this._finishSetupUI = (t) => {
            if (this._map) {
              if (t === !1) {
                l.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const s = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s);
              } else {
                const s = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = !1, this._geolocateButton.title = s, this._geolocateButton.setAttribute("aria-label", s);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = U.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Yo({ element: this._dotElement }), this._circleElement = U.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Yo({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (s) => {
                s.geolocateSource || this._watchState !== "ACTIVE_LOCK" || s.originalEvent && s.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new l.k("trackuserlocationend")), this.fire(new l.k("userlocationlostfocus")));
              });
            }
          }, this.options = l.e({}, ic, p);
        }
        onAdd(p) {
          return this._map = p, this._container = U.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return l._(this, arguments, void 0, function* (t = !1) {
              if (Bs !== void 0 && !t) return Bs;
              if (window.navigator.permissions === void 0) return Bs = !!window.navigator.geolocation, Bs;
              try {
                Bs = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
              } catch {
                Bs = !!window.navigator.geolocation;
              }
              return Bs;
            });
          }().then((t) => this._finishSetupUI(t)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), U.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, bs = 0, Vi = !1;
        }
        _isOutOfMapMaxBounds(p) {
          const t = this._map.getMaxBounds(), s = p.coords;
          return t && (s.longitude < t.getWest() || s.longitude > t.getEast() || s.latitude < t.getSouth() || s.latitude > t.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const p = this._map.getBounds(), t = p.getSouthEast(), s = p.getNorthEast(), c = t.distanceTo(s), r = Math.ceil(this._accuracy / (c / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${r}px`, this._circleElement.style.height = `${r}px`;
        }
        trigger() {
          if (!this._setup) return l.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new l.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                bs--, Vi = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new l.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new l.k("trackuserlocationstart")), this.fire(new l.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let p;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), bs++, bs > 1 ? (p = { maximumAge: 6e5, timeout: 0 }, Vi = !0) : (p = this.options.positionOptions, Vi = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, p);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, v.Hash = on, v.ImageSource = $e, v.KeyboardHandler = Ho, v.LngLatBounds = K, v.LogoControl = Fe, v.Map = class extends tc {
        constructor(p) {
          l.be.mark(l.bf.create);
          const t = Object.assign(Object.assign({}, ul), p);
          if (t.minZoom != null && t.maxZoom != null && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (t.minPitch != null && t.maxPitch != null && t.minPitch > t.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (t.minPitch != null && t.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (t.maxPitch != null && t.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (super(new zs(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), { bearingSnap: t.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Rs(), this._controls = [], this._mapId = l.a4(), this._contextLost = (s) => {
            s.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new l.k("webglcontextlost", { originalEvent: s }));
          }, this._contextRestored = (s) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new l.k("webglcontextrestored", { originalEvent: s }));
          }, this._onMapScroll = (s) => {
            if (s.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = t.interactive, this._maxTileCacheSize = t.maxTileCacheSize, this._maxTileCacheZoomLevels = t.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat === !0, this._preserveDrawingBuffer = t.preserveDrawingBuffer === !0, this._antialias = t.antialias === !0, this._trackResize = t.trackResize === !0, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles === !0, this._fadeDuration = t.fadeDuration, this._crossSourceCollisions = t.crossSourceCollisions === !0, this._collectResourceTiming = t.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, El), t.locale), this._clickTolerance = t.clickTolerance, this._overridePixelRatio = t.pixelRatio, this._maxCanvasSize = t.maxCanvasSize, this.transformCameraUpdate = t.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = t.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Mt.addThrottleControl(() => this.isMoving()), this._requestManager = new Qt(t.transformRequest), typeof t.container == "string") {
            if (this._container = document.getElementById(t.container), !this._container) throw new Error(`Container '${t.container}' not found.`);
          } else {
            if (!(t.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t.container;
          }
          if (t.maxBounds && this.setMaxBounds(t.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)).on("moveend", () => this._update(!1)).on("zoom", () => this._update(!0)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }).once("idle", () => {
            this._idleTriggered = !0;
          }), typeof window < "u") {
            addEventListener("online", this._onWindowOnline, !1);
            let s = !1;
            const c = zn((r) => {
              this._trackResize && !this._removed && this.resize(r)._update();
            }, 50);
            this._resizeObserver = new ResizeObserver((r) => {
              s ? c(r) : s = !0;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new Ql(this, t), this._hash = t.hash && new on(typeof t.hash == "string" && t.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t.center, zoom: t.zoom, bearing: t.bearing, pitch: t.pitch }), t.bounds && (this.resize(), this.fitBounds(t.bounds, l.e({}, t.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = t.localIdeographFontFamily, this._validateStyle = t.validateStyle, t.style && this.setStyle(t.style, { localIdeographFontFamily: t.localIdeographFontFamily }), t.attributionControl && this.addControl(new vs(typeof t.attributionControl == "boolean" ? void 0 : t.attributionControl)), t.maplibreLogo && this.addControl(new Fe(), t.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (s) => {
            this._update(s.dataType === "style"), this.fire(new l.k(`${s.dataType}data`, s));
          }), this.on("dataloading", (s) => {
            this.fire(new l.k(`${s.dataType}dataloading`, s));
          }), this.on("dataabort", (s) => {
            this.fire(new l.k("sourcedataabort", s));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(p, t) {
          if (t === void 0 && (t = p.getDefaultPosition ? p.getDefaultPosition() : "top-right"), !p || !p.onAdd) return this.fire(new l.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const s = p.onAdd(this);
          this._controls.push(p);
          const c = this._controlPositions[t];
          return t.indexOf("bottom") !== -1 ? c.insertBefore(s, c.firstChild) : c.appendChild(s), this;
        }
        removeControl(p) {
          if (!p || !p.onRemove) return this.fire(new l.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const t = this._controls.indexOf(p);
          return t > -1 && this._controls.splice(t, 1), p.onRemove(this), this;
        }
        hasControl(p) {
          return this._controls.indexOf(p) > -1;
        }
        calculateCameraOptionsFromTo(p, t, s, c) {
          return c == null && this.terrain && (c = this.terrain.getElevationForLngLatZoom(s, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(p, t, s, c);
        }
        resize(p) {
          var t;
          const s = this._containerDimensions(), c = s[0], r = s[1], a = this._getClampedPixelRatio(c, r);
          if (this._resizeCanvas(c, r, a), this.painter.resize(c, r, a), this.painter.overLimit()) {
            const d = this.painter.context.gl;
            this._maxCanvasSize = [d.drawingBufferWidth, d.drawingBufferHeight];
            const _ = this._getClampedPixelRatio(c, r);
            this._resizeCanvas(c, r, _), this.painter.resize(c, r, _);
          }
          this.transform.resize(c, r), (t = this._requestedCameraState) === null || t === void 0 || t.resize(c, r);
          const h = !this._moving;
          return h && (this.stop(), this.fire(new l.k("movestart", p)).fire(new l.k("move", p))), this.fire(new l.k("resize", p)), h && this.fire(new l.k("moveend", p)), this;
        }
        _getClampedPixelRatio(p, t) {
          const { 0: s, 1: c } = this._maxCanvasSize, r = this.getPixelRatio(), a = p * r, h = t * r;
          return Math.min(a > s ? s / a : 1, h > c ? c / h : 1) * r;
        }
        getPixelRatio() {
          var p;
          return (p = this._overridePixelRatio) !== null && p !== void 0 ? p : devicePixelRatio;
        }
        setPixelRatio(p) {
          this._overridePixelRatio = p, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(p) {
          return this.transform.setMaxBounds(K.convert(p)), this._update();
        }
        setMinZoom(p) {
          if ((p = p ?? -2) >= -2 && p <= this.transform.maxZoom) return this.transform.minZoom = p, this._update(), this.getZoom() < p && this.setZoom(p), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(p) {
          if ((p = p ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = p, this._update(), this.getZoom() > p && this.setZoom(p), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(p) {
          if ((p = p ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (p >= 0 && p <= this.transform.maxPitch) return this.transform.minPitch = p, this._update(), this.getPitch() < p && this.setPitch(p), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(p) {
          if ((p = p ?? 60) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (p >= this.transform.minPitch) return this.transform.maxPitch = p, this._update(), this.getPitch() > p && this.setPitch(p), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(p) {
          return this.transform.renderWorldCopies = p, this._update();
        }
        project(p) {
          return this.transform.locationPoint(l.N.convert(p), this.style && this.terrain);
        }
        unproject(p) {
          return this.transform.pointLocation(l.P.convert(p), this.terrain);
        }
        isMoving() {
          var p;
          return this._moving || ((p = this.handlers) === null || p === void 0 ? void 0 : p.isMoving());
        }
        isZooming() {
          var p;
          return this._zooming || ((p = this.handlers) === null || p === void 0 ? void 0 : p.isZooming());
        }
        isRotating() {
          var p;
          return this._rotating || ((p = this.handlers) === null || p === void 0 ? void 0 : p.isRotating());
        }
        _createDelegatedListener(p, t, s) {
          if (p === "mouseenter" || p === "mouseover") {
            let c = !1;
            return { layer: t, listener: s, delegates: { mousemove: (a) => {
              const h = this.getLayer(t) ? this.queryRenderedFeatures(a.point, { layers: [t] }) : [];
              h.length ? c || (c = !0, s.call(this, new Pi(p, this, a.originalEvent, { features: h }))) : c = !1;
            }, mouseout: () => {
              c = !1;
            } } };
          }
          if (p === "mouseleave" || p === "mouseout") {
            let c = !1;
            return { layer: t, listener: s, delegates: { mousemove: (h) => {
              (this.getLayer(t) ? this.queryRenderedFeatures(h.point, { layers: [t] }) : []).length ? c = !0 : c && (c = !1, s.call(this, new Pi(p, this, h.originalEvent)));
            }, mouseout: (h) => {
              c && (c = !1, s.call(this, new Pi(p, this, h.originalEvent)));
            } } };
          }
          {
            const c = (r) => {
              const a = this.getLayer(t) ? this.queryRenderedFeatures(r.point, { layers: [t] }) : [];
              a.length && (r.features = a, s.call(this, r), delete r.features);
            };
            return { layer: t, listener: s, delegates: { [p]: c } };
          }
        }
        on(p, t, s) {
          if (s === void 0) return super.on(p, t);
          const c = this._createDelegatedListener(p, t, s);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[p] = this._delegatedListeners[p] || [], this._delegatedListeners[p].push(c);
          for (const r in c.delegates) this.on(r, c.delegates[r]);
          return this;
        }
        once(p, t, s) {
          if (s === void 0) return super.once(p, t);
          const c = this._createDelegatedListener(p, t, s);
          for (const r in c.delegates) this.once(r, c.delegates[r]);
          return this;
        }
        off(p, t, s) {
          return s === void 0 ? super.off(p, t) : (this._delegatedListeners && this._delegatedListeners[p] && ((c) => {
            const r = this._delegatedListeners[p];
            for (let a = 0; a < r.length; a++) {
              const h = r[a];
              if (h.layer === t && h.listener === s) {
                for (const d in h.delegates) this.off(d, h.delegates[d]);
                return r.splice(a, 1), this;
              }
            }
          })(), this);
        }
        queryRenderedFeatures(p, t) {
          if (!this.style) return [];
          let s;
          const c = p instanceof l.P || Array.isArray(p), r = c ? p : [[0, 0], [this.transform.width, this.transform.height]];
          if (t = t || (c ? {} : p) || {}, r instanceof l.P || typeof r[0] == "number") s = [l.P.convert(r)];
          else {
            const a = l.P.convert(r[0]), h = l.P.convert(r[1]);
            s = [a, new l.P(h.x, a.y), h, new l.P(a.x, h.y), a];
          }
          return this.style.queryRenderedFeatures(s, t, this.transform);
        }
        querySourceFeatures(p, t) {
          return this.style.querySourceFeatures(p, t);
        }
        setStyle(p, t) {
          return (t = l.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, t)).diff !== !1 && t.localIdeographFontFamily === this._localIdeographFontFamily && this.style && p ? (this._diffStyle(p, t), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._updateStyle(p, t));
        }
        setTransformRequest(p) {
          return this._requestManager.setTransformRequest(p), this;
        }
        _getUIString(p) {
          const t = this._locale[p];
          if (t == null) throw new Error(`Missing UI string '${p}'`);
          return t;
        }
        _updateStyle(p, t) {
          if (t.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(p, t));
          const s = this.style && t.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!p)), p ? (this.style = new Gs(this, t || {}), this.style.setEventedParent(this, { style: this.style }), typeof p == "string" ? this.style.loadURL(p, t, s) : this.style.loadJSON(p, t, s), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Gs(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(p, t) {
          if (typeof p == "string") {
            const s = this._requestManager.transformRequest(p, "Style");
            l.h(s, new AbortController()).then((c) => {
              this._updateDiff(c.data, t);
            }).catch((c) => {
              c && this.fire(new l.j(c));
            });
          } else typeof p == "object" && this._updateDiff(p, t);
        }
        _updateDiff(p, t) {
          try {
            this.style.setState(p, t) && this._update(!0);
          } catch (s) {
            l.w(`Unable to perform style diff: ${s.message || s.error || s}.  Rebuilding the style from scratch.`), this._updateStyle(p, t);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : l.w("There is no style added to the map.");
        }
        addSource(p, t) {
          return this._lazyInitEmptyStyle(), this.style.addSource(p, t), this._update(!0);
        }
        isSourceLoaded(p) {
          const t = this.style && this.style.sourceCaches[p];
          if (t !== void 0) return t.loaded();
          this.fire(new l.j(new Error(`There is no source with ID '${p}'`)));
        }
        setTerrain(p) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), p) {
            const t = this.style.sourceCaches[p.source];
            if (!t) throw new Error(`cannot load terrain, because there exists no source with ID: ${p.source}`);
            this.terrain === null && t.reload();
            for (const s in this.style._layers) {
              const c = this.style._layers[s];
              c.type === "hillshade" && c.source === p.source && l.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new Xo(this.painter, t, p), this.painter.renderToTexture = new ui(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (s) => {
              s.dataType === "style" ? this.terrain.sourceCache.freeRtt() : s.dataType === "source" && s.tile && (s.sourceId !== p.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(s.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new l.k("terrain", { terrain: p })), this;
        }
        getTerrain() {
          var p, t;
          return (t = (p = this.terrain) === null || p === void 0 ? void 0 : p.options) !== null && t !== void 0 ? t : null;
        }
        areTilesLoaded() {
          const p = this.style && this.style.sourceCaches;
          for (const t in p) {
            const s = p[t]._tiles;
            for (const c in s) {
              const r = s[c];
              if (r.state !== "loaded" && r.state !== "errored") return !1;
            }
          }
          return !0;
        }
        removeSource(p) {
          return this.style.removeSource(p), this._update(!0);
        }
        getSource(p) {
          return this.style.getSource(p);
        }
        addImage(p, t, s = {}) {
          const { pixelRatio: c = 1, sdf: r = !1, stretchX: a, stretchY: h, content: d, textFitWidth: _, textFitHeight: w } = s;
          if (this._lazyInitEmptyStyle(), !(t instanceof HTMLImageElement || l.b(t))) {
            if (t.width === void 0 || t.height === void 0) return this.fire(new l.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: k, height: T, data: C } = t, z = t;
              return this.style.addImage(p, { data: new l.R({ width: k, height: T }, new Uint8Array(C)), pixelRatio: c, stretchX: a, stretchY: h, content: d, textFitWidth: _, textFitHeight: w, sdf: r, version: 0, userImage: z }), z.onAdd && z.onAdd(this, p), this;
            }
          }
          {
            const { width: k, height: T, data: C } = q.getImageData(t);
            this.style.addImage(p, { data: new l.R({ width: k, height: T }, C), pixelRatio: c, stretchX: a, stretchY: h, content: d, textFitWidth: _, textFitHeight: w, sdf: r, version: 0 });
          }
        }
        updateImage(p, t) {
          const s = this.style.getImage(p);
          if (!s) return this.fire(new l.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const c = t instanceof HTMLImageElement || l.b(t) ? q.getImageData(t) : t, { width: r, height: a, data: h } = c;
          if (r === void 0 || a === void 0) return this.fire(new l.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (r !== s.data.width || a !== s.data.height) return this.fire(new l.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const d = !(t instanceof HTMLImageElement || l.b(t));
          return s.data.replace(h, d), this.style.updateImage(p, s), this;
        }
        getImage(p) {
          return this.style.getImage(p);
        }
        hasImage(p) {
          return p ? !!this.style.getImage(p) : (this.fire(new l.j(new Error("Missing required image id"))), !1);
        }
        removeImage(p) {
          this.style.removeImage(p);
        }
        loadImage(p) {
          return Mt.getImage(this._requestManager.transformRequest(p, "Image"), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(p, t) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(p, t), this._update(!0);
        }
        moveLayer(p, t) {
          return this.style.moveLayer(p, t), this._update(!0);
        }
        removeLayer(p) {
          return this.style.removeLayer(p), this._update(!0);
        }
        getLayer(p) {
          return this.style.getLayer(p);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(p, t, s) {
          return this.style.setLayerZoomRange(p, t, s), this._update(!0);
        }
        setFilter(p, t, s = {}) {
          return this.style.setFilter(p, t, s), this._update(!0);
        }
        getFilter(p) {
          return this.style.getFilter(p);
        }
        setPaintProperty(p, t, s, c = {}) {
          return this.style.setPaintProperty(p, t, s, c), this._update(!0);
        }
        getPaintProperty(p, t) {
          return this.style.getPaintProperty(p, t);
        }
        setLayoutProperty(p, t, s, c = {}) {
          return this.style.setLayoutProperty(p, t, s, c), this._update(!0);
        }
        getLayoutProperty(p, t) {
          return this.style.getLayoutProperty(p, t);
        }
        setGlyphs(p, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(p, t), this._update(!0);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(p, t, s = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(p, t, s, (c) => {
            c || this._update(!0);
          }), this;
        }
        removeSprite(p) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(p), this._update(!0);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(p, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(p, t, (s) => {
            s || this._update(!0);
          }), this;
        }
        setLight(p, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(p, t), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(p) {
          return this._lazyInitEmptyStyle(), this.style.setSky(p), this._update(!0);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(p, t) {
          return this.style.setFeatureState(p, t), this._update();
        }
        removeFeatureState(p, t) {
          return this.style.removeFeatureState(p, t), this._update();
        }
        getFeatureState(p) {
          return this.style.getFeatureState(p);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let p = 0, t = 0;
          return this._container && (p = this._container.clientWidth || 400, t = this._container.clientHeight || 300), [p, t];
        }
        _setupContainer() {
          const p = this._container;
          p.classList.add("maplibregl-map");
          const t = this._canvasContainer = U.create("div", "maplibregl-canvas-container", p);
          this._interactive && t.classList.add("maplibregl-interactive"), this._canvas = U.create("canvas", "maplibregl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const s = this._containerDimensions(), c = this._getClampedPixelRatio(s[0], s[1]);
          this._resizeCanvas(s[0], s[1], c);
          const r = this._controlContainer = U.create("div", "maplibregl-control-container", p), a = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((h) => {
            a[h] = U.create("div", `maplibregl-ctrl-${h} `, r);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(p, t, s) {
          this._canvas.width = Math.floor(s * p), this._canvas.height = Math.floor(s * t), this._canvas.style.width = `${p}px`, this._canvas.style.height = `${t}px`;
        }
        _setupPainter() {
          const p = { alpha: !0, stencil: !0, depth: !0, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 };
          let t = null;
          this._canvas.addEventListener("webglcontextcreationerror", (c) => {
            t = { requestedAttributes: p }, c && (t.statusMessage = c.statusMessage, t.type = c.type);
          }, { once: !0 });
          const s = this._canvas.getContext("webgl2", p) || this._canvas.getContext("webgl", p);
          if (!s) {
            const c = "Failed to initialize WebGL";
            throw t ? (t.message = c, new Error(JSON.stringify(t))) : new Error(c);
          }
          this.painter = new hn(s, this.transform), F.testSupport(s);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(p) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || p, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(p) {
          return this._update(), this._renderTaskQueue.add(p);
        }
        _cancelRenderFrame(p) {
          this._renderTaskQueue.remove(p);
        }
        _render(p) {
          const t = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(p), this._removed) return;
          let s = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const r = this.transform.zoom, a = q.now();
            this.style.zoomHistory.update(r, a);
            const h = new l.z(r, { now: a, fadeDuration: t, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), d = h.crossFadingFactor();
            d === 1 && d === this._crossFadingFactor || (s = !0, this._crossFadingFactor = d), this.style.update(h);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, t, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: t, showPadding: this.showPadding }), this.fire(new l.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, l.be.mark(l.bf.load), this.fire(new l.k("load"))), this.style && (this.style.hasTransitions() || s) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const c = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return c || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new l.k("idle")), !this._loaded || this._fullyLoaded || c || (this._fullyLoaded = !0, l.be.mark(l.bf.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var p;
          this._hash && this._hash.remove();
          for (const s of this._controls) s.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Mt.removeThrottleControl(this._imageQueueHandle), (p = this._resizeObserver) === null || p === void 0 || p.disconnect();
          const t = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t != null && t.loseContext && t.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), U.remove(this._canvasContainer), U.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), l.be.clearMetrics(), this._removed = !0, this.fire(new l.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), q.frameAsync(this._frameRequest).then((p) => {
            l.be.frame(p), this._frameRequest = null, this._render(p);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(p) {
          this._showTileBoundaries !== p && (this._showTileBoundaries = p, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(p) {
          this._showPadding !== p && (this._showPadding = p, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(p) {
          this._showCollisionBoxes !== p && (this._showCollisionBoxes = p, p ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(p) {
          this._showOverdrawInspector !== p && (this._showOverdrawInspector = p, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(p) {
          this._repaint !== p && (this._repaint = p, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(p) {
          this._vertices = p, this._update();
        }
        get version() {
          return Nc;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, v.MapMouseEvent = Pi, v.MapTouchEvent = ji, v.MapWheelEvent = Ki, v.Marker = Yo, v.NavigationControl = class {
        constructor(p) {
          this._updateZoomButtons = () => {
            const t = this._map.getZoom(), s = t === this._map.getMaxZoom(), c = t === this._map.getMinZoom();
            this._zoomInButton.disabled = s, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", s.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
          }, this._rotateCompassArrow = () => {
            const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = t;
          }, this._setButtonTitle = (t, s) => {
            const c = this._map._getUIString(`NavigationControl.${s}`);
            t.title = c, t.setAttribute("aria-label", c);
          }, this.options = l.e({}, ec, p), this._container = U.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t) => this._map.zoomIn({}, { originalEvent: t })), U.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t) => this._map.zoomOut({}, { originalEvent: t })), U.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t }) : this._map.resetNorth({}, { originalEvent: t });
          }), this._compassIcon = U.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(p) {
          return this._map = p, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new zl(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          U.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(p, t) {
          const s = U.create("button", p, this._container);
          return s.type = "button", s.addEventListener("click", t), s;
        }
      }, v.Popup = class extends l.E {
        constructor(p) {
          super(), this.remove = () => (this._content && U.remove(this._content), this._container && (U.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new l.k("close"))), this), this._onMouseUp = (t) => {
            this._update(t.point);
          }, this._onMouseMove = (t) => {
            this._update(t.point);
          }, this._onDrag = (t) => {
            this._update(t.point);
          }, this._update = (t) => {
            var s;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = U.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = U.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const d of this.options.className.split(" ")) this._container.classList.add(d);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? mo(this._lngLat, this._flatPos, this._map.transform) : (s = this._lngLat) === null || s === void 0 ? void 0 : s.wrap(), this._trackPointer && !t) return;
            const c = this._flatPos = this._pos = this._trackPointer && t ? t : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && t ? t : this._map.transform.locationPoint(this._lngLat));
            let r = this.options.anchor;
            const a = sc(this.options.offset);
            if (!r) {
              const d = this._container.offsetWidth, _ = this._container.offsetHeight;
              let w;
              w = c.y + a.bottom.y < _ ? ["top"] : c.y > this._map.transform.height - _ ? ["bottom"] : [], c.x < d / 2 ? w.push("left") : c.x > this._map.transform.width - d / 2 && w.push("right"), r = w.length === 0 ? "bottom" : w.join("-");
            }
            let h = c.add(a[r]);
            this.options.subpixelPositioning || (h = h.round()), U.setTransform(this._container, `${go[r]} translate(${h.x}px,${h.y}px)`), Ma(this._container, r, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = l.e(Object.create(rc), p);
        }
        addTo(p) {
          return this._map && this.remove(), this._map = p, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new l.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(p) {
          return this._lngLat = l.N.convert(p), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(p) {
          return this.setDOMContent(document.createTextNode(p));
        }
        setHTML(p) {
          const t = document.createDocumentFragment(), s = document.createElement("body");
          let c;
          for (s.innerHTML = p; c = s.firstChild, c; ) t.appendChild(c);
          return this.setDOMContent(t);
        }
        getMaxWidth() {
          var p;
          return (p = this._container) === null || p === void 0 ? void 0 : p.style.maxWidth;
        }
        setMaxWidth(p) {
          return this.options.maxWidth = p, this._update(), this;
        }
        setDOMContent(p) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = U.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(p), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(p) {
          return this._container && this._container.classList.add(p), this;
        }
        removeClassName(p) {
          return this._container && this._container.classList.remove(p), this;
        }
        setOffset(p) {
          return this.options.offset = p, this._update(), this;
        }
        toggleClassName(p) {
          if (this._container) return this._container.classList.toggle(p);
        }
        setSubpixelPositioning(p) {
          this.options.subpixelPositioning = p;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = U.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const p = this._container.querySelector(nc);
          p && p.focus();
        }
      }, v.RasterDEMTileSource = ye, v.RasterTileSource = oe, v.ScaleControl = class {
        constructor(p) {
          this._onMove = () => {
            pl(this._map, this._container, this.options);
          }, this.setUnit = (t) => {
            this.options.unit = t, pl(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, dl), p);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(p) {
          return this._map = p, this._container = U.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", p.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          U.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, v.ScrollZoomHandler = hl, v.Style = Gs, v.TerrainControl = class {
        constructor(p) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = p;
        }
        onAdd(p) {
          return this._map = p, this._container = U.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = U.create("button", "maplibregl-ctrl-terrain", this._container), U.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          U.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, v.TwoFingersTouchPitchHandler = Go, v.TwoFingersTouchRotateHandler = Ns, v.TwoFingersTouchZoomHandler = co, v.TwoFingersTouchZoomRotateHandler = Sn, v.VectorTileSource = Ue, v.VideoSource = hi, v.addSourceType = (p, t) => l._(void 0, void 0, void 0, function* () {
        if (Ii(p)) throw new Error(`A source type called "${p}" already exists.`);
        ((s, c) => {
          _i[s] = c;
        })(p, t);
      }), v.clearPrewarmedResources = function() {
        const p = Ot;
        p && (p.isPreloaded() && p.numActive() === 1 ? (p.release(_t), Ot = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, v.getMaxParallelImageRequests = function() {
        return l.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, v.getRTLTextPluginStatus = function() {
        return Pe().getRTLTextPluginStatus();
      }, v.getVersion = function() {
        return es;
      }, v.getWorkerCount = function() {
        return Ct.workerCount;
      }, v.getWorkerUrl = function() {
        return l.a.WORKER_URL;
      }, v.importScriptInWorkers = function(p) {
        return ve().broadcast("IS", p);
      }, v.prewarm = function() {
        Wt().acquire(_t);
      }, v.setMaxParallelImageRequests = function(p) {
        l.a.MAX_PARALLEL_IMAGE_REQUESTS = p;
      }, v.setRTLTextPlugin = function(p, t) {
        return Pe().setRTLTextPlugin(p, t);
      }, v.setWorkerCount = function(p) {
        Ct.workerCount = p;
      }, v.setWorkerUrl = function(p) {
        l.a.WORKER_URL = p;
      };
    });
    var A = y;
    return A;
  });
})(Yp);
var cg = Yp.exports, hg = Object.defineProperty, ug = (b, g, y) => g in b ? hg(b, g, { enumerable: !0, configurable: !0, writable: !0, value: y }) : b[g] = y, Zi = (b, g, y) => ug(b, typeof g != "symbol" ? g + "" : g, y);
class dg {
  constructor(g) {
    Zi(this, "map"), Zi(this, "width"), Zi(this, "height"), Zi(this, "svgCanvas"), Zi(this, "xLine"), Zi(this, "yLine"), Zi(this, "color", "#535353"), this.map = g, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var g, y;
    this.width = (g = this.map) == null ? void 0 : g.getCanvas().clientWidth, this.height = (y = this.map) == null ? void 0 : y.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const g = this.width / 2, y = this.height / 2;
      this.yLine.setAttribute("x1", `${g}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${g}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${y}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${y}px`);
    } else
      console.error("element value is null");
  }
  createCanvas(g) {
    if (this.width !== void 0 && this.height !== void 0) {
      const y = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      y.style.position = "relative", y.setAttribute("width", `${this.width}px`), y.setAttribute("height", `${this.height}px`);
      const x = this.width / 2, P = this.height / 2;
      this.yLine = y.appendChild(
        this.createLine(x, 0, x, this.height, this.color, "2px")
      ), this.xLine = y.appendChild(
        this.createLine(0, P, this.width, P, this.color, "2px")
      ), g == null || g.appendChild(y), this.svgCanvas = y;
    }
  }
  createLine(g, y, x, P, A, v) {
    const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return l.setAttribute("x1", g), l.setAttribute("y1", y), l.setAttribute("x2", x), l.setAttribute("y2", P), l.setAttribute("stroke-dasharray", "5,5"), l.setAttribute("stroke", A), l.setAttribute("stroke-width", v), l;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const Tp = {
  72: 72,
  96: 96,
  200: 200,
  300: 300,
  400: 400
}, nl = {
  JPEG: "jpg",
  PNG: "png",
  PDF: "pdf",
  SVG: "svg"
}, zh = {
  Landscape: "landscape",
  Portrait: "portrait"
}, Gl = {
  LARGE: [474, 406.2],
  //5600 x 4800
  LANDSCAPE: [609.4, 304.65],
  EXTRA: [507.75, 406.2],
  A_FORMAT: [440, 14, 406.2],
  // 5200 x 4800
  A_FORMAT_LANDSCAPE: [574.55, 175.07],
  // A2: [594, 420],
  // A3: [420, 297],
  A4: [297, 210]
  // A5: [210, 148],
  // A6: [148, 105],
  // B2: [707, 500],
  // B3: [500, 353],
  // B4: [353, 250],
  // B5: [250, 176],
  // B6: [176, 125]
}, Hl = {
  // don't use inch unit. because page size setting is using mm unit.
  in: "in",
  mm: "mm"
};
class pg {
  constructor(g) {
    Zi(this, "map"), Zi(this, "width"), Zi(this, "height"), Zi(this, "unit"), Zi(this, "svgCanvas"), Zi(this, "svgPath");
    var y, x, P;
    if (this.map = g, this.map === void 0)
      return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const A = (y = this.map) == null ? void 0 : y.getCanvas().clientWidth, v = (x = this.map) == null ? void 0 : x.getCanvas().clientHeight, l = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    l.style.position = "absolute", l.style.top = "0px", l.style.left = "0px", l.setAttribute("width", `${A}px`), l.setAttribute("height", `${v}px`);
    const M = document.createElementNS("http://www.w3.org/2000/svg", "path");
    M.setAttribute("style", "fill:#888888;stroke-width:0"), M.setAttribute("fill-opacity", "0.5"), l.append(M), (P = this.map) == null || P.getCanvasContainer().appendChild(l), this.svgCanvas = l, this.svgPath = M;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(g, y) {
    this.width = g, this.height = y, this.unit = Hl.mm, this.generateCutOut();
  }
  generateCutOut() {
    var g, y;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0)
      return;
    const x = this.toPixels(this.width), P = this.toPixels(this.height), A = (g = this.map) == null ? void 0 : g.getCanvas().clientWidth, v = (y = this.map) == null ? void 0 : y.getCanvas().clientHeight, l = A / 2 - x / 2, M = l + x, B = v / 2 - P / 2, $ = B + P;
    this.svgCanvas.setAttribute("width", `${A}px`), this.svgCanvas.setAttribute("height", `${v}px`), this.svgPath.setAttribute(
      "d",
      `M 0 0 L ${A} 0 L ${A} ${v} L 0 ${v} M ${l} ${B} L ${l} ${$} L ${M} ${$} L ${M} ${B}`
    );
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(g, y = 96) {
    return this.unit === Hl.mm && (y /= 25.4), y * g;
  }
}
const Kp = {
  PageSize: "Page Size",
  PageOrientation: "Page Orientation",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generate",
  LanguageName: "English",
  LanguageCode: "en"
}, fg = {
  PageSize: "Taille de page",
  PageOrientation: "Orientation de la page",
  Format: "Format",
  DPI: "DPI",
  Generate: "Gnrer",
  LanguageName: "Franais",
  LanguageCode: "fr"
}, mg = {
  PageSize: "Sivukoko",
  PageOrientation: "Sivun suunta",
  Format: "Muoto",
  DPI: "DPI",
  Generate: "Generoi",
  LanguageName: "Suomalainen",
  LanguageCode: "fi"
}, gg = {
  PageSize: "Papierformat",
  PageOrientation: "Papierausrichtung",
  Format: "Dateiformat",
  DPI: "Druckauflsung",
  Generate: "Erstellen",
  LanguageName: "Deutsch",
  LanguageCode: "de"
}, yg = {
  PageSize: "Sidstorlek",
  PageOrientation: "Sidorientering",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generera",
  LanguageName: "Svenska",
  LanguageCode: "sv"
}, _g = {
  PageSize: "Tamao de pgina",
  PageOrientation: "Orientacin de pgina",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Generar",
  LanguageName: "Espaola",
  LanguageCode: "es"
}, vg = {
  PageSize: "Mida",
  PageOrientation: "Orientaci",
  Format: "Format",
  DPI: "DPI",
  Generate: "Genera",
  LanguageName: "Catalan",
  LanguageCode: "ca"
}, xg = {
  PageSize: "Kch thc trang",
  PageOrientation: "Loi trang",
  Format: "nh dng",
  DPI: "Mt  im nh (DPI)",
  Generate: "To",
  LanguageName: "Ting Vit",
  LanguageCode: "vi"
}, bg = {
  PageSize: " ",
  PageOrientation: " ",
  Format: "",
  DPI: "DPI",
  Generate: "",
  LanguageName: "",
  LanguageCode: "uk"
}, wg = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "",
  Generate: "",
  LanguageName: "",
  LanguageCode: "zhHans"
}, Sg = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "",
  Generate: "",
  LanguageName: "",
  LanguageCode: "zhHant"
}, Ag = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "DPI",
  Generate: "",
  LanguageName: "",
  LanguageCode: "ja"
}, Pg = {
  PageSize: "Tamanho da pgina",
  PageOrientation: "Orientao da pgina",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Gerar",
  LanguageName: "Portugus",
  LanguageCode: "pt"
}, Ig = [
  Kp,
  fg,
  mg,
  gg,
  yg,
  _g,
  vg,
  xg,
  bg,
  wg,
  Sg,
  Ag,
  Pg
], kg = (b) => Ig.find((g) => g.LanguageCode === b) ?? Kp;
(function(b) {
  var g = {};
  function y(x) {
    if (g[x]) return g[x].exports;
    var P = g[x] = { i: x, l: !1, exports: {} };
    return b[x].call(P.exports, P, P.exports, y), P.l = !0, P.exports;
  }
  y.m = b, y.c = g, y.d = function(x, P, A) {
    y.o(x, P) || Object.defineProperty(x, P, { enumerable: !0, get: A });
  }, y.r = function(x) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(x, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(x, "__esModule", { value: !0 });
  }, y.t = function(x, P) {
    if (1 & P && (x = y(x)), 8 & P || 4 & P && typeof x == "object" && x && x.__esModule) return x;
    var A = /* @__PURE__ */ Object.create(null);
    if (y.r(A), Object.defineProperty(A, "default", { enumerable: !0, value: x }), 2 & P && typeof x != "string") for (var v in x) y.d(A, v, (function(l) {
      return x[l];
    }).bind(null, v));
    return A;
  }, y.n = function(x) {
    var P = x && x.__esModule ? function() {
      return x.default;
    } : function() {
      return x;
    };
    return y.d(P, "a", P), P;
  }, y.o = function(x, P) {
    return Object.prototype.hasOwnProperty.call(x, P);
  }, y.p = "", y(y.s = 0);
})([function(b, g, y) {
  b.exports = y(1);
}, function(b, g) {
  function y(P, A) {
    for (var v = 0; v < A.length; v++) {
      var l = A[v];
      l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(P, l.key, l);
    }
  }
  var x = function() {
    function P() {
      (function(l, M) {
        if (!(l instanceof M)) throw new TypeError("Cannot call a class as a function");
      })(this, P), this.options = { overlayBackgroundColor: "#666666", overlayOpacity: 0.6, spinnerIcon: "ball-circus", spinnerColor: "#000", spinnerSize: "3x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetY: 0, offsetX: 0, lockScroll: !1, containerID: null, spinnerZIndex: 99999, overlayZIndex: 99998 }, this.stylesheetBaseURL = "https://cdn.jsdelivr.net/npm/load-awesome@1.1.0/css/", this.spinner = null, this.spinnerStylesheetURL = null, this.numberOfEmptyDivForSpinner = { "ball-8bits": 16, "ball-atom": 4, "ball-beat": 3, "ball-circus": 5, "ball-climbing-dot": 1, "ball-clip-rotate": 1, "ball-clip-rotate-multiple": 2, "ball-clip-rotate-pulse": 2, "ball-elastic-dots": 5, "ball-fall": 3, "ball-fussion": 4, "ball-grid-beat": 9, "ball-grid-pulse": 9, "ball-newton-cradle": 4, "ball-pulse": 3, "ball-pulse-rise": 5, "ball-pulse-sync": 3, "ball-rotate": 1, "ball-running-dots": 5, "ball-scale": 1, "ball-scale-multiple": 3, "ball-scale-pulse": 2, "ball-scale-ripple": 1, "ball-scale-ripple-multiple": 3, "ball-spin": 8, "ball-spin-clockwise": 8, "ball-spin-clockwise-fade": 8, "ball-spin-clockwise-fade-rotating": 8, "ball-spin-fade": 8, "ball-spin-fade-rotating": 8, "ball-spin-rotate": 2, "ball-square-clockwise-spin": 8, "ball-square-spin": 8, "ball-triangle-path": 3, "ball-zig-zag": 2, "ball-zig-zag-deflect": 2, cog: 1, "cube-transition": 2, fire: 3, "line-scale": 5, "line-scale-party": 5, "line-scale-pulse-out": 5, "line-scale-pulse-out-rapid": 5, "line-spin-clockwise-fade": 8, "line-spin-clockwise-fade-rotating": 8, "line-spin-fade": 8, "line-spin-fade-rotating": 8, pacman: 6, "square-jelly-box": 2, "square-loader": 1, "square-spin": 1, timer: 1, "triangle-skew-spin": 1 };
    }
    var A, v;
    return A = P, (v = [{ key: "show", value: function(l) {
      this.setOptions(l), this.addSpinnerStylesheet(), this.generateSpinnerElement(), this.options.lockScroll && (document.body.style.overflow = "hidden", document.documentElement.style.overflow = "hidden"), this.generateAndAddOverlayElement();
    } }, { key: "hide", value: function() {
      this.options.lockScroll && (document.body.style.overflow = "", document.documentElement.style.overflow = "");
      var l = document.getElementById("loading-overlay-stylesheet");
      l && (l.disabled = !0, l.parentNode.removeChild(l), document.getElementById(this.options.overlayIDName).remove(), document.getElementById(this.options.spinnerIDName).remove());
    } }, { key: "setOptions", value: function(l) {
      if (l !== void 0) for (var M in l) this.options[M] = l[M];
    } }, { key: "generateAndAddOverlayElement", value: function() {
      var l = "50%";
      this.options.offsetX !== 0 && (l = "calc(50% + " + this.options.offsetX + ")");
      var M = "50%";
      if (this.options.offsetY !== 0 && (M = "calc(50% + " + this.options.offsetY + ")"), this.options.containerID && document.body.contains(document.getElementById(this.options.containerID))) {
        var B = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: absolute; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, '; z-index: 50; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: absolute; top: ').concat(M, "; left: ").concat(l, '; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: 9999;">').concat(this.spinner, "</div>"), $ = document.getElementById(this.options.containerID);
        return $.style.position = "relative", void $.insertAdjacentHTML("beforeend", B);
      }
      var q = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: fixed; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, "; z-index: ").concat(this.options.overlayZIndex, '; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: fixed; top: ').concat(M, "; left: ").concat(l, "; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: ").concat(this.options.spinnerZIndex, ';">').concat(this.spinner, "</div>");
      document.body.insertAdjacentHTML("beforeend", q);
    } }, { key: "generateSpinnerElement", value: function() {
      var l = this, M = Object.keys(this.numberOfEmptyDivForSpinner).find(function($) {
        return $ === l.options.spinnerIcon;
      }), B = this.generateEmptyDivElement(this.numberOfEmptyDivForSpinner[M]);
      this.spinner = '<div style="color: '.concat(this.options.spinnerColor, '" class="la-').concat(this.options.spinnerIcon, " la-").concat(this.options.spinnerSize, '">').concat(B, "</div>");
    } }, { key: "addSpinnerStylesheet", value: function() {
      this.setSpinnerStylesheetURL();
      var l = document.createElement("link");
      l.setAttribute("id", "loading-overlay-stylesheet"), l.setAttribute("rel", "stylesheet"), l.setAttribute("type", "text/css"), l.setAttribute("href", this.spinnerStylesheetURL), document.getElementsByTagName("head")[0].appendChild(l);
    } }, { key: "setSpinnerStylesheetURL", value: function() {
      this.spinnerStylesheetURL = this.stylesheetBaseURL + this.options.spinnerIcon + ".min.css";
    } }, { key: "generateEmptyDivElement", value: function(l) {
      for (var M = "", B = 1; B <= l; B++) M += "<div></div>";
      return M;
    } }]) && y(A.prototype, v), P;
  }();
  window.JsLoadingOverlay = new x(), b.exports = JsLoadingOverlay;
}]);
function ir(b) {
  "@babel/helpers - typeof";
  return ir = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
    return typeof g;
  } : function(g) {
    return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
  }, ir(b);
}
var Is = Uint8Array, as = Uint16Array, ch = Uint32Array, $h = new Is([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Zh = new Is([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), ju = new Is([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Qp = function(b, g) {
  for (var y = new as(31), x = 0; x < 31; ++x)
    y[x] = g += 1 << b[x - 1];
  for (var P = new ch(y[30]), x = 1; x < 30; ++x)
    for (var A = y[x]; A < y[x + 1]; ++A)
      P[A] = A - y[x] << 5 | x;
  return [y, P];
}, tf = Qp($h, 2), ef = tf[0], qu = tf[1];
ef[28] = 258, qu[258] = 28;
var rf = Qp(Zh, 0), Tg = rf[0], Lp = rf[1], Uu = new as(32768);
for (var _r = 0; _r < 32768; ++_r) {
  var bl = (_r & 43690) >>> 1 | (_r & 21845) << 1;
  bl = (bl & 52428) >>> 2 | (bl & 13107) << 2, bl = (bl & 61680) >>> 4 | (bl & 3855) << 4, Uu[_r] = ((bl & 65280) >>> 8 | (bl & 255) << 8) >>> 1;
}
var Eo = function(b, g, y) {
  for (var x = b.length, P = 0, A = new as(g); P < x; ++P)
    ++A[b[P] - 1];
  var v = new as(g);
  for (P = 0; P < g; ++P)
    v[P] = v[P - 1] + A[P - 1] << 1;
  var l;
  if (y) {
    l = new as(1 << g);
    var M = 15 - g;
    for (P = 0; P < x; ++P)
      if (b[P])
        for (var B = P << 4 | b[P], $ = g - b[P], q = v[b[P] - 1]++ << $, U = q | (1 << $) - 1; q <= U; ++q)
          l[Uu[q] >>> M] = B;
  } else
    for (l = new as(x), P = 0; P < x; ++P)
      l[P] = Uu[v[b[P] - 1]++] >>> 15 - b[P];
  return l;
}, Al = new Is(288);
for (var _r = 0; _r < 144; ++_r)
  Al[_r] = 8;
for (var _r = 144; _r < 256; ++_r)
  Al[_r] = 9;
for (var _r = 256; _r < 280; ++_r)
  Al[_r] = 7;
for (var _r = 280; _r < 288; ++_r)
  Al[_r] = 8;
var hh = new Is(32);
for (var _r = 0; _r < 32; ++_r)
  hh[_r] = 5;
var Lg = /* @__PURE__ */ Eo(Al, 9, 0), Cg = /* @__PURE__ */ Eo(Al, 9, 1), Eg = /* @__PURE__ */ Eo(hh, 5, 0), Mg = /* @__PURE__ */ Eo(hh, 5, 1), Mu = function(b) {
  for (var g = b[0], y = 1; y < b.length; ++y)
    b[y] > g && (g = b[y]);
  return g;
}, Ba = function(b, g, y) {
  var x = g / 8 >> 0;
  return (b[x] | b[x + 1] << 8) >>> (g & 7) & y;
}, zu = function(b, g) {
  var y = g / 8 >> 0;
  return (b[y] | b[y + 1] << 8 | b[y + 2] << 16) >>> (g & 7);
}, Ku = function(b) {
  return (b / 8 >> 0) + (b & 7 && 1);
}, nf = function(b, g, y) {
  (y == null || y > b.length) && (y = b.length);
  var x = new (b instanceof as ? as : b instanceof ch ? ch : Is)(y - g);
  return x.set(b.subarray(g, y)), x;
}, zg = function(b, g, y) {
  var x = b.length, P = !g || y, A = !y || y.i;
  y || (y = {}), g || (g = new Is(x * 3));
  var v = function(Dt) {
    var Ot = g.length;
    if (Dt > Ot) {
      var Vt = new Is(Math.max(Ot * 2, Dt));
      Vt.set(g), g = Vt;
    }
  }, l = y.f || 0, M = y.p || 0, B = y.b || 0, $ = y.l, q = y.d, U = y.m, F = y.n, mt = x * 8;
  do {
    if (!$) {
      y.f = l = Ba(b, M, 1);
      var ot = Ba(b, M + 1, 3);
      if (M += 3, ot)
        if (ot == 1)
          $ = Cg, q = Mg, U = 9, F = 5;
        else if (ot == 2) {
          var yt = Ba(b, M, 31) + 257, st = Ba(b, M + 10, 15) + 4, gt = yt + Ba(b, M + 5, 31) + 1;
          M += 14;
          for (var Mt = new Is(gt), Qt = new Is(19), Ht = 0; Ht < st; ++Ht)
            Qt[ju[Ht]] = Ba(b, M + Ht * 3, 7);
          M += st * 3;
          var pe = Mu(Qt), jt = (1 << pe) - 1;
          if (!A && M + gt * (pe + 7) > mt)
            break;
          for (var Tt = Eo(Qt, pe, 1), Ht = 0; Ht < gt; ) {
            var le = Tt[Ba(b, M, jt)];
            M += le & 15;
            var ne = le >>> 4;
            if (ne < 16)
              Mt[Ht++] = ne;
            else {
              var at = 0, lt = 0;
              for (ne == 16 ? (lt = 3 + Ba(b, M, 3), M += 2, at = Mt[Ht - 1]) : ne == 17 ? (lt = 3 + Ba(b, M, 7), M += 3) : ne == 18 && (lt = 11 + Ba(b, M, 127), M += 7); lt--; )
                Mt[Ht++] = at;
            }
          }
          var Pt = Mt.subarray(0, yt), bt = Mt.subarray(yt);
          U = Mu(Pt), F = Mu(bt), $ = Eo(Pt, U, 1), q = Eo(bt, F, 1);
        } else
          throw "invalid block type";
      else {
        var ne = Ku(M) + 4, Jt = b[ne - 4] | b[ne - 3] << 8, Yt = ne + Jt;
        if (Yt > x) {
          if (A)
            throw "unexpected EOF";
          break;
        }
        P && v(B + Jt), g.set(b.subarray(ne, Yt), B), y.b = B += Jt, y.p = M = Yt * 8;
        continue;
      }
      if (M > mt)
        throw "unexpected EOF";
    }
    P && v(B + 131072);
    for (var te = (1 << U) - 1, Ut = (1 << F) - 1, se = U + F + 18; A || M + se < mt; ) {
      var at = $[zu(b, M) & te], ee = at >>> 4;
      if (M += at & 15, M > mt)
        throw "unexpected EOF";
      if (!at)
        throw "invalid length/literal";
      if (ee < 256)
        g[B++] = ee;
      else if (ee == 256) {
        $ = null;
        break;
      } else {
        var be = ee - 254;
        if (ee > 264) {
          var Ht = ee - 257, Q = $h[Ht];
          be = Ba(b, M, (1 << Q) - 1) + ef[Ht], M += Q;
        }
        var pt = q[zu(b, M) & Ut], _t = pt >>> 4;
        if (!pt)
          throw "invalid distance";
        M += pt & 15;
        var bt = Tg[_t];
        if (_t > 3) {
          var Q = Zh[_t];
          bt += zu(b, M) & (1 << Q) - 1, M += Q;
        }
        if (M > mt)
          throw "unexpected EOF";
        P && v(B + 131072);
        for (var Ct = B + be; B < Ct; B += 4)
          g[B] = g[B - bt], g[B + 1] = g[B + 1 - bt], g[B + 2] = g[B + 2 - bt], g[B + 3] = g[B + 3 - bt];
        B = Ct;
      }
    }
    y.l = $, y.p = M, y.b = B, $ && (l = 1, y.m = U, y.d = q, y.n = F);
  } while (!l);
  return B == g.length ? g : nf(g, 0, B);
}, rl = function(b, g, y) {
  y <<= g & 7;
  var x = g / 8 >> 0;
  b[x] |= y, b[x + 1] |= y >>> 8;
}, ah = function(b, g, y) {
  y <<= g & 7;
  var x = g / 8 >> 0;
  b[x] |= y, b[x + 1] |= y >>> 8, b[x + 2] |= y >>> 16;
}, Du = function(b, g) {
  for (var y = [], x = 0; x < b.length; ++x)
    b[x] && y.push({ s: x, f: b[x] });
  var P = y.length, A = y.slice();
  if (!P)
    return [new Is(0), 0];
  if (P == 1) {
    var v = new Is(y[0].s + 1);
    return v[y[0].s] = 1, [v, 1];
  }
  y.sort(function(Ht, pe) {
    return Ht.f - pe.f;
  }), y.push({ s: -1, f: 25001 });
  var l = y[0], M = y[1], B = 0, $ = 1, q = 2;
  for (y[0] = { s: -1, f: l.f + M.f, l, r: M }; $ != P - 1; )
    l = y[y[B].f < y[q].f ? B++ : q++], M = y[B != $ && y[B].f < y[q].f ? B++ : q++], y[$++] = { s: -1, f: l.f + M.f, l, r: M };
  for (var U = A[0].s, x = 1; x < P; ++x)
    A[x].s > U && (U = A[x].s);
  var F = new as(U + 1), mt = Vu(y[$ - 1], F, 0);
  if (mt > g) {
    var x = 0, ot = 0, yt = mt - g, st = 1 << yt;
    for (A.sort(function(pe, jt) {
      return F[jt.s] - F[pe.s] || pe.f - jt.f;
    }); x < P; ++x) {
      var gt = A[x].s;
      if (F[gt] > g)
        ot += st - (1 << mt - F[gt]), F[gt] = g;
      else
        break;
    }
    for (ot >>>= yt; ot > 0; ) {
      var Mt = A[x].s;
      F[Mt] < g ? ot -= 1 << g - F[Mt]++ - 1 : ++x;
    }
    for (; x >= 0 && ot; --x) {
      var Qt = A[x].s;
      F[Qt] == g && (--F[Qt], ++ot);
    }
    mt = g;
  }
  return [new Is(F), mt];
}, Vu = function(b, g, y) {
  return b.s == -1 ? Math.max(Vu(b.l, g, y + 1), Vu(b.r, g, y + 1)) : g[b.s] = y;
}, Cp = function(b) {
  for (var g = b.length; g && !b[--g]; )
    ;
  for (var y = new as(++g), x = 0, P = b[0], A = 1, v = function(M) {
    y[x++] = M;
  }, l = 1; l <= g; ++l)
    if (b[l] == P && l != g)
      ++A;
    else {
      if (!P && A > 2) {
        for (; A > 138; A -= 138)
          v(32754);
        A > 2 && (v(A > 10 ? A - 11 << 5 | 28690 : A - 3 << 5 | 12305), A = 0);
      } else if (A > 3) {
        for (v(P), --A; A > 6; A -= 6)
          v(8304);
        A > 2 && (v(A - 3 << 5 | 8208), A = 0);
      }
      for (; A--; )
        v(P);
      A = 1, P = b[l];
    }
  return [y.subarray(0, x), g];
}, oh = function(b, g) {
  for (var y = 0, x = 0; x < g.length; ++x)
    y += b[x] * g[x];
  return y;
}, $u = function(b, g, y) {
  var x = y.length, P = Ku(g + 2);
  b[P] = x & 255, b[P + 1] = x >>> 8, b[P + 2] = b[P] ^ 255, b[P + 3] = b[P + 1] ^ 255;
  for (var A = 0; A < x; ++A)
    b[P + A + 4] = y[A];
  return (P + 4 + x) * 8;
}, Ep = function(b, g, y, x, P, A, v, l, M, B, $) {
  rl(g, $++, y), ++P[256];
  for (var q = Du(P, 15), U = q[0], F = q[1], mt = Du(A, 15), ot = mt[0], yt = mt[1], st = Cp(U), gt = st[0], Mt = st[1], Qt = Cp(ot), Ht = Qt[0], pe = Qt[1], jt = new as(19), Tt = 0; Tt < gt.length; ++Tt)
    jt[gt[Tt] & 31]++;
  for (var Tt = 0; Tt < Ht.length; ++Tt)
    jt[Ht[Tt] & 31]++;
  for (var le = Du(jt, 7), ne = le[0], at = le[1], lt = 19; lt > 4 && !ne[ju[lt - 1]]; --lt)
    ;
  var Pt = B + 5 << 3, bt = oh(P, Al) + oh(A, hh) + v, Jt = oh(P, U) + oh(A, ot) + v + 14 + 3 * lt + oh(jt, ne) + (2 * jt[16] + 3 * jt[17] + 7 * jt[18]);
  if (Pt <= bt && Pt <= Jt)
    return $u(g, $, b.subarray(M, M + B));
  var Yt, te, Ut, se;
  if (rl(g, $, 1 + (Jt < bt)), $ += 2, Jt < bt) {
    Yt = Eo(U, F, 0), te = U, Ut = Eo(ot, yt, 0), se = ot;
    var ee = Eo(ne, at, 0);
    rl(g, $, Mt - 257), rl(g, $ + 5, pe - 1), rl(g, $ + 10, lt - 4), $ += 14;
    for (var Tt = 0; Tt < lt; ++Tt)
      rl(g, $ + 3 * Tt, ne[ju[Tt]]);
    $ += 3 * lt;
    for (var be = [gt, Ht], Q = 0; Q < 2; ++Q)
      for (var pt = be[Q], Tt = 0; Tt < pt.length; ++Tt) {
        var _t = pt[Tt] & 31;
        rl(g, $, ee[_t]), $ += ne[_t], _t > 15 && (rl(g, $, pt[Tt] >>> 5 & 127), $ += pt[Tt] >>> 12);
      }
  } else
    Yt = Lg, te = Al, Ut = Eg, se = hh;
  for (var Tt = 0; Tt < l; ++Tt)
    if (x[Tt] > 255) {
      var _t = x[Tt] >>> 18 & 31;
      ah(g, $, Yt[_t + 257]), $ += te[_t + 257], _t > 7 && (rl(g, $, x[Tt] >>> 23 & 31), $ += $h[_t]);
      var Ct = x[Tt] & 31;
      ah(g, $, Ut[Ct]), $ += se[Ct], Ct > 3 && (ah(g, $, x[Tt] >>> 5 & 8191), $ += Zh[Ct]);
    } else
      ah(g, $, Yt[x[Tt]]), $ += te[x[Tt]];
  return ah(g, $, Yt[256]), $ + te[256];
}, Dg = /* @__PURE__ */ new ch([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Ng = function(b, g, y, x, P, A) {
  var v = b.length, l = new Is(x + v + 5 * (1 + Math.floor(v / 7e3)) + P), M = l.subarray(x, l.length - P), B = 0;
  if (!g || v < 8)
    for (var $ = 0; $ <= v; $ += 65535) {
      var q = $ + 65535;
      q < v ? B = $u(M, B, b.subarray($, q)) : (M[$] = A, B = $u(M, B, b.subarray($, v)));
    }
  else {
    for (var U = Dg[g - 1], F = U >>> 13, mt = U & 8191, ot = (1 << y) - 1, yt = new as(32768), st = new as(ot + 1), gt = Math.ceil(y / 3), Mt = 2 * gt, Qt = function(Je) {
      return (b[Je] ^ b[Je + 1] << gt ^ b[Je + 2] << Mt) & ot;
    }, Ht = new ch(25e3), pe = new as(288), jt = new as(32), Tt = 0, le = 0, $ = 0, ne = 0, at = 0, lt = 0; $ < v; ++$) {
      var Pt = Qt($), bt = $ & 32767, Jt = st[Pt];
      if (yt[bt] = Jt, st[Pt] = bt, at <= $) {
        var Yt = v - $;
        if ((Tt > 7e3 || ne > 24576) && Yt > 423) {
          B = Ep(b, M, 0, Ht, pe, jt, le, ne, lt, $ - lt, B), ne = Tt = le = 0, lt = $;
          for (var te = 0; te < 286; ++te)
            pe[te] = 0;
          for (var te = 0; te < 30; ++te)
            jt[te] = 0;
        }
        var Ut = 2, se = 0, ee = mt, be = bt - Jt & 32767;
        if (Yt > 2 && Pt == Qt($ - be))
          for (var Q = Math.min(F, Yt) - 1, pt = Math.min(32767, $), _t = Math.min(258, Yt); be <= pt && --ee && bt != Jt; ) {
            if (b[$ + Ut] == b[$ + Ut - be]) {
              for (var Ct = 0; Ct < _t && b[$ + Ct] == b[$ + Ct - be]; ++Ct)
                ;
              if (Ct > Ut) {
                if (Ut = Ct, se = be, Ct > Q)
                  break;
                for (var Dt = Math.min(be, Ct - 2), Ot = 0, te = 0; te < Dt; ++te) {
                  var Vt = $ - be + te + 32768 & 32767, Wt = yt[Vt], xe = Vt - Wt + 32768 & 32767;
                  xe > Ot && (Ot = xe, Jt = Vt);
                }
              }
            }
            bt = Jt, Jt = yt[bt], be += bt - Jt + 32768 & 32767;
          }
        if (se) {
          Ht[ne++] = 268435456 | qu[Ut] << 18 | Lp[se];
          var ve = qu[Ut] & 31, ke = Lp[se] & 31;
          le += $h[ve] + Zh[ke], ++pe[257 + ve], ++jt[ke], at = $ + Ut, ++Tt;
        } else
          Ht[ne++] = b[$], ++pe[b[$]];
      }
    }
    B = Ep(b, M, A, Ht, pe, jt, le, ne, lt, $ - lt, B);
  }
  return nf(l, 0, x + Ku(B) + P);
}, Fg = function() {
  var b = 1, g = 0;
  return {
    p: function(y) {
      for (var x = b, P = g, A = y.length, v = 0; v != A; ) {
        for (var l = Math.min(v + 5552, A); v < l; ++v)
          x += y[v], P += x;
        x %= 65521, P %= 65521;
      }
      b = x, g = P;
    },
    d: function() {
      return (b >>> 8 << 16 | (g & 255) << 8 | g >>> 8) + ((b & 255) << 23) * 2;
    }
  };
}, Rg = function(b, g, y, x, P) {
  return Ng(b, g.level == null ? 6 : g.level, g.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(b.length))) * 1.5) : 12 + g.mem, y, x, !P);
}, Bg = function(b, g, y) {
  for (; y; ++g)
    b[g] = y, y >>>= 8;
}, Og = function(b, g) {
  var y = g.level, x = y == 0 ? 0 : y < 6 ? 1 : y == 9 ? 3 : 2;
  b[0] = 120, b[1] = x << 6 | (x ? 32 - 2 * x : 1);
}, jg = function(b) {
  if ((b[0] & 15) != 8 || b[0] >>> 4 > 7 || (b[0] << 8 | b[1]) % 31)
    throw "invalid zlib data";
  if (b[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Zu(b, g) {
  g === void 0 && (g = {});
  var y = Fg();
  y.p(b);
  var x = Rg(b, g, 2, 4);
  return Og(x, g), Bg(x, x.length - 4, y.d()), x;
}
function qg(b, g) {
  return zg((jg(b), b.subarray(2, -4)), g);
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var fi = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function Nu() {
  fi.console && typeof fi.console.log == "function" && fi.console.log.apply(fi.console, arguments);
}
var ur = { log: Nu, warn: function(b) {
  fi.console && (typeof fi.console.warn == "function" ? fi.console.warn.apply(fi.console, arguments) : Nu.call(null, arguments));
}, error: function(b) {
  fi.console && (typeof fi.console.error == "function" ? fi.console.error.apply(fi.console, arguments) : Nu(b));
} };
function Fu(b, g, y) {
  var x = new XMLHttpRequest();
  x.open("GET", b), x.responseType = "blob", x.onload = function() {
    $l(x.response, g, y);
  }, x.onerror = function() {
    ur.error("could not download file");
  }, x.send();
}
function Mp(b) {
  var g = new XMLHttpRequest();
  g.open("HEAD", b, !1);
  try {
    g.send();
  } catch {
  }
  return g.status >= 200 && g.status <= 299;
}
function Dh(b) {
  try {
    b.dispatchEvent(new MouseEvent("click"));
  } catch {
    var g = document.createEvent("MouseEvents");
    g.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), b.dispatchEvent(g);
  }
}
var lh, Gu, $l = fi.saveAs || ((typeof window > "u" ? "undefined" : ir(window)) !== "object" || window !== fi ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(b, g, y) {
  var x = fi.URL || fi.webkitURL, P = document.createElement("a");
  g = g || b.name || "download", P.download = g, P.rel = "noopener", typeof b == "string" ? (P.href = b, P.origin !== location.origin ? Mp(P.href) ? Fu(b, g, y) : Dh(P, P.target = "_blank") : Dh(P)) : (P.href = x.createObjectURL(b), setTimeout(function() {
    x.revokeObjectURL(P.href);
  }, 4e4), setTimeout(function() {
    Dh(P);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(b, g, y) {
  if (g = g || b.name || "download", typeof b == "string") if (Mp(b)) Fu(b, g, y);
  else {
    var x = document.createElement("a");
    x.href = b, x.target = "_blank", setTimeout(function() {
      Dh(x);
    });
  }
  else navigator.msSaveOrOpenBlob(function(P, A) {
    return A === void 0 ? A = { autoBom: !1 } : ir(A) !== "object" && (ur.warn("Deprecated: Expected third argument to be a object"), A = { autoBom: !A }), A.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(P.type) ? new Blob(["\uFEFF", P], { type: P.type }) : P;
  }(b, y), g);
} : function(b, g, y, x) {
  if ((x = x || open("", "_blank")) && (x.document.title = x.document.body.innerText = "downloading..."), typeof b == "string") return Fu(b, g, y);
  var P = b.type === "application/octet-stream", A = /constructor/i.test(fi.HTMLElement) || fi.safari, v = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((v || P && A) && (typeof FileReader > "u" ? "undefined" : ir(FileReader)) === "object") {
    var l = new FileReader();
    l.onloadend = function() {
      var $ = l.result;
      $ = v ? $ : $.replace(/^data:[^;]*;/, "data:attachment/file;"), x ? x.location.href = $ : location = $, x = null;
    }, l.readAsDataURL(b);
  } else {
    var M = fi.URL || fi.webkitURL, B = M.createObjectURL(b);
    x ? x.location = B : location.href = B, x = null, setTimeout(function() {
      M.revokeObjectURL(B);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function sf(b) {
  var g;
  b = b || "", this.ok = !1, b.charAt(0) == "#" && (b = b.substr(1, 6)), b = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[b = (b = b.replace(/ /g, "")).toLowerCase()] || b;
  for (var y = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(l) {
    return [parseInt(l[1]), parseInt(l[2]), parseInt(l[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(l) {
    return [parseInt(l[1], 16), parseInt(l[2], 16), parseInt(l[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(l) {
    return [parseInt(l[1] + l[1], 16), parseInt(l[2] + l[2], 16), parseInt(l[3] + l[3], 16)];
  } }], x = 0; x < y.length; x++) {
    var P = y[x].re, A = y[x].process, v = P.exec(b);
    v && (g = A(v), this.r = g[0], this.g = g[1], this.b = g[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var l = this.r.toString(16), M = this.g.toString(16), B = this.b.toString(16);
    return l.length == 1 && (l = "0" + l), M.length == 1 && (M = "0" + M), B.length == 1 && (B = "0" + B), "#" + l + M + B;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function Ru(b, g) {
  var y = b[0], x = b[1], P = b[2], A = b[3];
  y = qn(y, x, P, A, g[0], 7, -680876936), A = qn(A, y, x, P, g[1], 12, -389564586), P = qn(P, A, y, x, g[2], 17, 606105819), x = qn(x, P, A, y, g[3], 22, -1044525330), y = qn(y, x, P, A, g[4], 7, -176418897), A = qn(A, y, x, P, g[5], 12, 1200080426), P = qn(P, A, y, x, g[6], 17, -1473231341), x = qn(x, P, A, y, g[7], 22, -45705983), y = qn(y, x, P, A, g[8], 7, 1770035416), A = qn(A, y, x, P, g[9], 12, -1958414417), P = qn(P, A, y, x, g[10], 17, -42063), x = qn(x, P, A, y, g[11], 22, -1990404162), y = qn(y, x, P, A, g[12], 7, 1804603682), A = qn(A, y, x, P, g[13], 12, -40341101), P = qn(P, A, y, x, g[14], 17, -1502002290), y = Un(y, x = qn(x, P, A, y, g[15], 22, 1236535329), P, A, g[1], 5, -165796510), A = Un(A, y, x, P, g[6], 9, -1069501632), P = Un(P, A, y, x, g[11], 14, 643717713), x = Un(x, P, A, y, g[0], 20, -373897302), y = Un(y, x, P, A, g[5], 5, -701558691), A = Un(A, y, x, P, g[10], 9, 38016083), P = Un(P, A, y, x, g[15], 14, -660478335), x = Un(x, P, A, y, g[4], 20, -405537848), y = Un(y, x, P, A, g[9], 5, 568446438), A = Un(A, y, x, P, g[14], 9, -1019803690), P = Un(P, A, y, x, g[3], 14, -187363961), x = Un(x, P, A, y, g[8], 20, 1163531501), y = Un(y, x, P, A, g[13], 5, -1444681467), A = Un(A, y, x, P, g[2], 9, -51403784), P = Un(P, A, y, x, g[7], 14, 1735328473), y = Vn(y, x = Un(x, P, A, y, g[12], 20, -1926607734), P, A, g[5], 4, -378558), A = Vn(A, y, x, P, g[8], 11, -2022574463), P = Vn(P, A, y, x, g[11], 16, 1839030562), x = Vn(x, P, A, y, g[14], 23, -35309556), y = Vn(y, x, P, A, g[1], 4, -1530992060), A = Vn(A, y, x, P, g[4], 11, 1272893353), P = Vn(P, A, y, x, g[7], 16, -155497632), x = Vn(x, P, A, y, g[10], 23, -1094730640), y = Vn(y, x, P, A, g[13], 4, 681279174), A = Vn(A, y, x, P, g[0], 11, -358537222), P = Vn(P, A, y, x, g[3], 16, -722521979), x = Vn(x, P, A, y, g[6], 23, 76029189), y = Vn(y, x, P, A, g[9], 4, -640364487), A = Vn(A, y, x, P, g[12], 11, -421815835), P = Vn(P, A, y, x, g[15], 16, 530742520), y = $n(y, x = Vn(x, P, A, y, g[2], 23, -995338651), P, A, g[0], 6, -198630844), A = $n(A, y, x, P, g[7], 10, 1126891415), P = $n(P, A, y, x, g[14], 15, -1416354905), x = $n(x, P, A, y, g[5], 21, -57434055), y = $n(y, x, P, A, g[12], 6, 1700485571), A = $n(A, y, x, P, g[3], 10, -1894986606), P = $n(P, A, y, x, g[10], 15, -1051523), x = $n(x, P, A, y, g[1], 21, -2054922799), y = $n(y, x, P, A, g[8], 6, 1873313359), A = $n(A, y, x, P, g[15], 10, -30611744), P = $n(P, A, y, x, g[6], 15, -1560198380), x = $n(x, P, A, y, g[13], 21, 1309151649), y = $n(y, x, P, A, g[4], 6, -145523070), A = $n(A, y, x, P, g[11], 10, -1120210379), P = $n(P, A, y, x, g[2], 15, 718787259), x = $n(x, P, A, y, g[9], 21, -343485551), b[0] = Sl(y, b[0]), b[1] = Sl(x, b[1]), b[2] = Sl(P, b[2]), b[3] = Sl(A, b[3]);
}
function Gh(b, g, y, x, P, A) {
  return g = Sl(Sl(g, b), Sl(x, A)), Sl(g << P | g >>> 32 - P, y);
}
function qn(b, g, y, x, P, A, v) {
  return Gh(g & y | ~g & x, b, g, P, A, v);
}
function Un(b, g, y, x, P, A, v) {
  return Gh(g & x | y & ~x, b, g, P, A, v);
}
function Vn(b, g, y, x, P, A, v) {
  return Gh(g ^ y ^ x, b, g, P, A, v);
}
function $n(b, g, y, x, P, A, v) {
  return Gh(y ^ (g | ~x), b, g, P, A, v);
}
function af(b) {
  var g, y = b.length, x = [1732584193, -271733879, -1732584194, 271733878];
  for (g = 64; g <= b.length; g += 64) Ru(x, Ug(b.substring(g - 64, g)));
  b = b.substring(g - 64);
  var P = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (g = 0; g < b.length; g++) P[g >> 2] |= b.charCodeAt(g) << (g % 4 << 3);
  if (P[g >> 2] |= 128 << (g % 4 << 3), g > 55) for (Ru(x, P), g = 0; g < 16; g++) P[g] = 0;
  return P[14] = 8 * y, Ru(x, P), x;
}
function Ug(b) {
  var g, y = [];
  for (g = 0; g < 64; g += 4) y[g >> 2] = b.charCodeAt(g) + (b.charCodeAt(g + 1) << 8) + (b.charCodeAt(g + 2) << 16) + (b.charCodeAt(g + 3) << 24);
  return y;
}
lh = fi.atob.bind(fi), Gu = fi.btoa.bind(fi);
var zp = "0123456789abcdef".split("");
function Vg(b) {
  for (var g = "", y = 0; y < 4; y++) g += zp[b >> 8 * y + 4 & 15] + zp[b >> 8 * y & 15];
  return g;
}
function $g(b) {
  return String.fromCharCode((255 & b) >> 0, (65280 & b) >> 8, (16711680 & b) >> 16, (4278190080 & b) >> 24);
}
function Wu(b) {
  return af(b).map($g).join("");
}
var Zg = function(b) {
  for (var g = 0; g < b.length; g++) b[g] = Vg(b[g]);
  return b.join("");
}(af("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Sl(b, g) {
  if (Zg) {
    var y = (65535 & b) + (65535 & g);
    return (b >> 16) + (g >> 16) + (y >> 16) << 16 | 65535 & y;
  }
  return b + g & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function Hu(b, g) {
  var y, x, P, A;
  if (b !== y) {
    for (var v = (P = b, A = 1 + (256 / b.length >> 0), new Array(A + 1).join(P)), l = [], M = 0; M < 256; M++) l[M] = M;
    var B = 0;
    for (M = 0; M < 256; M++) {
      var $ = l[M];
      B = (B + $ + v.charCodeAt(M)) % 256, l[M] = l[B], l[B] = $;
    }
    y = b, x = l;
  } else l = x;
  var q = g.length, U = 0, F = 0, mt = "";
  for (M = 0; M < q; M++) F = (F + ($ = l[U = (U + 1) % 256])) % 256, l[U] = l[F], l[F] = $, v = l[(l[U] + l[F]) % 256], mt += String.fromCharCode(g.charCodeAt(M) ^ v);
  return mt;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var Dp = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function kc(b, g, y, x) {
  this.v = 1, this.r = 2;
  var P = 192;
  b.forEach(function(l) {
    if (Dp.perm !== void 0) throw new Error("Invalid permission: " + l);
    P += Dp[l];
  }), this.padding = "(N^NuAd\0NV\b..\0h>/\fdSiz";
  var A = (g + this.padding).substr(0, 32), v = (y + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(A, v), this.P = -(1 + (255 ^ P)), this.encryptionKey = Wu(A + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(x)).substr(0, 5), this.U = Hu(this.encryptionKey, this.padding);
}
function Tc(b) {
  if (/[^\u0000-\u00ff]/.test(b)) throw new Error("Invalid PDF Name Object: " + b + ", Only accept ASCII characters.");
  for (var g = "", y = b.length, x = 0; x < y; x++) {
    var P = b.charCodeAt(x);
    P < 33 || P === 35 || P === 37 || P === 40 || P === 41 || P === 47 || P === 60 || P === 62 || P === 91 || P === 93 || P === 123 || P === 125 || P > 126 ? g += "#" + ("0" + P.toString(16)).slice(-2) : g += b[x];
  }
  return g;
}
function Np(b) {
  if (ir(b) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var g = {};
  this.subscribe = function(y, x, P) {
    if (P = P || !1, typeof y != "string" || typeof x != "function" || typeof P != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    g.hasOwnProperty(y) || (g[y] = {});
    var A = Math.random().toString(35);
    return g[y][A] = [x, !!P], A;
  }, this.unsubscribe = function(y) {
    for (var x in g) if (g[x][y]) return delete g[x][y], Object.keys(g[x]).length === 0 && delete g[x], !0;
    return !1;
  }, this.publish = function(y) {
    if (g.hasOwnProperty(y)) {
      var x = Array.prototype.slice.call(arguments, 1), P = [];
      for (var A in g[y]) {
        var v = g[y][A];
        try {
          v[0].apply(b, x);
        } catch (l) {
          fi.console && ur.error("jsPDF PubSub Error", l.message, l);
        }
        v[1] && P.push(A);
      }
      P.length && P.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return g;
  };
}
function Uh(b) {
  if (!(this instanceof Uh)) return new Uh(b);
  var g = "opacity,stroke-opacity".split(",");
  for (var y in b) b.hasOwnProperty(y) && g.indexOf(y) >= 0 && (this[y] = b[y]);
  this.id = "", this.objectNumber = -1;
}
function of(b, g) {
  this.gState = b, this.matrix = g, this.id = "", this.objectNumber = -1;
}
function Zl(b, g, y, x, P) {
  if (!(this instanceof Zl)) return new Zl(b, g, y, x, P);
  this.type = b === "axial" ? 2 : 3, this.coords = g, this.colors = y, of.call(this, x, P);
}
function Lc(b, g, y, x, P) {
  if (!(this instanceof Lc)) return new Lc(b, g, y, x, P);
  this.boundingBox = b, this.xStep = g, this.yStep = y, this.stream = "", this.cloneIndex = 0, of.call(this, x, P);
}
function pi(b) {
  var g, y = typeof arguments[0] == "string" ? arguments[0] : "p", x = arguments[1], P = arguments[2], A = arguments[3], v = [], l = 1, M = 16, B = "S", $ = null;
  ir(b = b || {}) === "object" && (y = b.orientation, x = b.unit || x, P = b.format || P, A = b.compress || b.compressPdf || A, ($ = b.encryption || null) !== null && ($.userPassword = $.userPassword || "", $.ownerPassword = $.ownerPassword || "", $.userPermissions = $.userPermissions || []), l = typeof b.userUnit == "number" ? Math.abs(b.userUnit) : 1, b.precision !== void 0 && (g = b.precision), b.floatPrecision !== void 0 && (M = b.floatPrecision), B = b.defaultPathOperation || "S"), v = b.filters || (A === !0 ? ["FlateEncode"] : v), x = x || "mm", y = ("" + (y || "P")).toLowerCase();
  var q = b.putOnlyUsedFonts || !1, U = {}, F = { internal: {}, __private__: {} };
  F.__private__.PubSub = Np;
  var mt = "1.3", ot = F.__private__.getPdfVersion = function() {
    return mt;
  };
  F.__private__.setPdfVersion = function(L) {
    mt = L;
  };
  var yt = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  F.__private__.getPageFormats = function() {
    return yt;
  };
  var st = F.__private__.getPageFormat = function(L) {
    return yt[L];
  };
  P = P || "a4";
  var gt = { COMPAT: "compat", ADVANCED: "advanced" }, Mt = gt.COMPAT;
  function Qt() {
    this.saveGraphicsState(), K(new wt(Pe, 0, 0, -Pe, 0, Js() * Pe).toString() + " cm"), this.setFontSize(this.getFontSize() / Pe), B = "n", Mt = gt.ADVANCED;
  }
  function Ht() {
    this.restoreGraphicsState(), B = "S", Mt = gt.COMPAT;
  }
  var pe = F.__private__.combineFontStyleAndFontWeight = function(L, X) {
    if (L == "bold" && X == "normal" || L == "bold" && X == 400 || L == "normal" && X == "italic" || L == "bold" && X == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return X && (L = X == 400 || X === "normal" ? L === "italic" ? "italic" : "normal" : X != 700 && X !== "bold" || L !== "normal" ? (X == 700 ? "bold" : X) + "" + L : "bold"), L;
  };
  F.advancedAPI = function(L) {
    var X = Mt === gt.COMPAT;
    return X && Qt.call(this), typeof L != "function" || (L(this), X && Ht.call(this)), this;
  }, F.compatAPI = function(L) {
    var X = Mt === gt.ADVANCED;
    return X && Ht.call(this), typeof L != "function" || (L(this), X && Qt.call(this)), this;
  }, F.isAdvancedAPI = function() {
    return Mt === gt.ADVANCED;
  };
  var jt, Tt = function(L) {
    if (Mt !== gt.ADVANCED) throw new Error(L + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, le = F.roundToPrecision = F.__private__.roundToPrecision = function(L, X) {
    var ft = g || X;
    if (isNaN(L) || isNaN(ft)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return L.toFixed(ft).replace(/0+$/, "");
  };
  jt = F.hpf = F.__private__.hpf = typeof M == "number" ? function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return le(L, M);
  } : M === "smart" ? function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return le(L, L > -1 && L < 1 ? 16 : 5);
  } : function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return le(L, 16);
  };
  var ne = F.f2 = F.__private__.f2 = function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.f2");
    return le(L, 2);
  }, at = F.__private__.f3 = function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.f3");
    return le(L, 3);
  }, lt = F.scale = F.__private__.scale = function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.scale");
    return Mt === gt.COMPAT ? L * Pe : Mt === gt.ADVANCED ? L : void 0;
  }, Pt = function(L) {
    return Mt === gt.COMPAT ? Js() - L : Mt === gt.ADVANCED ? L : void 0;
  }, bt = function(L) {
    return lt(Pt(L));
  };
  F.__private__.setPrecision = F.setPrecision = function(L) {
    typeof parseInt(L, 10) == "number" && (g = parseInt(L, 10));
  };
  var Jt, Yt = "00000000000000000000000000000000", te = F.__private__.getFileId = function() {
    return Yt;
  }, Ut = F.__private__.setFileId = function(L) {
    return Yt = L !== void 0 && /^[a-fA-F0-9]{32}$/.test(L) ? L.toUpperCase() : Yt.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), $ !== null && (cr = new kc($.userPermissions, $.userPassword, $.ownerPassword, Yt)), Yt;
  };
  F.setFileId = function(L) {
    return Ut(L), this;
  }, F.getFileId = function() {
    return te();
  };
  var se = F.__private__.convertDateToPDFDate = function(L) {
    var X = L.getTimezoneOffset(), ft = X < 0 ? "+" : "-", Lt = Math.floor(Math.abs(X / 60)), Ft = Math.abs(X % 60), Kt = [ft, _t(Lt), "'", _t(Ft), "'"].join("");
    return ["D:", L.getFullYear(), _t(L.getMonth() + 1), _t(L.getDate()), _t(L.getHours()), _t(L.getMinutes()), _t(L.getSeconds()), Kt].join("");
  }, ee = F.__private__.convertPDFDateToDate = function(L) {
    var X = parseInt(L.substr(2, 4), 10), ft = parseInt(L.substr(6, 2), 10) - 1, Lt = parseInt(L.substr(8, 2), 10), Ft = parseInt(L.substr(10, 2), 10), Kt = parseInt(L.substr(12, 2), 10), _e = parseInt(L.substr(14, 2), 10);
    return new Date(X, ft, Lt, Ft, Kt, _e, 0);
  }, be = F.__private__.setCreationDate = function(L) {
    var X;
    if (L === void 0 && (L = /* @__PURE__ */ new Date()), L instanceof Date) X = se(L);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(L)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      X = L;
    }
    return Jt = X;
  }, Q = F.__private__.getCreationDate = function(L) {
    var X = Jt;
    return L === "jsDate" && (X = ee(Jt)), X;
  };
  F.setCreationDate = function(L) {
    return be(L), this;
  }, F.getCreationDate = function(L) {
    return Q(L);
  };
  var pt, _t = F.__private__.padd2 = function(L) {
    return ("0" + parseInt(L)).slice(-2);
  }, Ct = F.__private__.padd2Hex = function(L) {
    return ("00" + (L = L.toString())).substr(L.length);
  }, Dt = 0, Ot = [], Vt = [], Wt = 0, xe = [], ve = [], ke = !1, ze = Vt, Je = function() {
    Dt = 0, Wt = 0, Vt = [], Ot = [], xe = [], ei = fe(), mi = fe();
  };
  F.__private__.setCustomOutputDestination = function(L) {
    ke = !0, ze = L;
  };
  var ie = function(L) {
    ke || (ze = L);
  };
  F.__private__.resetCustomOutputDestination = function() {
    ke = !1, ze = Vt;
  };
  var K = F.__private__.out = function(L) {
    return L = L.toString(), Wt += L.length + 1, ze.push(L), ze;
  }, ci = F.__private__.write = function(L) {
    return K(arguments.length === 1 ? L.toString() : Array.prototype.join.call(arguments, " "));
  }, Ue = F.__private__.getArrayBuffer = function(L) {
    for (var X = L.length, ft = new ArrayBuffer(X), Lt = new Uint8Array(ft); X--; ) Lt[X] = L.charCodeAt(X);
    return ft;
  }, oe = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  F.__private__.getStandardFonts = function() {
    return oe;
  };
  var ye = b.fontSize || 16;
  F.__private__.setFontSize = F.setFontSize = function(L) {
    return ye = Mt === gt.ADVANCED ? L / Pe : L, this;
  };
  var De, Ae = F.__private__.getFontSize = F.getFontSize = function() {
    return Mt === gt.COMPAT ? ye : ye * Pe;
  }, $e = b.R2L || !1;
  F.__private__.setR2L = F.setR2L = function(L) {
    return $e = L, this;
  }, F.__private__.getR2L = F.getR2L = function() {
    return $e;
  };
  var hi, si = F.__private__.setZoomMode = function(L) {
    var X = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(L)) De = L;
    else if (isNaN(L)) {
      if (X.indexOf(L) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + L + '" is not recognized.');
      De = L;
    } else De = parseInt(L, 10);
  };
  F.__private__.getZoomMode = function() {
    return De;
  };
  var _i, Ii = F.__private__.setPageMode = function(L) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(L) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + L + '" is not recognized.');
    hi = L;
  };
  F.__private__.getPageMode = function() {
    return hi;
  };
  var he = F.__private__.setLayoutMode = function(L) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(L) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + L + '" is not recognized.');
    _i = L;
  };
  F.__private__.getLayoutMode = function() {
    return _i;
  }, F.__private__.setDisplayMode = F.setDisplayMode = function(L, X, ft) {
    return si(L), he(X), Ii(ft), this;
  };
  var Ke = { title: "", subject: "", author: "", keywords: "", creator: "" };
  F.__private__.getDocumentProperty = function(L) {
    if (Object.keys(Ke).indexOf(L) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return Ke[L];
  }, F.__private__.getDocumentProperties = function() {
    return Ke;
  }, F.__private__.setDocumentProperties = F.setProperties = F.setDocumentProperties = function(L) {
    for (var X in Ke) Ke.hasOwnProperty(X) && L[X] && (Ke[X] = L[X]);
    return this;
  }, F.__private__.setDocumentProperty = function(L, X) {
    if (Object.keys(Ke).indexOf(L) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return Ke[L] = X;
  };
  var ai, Pe, lr, ue, ni, Te = {}, ki = {}, vr = [], Me = {}, Ur = {}, qi = {}, Ir = {}, kr = null, ht = 0, O = [], V = new Np(F), it = b.hotfixes || [], ct = {}, At = {}, Et = [], wt = function L(X, ft, Lt, Ft, Kt, _e) {
    if (!(this instanceof L)) return new L(X, ft, Lt, Ft, Kt, _e);
    isNaN(X) && (X = 1), isNaN(ft) && (ft = 0), isNaN(Lt) && (Lt = 0), isNaN(Ft) && (Ft = 1), isNaN(Kt) && (Kt = 0), isNaN(_e) && (_e = 0), this._matrix = [X, ft, Lt, Ft, Kt, _e];
  };
  Object.defineProperty(wt.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(L) {
    this._matrix[0] = L;
  } }), Object.defineProperty(wt.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(L) {
    this._matrix[1] = L;
  } }), Object.defineProperty(wt.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(L) {
    this._matrix[2] = L;
  } }), Object.defineProperty(wt.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(L) {
    this._matrix[3] = L;
  } }), Object.defineProperty(wt.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(L) {
    this._matrix[4] = L;
  } }), Object.defineProperty(wt.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(L) {
    this._matrix[5] = L;
  } }), Object.defineProperty(wt.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(L) {
    this._matrix[0] = L;
  } }), Object.defineProperty(wt.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(L) {
    this._matrix[1] = L;
  } }), Object.defineProperty(wt.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(L) {
    this._matrix[2] = L;
  } }), Object.defineProperty(wt.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(L) {
    this._matrix[3] = L;
  } }), Object.defineProperty(wt.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(L) {
    this._matrix[4] = L;
  } }), Object.defineProperty(wt.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(L) {
    this._matrix[5] = L;
  } }), Object.defineProperty(wt.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(wt.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(wt.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(wt.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), wt.prototype.join = function(L) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(jt).join(L);
  }, wt.prototype.multiply = function(L) {
    var X = L.sx * this.sx + L.shy * this.shx, ft = L.sx * this.shy + L.shy * this.sy, Lt = L.shx * this.sx + L.sy * this.shx, Ft = L.shx * this.shy + L.sy * this.sy, Kt = L.tx * this.sx + L.ty * this.shx + this.tx, _e = L.tx * this.shy + L.ty * this.sy + this.ty;
    return new wt(X, ft, Lt, Ft, Kt, _e);
  }, wt.prototype.decompose = function() {
    var L = this.sx, X = this.shy, ft = this.shx, Lt = this.sy, Ft = this.tx, Kt = this.ty, _e = Math.sqrt(L * L + X * X), Re = (L /= _e) * ft + (X /= _e) * Lt;
    ft -= L * Re, Lt -= X * Re;
    var Qe = Math.sqrt(ft * ft + Lt * Lt);
    return Re /= Qe, L * (Lt /= Qe) < X * (ft /= Qe) && (L = -L, X = -X, Re = -Re, _e = -_e), { scale: new wt(_e, 0, 0, Qe, 0, 0), translate: new wt(1, 0, 0, 1, Ft, Kt), rotate: new wt(L, X, -X, L, 0, 0), skew: new wt(1, 0, Re, 1, 0, 0) };
  }, wt.prototype.toString = function(L) {
    return this.join(" ");
  }, wt.prototype.inversed = function() {
    var L = this.sx, X = this.shy, ft = this.shx, Lt = this.sy, Ft = this.tx, Kt = this.ty, _e = 1 / (L * Lt - X * ft), Re = Lt * _e, Qe = -X * _e, gi = -ft * _e, vi = L * _e;
    return new wt(Re, Qe, gi, vi, -Re * Ft - gi * Kt, -Qe * Ft - vi * Kt);
  }, wt.prototype.applyToPoint = function(L) {
    var X = L.x * this.sx + L.y * this.shx + this.tx, ft = L.x * this.shy + L.y * this.sy + this.ty;
    return new Cn(X, ft);
  }, wt.prototype.applyToRectangle = function(L) {
    var X = this.applyToPoint(L), ft = this.applyToPoint(new Cn(L.x + L.w, L.y + L.h));
    return new to(X.x, X.y, ft.x - X.x, ft.y - X.y);
  }, wt.prototype.clone = function() {
    var L = this.sx, X = this.shy, ft = this.shx, Lt = this.sy, Ft = this.tx, Kt = this.ty;
    return new wt(L, X, ft, Lt, Ft, Kt);
  }, F.Matrix = wt;
  var xt = F.matrixMult = function(L, X) {
    return X.multiply(L);
  }, $t = new wt(1, 0, 0, 1, 0, 0);
  F.unitMatrix = F.identityMatrix = $t;
  var re = function(L, X) {
    if (!Ur[L]) {
      var ft = (X instanceof Zl ? "Sh" : "P") + (Object.keys(Me).length + 1).toString(10);
      X.id = ft, Ur[L] = ft, Me[ft] = X, V.publish("addPattern", X);
    }
  };
  F.ShadingPattern = Zl, F.TilingPattern = Lc, F.addShadingPattern = function(L, X) {
    return Tt("addShadingPattern()"), re(L, X), this;
  }, F.beginTilingPattern = function(L) {
    Tt("beginTilingPattern()"), jo(L.boundingBox[0], L.boundingBox[1], L.boundingBox[2] - L.boundingBox[0], L.boundingBox[3] - L.boundingBox[1], L.matrix);
  }, F.endTilingPattern = function(L, X) {
    Tt("endTilingPattern()"), X.stream = ve[pt].join(`
`), re(L, X), V.publish("endTilingPattern", X), Et.pop().restore();
  };
  var Rt = F.__private__.newObject = function() {
    var L = fe();
    return Ne(L, !0), L;
  }, fe = F.__private__.newObjectDeferred = function() {
    return Dt++, Ot[Dt] = function() {
      return Wt;
    }, Dt;
  }, Ne = function(L, X) {
    return X = typeof X == "boolean" && X, Ot[L] = Wt, X && K(L + " 0 obj"), L;
  }, Ve = F.__private__.newAdditionalObject = function() {
    var L = { objId: fe(), content: "" };
    return xe.push(L), L;
  }, ei = fe(), mi = fe(), He = F.__private__.decodeColorString = function(L) {
    var X = L.split(" ");
    if (X.length !== 2 || X[1] !== "g" && X[1] !== "G")
      X.length === 5 && (X[4] === "k" || X[4] === "K") && (X = [(1 - X[0]) * (1 - X[3]), (1 - X[1]) * (1 - X[3]), (1 - X[2]) * (1 - X[3]), "r"]);
    else {
      var ft = parseFloat(X[0]);
      X = [ft, ft, ft, "r"];
    }
    for (var Lt = "#", Ft = 0; Ft < 3; Ft++) Lt += ("0" + Math.floor(255 * parseFloat(X[Ft])).toString(16)).slice(-2);
    return Lt;
  }, Ti = F.__private__.encodeColorString = function(L) {
    var X;
    typeof L == "string" && (L = { ch1: L });
    var ft = L.ch1, Lt = L.ch2, Ft = L.ch3, Kt = L.ch4, _e = L.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof ft == "string" && ft.charAt(0) !== "#") {
      var Re = new sf(ft);
      if (Re.ok) ft = Re.toHex();
      else if (!/^\d*\.?\d*$/.test(ft)) throw new Error('Invalid color "' + ft + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof ft == "string" && /^#[0-9A-Fa-f]{3}$/.test(ft) && (ft = "#" + ft[1] + ft[1] + ft[2] + ft[2] + ft[3] + ft[3]), typeof ft == "string" && /^#[0-9A-Fa-f]{6}$/.test(ft)) {
      var Qe = parseInt(ft.substr(1), 16);
      ft = Qe >> 16 & 255, Lt = Qe >> 8 & 255, Ft = 255 & Qe;
    }
    if (Lt === void 0 || Kt === void 0 && ft === Lt && Lt === Ft) if (typeof ft == "string") X = ft + " " + _e[0];
    else switch (L.precision) {
      case 2:
        X = ne(ft / 255) + " " + _e[0];
        break;
      case 3:
      default:
        X = at(ft / 255) + " " + _e[0];
    }
    else if (Kt === void 0 || ir(Kt) === "object") {
      if (Kt && !isNaN(Kt.a) && Kt.a === 0) return X = ["1.", "1.", "1.", _e[1]].join(" ");
      if (typeof ft == "string") X = [ft, Lt, Ft, _e[1]].join(" ");
      else switch (L.precision) {
        case 2:
          X = [ne(ft / 255), ne(Lt / 255), ne(Ft / 255), _e[1]].join(" ");
          break;
        default:
        case 3:
          X = [at(ft / 255), at(Lt / 255), at(Ft / 255), _e[1]].join(" ");
      }
    } else if (typeof ft == "string") X = [ft, Lt, Ft, Kt, _e[2]].join(" ");
    else switch (L.precision) {
      case 2:
        X = [ne(ft), ne(Lt), ne(Ft), ne(Kt), _e[2]].join(" ");
        break;
      case 3:
      default:
        X = [at(ft), at(Lt), at(Ft), at(Kt), _e[2]].join(" ");
    }
    return X;
  }, Di = F.__private__.getFilters = function() {
    return v;
  }, Oi = F.__private__.putStream = function(L) {
    var X = (L = L || {}).data || "", ft = L.filters || Di(), Lt = L.alreadyAppliedFilters || [], Ft = L.addLength1 || !1, Kt = X.length, _e = L.objectId, Re = function(Cr) {
      return Cr;
    };
    if ($ !== null && _e === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    $ !== null && (Re = cr.encryptor(_e, 0));
    var Qe = {};
    ft === !0 && (ft = ["FlateEncode"]);
    var gi = L.additionalKeyValues || [], vi = (Qe = pi.API.processDataByFilters !== void 0 ? pi.API.processDataByFilters(X, ft) : { data: X, reverseChain: [] }).reverseChain + (Array.isArray(Lt) ? Lt.join(" ") : Lt.toString());
    if (Qe.data.length !== 0 && (gi.push({ key: "Length", value: Qe.data.length }), Ft === !0 && gi.push({ key: "Length1", value: Kt })), vi.length != 0) if (vi.split("/").length - 1 == 1) gi.push({ key: "Filter", value: vi });
    else {
      gi.push({ key: "Filter", value: "[" + vi + "]" });
      for (var bi = 0; bi < gi.length; bi += 1) if (gi[bi].key === "DecodeParms") {
        for (var di = [], mr = 0; mr < Qe.reverseChain.split("/").length - 1; mr += 1) di.push("null");
        di.push(gi[bi].value), gi[bi].value = "[" + di.join(" ") + "]";
      }
    }
    K("<<");
    for (var Xe = 0; Xe < gi.length; Xe++) K("/" + gi[Xe].key + " " + gi[Xe].value);
    K(">>"), Qe.data.length !== 0 && (K("stream"), K(Re(Qe.data)), K("endstream"));
  }, oi = F.__private__.putPage = function(L) {
    var X = L.number, ft = L.data, Lt = L.objId, Ft = L.contentsObjId;
    Ne(Lt, !0), K("<</Type /Page"), K("/Parent " + L.rootDictionaryObjId + " 0 R"), K("/Resources " + L.resourceDictionaryObjId + " 0 R"), K("/MediaBox [" + parseFloat(jt(L.mediaBox.bottomLeftX)) + " " + parseFloat(jt(L.mediaBox.bottomLeftY)) + " " + jt(L.mediaBox.topRightX) + " " + jt(L.mediaBox.topRightY) + "]"), L.cropBox !== null && K("/CropBox [" + jt(L.cropBox.bottomLeftX) + " " + jt(L.cropBox.bottomLeftY) + " " + jt(L.cropBox.topRightX) + " " + jt(L.cropBox.topRightY) + "]"), L.bleedBox !== null && K("/BleedBox [" + jt(L.bleedBox.bottomLeftX) + " " + jt(L.bleedBox.bottomLeftY) + " " + jt(L.bleedBox.topRightX) + " " + jt(L.bleedBox.topRightY) + "]"), L.trimBox !== null && K("/TrimBox [" + jt(L.trimBox.bottomLeftX) + " " + jt(L.trimBox.bottomLeftY) + " " + jt(L.trimBox.topRightX) + " " + jt(L.trimBox.topRightY) + "]"), L.artBox !== null && K("/ArtBox [" + jt(L.artBox.bottomLeftX) + " " + jt(L.artBox.bottomLeftY) + " " + jt(L.artBox.topRightX) + " " + jt(L.artBox.topRightY) + "]"), typeof L.userUnit == "number" && L.userUnit !== 1 && K("/UserUnit " + L.userUnit), V.publish("putPage", { objId: Lt, pageContext: O[X], pageNumber: X, page: ft }), K("/Contents " + Ft + " 0 R"), K(">>"), K("endobj");
    var Kt = ft.join(`
`);
    return Mt === gt.ADVANCED && (Kt += `
Q`), Ne(Ft, !0), Oi({ data: Kt, filters: Di(), objectId: Ft }), K("endobj"), Lt;
  }, Ci = F.__private__.putPages = function() {
    var L, X, ft = [];
    for (L = 1; L <= ht; L++) O[L].objId = fe(), O[L].contentsObjId = fe();
    for (L = 1; L <= ht; L++) ft.push(oi({ number: L, data: ve[L], objId: O[L].objId, contentsObjId: O[L].contentsObjId, mediaBox: O[L].mediaBox, cropBox: O[L].cropBox, bleedBox: O[L].bleedBox, trimBox: O[L].trimBox, artBox: O[L].artBox, userUnit: O[L].userUnit, rootDictionaryObjId: ei, resourceDictionaryObjId: mi }));
    Ne(ei, !0), K("<</Type /Pages");
    var Lt = "/Kids [";
    for (X = 0; X < ht; X++) Lt += ft[X] + " 0 R ";
    K(Lt + "]"), K("/Count " + ht), K(">>"), K("endobj"), V.publish("postPutPages");
  }, Ui = function(L) {
    V.publish("putFont", { font: L, out: K, newObject: Rt, putStream: Oi }), L.isAlreadyPutted !== !0 && (L.objectNumber = Rt(), K("<<"), K("/Type /Font"), K("/BaseFont /" + Tc(L.postScriptName)), K("/Subtype /Type1"), typeof L.encoding == "string" && K("/Encoding /" + L.encoding), K("/FirstChar 32"), K("/LastChar 255"), K(">>"), K("endobj"));
  }, rr = function() {
    for (var L in Te) Te.hasOwnProperty(L) && (q === !1 || q === !0 && U.hasOwnProperty(L)) && Ui(Te[L]);
  }, pr = function(L) {
    L.objectNumber = Rt();
    var X = [];
    X.push({ key: "Type", value: "/XObject" }), X.push({ key: "Subtype", value: "/Form" }), X.push({ key: "BBox", value: "[" + [jt(L.x), jt(L.y), jt(L.x + L.width), jt(L.y + L.height)].join(" ") + "]" }), X.push({ key: "Matrix", value: "[" + L.matrix.toString() + "]" });
    var ft = L.pages[1].join(`
`);
    Oi({ data: ft, additionalKeyValues: X, objectId: L.objectNumber }), K("endobj");
  }, fr = function() {
    for (var L in ct) ct.hasOwnProperty(L) && pr(ct[L]);
  }, $s = function(L, X) {
    var ft, Lt = [], Ft = 1 / (X - 1);
    for (ft = 0; ft < 1; ft += Ft) Lt.push(ft);
    if (Lt.push(1), L[0].offset != 0) {
      var Kt = { offset: 0, color: L[0].color };
      L.unshift(Kt);
    }
    if (L[L.length - 1].offset != 1) {
      var _e = { offset: 1, color: L[L.length - 1].color };
      L.push(_e);
    }
    for (var Re = "", Qe = 0, gi = 0; gi < Lt.length; gi++) {
      for (ft = Lt[gi]; ft > L[Qe + 1].offset; ) Qe++;
      var vi = L[Qe].offset, bi = (ft - vi) / (L[Qe + 1].offset - vi), di = L[Qe].color, mr = L[Qe + 1].color;
      Re += Ct(Math.round((1 - bi) * di[0] + bi * mr[0]).toString(16)) + Ct(Math.round((1 - bi) * di[1] + bi * mr[1]).toString(16)) + Ct(Math.round((1 - bi) * di[2] + bi * mr[2]).toString(16));
    }
    return Re.trim();
  }, Ni = function(L, X) {
    X || (X = 21);
    var ft = Rt(), Lt = $s(L.colors, X), Ft = [];
    Ft.push({ key: "FunctionType", value: "0" }), Ft.push({ key: "Domain", value: "[0.0 1.0]" }), Ft.push({ key: "Size", value: "[" + X + "]" }), Ft.push({ key: "BitsPerSample", value: "8" }), Ft.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Ft.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Oi({ data: Lt, additionalKeyValues: Ft, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: ft }), K("endobj"), L.objectNumber = Rt(), K("<< /ShadingType " + L.type), K("/ColorSpace /DeviceRGB");
    var Kt = "/Coords [" + jt(parseFloat(L.coords[0])) + " " + jt(parseFloat(L.coords[1])) + " ";
    L.type === 2 ? Kt += jt(parseFloat(L.coords[2])) + " " + jt(parseFloat(L.coords[3])) : Kt += jt(parseFloat(L.coords[2])) + " " + jt(parseFloat(L.coords[3])) + " " + jt(parseFloat(L.coords[4])) + " " + jt(parseFloat(L.coords[5])), K(Kt += "]"), L.matrix && K("/Matrix [" + L.matrix.toString() + "]"), K("/Function " + ft + " 0 R"), K("/Extend [true true]"), K(">>"), K("endobj");
  }, zo = function(L, X) {
    var ft = fe(), Lt = Rt();
    X.push({ resourcesOid: ft, objectOid: Lt }), L.objectNumber = Lt;
    var Ft = [];
    Ft.push({ key: "Type", value: "/Pattern" }), Ft.push({ key: "PatternType", value: "1" }), Ft.push({ key: "PaintType", value: "1" }), Ft.push({ key: "TilingType", value: "1" }), Ft.push({ key: "BBox", value: "[" + L.boundingBox.map(jt).join(" ") + "]" }), Ft.push({ key: "XStep", value: jt(L.xStep) }), Ft.push({ key: "YStep", value: jt(L.yStep) }), Ft.push({ key: "Resources", value: ft + " 0 R" }), L.matrix && Ft.push({ key: "Matrix", value: "[" + L.matrix.toString() + "]" }), Oi({ data: L.stream, additionalKeyValues: Ft, objectId: L.objectNumber }), K("endobj");
  }, Zs = function(L) {
    var X;
    for (X in Me) Me.hasOwnProperty(X) && (Me[X] instanceof Zl ? Ni(Me[X]) : Me[X] instanceof Lc && zo(Me[X], L));
  }, Vr = function(L) {
    for (var X in L.objectNumber = Rt(), K("<<"), L) switch (X) {
      case "opacity":
        K("/ca " + ne(L[X]));
        break;
      case "stroke-opacity":
        K("/CA " + ne(L[X]));
    }
    K(">>"), K("endobj");
  }, tn = function() {
    var L;
    for (L in qi) qi.hasOwnProperty(L) && Vr(qi[L]);
  }, Do = function() {
    for (var L in K("/XObject <<"), ct) ct.hasOwnProperty(L) && ct[L].objectNumber >= 0 && K("/" + L + " " + ct[L].objectNumber + " 0 R");
    V.publish("putXobjectDict"), K(">>");
  }, en = function() {
    cr.oid = Rt(), K("<<"), K("/Filter /Standard"), K("/V " + cr.v), K("/R " + cr.r), K("/U <" + cr.toHexString(cr.U) + ">"), K("/O <" + cr.toHexString(cr.O) + ">"), K("/P " + cr.P), K(">>"), K("endobj");
  }, br = function() {
    for (var L in K("/Font <<"), Te) Te.hasOwnProperty(L) && (q === !1 || q === !0 && U.hasOwnProperty(L)) && K("/" + L + " " + Te[L].objectNumber + " 0 R");
    K(">>");
  }, Ua = function() {
    if (Object.keys(Me).length > 0) {
      for (var L in K("/Shading <<"), Me) Me.hasOwnProperty(L) && Me[L] instanceof Zl && Me[L].objectNumber >= 0 && K("/" + L + " " + Me[L].objectNumber + " 0 R");
      V.publish("putShadingPatternDict"), K(">>");
    }
  }, os = function(L) {
    if (Object.keys(Me).length > 0) {
      for (var X in K("/Pattern <<"), Me) Me.hasOwnProperty(X) && Me[X] instanceof F.TilingPattern && Me[X].objectNumber >= 0 && Me[X].objectNumber < L && K("/" + X + " " + Me[X].objectNumber + " 0 R");
      V.publish("putTilingPatternDict"), K(">>");
    }
  }, dr = function() {
    if (Object.keys(qi).length > 0) {
      var L;
      for (L in K("/ExtGState <<"), qi) qi.hasOwnProperty(L) && qi[L].objectNumber >= 0 && K("/" + L + " " + qi[L].objectNumber + " 0 R");
      V.publish("putGStateDict"), K(">>");
    }
  }, $i = function(L) {
    Ne(L.resourcesOid, !0), K("<<"), K("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), br(), Ua(), os(L.objectOid), dr(), Do(), K(">>"), K("endobj");
  }, ls = function() {
    var L = [];
    rr(), tn(), fr(), Zs(L), V.publish("putResources"), L.forEach($i), $i({ resourcesOid: mi, objectOid: Number.MAX_SAFE_INTEGER }), V.publish("postPutResources");
  }, nr = function() {
    V.publish("putAdditionalObjects");
    for (var L = 0; L < xe.length; L++) {
      var X = xe[L];
      Ne(X.objId, !0), K(X.content), K("endobj");
    }
    V.publish("postPutAdditionalObjects");
  }, fa = function(L) {
    ki[L.fontName] = ki[L.fontName] || {}, ki[L.fontName][L.fontStyle] = L.id;
  }, $r = function(L, X, ft, Lt, Ft) {
    var Kt = { id: "F" + (Object.keys(Te).length + 1).toString(10), postScriptName: L, fontName: X, fontStyle: ft, encoding: Lt, isStandardFont: Ft || !1, metadata: {} };
    return V.publish("addFont", { font: Kt, instance: this }), Te[Kt.id] = Kt, fa(Kt), Kt.id;
  }, ma = function(L) {
    for (var X = 0, ft = oe.length; X < ft; X++) {
      var Lt = $r.call(this, L[X][0], L[X][1], L[X][2], oe[X][3], !0);
      q === !1 && (U[Lt] = !0);
      var Ft = L[X][0].split("-");
      fa({ id: Lt, fontName: Ft[0], fontStyle: Ft[1] || "" });
    }
    V.publish("addFonts", { fonts: Te, dictionary: ki });
  }, Tr = function(L) {
    return L.foo = function() {
      try {
        return L.apply(this, arguments);
      } catch (Lt) {
        var X = Lt.stack || "";
        ~X.indexOf(" at ") && (X = X.split(" at ")[1]);
        var ft = "Error in function " + X.split(`
`)[0].split("<")[0] + ": " + Lt.message;
        if (!fi.console) throw new Error(ft);
        fi.console.error(ft, Lt), fi.alert && alert(ft);
      }
    }, L.foo.bar = L, L.foo;
  }, Gs = function(L, X) {
    var ft, Lt, Ft, Kt, _e, Re, Qe, gi, vi;
    if (Ft = (X = X || {}).sourceEncoding || "Unicode", _e = X.outputEncoding, (X.autoencode || _e) && Te[ai].metadata && Te[ai].metadata[Ft] && Te[ai].metadata[Ft].encoding && (Kt = Te[ai].metadata[Ft].encoding, !_e && Te[ai].encoding && (_e = Te[ai].encoding), !_e && Kt.codePages && (_e = Kt.codePages[0]), typeof _e == "string" && (_e = Kt[_e]), _e)) {
      for (Qe = !1, Re = [], ft = 0, Lt = L.length; ft < Lt; ft++) (gi = _e[L.charCodeAt(ft)]) ? Re.push(String.fromCharCode(gi)) : Re.push(L[ft]), Re[ft].charCodeAt(0) >> 8 && (Qe = !0);
      L = Re.join("");
    }
    for (ft = L.length; Qe === void 0 && ft !== 0; ) L.charCodeAt(ft - 1) >> 8 && (Qe = !0), ft--;
    if (!Qe) return L;
    for (Re = X.noBOM ? [] : [254, 255], ft = 0, Lt = L.length; ft < Lt; ft++) {
      if ((vi = (gi = L.charCodeAt(ft)) >> 8) >> 8) throw new Error("Character at position " + ft + " of string '" + L + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      Re.push(vi), Re.push(gi - (vi << 8));
    }
    return String.fromCharCode.apply(void 0, Re);
  }, Lr = F.__private__.pdfEscape = F.pdfEscape = function(L, X) {
    return Gs(L, X).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, Ln = F.__private__.beginPage = function(L) {
    ve[++ht] = [], O[ht] = { objId: 0, contentsObjId: 0, userUnit: Number(l), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(L[0]), topRightY: Number(L[1]) } }, $a(ht), ie(ve[pt]);
  }, Ei = function(L, X) {
    var ft, Lt, Ft;
    switch (y = X || y, typeof L == "string" && (ft = st(L.toLowerCase()), Array.isArray(ft) && (Lt = ft[0], Ft = ft[1])), Array.isArray(L) && (Lt = L[0] * Pe, Ft = L[1] * Pe), isNaN(Lt) && (Lt = P[0], Ft = P[1]), (Lt > 14400 || Ft > 14400) && (ur.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), Lt = Math.min(14400, Lt), Ft = Math.min(14400, Ft)), P = [Lt, Ft], y.substr(0, 1)) {
      case "l":
        Ft > Lt && (P = [Ft, Lt]);
        break;
      case "p":
        Lt > Ft && (P = [Ft, Lt]);
    }
    Ln(P), Ya(Sa), K(Wn), Ka !== 0 && K(Ka + " J"), Qa !== 0 && K(Qa + " j"), V.publish("addPage", { pageNumber: ht });
  }, Va = function(L) {
    L > 0 && L <= ht && (ve.splice(L, 1), O.splice(L, 1), ht--, pt > ht && (pt = ht), this.setPage(pt));
  }, $a = function(L) {
    L > 0 && L <= ht && (pt = L);
  }, ga = F.__private__.getNumberOfPages = F.getNumberOfPages = function() {
    return ve.length - 1;
  }, ya = function(L, X, ft) {
    var Lt, Ft = void 0;
    return ft = ft || {}, L = L !== void 0 ? L : Te[ai].fontName, X = X !== void 0 ? X : Te[ai].fontStyle, Lt = L.toLowerCase(), ki[Lt] !== void 0 && ki[Lt][X] !== void 0 ? Ft = ki[Lt][X] : ki[L] !== void 0 && ki[L][X] !== void 0 ? Ft = ki[L][X] : ft.disableWarning === !1 && ur.warn("Unable to look up font label for font '" + L + "', '" + X + "'. Refer to getFontList() for available fonts."), Ft || ft.noFallback || (Ft = ki.times[X]) == null && (Ft = ki.times.normal), Ft;
  }, Za = F.__private__.putInfo = function() {
    var L = Rt(), X = function(Lt) {
      return Lt;
    };
    for (var ft in $ !== null && (X = cr.encryptor(L, 0)), K("<<"), K("/Producer (" + Lr(X("jsPDF " + pi.version)) + ")"), Ke) Ke.hasOwnProperty(ft) && Ke[ft] && K("/" + ft.substr(0, 1).toUpperCase() + ft.substr(1) + " (" + Lr(X(Ke[ft])) + ")");
    K("/CreationDate (" + Lr(X(Jt)) + ")"), K(">>"), K("endobj");
  }, Ws = F.__private__.putCatalog = function(L) {
    var X = (L = L || {}).rootDictionaryObjId || ei;
    switch (Rt(), K("<<"), K("/Type /Catalog"), K("/Pages " + X + " 0 R"), De || (De = "fullwidth"), De) {
      case "fullwidth":
        K("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        K("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        K("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        K("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var ft = "" + De;
        ft.substr(ft.length - 1) === "%" && (De = parseInt(De) / 100), typeof De == "number" && K("/OpenAction [3 0 R /XYZ null null " + ne(De) + "]");
    }
    switch (_i || (_i = "continuous"), _i) {
      case "continuous":
        K("/PageLayout /OneColumn");
        break;
      case "single":
        K("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        K("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        K("/PageLayout /TwoColumnRight");
    }
    hi && K("/PageMode /" + hi), V.publish("putCatalog"), K(">>"), K("endobj");
  }, Ga = F.__private__.putTrailer = function() {
    K("trailer"), K("<<"), K("/Size " + (Dt + 1)), K("/Root " + Dt + " 0 R"), K("/Info " + (Dt - 1) + " 0 R"), $ !== null && K("/Encrypt " + cr.oid + " 0 R"), K("/ID [ <" + Yt + "> <" + Yt + "> ]"), K(">>");
  }, _a = F.__private__.putHeader = function() {
    K("%PDF-" + mt), K("%");
  }, Hs = F.__private__.putXRef = function() {
    var L = "0000000000";
    K("xref"), K("0 " + (Dt + 1)), K("0000000000 65535 f ");
    for (var X = 1; X <= Dt; X++)
      typeof Ot[X] == "function" ? K((L + Ot[X]()).slice(-10) + " 00000 n ") : Ot[X] !== void 0 ? K((L + Ot[X]).slice(-10) + " 00000 n ") : K("0000000000 00000 n ");
  }, Ts = F.__private__.buildDocument = function() {
    Je(), ie(Vt), V.publish("buildDocument"), _a(), Ci(), nr(), ls(), $ !== null && en(), Za(), Ws();
    var L = Wt;
    return Hs(), Ga(), K("startxref"), K("" + L), K("%%EOF"), ie(ve[pt]), Vt.join(`
`);
  }, Wa = F.__private__.getBlob = function(L) {
    return new Blob([Ue(L)], { type: "application/pdf" });
  }, va = F.output = F.__private__.output = Tr(function(L, X) {
    switch (typeof (X = X || {}) == "string" ? X = { filename: X } : X.filename = X.filename || "generated.pdf", L) {
      case void 0:
        return Ts();
      case "save":
        F.save(X.filename);
        break;
      case "arraybuffer":
        return Ue(Ts());
      case "blob":
        return Wa(Ts());
      case "bloburi":
      case "bloburl":
        if (fi.URL !== void 0 && typeof fi.URL.createObjectURL == "function") return fi.URL && fi.URL.createObjectURL(Wa(Ts())) || void 0;
        ur.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var ft = "", Lt = Ts();
        try {
          ft = Gu(Lt);
        } catch {
          ft = Gu(unescape(encodeURIComponent(Lt)));
        }
        return "data:application/pdf;filename=" + X.filename + ";base64," + ft;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(fi) === "[object Window]") {
          var Ft = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", Kt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          X.pdfObjectUrl && (Ft = X.pdfObjectUrl, Kt = "");
          var _e = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Ft + '"' + Kt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(X) + ");<\/script></body></html>", Re = fi.open();
          return Re !== null && Re.document.write(_e), Re;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(fi) === "[object Window]") {
          var Qe = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (X.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + X.filename + '" width="500px" height="400px" /></body></html>', gi = fi.open();
          if (gi !== null) {
            gi.document.write(Qe);
            var vi = this;
            gi.document.documentElement.querySelector("#pdfViewer").onload = function() {
              gi.document.title = X.filename, gi.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(vi.output("bloburl"));
            };
          }
          return gi;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(fi) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var bi = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", X) + '"></iframe></body></html>', di = fi.open();
        if (di !== null && (di.document.write(bi), di.document.title = X.filename), di || typeof safari > "u") return di;
        break;
      case "datauri":
      case "dataurl":
        return fi.document.location.href = this.output("datauristring", X);
      default:
        return null;
    }
  }), sl = function(L) {
    return Array.isArray(it) === !0 && it.indexOf(L) > -1;
  };
  switch (x) {
    case "pt":
      Pe = 1;
      break;
    case "mm":
      Pe = 72 / 25.4;
      break;
    case "cm":
      Pe = 72 / 2.54;
      break;
    case "in":
      Pe = 72;
      break;
    case "px":
      Pe = sl("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Pe = 12;
      break;
    case "ex":
      Pe = 6;
      break;
    default:
      if (typeof x != "number") throw new Error("Invalid unit: " + x);
      Pe = x;
  }
  var cr = null;
  be(), Ut();
  var xa = function(L) {
    return $ !== null ? cr.encryptor(L, 0) : function(X) {
      return X;
    };
  }, Zr = F.__private__.getPageInfo = F.getPageInfo = function(L) {
    if (isNaN(L) || L % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: O[L].objId, pageNumber: L, pageContext: O[L] };
  }, Ye = F.__private__.getPageInfoByObjId = function(L) {
    if (isNaN(L) || L % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var X in O) if (O[X].objId === L) break;
    return Zr(X);
  }, ba = F.__private__.getCurrentPageInfo = F.getCurrentPageInfo = function() {
    return { objId: O[pt].objId, pageNumber: pt, pageContext: O[pt] };
  };
  F.addPage = function() {
    return Ei.apply(this, arguments), this;
  }, F.setPage = function() {
    return $a.apply(this, arguments), ie.call(this, ve[pt]), this;
  }, F.insertPage = function(L) {
    return this.addPage(), this.movePage(pt, L), this;
  }, F.movePage = function(L, X) {
    var ft, Lt;
    if (L > X) {
      ft = ve[L], Lt = O[L];
      for (var Ft = L; Ft > X; Ft--) ve[Ft] = ve[Ft - 1], O[Ft] = O[Ft - 1];
      ve[X] = ft, O[X] = Lt, this.setPage(X);
    } else if (L < X) {
      ft = ve[L], Lt = O[L];
      for (var Kt = L; Kt < X; Kt++) ve[Kt] = ve[Kt + 1], O[Kt] = O[Kt + 1];
      ve[X] = ft, O[X] = Lt, this.setPage(X);
    }
    return this;
  }, F.deletePage = function() {
    return Va.apply(this, arguments), this;
  }, F.__private__.text = F.text = function(L, X, ft, Lt, Ft) {
    var Kt, _e, Re, Qe, gi, vi, bi, di, mr, Xe = (Lt = Lt || {}).scope || this;
    if (typeof L == "number" && typeof X == "number" && (typeof ft == "string" || Array.isArray(ft))) {
      var Cr = ft;
      ft = X, X = L, L = Cr;
    }
    if (arguments[3] instanceof wt ? (Tt("The transform parameter of text() with a Matrix value"), mr = Ft) : (Re = arguments[4], Qe = arguments[5], ir(bi = arguments[3]) === "object" && bi !== null || (typeof Re == "string" && (Qe = Re, Re = null), typeof bi == "string" && (Qe = bi, bi = null), typeof bi == "number" && (Re = bi, bi = null), Lt = { flags: bi, angle: Re, align: Qe })), isNaN(X) || isNaN(ft) || L == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (L.length === 0) return Xe;
    var xi = "", Li = !1, nn = typeof Lt.lineHeightFactor == "number" ? Lt.lineHeightFactor : Ls, Hn = Xe.internal.scaleFactor;
    function Ks(Pi) {
      return Pi = Pi.split("	").join(Array(Lt.TabLen || 9).join(" ")), Lr(Pi, bi);
    }
    function Qs(Pi) {
      for (var ji, Ki = Pi.concat(), gr = [], ys = Ki.length; ys--; ) typeof (ji = Ki.shift()) == "string" ? gr.push(ji) : Array.isArray(Pi) && (ji.length === 1 || ji[1] === void 0 && ji[2] === void 0) ? gr.push(ji[0]) : gr.push([ji[0], ji[1], ji[2]]);
      return gr;
    }
    function ta(Pi, ji) {
      var Ki;
      if (typeof Pi == "string") Ki = ji(Pi)[0];
      else if (Array.isArray(Pi)) {
        for (var gr, ys, bn = Pi.concat(), _s = [], sa = bn.length; sa--; ) typeof (gr = bn.shift()) == "string" ? _s.push(ji(gr)[0]) : Array.isArray(gr) && typeof gr[0] == "string" && (ys = ji(gr[0], gr[1], gr[2]), _s.push([ys[0], ys[1], ys[2]]));
        Ki = _s;
      }
      return Ki;
    }
    var ea = !1, Xn = !0;
    if (typeof L == "string") ea = !0;
    else if (Array.isArray(L)) {
      var Yn = L.concat();
      _e = [];
      for (var Er, Gr = Yn.length; Gr--; ) (typeof (Er = Yn.shift()) != "string" || Array.isArray(Er) && typeof Er[0] != "string") && (Xn = !1);
      ea = Xn;
    }
    if (ea === !1) throw new Error('Type of text must be string or Array. "' + L + '" is not recognized.');
    typeof L == "string" && (L = L.match(/[\r?\n]/) ? L.split(/\r\n|\r|\n/g) : [L]);
    var ia = ye / Xe.internal.scaleFactor, ps = ia * (nn - 1);
    switch (Lt.baseline) {
      case "bottom":
        ft -= ps;
        break;
      case "top":
        ft += ia - ps;
        break;
      case "hanging":
        ft += ia - 2 * ps;
        break;
      case "middle":
        ft += ia / 2 - ps;
    }
    if ((vi = Lt.maxWidth || 0) > 0 && (typeof L == "string" ? L = Xe.splitTextToSize(L, vi) : Object.prototype.toString.call(L) === "[object Array]" && (L = L.reduce(function(Pi, ji) {
      return Pi.concat(Xe.splitTextToSize(ji, vi));
    }, []))), Kt = { text: L, x: X, y: ft, options: Lt, mutex: { pdfEscape: Lr, activeFontKey: ai, fonts: Te, activeFontSize: ye } }, V.publish("preProcessText", Kt), L = Kt.text, Re = (Lt = Kt.options).angle, !(mr instanceof wt) && Re && typeof Re == "number") {
      Re *= Math.PI / 180, Lt.rotationDirection === 0 && (Re = -Re), Mt === gt.ADVANCED && (Re = -Re);
      var En = Math.cos(Re), ra = Math.sin(Re);
      mr = new wt(En, ra, -ra, En, 0, 0);
    } else Re && Re instanceof wt && (mr = Re);
    Mt !== gt.ADVANCED || mr || (mr = $t), (gi = Lt.charSpace || Ys) !== void 0 && (xi += jt(lt(gi)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (di = Lt.horizontalScale) !== void 0 && (xi += jt(100 * di) + ` Tz
`), Lt.lang;
    var Nr = -1, Ia = Lt.renderingMode !== void 0 ? Lt.renderingMode : Lt.stroke, na = Xe.internal.getCurrentPageInfo().pageContext;
    switch (Ia) {
      case 0:
      case !1:
      case "fill":
        Nr = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        Nr = 1;
        break;
      case 2:
      case "fillThenStroke":
        Nr = 2;
        break;
      case 3:
      case "invisible":
        Nr = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        Nr = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        Nr = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        Nr = 6;
        break;
      case 7:
      case "addToPathForClipping":
        Nr = 7;
    }
    var Uo = na.usedRenderingMode !== void 0 ? na.usedRenderingMode : -1;
    Nr !== -1 ? xi += Nr + ` Tr
` : Uo !== -1 && (xi += `0 Tr
`), Nr !== -1 && (na.usedRenderingMode = Nr), Qe = Lt.align || "left";
    var Wr, fs = ye * nn, Vo = Xe.internal.pageSize.getWidth(), ro = Te[ai];
    gi = Lt.charSpace || Ys, vi = Lt.maxWidth || 0, bi = Object.assign({ autoencode: !0, noBOM: !0 }, Lt.flags);
    var yi = [];
    if (Object.prototype.toString.call(L) === "[object Array]") {
      var sn;
      _e = Qs(L), Qe !== "left" && (Wr = _e.map(function(Pi) {
        return Xe.getStringUnitWidth(Pi, { font: ro, charSpace: gi, fontSize: ye, doKerning: !1 }) * ye / Hn;
      }));
      var Mn, ms = 0;
      if (Qe === "right") {
        X -= Wr[0], L = [], Gr = _e.length;
        for (var hn = 0; hn < Gr; hn++) hn === 0 ? (Mn = Es(X), sn = Gn(ft)) : (Mn = lt(ms - Wr[hn]), sn = -fs), L.push([_e[hn], Mn, sn]), ms = Wr[hn];
      } else if (Qe === "center") {
        X -= Wr[0] / 2, L = [], Gr = _e.length;
        for (var Jn = 0; Jn < Gr; Jn++) Jn === 0 ? (Mn = Es(X), sn = Gn(ft)) : (Mn = lt((ms - Wr[Jn]) / 2), sn = -fs), L.push([_e[Jn], Mn, sn]), ms = Wr[Jn];
      } else if (Qe === "left") {
        L = [], Gr = _e.length;
        for (var Ms = 0; Ms < Gr; Ms++) L.push(_e[Ms]);
      } else {
        if (Qe !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        L = [], Gr = _e.length, vi = vi !== 0 ? vi : Vo;
        for (var an = 0; an < Gr; an++) sn = an === 0 ? Gn(ft) : -fs, Mn = an === 0 ? Es(X) : 0, an < Gr - 1 ? yi.push(jt(lt((vi - Wr[an]) / (_e[an].split(" ").length - 1)))) : yi.push(0), L.push([_e[an], Mn, sn]);
      }
    }
    var ka = typeof Lt.R2L == "boolean" ? Lt.R2L : $e;
    ka === !0 && (L = ta(L, function(Pi, ji, Ki) {
      return [Pi.split("").reverse().join(""), ji, Ki];
    })), Kt = { text: L, x: X, y: ft, options: Lt, mutex: { pdfEscape: Lr, activeFontKey: ai, fonts: Te, activeFontSize: ye } }, V.publish("postProcessText", Kt), L = Kt.text, Li = Kt.mutex.isHex || !1;
    var zs = Te[ai].encoding;
    zs !== "WinAnsiEncoding" && zs !== "StandardEncoding" || (L = ta(L, function(Pi, ji, Ki) {
      return [Ks(Pi), ji, Ki];
    })), _e = Qs(L), L = [];
    for (var zn, on, un, Ds = 0, Ta = 1, gs = Array.isArray(_e[0]) ? Ta : Ds, Kn = "", La = function(Pi, ji, Ki) {
      var gr = "";
      return Ki instanceof wt ? (Ki = typeof Lt.angle == "number" ? xt(Ki, new wt(1, 0, 0, 1, Pi, ji)) : xt(new wt(1, 0, 0, 1, Pi, ji), Ki), Mt === gt.ADVANCED && (Ki = xt(new wt(1, 0, 0, -1, 0, 0), Ki)), gr = Ki.join(" ") + ` Tm
`) : gr = jt(Pi) + " " + jt(ji) + ` Td
`, gr;
    }, ln = 0; ln < _e.length; ln++) {
      switch (Kn = "", gs) {
        case Ta:
          un = (Li ? "<" : "(") + _e[ln][0] + (Li ? ">" : ")"), zn = parseFloat(_e[ln][1]), on = parseFloat(_e[ln][2]);
          break;
        case Ds:
          un = (Li ? "<" : "(") + _e[ln] + (Li ? ">" : ")"), zn = Es(X), on = Gn(ft);
      }
      yi !== void 0 && yi[ln] !== void 0 && (Kn = yi[ln] + ` Tw
`), ln === 0 ? L.push(Kn + La(zn, on, mr) + un) : gs === Ds ? L.push(Kn + un) : gs === Ta && L.push(Kn + La(zn, on, mr) + un);
    }
    L = gs === Ds ? L.join(` Tj
T* `) : L.join(` Tj
`), L += ` Tj
`;
    var dn = `BT
/`;
    return dn += ai + " " + ye + ` Tf
`, dn += jt(ye * nn) + ` TL
`, dn += Aa + `
`, dn += xi, dn += L, K(dn += "ET"), U[ai] = !0, Xe;
  };
  var Ha = F.__private__.clip = F.clip = function(L) {
    return K(L === "evenodd" ? "W*" : "W"), this;
  };
  F.clipEvenOdd = function() {
    return Ha("evenodd");
  }, F.__private__.discardPath = F.discardPath = function() {
    return K("n"), this;
  };
  var Zn = F.__private__.isValidStyle = function(L) {
    var X = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(L) !== -1 && (X = !0), X;
  };
  F.__private__.setDefaultPathOperation = F.setDefaultPathOperation = function(L) {
    return Zn(L) && (B = L), this;
  };
  var No = F.__private__.getStyle = F.getStyle = function(L) {
    var X = B;
    switch (L) {
      case "D":
      case "S":
        X = "S";
        break;
      case "F":
        X = "f";
        break;
      case "FD":
      case "DF":
        X = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        X = L;
    }
    return X;
  }, cs = F.close = function() {
    return K("h"), this;
  };
  F.stroke = function() {
    return K("S"), this;
  }, F.fill = function(L) {
    return wa("f", L), this;
  }, F.fillEvenOdd = function(L) {
    return wa("f*", L), this;
  }, F.fillStroke = function(L) {
    return wa("B", L), this;
  }, F.fillStrokeEvenOdd = function(L) {
    return wa("B*", L), this;
  };
  var wa = function(L, X) {
    ir(X) === "object" ? al(X, L) : K(L);
  }, Fo = function(L) {
    L === null || Mt === gt.ADVANCED && L === void 0 || (L = No(L), K(L));
  };
  function Il(L, X, ft, Lt, Ft) {
    var Kt = new Lc(X || this.boundingBox, ft || this.xStep, Lt || this.yStep, this.gState, Ft || this.matrix);
    Kt.stream = this.stream;
    var _e = L + "$$" + this.cloneIndex++ + "$$";
    return re(_e, Kt), Kt;
  }
  var al = function(L, X) {
    var ft = Ur[L.key], Lt = Me[ft];
    if (Lt instanceof Zl) K("q"), K(ol(X)), Lt.gState && F.setGState(Lt.gState), K(L.matrix.toString() + " cm"), K("/" + ft + " sh"), K("Q");
    else if (Lt instanceof Lc) {
      var Ft = new wt(1, 0, 0, -1, 0, Js());
      L.matrix && (Ft = Ft.multiply(L.matrix || $t), ft = Il.call(Lt, L.key, L.boundingBox, L.xStep, L.yStep, Ft).id), K("q"), K("/Pattern cs"), K("/" + ft + " scn"), Lt.gState && F.setGState(Lt.gState), K(X), K("Q");
    }
  }, ol = function(L) {
    switch (L) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, Ro = F.moveTo = function(L, X) {
    return K(jt(lt(L)) + " " + jt(bt(X)) + " m"), this;
  }, hs = F.lineTo = function(L, X) {
    return K(jt(lt(L)) + " " + jt(bt(X)) + " l"), this;
  }, us = F.curveTo = function(L, X, ft, Lt, Ft, Kt) {
    return K([jt(lt(L)), jt(bt(X)), jt(lt(ft)), jt(bt(Lt)), jt(lt(Ft)), jt(bt(Kt)), "c"].join(" ")), this;
  };
  F.__private__.line = F.line = function(L, X, ft, Lt, Ft) {
    if (isNaN(L) || isNaN(X) || isNaN(ft) || isNaN(Lt) || !Zn(Ft)) throw new Error("Invalid arguments passed to jsPDF.line");
    return Mt === gt.COMPAT ? this.lines([[ft - L, Lt - X]], L, X, [1, 1], Ft || "S") : this.lines([[ft - L, Lt - X]], L, X, [1, 1]).stroke();
  }, F.__private__.lines = F.lines = function(L, X, ft, Lt, Ft, Kt) {
    var _e, Re, Qe, gi, vi, bi, di, mr, Xe, Cr, xi, Li;
    if (typeof L == "number" && (Li = ft, ft = X, X = L, L = Li), Lt = Lt || [1, 1], Kt = Kt || !1, isNaN(X) || isNaN(ft) || !Array.isArray(L) || !Array.isArray(Lt) || !Zn(Ft) || typeof Kt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Ro(X, ft), _e = Lt[0], Re = Lt[1], gi = L.length, Cr = X, xi = ft, Qe = 0; Qe < gi; Qe++) (vi = L[Qe]).length === 2 ? (Cr = vi[0] * _e + Cr, xi = vi[1] * Re + xi, hs(Cr, xi)) : (bi = vi[0] * _e + Cr, di = vi[1] * Re + xi, mr = vi[2] * _e + Cr, Xe = vi[3] * Re + xi, Cr = vi[4] * _e + Cr, xi = vi[5] * Re + xi, us(bi, di, mr, Xe, Cr, xi));
    return Kt && cs(), Fo(Ft), this;
  }, F.path = function(L) {
    for (var X = 0; X < L.length; X++) {
      var ft = L[X], Lt = ft.c;
      switch (ft.op) {
        case "m":
          Ro(Lt[0], Lt[1]);
          break;
        case "l":
          hs(Lt[0], Lt[1]);
          break;
        case "c":
          us.apply(this, Lt);
          break;
        case "h":
          cs();
      }
    }
    return this;
  }, F.__private__.rect = F.rect = function(L, X, ft, Lt, Ft) {
    if (isNaN(L) || isNaN(X) || isNaN(ft) || isNaN(Lt) || !Zn(Ft)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return Mt === gt.COMPAT && (Lt = -Lt), K([jt(lt(L)), jt(bt(X)), jt(lt(ft)), jt(lt(Lt)), "re"].join(" ")), Fo(Ft), this;
  }, F.__private__.triangle = F.triangle = function(L, X, ft, Lt, Ft, Kt, _e) {
    if (isNaN(L) || isNaN(X) || isNaN(ft) || isNaN(Lt) || isNaN(Ft) || isNaN(Kt) || !Zn(_e)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[ft - L, Lt - X], [Ft - ft, Kt - Lt], [L - Ft, X - Kt]], L, X, [1, 1], _e, !0), this;
  }, F.__private__.roundedRect = F.roundedRect = function(L, X, ft, Lt, Ft, Kt, _e) {
    if (isNaN(L) || isNaN(X) || isNaN(ft) || isNaN(Lt) || isNaN(Ft) || isNaN(Kt) || !Zn(_e)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Re = 4 / 3 * (Math.SQRT2 - 1);
    return Ft = Math.min(Ft, 0.5 * ft), Kt = Math.min(Kt, 0.5 * Lt), this.lines([[ft - 2 * Ft, 0], [Ft * Re, 0, Ft, Kt - Kt * Re, Ft, Kt], [0, Lt - 2 * Kt], [0, Kt * Re, -Ft * Re, Kt, -Ft, Kt], [2 * Ft - ft, 0], [-Ft * Re, 0, -Ft, -Kt * Re, -Ft, -Kt], [0, 2 * Kt - Lt], [0, -Kt * Re, Ft * Re, -Kt, Ft, -Kt]], L + Ft, X, [1, 1], _e, !0), this;
  }, F.__private__.ellipse = F.ellipse = function(L, X, ft, Lt, Ft) {
    if (isNaN(L) || isNaN(X) || isNaN(ft) || isNaN(Lt) || !Zn(Ft)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var Kt = 4 / 3 * (Math.SQRT2 - 1) * ft, _e = 4 / 3 * (Math.SQRT2 - 1) * Lt;
    return Ro(L + ft, X), us(L + ft, X - _e, L + Kt, X - Lt, L, X - Lt), us(L - Kt, X - Lt, L - ft, X - _e, L - ft, X), us(L - ft, X + _e, L - Kt, X + Lt, L, X + Lt), us(L + Kt, X + Lt, L + ft, X + _e, L + ft, X), Fo(Ft), this;
  }, F.__private__.circle = F.circle = function(L, X, ft, Lt) {
    if (isNaN(L) || isNaN(X) || isNaN(ft) || !Zn(Lt)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(L, X, ft, ft, Lt);
  }, F.setFont = function(L, X, ft) {
    return ft && (X = pe(X, ft)), ai = ya(L, X, { disableWarning: !1 }), this;
  };
  var Xa = F.__private__.getFont = F.getFont = function() {
    return Te[ya.apply(F, arguments)];
  };
  F.__private__.getFontList = F.getFontList = function() {
    var L, X, ft = {};
    for (L in ki) if (ki.hasOwnProperty(L)) for (X in ft[L] = [], ki[L]) ki[L].hasOwnProperty(X) && ft[L].push(X);
    return ft;
  }, F.addFont = function(L, X, ft, Lt, Ft) {
    var Kt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && Kt.indexOf(arguments[3]) !== -1 ? Ft = arguments[3] : arguments[3] && Kt.indexOf(arguments[3]) == -1 && (ft = pe(ft, Lt)), Ft = Ft || "Identity-H", $r.call(this, L, X, ft, Ft);
  };
  var Ls, Sa = b.lineWidth || 0.200025, rn = F.__private__.getLineWidth = F.getLineWidth = function() {
    return Sa;
  }, Ya = F.__private__.setLineWidth = F.setLineWidth = function(L) {
    return Sa = L, K(jt(lt(L)) + " w"), this;
  };
  F.__private__.setLineDash = pi.API.setLineDash = pi.API.setLineDashPattern = function(L, X) {
    if (L = L || [], X = X || 0, isNaN(X) || !Array.isArray(L)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return L = L.map(function(ft) {
      return jt(lt(ft));
    }).join(" "), X = jt(lt(X)), K("[" + L + "] " + X + " d"), this;
  };
  var Cs = F.__private__.getLineHeight = F.getLineHeight = function() {
    return ye * Ls;
  };
  F.__private__.getLineHeight = F.getLineHeight = function() {
    return ye * Ls;
  };
  var Si = F.__private__.setLineHeightFactor = F.setLineHeightFactor = function(L) {
    return typeof (L = L || 1.15) == "number" && (Ls = L), this;
  }, Xs = F.__private__.getLineHeightFactor = F.getLineHeightFactor = function() {
    return Ls;
  };
  Si(b.lineHeight);
  var Es = F.__private__.getHorizontalCoordinate = function(L) {
    return lt(L);
  }, Gn = F.__private__.getVerticalCoordinate = function(L) {
    return Mt === gt.ADVANCED ? L : O[pt].mediaBox.topRightY - O[pt].mediaBox.bottomLeftY - lt(L);
  }, kl = F.__private__.getHorizontalCoordinateString = F.getHorizontalCoordinateString = function(L) {
    return jt(Es(L));
  }, xn = F.__private__.getVerticalCoordinateString = F.getVerticalCoordinateString = function(L) {
    return jt(Gn(L));
  }, Wn = b.strokeColor || "0 G";
  F.__private__.getStrokeColor = F.getDrawColor = function() {
    return He(Wn);
  }, F.__private__.setStrokeColor = F.setDrawColor = function(L, X, ft, Lt) {
    return Wn = Ti({ ch1: L, ch2: X, ch3: ft, ch4: Lt, pdfColorType: "draw", precision: 2 }), K(Wn), this;
  };
  var Ja = b.fillColor || "0 g";
  F.__private__.getFillColor = F.getFillColor = function() {
    return He(Ja);
  }, F.__private__.setFillColor = F.setFillColor = function(L, X, ft, Lt) {
    return Ja = Ti({ ch1: L, ch2: X, ch3: ft, ch4: Lt, pdfColorType: "fill", precision: 2 }), K(Ja), this;
  };
  var Aa = b.textColor || "0 g", ll = F.__private__.getTextColor = F.getTextColor = function() {
    return He(Aa);
  };
  F.__private__.setTextColor = F.setTextColor = function(L, X, ft, Lt) {
    return Aa = Ti({ ch1: L, ch2: X, ch3: ft, ch4: Lt, pdfColorType: "text", precision: 3 }), this;
  };
  var Ys = b.charSpace, cl = F.__private__.getCharSpace = F.getCharSpace = function() {
    return parseFloat(Ys || 0);
  };
  F.__private__.setCharSpace = F.setCharSpace = function(L) {
    if (isNaN(L)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return Ys = L, this;
  };
  var Ka = 0;
  F.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, F.__private__.setLineCap = F.setLineCap = function(L) {
    var X = F.CapJoinStyles[L];
    if (X === void 0) throw new Error("Line cap style of '" + L + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ka = X, K(X + " J"), this;
  };
  var Qa = 0;
  F.__private__.setLineJoin = F.setLineJoin = function(L) {
    var X = F.CapJoinStyles[L];
    if (X === void 0) throw new Error("Line join style of '" + L + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Qa = X, K(X + " j"), this;
  }, F.__private__.setLineMiterLimit = F.__private__.setMiterLimit = F.setLineMiterLimit = F.setMiterLimit = function(L) {
    if (L = L || 0, isNaN(L)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return K(jt(lt(L)) + " M"), this;
  }, F.GState = Uh, F.setGState = function(L) {
    (L = typeof L == "string" ? qi[Ir[L]] : Bo(null, L)).equals(kr) || (K("/" + L.id + " gs"), kr = L);
  };
  var Bo = function(L, X) {
    if (!L || !Ir[L]) {
      var ft = !1;
      for (var Lt in qi) if (qi.hasOwnProperty(Lt) && qi[Lt].equals(X)) {
        ft = !0;
        break;
      }
      if (ft) X = qi[Lt];
      else {
        var Ft = "GS" + (Object.keys(qi).length + 1).toString(10);
        qi[Ft] = X, X.id = Ft;
      }
      return L && (Ir[L] = X.id), V.publish("addGState", X), X;
    }
  };
  F.addGState = function(L, X) {
    return Bo(L, X), this;
  }, F.saveGraphicsState = function() {
    return K("q"), vr.push({ key: ai, size: ye, color: Aa }), this;
  }, F.restoreGraphicsState = function() {
    K("Q");
    var L = vr.pop();
    return ai = L.key, ye = L.size, Aa = L.color, kr = null, this;
  }, F.setCurrentTransformationMatrix = function(L) {
    return K(L.toString() + " cm"), this;
  }, F.comment = function(L) {
    return K("#" + L), this;
  };
  var Cn = function(L, X) {
    var ft = L || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return ft;
    }, set: function(Kt) {
      isNaN(Kt) || (ft = parseFloat(Kt));
    } });
    var Lt = X || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return Lt;
    }, set: function(Kt) {
      isNaN(Kt) || (Lt = parseFloat(Kt));
    } });
    var Ft = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Ft;
    }, set: function(Kt) {
      Ft = Kt.toString();
    } }), this;
  }, to = function(L, X, ft, Lt) {
    Cn.call(this, L, X), this.type = "rect";
    var Ft = ft || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Ft;
    }, set: function(_e) {
      isNaN(_e) || (Ft = parseFloat(_e));
    } });
    var Kt = Lt || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return Kt;
    }, set: function(_e) {
      isNaN(_e) || (Kt = parseFloat(_e));
    } }), this;
  }, Oo = function() {
    this.page = ht, this.currentPage = pt, this.pages = ve.slice(0), this.pagesContext = O.slice(0), this.x = lr, this.y = ue, this.matrix = ni, this.width = ds(pt), this.height = Js(pt), this.outputDestination = ze, this.id = "", this.objectNumber = -1;
  };
  Oo.prototype.restore = function() {
    ht = this.page, pt = this.currentPage, O = this.pagesContext, ve = this.pages, lr = this.x, ue = this.y, ni = this.matrix, qo(pt, this.width), io(pt, this.height), ze = this.outputDestination;
  };
  var jo = function(L, X, ft, Lt, Ft) {
    Et.push(new Oo()), ht = pt = 0, ve = [], lr = L, ue = X, ni = Ft, Ln([ft, Lt]);
  }, Pa = function(L) {
    if (At[L]) Et.pop().restore();
    else {
      var X = new Oo(), ft = "Xo" + (Object.keys(ct).length + 1).toString(10);
      X.id = ft, At[L] = ft, ct[ft] = X, V.publish("addFormObject", X), Et.pop().restore();
    }
  };
  for (var eo in F.beginFormObject = function(L, X, ft, Lt, Ft) {
    return jo(L, X, ft, Lt, Ft), this;
  }, F.endFormObject = function(L) {
    return Pa(L), this;
  }, F.doFormObject = function(L, X) {
    var ft = ct[At[L]];
    return K("q"), K(X.toString() + " cm"), K("/" + ft.id + " Do"), K("Q"), this;
  }, F.getFormObject = function(L) {
    var X = ct[At[L]];
    return { x: X.x, y: X.y, width: X.width, height: X.height, matrix: X.matrix };
  }, F.save = function(L, X) {
    return L = L || "generated.pdf", (X = X || {}).returnPromise = X.returnPromise || !1, X.returnPromise === !1 ? ($l(Wa(Ts()), L), typeof $l.unload == "function" && fi.setTimeout && setTimeout($l.unload, 911), this) : new Promise(function(ft, Lt) {
      try {
        var Ft = $l(Wa(Ts()), L);
        typeof $l.unload == "function" && fi.setTimeout && setTimeout($l.unload, 911), ft(Ft);
      } catch (Kt) {
        Lt(Kt.message);
      }
    });
  }, pi.API) pi.API.hasOwnProperty(eo) && (eo === "events" && pi.API.events.length ? function(L, X) {
    var ft, Lt, Ft;
    for (Ft = X.length - 1; Ft !== -1; Ft--) ft = X[Ft][0], Lt = X[Ft][1], L.subscribe.apply(L, [ft].concat(typeof Lt == "function" ? [Lt] : Lt));
  }(V, pi.API.events) : F[eo] = pi.API[eo]);
  var ds = F.getPageWidth = function(L) {
    return (O[L = L || pt].mediaBox.topRightX - O[L].mediaBox.bottomLeftX) / Pe;
  }, qo = F.setPageWidth = function(L, X) {
    O[L].mediaBox.topRightX = X * Pe + O[L].mediaBox.bottomLeftX;
  }, Js = F.getPageHeight = function(L) {
    return (O[L = L || pt].mediaBox.topRightY - O[L].mediaBox.bottomLeftY) / Pe;
  }, io = F.setPageHeight = function(L, X) {
    O[L].mediaBox.topRightY = X * Pe + O[L].mediaBox.bottomLeftY;
  };
  return F.internal = { pdfEscape: Lr, getStyle: No, getFont: Xa, getFontSize: Ae, getCharSpace: cl, getTextColor: ll, getLineHeight: Cs, getLineHeightFactor: Xs, getLineWidth: rn, write: ci, getHorizontalCoordinate: Es, getVerticalCoordinate: Gn, getCoordinateString: kl, getVerticalCoordinateString: xn, collections: {}, newObject: Rt, newAdditionalObject: Ve, newObjectDeferred: fe, newObjectDeferredBegin: Ne, getFilters: Di, putStream: Oi, events: V, scaleFactor: Pe, pageSize: { getWidth: function() {
    return ds(pt);
  }, setWidth: function(L) {
    qo(pt, L);
  }, getHeight: function() {
    return Js(pt);
  }, setHeight: function(L) {
    io(pt, L);
  } }, encryptionOptions: $, encryption: cr, getEncryptor: xa, output: va, getNumberOfPages: ga, pages: ve, out: K, f2: ne, f3: at, getPageInfo: Zr, getPageInfoByObjId: Ye, getCurrentPageInfo: ba, getPDFVersion: ot, Point: Cn, Rectangle: to, Matrix: wt, hasHotfix: sl }, Object.defineProperty(F.internal.pageSize, "width", { get: function() {
    return ds(pt);
  }, set: function(L) {
    qo(pt, L);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(F.internal.pageSize, "height", { get: function() {
    return Js(pt);
  }, set: function(L) {
    io(pt, L);
  }, enumerable: !0, configurable: !0 }), ma.call(F, oe), ai = "F1", Ei(P, y), V.publish("initialized"), F;
}
kc.prototype.lsbFirstWord = function(b) {
  return String.fromCharCode(b >> 0 & 255, b >> 8 & 255, b >> 16 & 255, b >> 24 & 255);
}, kc.prototype.toHexString = function(b) {
  return b.split("").map(function(g) {
    return ("0" + (255 & g.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, kc.prototype.hexToBytes = function(b) {
  for (var g = [], y = 0; y < b.length; y += 2) g.push(String.fromCharCode(parseInt(b.substr(y, 2), 16)));
  return g.join("");
}, kc.prototype.processOwnerPassword = function(b, g) {
  return Hu(Wu(g).substr(0, 5), b);
}, kc.prototype.encryptor = function(b, g) {
  var y = Wu(this.encryptionKey + String.fromCharCode(255 & b, b >> 8 & 255, b >> 16 & 255, 255 & g, g >> 8 & 255)).substr(0, 10);
  return function(x) {
    return Hu(y, x);
  };
}, Uh.prototype.equals = function(b) {
  var g, y = "id,objectNumber,equals";
  if (!b || ir(b) !== ir(this)) return !1;
  var x = 0;
  for (g in this) if (!(y.indexOf(g) >= 0)) {
    if (this.hasOwnProperty(g) && !b.hasOwnProperty(g) || this[g] !== b[g]) return !1;
    x++;
  }
  for (g in b) b.hasOwnProperty(g) && y.indexOf(g) < 0 && x--;
  return x === 0;
}, pi.API = { events: [] }, pi.version = "2.5.1";
var Dr = pi.API, Qu = 1, Xl = function(b) {
  return b.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, Pc = function(b) {
  return b.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, wi = function(b) {
  return b.toFixed(2);
}, wl = function(b) {
  return b.toFixed(5);
};
Dr.__acroform__ = {};
var ks = function(b, g) {
  b.prototype = Object.create(g.prototype), b.prototype.constructor = b;
}, Fp = function(b) {
  return b * Qu;
}, Lo = function(b) {
  var g = new cf(), y = Ge.internal.getHeight(b) || 0, x = Ge.internal.getWidth(b) || 0;
  return g.BBox = [0, 0, Number(wi(x)), Number(wi(y))], g;
}, Gg = Dr.__acroform__.setBit = function(b, g) {
  if (b = b || 0, g = g || 0, isNaN(b) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return b |= 1 << g;
}, Wg = Dr.__acroform__.clearBit = function(b, g) {
  if (b = b || 0, g = g || 0, isNaN(b) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return b &= ~(1 << g);
}, Hg = Dr.__acroform__.getBit = function(b, g) {
  if (isNaN(b) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return b & 1 << g ? 1 : 0;
}, Or = Dr.__acroform__.getBitForPdf = function(b, g) {
  if (isNaN(b) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return Hg(b, g - 1);
}, jr = Dr.__acroform__.setBitForPdf = function(b, g) {
  if (isNaN(b) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return Gg(b, g - 1);
}, qr = Dr.__acroform__.clearBitForPdf = function(b, g) {
  if (isNaN(b) || isNaN(g)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Wg(b, g - 1);
}, Xg = Dr.__acroform__.calculateCoordinates = function(b, g) {
  var y = g.internal.getHorizontalCoordinate, x = g.internal.getVerticalCoordinate, P = b[0], A = b[1], v = b[2], l = b[3], M = {};
  return M.lowerLeft_X = y(P) || 0, M.lowerLeft_Y = x(A + l) || 0, M.upperRight_X = y(P + v) || 0, M.upperRight_Y = x(A) || 0, [Number(wi(M.lowerLeft_X)), Number(wi(M.lowerLeft_Y)), Number(wi(M.upperRight_X)), Number(wi(M.upperRight_Y))];
}, Yg = function(b) {
  if (b.appearanceStreamContent) return b.appearanceStreamContent;
  if (b.V || b.DV) {
    var g = [], y = b._V || b.DV, x = Xu(b, y), P = b.scope.internal.getFont(b.fontName, b.fontStyle).id;
    g.push("/Tx BMC"), g.push("q"), g.push("BT"), g.push(b.scope.__private__.encodeColorString(b.color)), g.push("/" + P + " " + wi(x.fontSize) + " Tf"), g.push("1 0 0 1 0 0 Tm"), g.push(x.text), g.push("ET"), g.push("Q"), g.push("EMC");
    var A = Lo(b);
    return A.scope = b.scope, A.stream = g.join(`
`), A;
  }
}, Xu = function(b, g) {
  var y = b.fontSize === 0 ? b.maxFontSize : b.fontSize, x = { text: "", fontSize: "" }, P = (g = (g = g.substr(0, 1) == "(" ? g.substr(1) : g).substr(g.length - 1) == ")" ? g.substr(0, g.length - 1) : g).split(" ");
  P = b.multiline ? P.map(function(at) {
    return at.split(`
`);
  }) : P.map(function(at) {
    return [at];
  });
  var A = y, v = Ge.internal.getHeight(b) || 0;
  v = v < 0 ? -v : v;
  var l = Ge.internal.getWidth(b) || 0;
  l = l < 0 ? -l : l;
  var M = function(at, lt, Pt) {
    if (at + 1 < P.length) {
      var bt = lt + " " + P[at + 1][0];
      return Nh(bt, b, Pt).width <= l - 4;
    }
    return !1;
  };
  A++;
  t: for (; A > 0; ) {
    g = "", A--;
    var B, $, q = Nh("3", b, A).height, U = b.multiline ? v - A : (v - q) / 2, F = U += 2, mt = 0, ot = 0, yt = 0;
    if (A <= 0) {
      g = `(...) Tj
`, g += "% Width of Text: " + Nh(g, b, A = 12).width + ", FieldWidth:" + l + `
`;
      break;
    }
    for (var st = "", gt = 0, Mt = 0; Mt < P.length; Mt++) if (P.hasOwnProperty(Mt)) {
      var Qt = !1;
      if (P[Mt].length !== 1 && yt !== P[Mt].length - 1) {
        if ((q + 2) * (gt + 2) + 2 > v) continue t;
        st += P[Mt][yt], Qt = !0, ot = Mt, Mt--;
      } else {
        st = (st += P[Mt][yt] + " ").substr(st.length - 1) == " " ? st.substr(0, st.length - 1) : st;
        var Ht = parseInt(Mt), pe = M(Ht, st, A), jt = Mt >= P.length - 1;
        if (pe && !jt) {
          st += " ", yt = 0;
          continue;
        }
        if (pe || jt) {
          if (jt) ot = Ht;
          else if (b.multiline && (q + 2) * (gt + 2) + 2 > v) continue t;
        } else {
          if (!b.multiline || (q + 2) * (gt + 2) + 2 > v) continue t;
          ot = Ht;
        }
      }
      for (var Tt = "", le = mt; le <= ot; le++) {
        var ne = P[le];
        if (b.multiline) {
          if (le === ot) {
            Tt += ne[yt] + " ", yt = (yt + 1) % ne.length;
            continue;
          }
          if (le === mt) {
            Tt += ne[ne.length - 1] + " ";
            continue;
          }
        }
        Tt += ne[0] + " ";
      }
      switch (Tt = Tt.substr(Tt.length - 1) == " " ? Tt.substr(0, Tt.length - 1) : Tt, $ = Nh(Tt, b, A).width, b.textAlign) {
        case "right":
          B = l - $ - 2;
          break;
        case "center":
          B = (l - $) / 2;
          break;
        case "left":
        default:
          B = 2;
      }
      g += wi(B) + " " + wi(F) + ` Td
`, g += "(" + Xl(Tt) + `) Tj
`, g += -wi(B) + ` 0 Td
`, F = -(A + 2), $ = 0, mt = Qt ? ot : ot + 1, gt++, st = "";
    }
    break;
  }
  return x.text = g, x.fontSize = A, x;
}, Nh = function(b, g, y) {
  var x = g.scope.internal.getFont(g.fontName, g.fontStyle), P = g.scope.getStringUnitWidth(b, { font: x, fontSize: parseFloat(y), charSpace: 0 }) * parseFloat(y);
  return { height: g.scope.getStringUnitWidth("3", { font: x, fontSize: parseFloat(y), charSpace: 0 }) * parseFloat(y) * 1.5, width: P };
}, Jg = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, Kg = function(b, g) {
  var y = { type: "reference", object: b };
  g.internal.getPageInfo(b.page).pageContext.annotations.find(function(x) {
    return x.type === y.type && x.object === y.object;
  }) === void 0 && g.internal.getPageInfo(b.page).pageContext.annotations.push(y);
}, Qg = function(b, g) {
  for (var y in b) if (b.hasOwnProperty(y)) {
    var x = y, P = b[y];
    g.internal.newObjectDeferredBegin(P.objId, !0), ir(P) === "object" && typeof P.putStream == "function" && P.putStream(), delete b[x];
  }
}, t0 = function(b, g) {
  if (g.scope = b, b.internal !== void 0 && (b.internal.acroformPlugin === void 0 || b.internal.acroformPlugin.isInitialized === !1)) {
    if (ja.FieldNum = 0, b.internal.acroformPlugin = JSON.parse(JSON.stringify(Jg)), b.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    Qu = b.internal.scaleFactor, b.internal.acroformPlugin.acroFormDictionaryRoot = new hf(), b.internal.acroformPlugin.acroFormDictionaryRoot.scope = b, b.internal.acroformPlugin.acroFormDictionaryRoot._eventID = b.internal.events.subscribe("postPutResources", function() {
      (function(y) {
        y.internal.events.unsubscribe(y.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete y.internal.acroformPlugin.acroFormDictionaryRoot._eventID, y.internal.acroformPlugin.printedOut = !0;
      })(b);
    }), b.internal.events.subscribe("buildDocument", function() {
      (function(y) {
        y.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var x = y.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var P in x) if (x.hasOwnProperty(P)) {
          var A = x[P];
          A.objId = void 0, A.hasAnnotation && Kg(A, y);
        }
      })(b);
    }), b.internal.events.subscribe("putCatalog", function() {
      (function(y) {
        if (y.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        y.internal.write("/AcroForm " + y.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(b);
    }), b.internal.events.subscribe("postPutPages", function(y) {
      (function(x, P) {
        var A = !x;
        for (var v in x || (P.internal.newObjectDeferredBegin(P.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), P.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), x = x || P.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (x.hasOwnProperty(v)) {
          var l = x[v], M = [], B = l.Rect;
          if (l.Rect && (l.Rect = Xg(l.Rect, P)), P.internal.newObjectDeferredBegin(l.objId, !0), l.DA = Ge.createDefaultAppearanceStream(l), ir(l) === "object" && typeof l.getKeyValueListForStream == "function" && (M = l.getKeyValueListForStream()), l.Rect = B, l.hasAppearanceStream && !l.appearanceStreamContent) {
            var $ = Yg(l);
            M.push({ key: "AP", value: "<</N " + $ + ">>" }), P.internal.acroformPlugin.xForms.push($);
          }
          if (l.appearanceStreamContent) {
            var q = "";
            for (var U in l.appearanceStreamContent) if (l.appearanceStreamContent.hasOwnProperty(U)) {
              var F = l.appearanceStreamContent[U];
              if (q += "/" + U + " ", q += "<<", Object.keys(F).length >= 1 || Array.isArray(F)) {
                for (var v in F) if (F.hasOwnProperty(v)) {
                  var mt = F[v];
                  typeof mt == "function" && (mt = mt.call(P, l)), q += "/" + v + " " + mt + " ", P.internal.acroformPlugin.xForms.indexOf(mt) >= 0 || P.internal.acroformPlugin.xForms.push(mt);
                }
              } else typeof (mt = F) == "function" && (mt = mt.call(P, l)), q += "/" + v + " " + mt, P.internal.acroformPlugin.xForms.indexOf(mt) >= 0 || P.internal.acroformPlugin.xForms.push(mt);
              q += ">>";
            }
            M.push({ key: "AP", value: `<<
` + q + ">>" });
          }
          P.internal.putStream({ additionalKeyValues: M, objectId: l.objId }), P.internal.out("endobj");
        }
        A && Qg(P.internal.acroformPlugin.xForms, P);
      })(y, b);
    }), b.internal.acroformPlugin.isInitialized = !0;
  }
}, lf = Dr.__acroform__.arrayToPdfArray = function(b, g, y) {
  var x = function(v) {
    return v;
  };
  if (Array.isArray(b)) {
    for (var P = "[", A = 0; A < b.length; A++) switch (A !== 0 && (P += " "), ir(b[A])) {
      case "boolean":
      case "number":
      case "object":
        P += b[A].toString();
        break;
      case "string":
        b[A].substr(0, 1) !== "/" ? (g !== void 0 && y && (x = y.internal.getEncryptor(g)), P += "(" + Xl(x(b[A].toString())) + ")") : P += b[A].toString();
    }
    return P += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Bu = function(b, g, y) {
  var x = function(P) {
    return P;
  };
  return g !== void 0 && y && (x = y.internal.getEncryptor(g)), (b = b || "").toString(), b = "(" + Xl(x(b)) + ")";
}, Co = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(b) {
    this._objId = b;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
Co.prototype.toString = function() {
  return this.objId + " 0 R";
}, Co.prototype.putStream = function() {
  var b = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: b, objectId: this.objId }), this.scope.internal.out("endobj");
}, Co.prototype.getKeyValueListForStream = function() {
  var b = [], g = Object.getOwnPropertyNames(this).filter(function(A) {
    return A != "content" && A != "appearanceStreamContent" && A != "scope" && A != "objId" && A.substring(0, 1) != "_";
  });
  for (var y in g) if (Object.getOwnPropertyDescriptor(this, g[y]).configurable === !1) {
    var x = g[y], P = this[x];
    P && (Array.isArray(P) ? b.push({ key: x, value: lf(P, this.objId, this.scope) }) : P instanceof Co ? (P.scope = this.scope, b.push({ key: x, value: P.objId + " 0 R" })) : typeof P != "function" && b.push({ key: x, value: P }));
  }
  return b;
};
var cf = function() {
  Co.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var b, g = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return g;
  }, set: function(y) {
    g = y;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(y) {
    b = y.trim();
  }, get: function() {
    return b || null;
  } });
};
ks(cf, Co);
var hf = function() {
  Co.call(this);
  var b, g = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return g.length > 0 ? g : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return g;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (b) {
      var y = function(x) {
        return x;
      };
      return this.scope && (y = this.scope.internal.getEncryptor(this.objId)), "(" + Xl(y(b)) + ")";
    }
  }, set: function(y) {
    b = y;
  } });
};
ks(hf, Co);
var ja = function b() {
  Co.call(this);
  var g = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return g;
  }, set: function(st) {
    if (isNaN(st)) throw new Error('Invalid value "' + st + '" for attribute F supplied.');
    g = st;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(g, 3);
  }, set: function(st) {
    st ? this.F = jr(g, 3) : this.F = qr(g, 3);
  } });
  var y = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return y;
  }, set: function(st) {
    if (isNaN(st)) throw new Error('Invalid value "' + st + '" for attribute Ff supplied.');
    y = st;
  } });
  var x = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (x.length !== 0) return x;
  }, set: function(st) {
    x = st !== void 0 ? st : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !x || isNaN(x[0]) ? 0 : x[0];
  }, set: function(st) {
    x[0] = st;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !x || isNaN(x[1]) ? 0 : x[1];
  }, set: function(st) {
    x[1] = st;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !x || isNaN(x[2]) ? 0 : x[2];
  }, set: function(st) {
    x[2] = st;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !x || isNaN(x[3]) ? 0 : x[3];
  }, set: function(st) {
    x[3] = st;
  } });
  var P = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return P;
  }, set: function(st) {
    switch (st) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        P = st;
        break;
      default:
        throw new Error('Invalid value "' + st + '" for attribute FT supplied.');
    }
  } });
  var A = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!A || A.length < 1) {
      if (this instanceof Vh) return;
      A = "FieldObject" + b.FieldNum++;
    }
    var st = function(gt) {
      return gt;
    };
    return this.scope && (st = this.scope.internal.getEncryptor(this.objId)), "(" + Xl(st(A)) + ")";
  }, set: function(st) {
    A = st.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return A;
  }, set: function(st) {
    A = st;
  } });
  var v = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return v;
  }, set: function(st) {
    v = st;
  } });
  var l = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return l;
  }, set: function(st) {
    l = st;
  } });
  var M = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return M;
  }, set: function(st) {
    M = st;
  } });
  var B = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return B === void 0 ? 50 / Qu : B;
  }, set: function(st) {
    B = st;
  } });
  var $ = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return $;
  }, set: function(st) {
    $ = st;
  } });
  var q = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!q || this instanceof Vh || this instanceof Wl)) return Bu(q, this.objId, this.scope);
  }, set: function(st) {
    st = st.toString(), q = st;
  } });
  var U = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (U) return this instanceof vn ? U : Bu(U, this.objId, this.scope);
  }, set: function(st) {
    st = st.toString(), U = this instanceof vn ? st : st.substr(0, 1) === "(" ? Pc(st.substr(1, st.length - 2)) : Pc(st);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof vn ? Pc(U.substr(1, U.length - 1)) : U;
  }, set: function(st) {
    st = st.toString(), U = this instanceof vn ? "/" + st : st;
  } });
  var F = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (F) return F;
  }, set: function(st) {
    this.V = st;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (F) return this instanceof vn ? F : Bu(F, this.objId, this.scope);
  }, set: function(st) {
    st = st.toString(), F = this instanceof vn ? st : st.substr(0, 1) === "(" ? Pc(st.substr(1, st.length - 2)) : Pc(st);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof vn ? Pc(F.substr(1, F.length - 1)) : F;
  }, set: function(st) {
    st = st.toString(), F = this instanceof vn ? "/" + st : st;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var mt, ot = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return ot;
  }, set: function(st) {
    st = !!st, ot = st;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (mt) return mt;
  }, set: function(st) {
    mt = st;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 1);
  }, set: function(st) {
    st ? this.Ff = jr(this.Ff, 1) : this.Ff = qr(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 2);
  }, set: function(st) {
    st ? this.Ff = jr(this.Ff, 2) : this.Ff = qr(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 3);
  }, set: function(st) {
    st ? this.Ff = jr(this.Ff, 3) : this.Ff = qr(this.Ff, 3);
  } });
  var yt = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (yt !== null) return yt;
  }, set: function(st) {
    if ([0, 1, 2].indexOf(st) === -1) throw new Error('Invalid value "' + st + '" for attribute Q supplied.');
    yt = st;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var st;
    switch (yt) {
      case 0:
      default:
        st = "left";
        break;
      case 1:
        st = "center";
        break;
      case 2:
        st = "right";
    }
    return st;
  }, configurable: !0, enumerable: !0, set: function(st) {
    switch (st) {
      case "right":
      case 2:
        yt = 2;
        break;
      case "center":
      case 1:
        yt = 1;
        break;
      case "left":
      case 0:
      default:
        yt = 0;
    }
  } });
};
ks(ja, Co);
var Cc = function() {
  ja.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var b = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return b;
  }, set: function(y) {
    b = y;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return b;
  }, set: function(y) {
    b = y;
  } });
  var g = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return lf(g, this.objId, this.scope);
  }, set: function(y) {
    var x, P;
    P = [], typeof (x = y) == "string" && (P = function(A, v, l) {
      l || (l = 1);
      for (var M, B = []; M = v.exec(A); ) B.push(M[l]);
      return B;
    }(x, /\((.*?)\)/g)), g = P;
  } }), this.getOptions = function() {
    return g;
  }, this.setOptions = function(y) {
    g = y, this.sort && g.sort();
  }, this.addOption = function(y) {
    y = (y = y || "").toString(), g.push(y), this.sort && g.sort();
  }, this.removeOption = function(y, x) {
    for (x = x || !1, y = (y = y || "").toString(); g.indexOf(y) !== -1 && (g.splice(g.indexOf(y), 1), x !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 18);
  }, set: function(y) {
    y ? this.Ff = jr(this.Ff, 18) : this.Ff = qr(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 19);
  }, set: function(y) {
    this.combo === !0 && (y ? this.Ff = jr(this.Ff, 19) : this.Ff = qr(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 20);
  }, set: function(y) {
    y ? (this.Ff = jr(this.Ff, 20), g.sort()) : this.Ff = qr(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 22);
  }, set: function(y) {
    y ? this.Ff = jr(this.Ff, 22) : this.Ff = qr(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 23);
  }, set: function(y) {
    y ? this.Ff = jr(this.Ff, 23) : this.Ff = qr(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 27);
  }, set: function(y) {
    y ? this.Ff = jr(this.Ff, 27) : this.Ff = qr(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
ks(Cc, ja);
var Ec = function() {
  Cc.call(this), this.fontName = "helvetica", this.combo = !1;
};
ks(Ec, Cc);
var Mc = function() {
  Ec.call(this), this.combo = !0;
};
ks(Mc, Ec);
var Bh = function() {
  Mc.call(this), this.edit = !0;
};
ks(Bh, Mc);
var vn = function() {
  ja.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 15);
  }, set: function(y) {
    y ? this.Ff = jr(this.Ff, 15) : this.Ff = qr(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 16);
  }, set: function(y) {
    y ? this.Ff = jr(this.Ff, 16) : this.Ff = qr(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 17);
  }, set: function(y) {
    y ? this.Ff = jr(this.Ff, 17) : this.Ff = qr(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 26);
  }, set: function(y) {
    y ? this.Ff = jr(this.Ff, 26) : this.Ff = qr(this.Ff, 26);
  } });
  var b, g = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var y = function(A) {
      return A;
    };
    if (this.scope && (y = this.scope.internal.getEncryptor(this.objId)), Object.keys(g).length !== 0) {
      var x, P = [];
      for (x in P.push("<<"), g) P.push("/" + x + " (" + Xl(y(g[x])) + ")");
      return P.push(">>"), P.join(`
`);
    }
  }, set: function(y) {
    ir(y) === "object" && (g = y);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return g.CA || "";
  }, set: function(y) {
    typeof y == "string" && (g.CA = y);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return b;
  }, set: function(y) {
    b = y;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return b.substr(1, b.length - 1);
  }, set: function(y) {
    b = "/" + y;
  } });
};
ks(vn, ja);
var Oh = function() {
  vn.call(this), this.pushButton = !0;
};
ks(Oh, vn);
var zc = function() {
  vn.call(this), this.radio = !0, this.pushButton = !1;
  var b = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return b;
  }, set: function(g) {
    b = g !== void 0 ? g : [];
  } });
};
ks(zc, vn);
var Vh = function() {
  var b, g;
  ja.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return b;
  }, set: function(P) {
    b = P;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return g;
  }, set: function(P) {
    g = P;
  } });
  var y, x = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var P = function(l) {
      return l;
    };
    this.scope && (P = this.scope.internal.getEncryptor(this.objId));
    var A, v = [];
    for (A in v.push("<<"), x) v.push("/" + A + " (" + Xl(P(x[A])) + ")");
    return v.push(">>"), v.join(`
`);
  }, set: function(P) {
    ir(P) === "object" && (x = P);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return x.CA || "";
  }, set: function(P) {
    typeof P == "string" && (x.CA = P);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return y;
  }, set: function(P) {
    y = P;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return y.substr(1, y.length - 1);
  }, set: function(P) {
    y = "/" + P;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = Ge.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
ks(Vh, ja), zc.prototype.setAppearance = function(b) {
  if (!("createAppearanceStream" in b) || !("getCA" in b)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var g in this.Kids) if (this.Kids.hasOwnProperty(g)) {
    var y = this.Kids[g];
    y.appearanceStreamContent = b.createAppearanceStream(y.optionName), y.caption = b.getCA();
  }
}, zc.prototype.createOption = function(b) {
  var g = new Vh();
  return g.Parent = this, g.optionName = b, this.Kids.push(g), e0.call(this.scope, g), g;
};
var jh = function() {
  vn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = Ge.CheckBox.createAppearanceStream();
};
ks(jh, vn);
var Wl = function() {
  ja.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 13);
  }, set: function(g) {
    g ? this.Ff = jr(this.Ff, 13) : this.Ff = qr(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 21);
  }, set: function(g) {
    g ? this.Ff = jr(this.Ff, 21) : this.Ff = qr(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 23);
  }, set: function(g) {
    g ? this.Ff = jr(this.Ff, 23) : this.Ff = qr(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 24);
  }, set: function(g) {
    g ? this.Ff = jr(this.Ff, 24) : this.Ff = qr(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 25);
  }, set: function(g) {
    g ? this.Ff = jr(this.Ff, 25) : this.Ff = qr(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 26);
  }, set: function(g) {
    g ? this.Ff = jr(this.Ff, 26) : this.Ff = qr(this.Ff, 26);
  } });
  var b = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return b;
  }, set: function(g) {
    b = g;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return b;
  }, set: function(g) {
    Number.isInteger(g) && (b = g);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
ks(Wl, ja);
var qh = function() {
  Wl.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!Or(this.Ff, 14);
  }, set: function(b) {
    b ? this.Ff = jr(this.Ff, 14) : this.Ff = qr(this.Ff, 14);
  } }), this.password = !0;
};
ks(qh, Wl);
var Ge = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: Ge.CheckBox.YesNormal }, D: { On: Ge.CheckBox.YesPushDown, Off: Ge.CheckBox.OffPushDown } };
}, YesPushDown: function(b) {
  var g = Lo(b);
  g.scope = b.scope;
  var y = [], x = b.scope.internal.getFont(b.fontName, b.fontStyle).id, P = b.scope.__private__.encodeColorString(b.color), A = Xu(b, b.caption);
  return y.push("0.749023 g"), y.push("0 0 " + wi(Ge.internal.getWidth(b)) + " " + wi(Ge.internal.getHeight(b)) + " re"), y.push("f"), y.push("BMC"), y.push("q"), y.push("0 0 1 rg"), y.push("/" + x + " " + wi(A.fontSize) + " Tf " + P), y.push("BT"), y.push(A.text), y.push("ET"), y.push("Q"), y.push("EMC"), g.stream = y.join(`
`), g;
}, YesNormal: function(b) {
  var g = Lo(b);
  g.scope = b.scope;
  var y = b.scope.internal.getFont(b.fontName, b.fontStyle).id, x = b.scope.__private__.encodeColorString(b.color), P = [], A = Ge.internal.getHeight(b), v = Ge.internal.getWidth(b), l = Xu(b, b.caption);
  return P.push("1 g"), P.push("0 0 " + wi(v) + " " + wi(A) + " re"), P.push("f"), P.push("q"), P.push("0 0 1 rg"), P.push("0 0 " + wi(v - 1) + " " + wi(A - 1) + " re"), P.push("W"), P.push("n"), P.push("0 g"), P.push("BT"), P.push("/" + y + " " + wi(l.fontSize) + " Tf " + x), P.push(l.text), P.push("ET"), P.push("Q"), g.stream = P.join(`
`), g;
}, OffPushDown: function(b) {
  var g = Lo(b);
  g.scope = b.scope;
  var y = [];
  return y.push("0.749023 g"), y.push("0 0 " + wi(Ge.internal.getWidth(b)) + " " + wi(Ge.internal.getHeight(b)) + " re"), y.push("f"), g.stream = y.join(`
`), g;
} }, RadioButton: { Circle: { createAppearanceStream: function(b) {
  var g = { D: { Off: Ge.RadioButton.Circle.OffPushDown }, N: {} };
  return g.N[b] = Ge.RadioButton.Circle.YesNormal, g.D[b] = Ge.RadioButton.Circle.YesPushDown, g;
}, getCA: function() {
  return "l";
}, YesNormal: function(b) {
  var g = Lo(b);
  g.scope = b.scope;
  var y = [], x = Ge.internal.getWidth(b) <= Ge.internal.getHeight(b) ? Ge.internal.getWidth(b) / 4 : Ge.internal.getHeight(b) / 4;
  x = Number((0.9 * x).toFixed(5));
  var P = Ge.internal.Bezier_C, A = Number((x * P).toFixed(5));
  return y.push("q"), y.push("1 0 0 1 " + wl(Ge.internal.getWidth(b) / 2) + " " + wl(Ge.internal.getHeight(b) / 2) + " cm"), y.push(x + " 0 m"), y.push(x + " " + A + " " + A + " " + x + " 0 " + x + " c"), y.push("-" + A + " " + x + " -" + x + " " + A + " -" + x + " 0 c"), y.push("-" + x + " -" + A + " -" + A + " -" + x + " 0 -" + x + " c"), y.push(A + " -" + x + " " + x + " -" + A + " " + x + " 0 c"), y.push("f"), y.push("Q"), g.stream = y.join(`
`), g;
}, YesPushDown: function(b) {
  var g = Lo(b);
  g.scope = b.scope;
  var y = [], x = Ge.internal.getWidth(b) <= Ge.internal.getHeight(b) ? Ge.internal.getWidth(b) / 4 : Ge.internal.getHeight(b) / 4;
  x = Number((0.9 * x).toFixed(5));
  var P = Number((2 * x).toFixed(5)), A = Number((P * Ge.internal.Bezier_C).toFixed(5)), v = Number((x * Ge.internal.Bezier_C).toFixed(5));
  return y.push("0.749023 g"), y.push("q"), y.push("1 0 0 1 " + wl(Ge.internal.getWidth(b) / 2) + " " + wl(Ge.internal.getHeight(b) / 2) + " cm"), y.push(P + " 0 m"), y.push(P + " " + A + " " + A + " " + P + " 0 " + P + " c"), y.push("-" + A + " " + P + " -" + P + " " + A + " -" + P + " 0 c"), y.push("-" + P + " -" + A + " -" + A + " -" + P + " 0 -" + P + " c"), y.push(A + " -" + P + " " + P + " -" + A + " " + P + " 0 c"), y.push("f"), y.push("Q"), y.push("0 g"), y.push("q"), y.push("1 0 0 1 " + wl(Ge.internal.getWidth(b) / 2) + " " + wl(Ge.internal.getHeight(b) / 2) + " cm"), y.push(x + " 0 m"), y.push(x + " " + v + " " + v + " " + x + " 0 " + x + " c"), y.push("-" + v + " " + x + " -" + x + " " + v + " -" + x + " 0 c"), y.push("-" + x + " -" + v + " -" + v + " -" + x + " 0 -" + x + " c"), y.push(v + " -" + x + " " + x + " -" + v + " " + x + " 0 c"), y.push("f"), y.push("Q"), g.stream = y.join(`
`), g;
}, OffPushDown: function(b) {
  var g = Lo(b);
  g.scope = b.scope;
  var y = [], x = Ge.internal.getWidth(b) <= Ge.internal.getHeight(b) ? Ge.internal.getWidth(b) / 4 : Ge.internal.getHeight(b) / 4;
  x = Number((0.9 * x).toFixed(5));
  var P = Number((2 * x).toFixed(5)), A = Number((P * Ge.internal.Bezier_C).toFixed(5));
  return y.push("0.749023 g"), y.push("q"), y.push("1 0 0 1 " + wl(Ge.internal.getWidth(b) / 2) + " " + wl(Ge.internal.getHeight(b) / 2) + " cm"), y.push(P + " 0 m"), y.push(P + " " + A + " " + A + " " + P + " 0 " + P + " c"), y.push("-" + A + " " + P + " -" + P + " " + A + " -" + P + " 0 c"), y.push("-" + P + " -" + A + " -" + A + " -" + P + " 0 -" + P + " c"), y.push(A + " -" + P + " " + P + " -" + A + " " + P + " 0 c"), y.push("f"), y.push("Q"), g.stream = y.join(`
`), g;
} }, Cross: { createAppearanceStream: function(b) {
  var g = { D: { Off: Ge.RadioButton.Cross.OffPushDown }, N: {} };
  return g.N[b] = Ge.RadioButton.Cross.YesNormal, g.D[b] = Ge.RadioButton.Cross.YesPushDown, g;
}, getCA: function() {
  return "8";
}, YesNormal: function(b) {
  var g = Lo(b);
  g.scope = b.scope;
  var y = [], x = Ge.internal.calculateCross(b);
  return y.push("q"), y.push("1 1 " + wi(Ge.internal.getWidth(b) - 2) + " " + wi(Ge.internal.getHeight(b) - 2) + " re"), y.push("W"), y.push("n"), y.push(wi(x.x1.x) + " " + wi(x.x1.y) + " m"), y.push(wi(x.x2.x) + " " + wi(x.x2.y) + " l"), y.push(wi(x.x4.x) + " " + wi(x.x4.y) + " m"), y.push(wi(x.x3.x) + " " + wi(x.x3.y) + " l"), y.push("s"), y.push("Q"), g.stream = y.join(`
`), g;
}, YesPushDown: function(b) {
  var g = Lo(b);
  g.scope = b.scope;
  var y = Ge.internal.calculateCross(b), x = [];
  return x.push("0.749023 g"), x.push("0 0 " + wi(Ge.internal.getWidth(b)) + " " + wi(Ge.internal.getHeight(b)) + " re"), x.push("f"), x.push("q"), x.push("1 1 " + wi(Ge.internal.getWidth(b) - 2) + " " + wi(Ge.internal.getHeight(b) - 2) + " re"), x.push("W"), x.push("n"), x.push(wi(y.x1.x) + " " + wi(y.x1.y) + " m"), x.push(wi(y.x2.x) + " " + wi(y.x2.y) + " l"), x.push(wi(y.x4.x) + " " + wi(y.x4.y) + " m"), x.push(wi(y.x3.x) + " " + wi(y.x3.y) + " l"), x.push("s"), x.push("Q"), g.stream = x.join(`
`), g;
}, OffPushDown: function(b) {
  var g = Lo(b);
  g.scope = b.scope;
  var y = [];
  return y.push("0.749023 g"), y.push("0 0 " + wi(Ge.internal.getWidth(b)) + " " + wi(Ge.internal.getHeight(b)) + " re"), y.push("f"), g.stream = y.join(`
`), g;
} } }, createDefaultAppearanceStream: function(b) {
  var g = b.scope.internal.getFont(b.fontName, b.fontStyle).id, y = b.scope.__private__.encodeColorString(b.color);
  return "/" + g + " " + b.fontSize + " Tf " + y;
} };
Ge.internal = { Bezier_C: 0.551915024494, calculateCross: function(b) {
  var g = Ge.internal.getWidth(b), y = Ge.internal.getHeight(b), x = Math.min(g, y);
  return { x1: { x: (g - x) / 2, y: (y - x) / 2 + x }, x2: { x: (g - x) / 2 + x, y: (y - x) / 2 }, x3: { x: (g - x) / 2, y: (y - x) / 2 }, x4: { x: (g - x) / 2 + x, y: (y - x) / 2 + x } };
} }, Ge.internal.getWidth = function(b) {
  var g = 0;
  return ir(b) === "object" && (g = Fp(b.Rect[2])), g;
}, Ge.internal.getHeight = function(b) {
  var g = 0;
  return ir(b) === "object" && (g = Fp(b.Rect[3])), g;
};
var e0 = Dr.addField = function(b) {
  if (t0(this, b), !(b instanceof ja)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var g;
  return (g = b).scope.internal.acroformPlugin.printedOut && (g.scope.internal.acroformPlugin.printedOut = !1, g.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), g.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(g), b.page = b.scope.internal.getCurrentPageInfo().pageNumber, this;
};
Dr.AcroFormChoiceField = Cc, Dr.AcroFormListBox = Ec, Dr.AcroFormComboBox = Mc, Dr.AcroFormEditBox = Bh, Dr.AcroFormButton = vn, Dr.AcroFormPushButton = Oh, Dr.AcroFormRadioButton = zc, Dr.AcroFormCheckBox = jh, Dr.AcroFormTextField = Wl, Dr.AcroFormPasswordField = qh, Dr.AcroFormAppearance = Ge, Dr.AcroForm = { ChoiceField: Cc, ListBox: Ec, ComboBox: Mc, EditBox: Bh, Button: vn, PushButton: Oh, RadioButton: zc, CheckBox: jh, TextField: Wl, PasswordField: qh, Appearance: Ge }, pi.AcroForm = { ChoiceField: Cc, ListBox: Ec, ComboBox: Mc, EditBox: Bh, Button: vn, PushButton: Oh, RadioButton: zc, CheckBox: jh, TextField: Wl, PasswordField: qh, Appearance: Ge };
function uf(b) {
  return b.reduce(function(g, y, x) {
    return g[y] = x, g;
  }, {});
}
(function(b) {
  b.__addimage__ = {};
  var g = "UNKNOWN", y = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, x = b.__addimage__.getImageFileTypeByImageData = function(at, lt) {
    var Pt, bt, Jt, Yt, te, Ut = g;
    if ((lt = lt || g) === "RGBA" || at.data !== void 0 && at.data instanceof Uint8ClampedArray && "height" in at && "width" in at) return "RGBA";
    if (pe(at)) for (te in y) for (Jt = y[te], Pt = 0; Pt < Jt.length; Pt += 1) {
      for (Yt = !0, bt = 0; bt < Jt[Pt].length; bt += 1) if (Jt[Pt][bt] !== void 0 && Jt[Pt][bt] !== at[bt]) {
        Yt = !1;
        break;
      }
      if (Yt === !0) {
        Ut = te;
        break;
      }
    }
    else for (te in y) for (Jt = y[te], Pt = 0; Pt < Jt.length; Pt += 1) {
      for (Yt = !0, bt = 0; bt < Jt[Pt].length; bt += 1) if (Jt[Pt][bt] !== void 0 && Jt[Pt][bt] !== at.charCodeAt(bt)) {
        Yt = !1;
        break;
      }
      if (Yt === !0) {
        Ut = te;
        break;
      }
    }
    return Ut === g && lt !== g && (Ut = lt), Ut;
  }, P = function at(lt) {
    for (var Pt = this.internal.write, bt = this.internal.putStream, Jt = (0, this.internal.getFilters)(); Jt.indexOf("FlateEncode") !== -1; ) Jt.splice(Jt.indexOf("FlateEncode"), 1);
    lt.objectId = this.internal.newObject();
    var Yt = [];
    if (Yt.push({ key: "Type", value: "/XObject" }), Yt.push({ key: "Subtype", value: "/Image" }), Yt.push({ key: "Width", value: lt.width }), Yt.push({ key: "Height", value: lt.height }), lt.colorSpace === yt.INDEXED ? Yt.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (lt.palette.length / 3 - 1) + " " + ("sMask" in lt && lt.sMask !== void 0 ? lt.objectId + 2 : lt.objectId + 1) + " 0 R]" }) : (Yt.push({ key: "ColorSpace", value: "/" + lt.colorSpace }), lt.colorSpace === yt.DEVICE_CMYK && Yt.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), Yt.push({ key: "BitsPerComponent", value: lt.bitsPerComponent }), "decodeParameters" in lt && lt.decodeParameters !== void 0 && Yt.push({ key: "DecodeParms", value: "<<" + lt.decodeParameters + ">>" }), "transparency" in lt && Array.isArray(lt.transparency)) {
      for (var te = "", Ut = 0, se = lt.transparency.length; Ut < se; Ut++) te += lt.transparency[Ut] + " " + lt.transparency[Ut] + " ";
      Yt.push({ key: "Mask", value: "[" + te + "]" });
    }
    lt.sMask !== void 0 && Yt.push({ key: "SMask", value: lt.objectId + 1 + " 0 R" });
    var ee = lt.filter !== void 0 ? ["/" + lt.filter] : void 0;
    if (bt({ data: lt.data, additionalKeyValues: Yt, alreadyAppliedFilters: ee, objectId: lt.objectId }), Pt("endobj"), "sMask" in lt && lt.sMask !== void 0) {
      var be = "/Predictor " + lt.predictor + " /Colors 1 /BitsPerComponent " + lt.bitsPerComponent + " /Columns " + lt.width, Q = { width: lt.width, height: lt.height, colorSpace: "DeviceGray", bitsPerComponent: lt.bitsPerComponent, decodeParameters: be, data: lt.sMask };
      "filter" in lt && (Q.filter = lt.filter), at.call(this, Q);
    }
    if (lt.colorSpace === yt.INDEXED) {
      var pt = this.internal.newObject();
      bt({ data: Tt(new Uint8Array(lt.palette)), objectId: pt }), Pt("endobj");
    }
  }, A = function() {
    var at = this.internal.collections.addImage_images;
    for (var lt in at) P.call(this, at[lt]);
  }, v = function() {
    var at, lt = this.internal.collections.addImage_images, Pt = this.internal.write;
    for (var bt in lt) Pt("/I" + (at = lt[bt]).index, at.objectId, "0", "R");
  }, l = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", A), this.internal.events.subscribe("putXobjectDict", v));
  }, M = function() {
    var at = this.internal.collections.addImage_images;
    return l.call(this), at;
  }, B = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, $ = function(at) {
    return typeof b["process" + at.toUpperCase()] == "function";
  }, q = function(at) {
    return ir(at) === "object" && at.nodeType === 1;
  }, U = function(at, lt) {
    if (at.nodeName === "IMG" && at.hasAttribute("src")) {
      var Pt = "" + at.getAttribute("src");
      if (Pt.indexOf("data:image/") === 0) return lh(unescape(Pt).split("base64,").pop());
      var bt = b.loadFile(Pt, !0);
      if (bt !== void 0) return bt;
    }
    if (at.nodeName === "CANVAS") {
      if (at.width === 0 || at.height === 0) throw new Error("Given canvas must have data. Canvas width: " + at.width + ", height: " + at.height);
      var Jt;
      switch (lt) {
        case "PNG":
          Jt = "image/png";
          break;
        case "WEBP":
          Jt = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          Jt = "image/jpeg";
      }
      return lh(at.toDataURL(Jt, 1).split("base64,").pop());
    }
  }, F = function(at) {
    var lt = this.internal.collections.addImage_images;
    if (lt) {
      for (var Pt in lt) if (at === lt[Pt].alias) return lt[Pt];
    }
  }, mt = function(at, lt, Pt) {
    return at || lt || (at = -96, lt = -96), at < 0 && (at = -1 * Pt.width * 72 / at / this.internal.scaleFactor), lt < 0 && (lt = -1 * Pt.height * 72 / lt / this.internal.scaleFactor), at === 0 && (at = lt * Pt.width / Pt.height), lt === 0 && (lt = at * Pt.height / Pt.width), [at, lt];
  }, ot = function(at, lt, Pt, bt, Jt, Yt) {
    var te = mt.call(this, Pt, bt, Jt), Ut = this.internal.getCoordinateString, se = this.internal.getVerticalCoordinateString, ee = M.call(this);
    if (Pt = te[0], bt = te[1], ee[Jt.index] = Jt, Yt) {
      Yt *= Math.PI / 180;
      var be = Math.cos(Yt), Q = Math.sin(Yt), pt = function(Ct) {
        return Ct.toFixed(4);
      }, _t = [pt(be), pt(Q), pt(-1 * Q), pt(be), 0, 0, "cm"];
    }
    this.internal.write("q"), Yt ? (this.internal.write([1, "0", "0", 1, Ut(at), se(lt + bt), "cm"].join(" ")), this.internal.write(_t.join(" ")), this.internal.write([Ut(Pt), "0", "0", Ut(bt), "0", "0", "cm"].join(" "))) : this.internal.write([Ut(Pt), "0", "0", Ut(bt), Ut(at), se(lt + bt), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + Jt.index + " Do"), this.internal.write("Q");
  }, yt = b.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  b.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var st = b.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, gt = b.__addimage__.sHashCode = function(at) {
    var lt, Pt, bt = 0;
    if (typeof at == "string") for (Pt = at.length, lt = 0; lt < Pt; lt++) bt = (bt << 5) - bt + at.charCodeAt(lt), bt |= 0;
    else if (pe(at)) for (Pt = at.byteLength / 2, lt = 0; lt < Pt; lt++) bt = (bt << 5) - bt + at[lt], bt |= 0;
    return bt;
  }, Mt = b.__addimage__.validateStringAsBase64 = function(at) {
    (at = at || "").toString().trim();
    var lt = !0;
    return at.length === 0 && (lt = !1), at.length % 4 != 0 && (lt = !1), /^[A-Za-z0-9+/]+$/.test(at.substr(0, at.length - 2)) === !1 && (lt = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(at.substr(-2)) === !1 && (lt = !1), lt;
  }, Qt = b.__addimage__.extractImageFromDataUrl = function(at) {
    var lt = (at = at || "").split("base64,"), Pt = null;
    if (lt.length === 2) {
      var bt = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(lt[0]);
      Array.isArray(bt) && (Pt = { mimeType: bt[1], charset: bt[2], data: lt[1] });
    }
    return Pt;
  }, Ht = b.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  b.__addimage__.isArrayBuffer = function(at) {
    return Ht() && at instanceof ArrayBuffer;
  };
  var pe = b.__addimage__.isArrayBufferView = function(at) {
    return Ht() && typeof Uint32Array < "u" && (at instanceof Int8Array || at instanceof Uint8Array || typeof Uint8ClampedArray < "u" && at instanceof Uint8ClampedArray || at instanceof Int16Array || at instanceof Uint16Array || at instanceof Int32Array || at instanceof Uint32Array || at instanceof Float32Array || at instanceof Float64Array);
  }, jt = b.__addimage__.binaryStringToUint8Array = function(at) {
    for (var lt = at.length, Pt = new Uint8Array(lt), bt = 0; bt < lt; bt++) Pt[bt] = at.charCodeAt(bt);
    return Pt;
  }, Tt = b.__addimage__.arrayBufferToBinaryString = function(at) {
    for (var lt = "", Pt = pe(at) ? at : new Uint8Array(at), bt = 0; bt < Pt.length; bt += 8192) lt += String.fromCharCode.apply(null, Pt.subarray(bt, bt + 8192));
    return lt;
  };
  b.addImage = function() {
    var at, lt, Pt, bt, Jt, Yt, te, Ut, se;
    if (typeof arguments[1] == "number" ? (lt = g, Pt = arguments[1], bt = arguments[2], Jt = arguments[3], Yt = arguments[4], te = arguments[5], Ut = arguments[6], se = arguments[7]) : (lt = arguments[1], Pt = arguments[2], bt = arguments[3], Jt = arguments[4], Yt = arguments[5], te = arguments[6], Ut = arguments[7], se = arguments[8]), ir(at = arguments[0]) === "object" && !q(at) && "imageData" in at) {
      var ee = at;
      at = ee.imageData, lt = ee.format || lt || g, Pt = ee.x || Pt || 0, bt = ee.y || bt || 0, Jt = ee.w || ee.width || Jt, Yt = ee.h || ee.height || Yt, te = ee.alias || te, Ut = ee.compression || Ut, se = ee.rotation || ee.angle || se;
    }
    var be = this.internal.getFilters();
    if (Ut === void 0 && be.indexOf("FlateEncode") !== -1 && (Ut = "SLOW"), isNaN(Pt) || isNaN(bt)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    l.call(this);
    var Q = le.call(this, at, lt, te, Ut);
    return ot.call(this, Pt, bt, Jt, Yt, Q, se), this;
  };
  var le = function(at, lt, Pt, bt) {
    var Jt, Yt, te;
    if (typeof at == "string" && x(at) === g) {
      at = unescape(at);
      var Ut = ne(at, !1);
      (Ut !== "" || (Ut = b.loadFile(at, !0)) !== void 0) && (at = Ut);
    }
    if (q(at) && (at = U(at, lt)), lt = x(at, lt), !$(lt)) throw new Error("addImage does not support files of type '" + lt + "', please ensure that a plugin for '" + lt + "' support is added.");
    if (((te = Pt) == null || te.length === 0) && (Pt = function(se) {
      return typeof se == "string" || pe(se) ? gt(se) : pe(se.data) ? gt(se.data) : null;
    }(at)), (Jt = F.call(this, Pt)) || (Ht() && (at instanceof Uint8Array || lt === "RGBA" || (Yt = at, at = jt(at))), Jt = this["process" + lt.toUpperCase()](at, B.call(this), Pt, function(se) {
      return se && typeof se == "string" && (se = se.toUpperCase()), se in b.image_compression ? se : st.NONE;
    }(bt), Yt)), !Jt) throw new Error("An unknown error occurred whilst processing the image.");
    return Jt;
  }, ne = b.__addimage__.convertBase64ToBinaryString = function(at, lt) {
    var Pt;
    lt = typeof lt != "boolean" || lt;
    var bt, Jt = "";
    if (typeof at == "string") {
      bt = (Pt = Qt(at)) !== null ? Pt.data : at;
      try {
        Jt = lh(bt);
      } catch (Yt) {
        if (lt) throw Mt(bt) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + Yt.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return Jt;
  };
  b.getImageProperties = function(at) {
    var lt, Pt, bt = "";
    if (q(at) && (at = U(at)), typeof at == "string" && x(at) === g && ((bt = ne(at, !1)) === "" && (bt = b.loadFile(at) || ""), at = bt), Pt = x(at), !$(Pt)) throw new Error("addImage does not support files of type '" + Pt + "', please ensure that a plugin for '" + Pt + "' support is added.");
    if (!Ht() || at instanceof Uint8Array || (at = jt(at)), !(lt = this["process" + Pt.toUpperCase()](at))) throw new Error("An unknown error occurred whilst processing the image");
    return lt.fileType = Pt, lt;
  };
})(pi.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  var g = function(y) {
    if (y !== void 0 && y != "") return !0;
  };
  pi.API.events.push(["addPage", function(y) {
    this.internal.getPageInfo(y.pageNumber).pageContext.annotations = [];
  }]), b.events.push(["putPage", function(y) {
    for (var x, P, A, v = this.internal.getCoordinateString, l = this.internal.getVerticalCoordinateString, M = this.internal.getPageInfoByObjId(y.objId), B = y.pageContext.annotations, $ = !1, q = 0; q < B.length && !$; q++) switch ((x = B[q]).type) {
      case "link":
        (g(x.options.url) || g(x.options.pageNumber)) && ($ = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        $ = !0;
    }
    if ($ != 0) {
      this.internal.write("/Annots [");
      for (var U = 0; U < B.length; U++) {
        x = B[U];
        var F = this.internal.pdfEscape, mt = this.internal.getEncryptor(y.objId);
        switch (x.type) {
          case "reference":
            this.internal.write(" " + x.object.objId + " 0 R ");
            break;
          case "text":
            var ot = this.internal.newAdditionalObject(), yt = this.internal.newAdditionalObject(), st = this.internal.getEncryptor(ot.objId), gt = x.title || "Note";
            A = "<</Type /Annot /Subtype /Text " + (P = "/Rect [" + v(x.bounds.x) + " " + l(x.bounds.y + x.bounds.h) + " " + v(x.bounds.x + x.bounds.w) + " " + l(x.bounds.y) + "] ") + "/Contents (" + F(st(x.contents)) + ")", A += " /Popup " + yt.objId + " 0 R", A += " /P " + M.objId + " 0 R", A += " /T (" + F(st(gt)) + ") >>", ot.content = A;
            var Mt = ot.objId + " 0 R";
            A = "<</Type /Annot /Subtype /Popup " + (P = "/Rect [" + v(x.bounds.x + 30) + " " + l(x.bounds.y + x.bounds.h) + " " + v(x.bounds.x + x.bounds.w + 30) + " " + l(x.bounds.y) + "] ") + " /Parent " + Mt, x.open && (A += " /Open true"), A += " >>", yt.content = A, this.internal.write(ot.objId, "0 R", yt.objId, "0 R");
            break;
          case "freetext":
            P = "/Rect [" + v(x.bounds.x) + " " + l(x.bounds.y) + " " + v(x.bounds.x + x.bounds.w) + " " + l(x.bounds.y + x.bounds.h) + "] ";
            var Qt = x.color || "#000000";
            A = "<</Type /Annot /Subtype /FreeText " + P + "/Contents (" + F(mt(x.contents)) + ")", A += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + Qt + ")", A += " /Border [0 0 0]", A += " >>", this.internal.write(A);
            break;
          case "link":
            if (x.options.name) {
              var Ht = this.annotations._nameMap[x.options.name];
              x.options.pageNumber = Ht.page, x.options.top = Ht.y;
            } else x.options.top || (x.options.top = 0);
            if (P = "/Rect [" + x.finalBounds.x + " " + x.finalBounds.y + " " + x.finalBounds.w + " " + x.finalBounds.h + "] ", A = "", x.options.url) A = "<</Type /Annot /Subtype /Link " + P + "/Border [0 0 0] /A <</S /URI /URI (" + F(mt(x.options.url)) + ") >>";
            else if (x.options.pageNumber)
              switch (A = "<</Type /Annot /Subtype /Link " + P + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(x.options.pageNumber).objId + " 0 R", x.options.magFactor = x.options.magFactor || "XYZ", x.options.magFactor) {
                case "Fit":
                  A += " /Fit]";
                  break;
                case "FitH":
                  A += " /FitH " + x.options.top + "]";
                  break;
                case "FitV":
                  x.options.left = x.options.left || 0, A += " /FitV " + x.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var pe = l(x.options.top);
                  x.options.left = x.options.left || 0, x.options.zoom === void 0 && (x.options.zoom = 0), A += " /XYZ " + x.options.left + " " + pe + " " + x.options.zoom + "]";
              }
            A != "" && (A += " >>", this.internal.write(A));
        }
      }
      this.internal.write("]");
    }
  }]), b.createAnnotation = function(y) {
    var x = this.internal.getCurrentPageInfo();
    switch (y.type) {
      case "link":
        this.link(y.bounds.x, y.bounds.y, y.bounds.w, y.bounds.h, y);
        break;
      case "text":
      case "freetext":
        x.pageContext.annotations.push(y);
    }
  }, b.link = function(y, x, P, A, v) {
    var l = this.internal.getCurrentPageInfo(), M = this.internal.getCoordinateString, B = this.internal.getVerticalCoordinateString;
    l.pageContext.annotations.push({ finalBounds: { x: M(y), y: B(x), w: M(y + P), h: B(x + A) }, options: v, type: "link" });
  }, b.textWithLink = function(y, x, P, A) {
    var v, l, M = this.getTextWidth(y), B = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (A.maxWidth !== void 0) {
      l = A.maxWidth;
      var $ = this.splitTextToSize(y, l).length;
      v = Math.ceil(B * $);
    } else l = M, v = B;
    return this.text(y, x, P, A), P += 0.2 * B, A.align === "center" && (x -= M / 2), A.align === "right" && (x -= M), this.link(x, P - B, l, v, A), M;
  }, b.getTextWidth = function(y) {
    var x = this.internal.getFontSize();
    return this.getStringUnitWidth(y) * x / this.internal.scaleFactor;
  };
}(pi.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  var g = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, y = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, x = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, P = [1570, 1571, 1573, 1575];
  b.__arabicParser__ = {};
  var A = b.__arabicParser__.isInArabicSubstitutionA = function(ot) {
    return g[ot.charCodeAt(0)] !== void 0;
  }, v = b.__arabicParser__.isArabicLetter = function(ot) {
    return typeof ot == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(ot);
  }, l = b.__arabicParser__.isArabicEndLetter = function(ot) {
    return v(ot) && A(ot) && g[ot.charCodeAt(0)].length <= 2;
  }, M = b.__arabicParser__.isArabicAlfLetter = function(ot) {
    return v(ot) && P.indexOf(ot.charCodeAt(0)) >= 0;
  };
  b.__arabicParser__.arabicLetterHasIsolatedForm = function(ot) {
    return v(ot) && A(ot) && g[ot.charCodeAt(0)].length >= 1;
  };
  var B = b.__arabicParser__.arabicLetterHasFinalForm = function(ot) {
    return v(ot) && A(ot) && g[ot.charCodeAt(0)].length >= 2;
  };
  b.__arabicParser__.arabicLetterHasInitialForm = function(ot) {
    return v(ot) && A(ot) && g[ot.charCodeAt(0)].length >= 3;
  };
  var $ = b.__arabicParser__.arabicLetterHasMedialForm = function(ot) {
    return v(ot) && A(ot) && g[ot.charCodeAt(0)].length == 4;
  }, q = b.__arabicParser__.resolveLigatures = function(ot) {
    var yt = 0, st = y, gt = "", Mt = 0;
    for (yt = 0; yt < ot.length; yt += 1) st[ot.charCodeAt(yt)] !== void 0 ? (Mt++, typeof (st = st[ot.charCodeAt(yt)]) == "number" && (gt += String.fromCharCode(st), st = y, Mt = 0), yt === ot.length - 1 && (st = y, gt += ot.charAt(yt - (Mt - 1)), yt -= Mt - 1, Mt = 0)) : (st = y, gt += ot.charAt(yt - Mt), yt -= Mt, Mt = 0);
    return gt;
  };
  b.__arabicParser__.isArabicDiacritic = function(ot) {
    return ot !== void 0 && x[ot.charCodeAt(0)] !== void 0;
  };
  var U = b.__arabicParser__.getCorrectForm = function(ot, yt, st) {
    return v(ot) ? A(ot) === !1 ? -1 : !B(ot) || !v(yt) && !v(st) || !v(st) && l(yt) || l(ot) && !v(yt) || l(ot) && M(yt) || l(ot) && l(yt) ? 0 : $(ot) && v(yt) && !l(yt) && v(st) && B(st) ? 3 : l(ot) || !v(st) ? 1 : 2 : -1;
  }, F = function(ot) {
    var yt = 0, st = 0, gt = 0, Mt = "", Qt = "", Ht = "", pe = (ot = ot || "").split("\\s+"), jt = [];
    for (yt = 0; yt < pe.length; yt += 1) {
      for (jt.push(""), st = 0; st < pe[yt].length; st += 1) Mt = pe[yt][st], Qt = pe[yt][st - 1], Ht = pe[yt][st + 1], v(Mt) ? (gt = U(Mt, Qt, Ht), jt[yt] += gt !== -1 ? String.fromCharCode(g[Mt.charCodeAt(0)][gt]) : Mt) : jt[yt] += Mt;
      jt[yt] = q(jt[yt]);
    }
    return jt.join(" ");
  }, mt = b.__arabicParser__.processArabic = b.processArabic = function() {
    var ot, yt = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, st = [];
    if (Array.isArray(yt)) {
      var gt = 0;
      for (st = [], gt = 0; gt < yt.length; gt += 1) Array.isArray(yt[gt]) ? st.push([F(yt[gt][0]), yt[gt][1], yt[gt][2]]) : st.push([F(yt[gt])]);
      ot = st;
    } else ot = F(yt);
    return typeof arguments[0] == "string" ? ot : (arguments[0].text = ot, arguments[0]);
  };
  b.events.push(["preProcessText", mt]);
}(pi.API), pi.API.autoPrint = function(b) {
  var g;
  switch ((b = b || {}).variant = b.variant || "non-conform", b.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        g = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + g + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  var g = function() {
    var y = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return y;
    }, set: function(l) {
      y = l;
    } });
    var x = 150;
    Object.defineProperty(this, "width", { get: function() {
      return x;
    }, set: function(l) {
      x = isNaN(l) || Number.isInteger(l) === !1 || l < 0 ? 150 : l, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = x + 1);
    } });
    var P = 300;
    Object.defineProperty(this, "height", { get: function() {
      return P;
    }, set: function(l) {
      P = isNaN(l) || Number.isInteger(l) === !1 || l < 0 ? 300 : l, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = P + 1);
    } });
    var A = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return A;
    }, set: function(l) {
      A = l;
    } });
    var v = {};
    Object.defineProperty(this, "style", { get: function() {
      return v;
    }, set: function(l) {
      v = l;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  g.prototype.getContext = function(y, x) {
    var P;
    if ((y = y || "2d") !== "2d") return null;
    for (P in x) this.pdf.context2d.hasOwnProperty(P) && (this.pdf.context2d[P] = x[P]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, g.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, b.events.push(["initialized", function() {
    this.canvas = new g(), this.canvas.pdf = this;
  }]);
}(pi.API), function(b) {
  var g = { left: 0, top: 0, bottom: 0, right: 0 }, y = !1, x = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, g), this.internal.__cell__.margins.width = this.getPageWidth(), P.call(this));
  }, P = function() {
    this.internal.__cell__.lastCell = new A(), this.internal.__cell__.pages = 1;
  }, A = function() {
    var M = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return M;
    }, set: function(ot) {
      M = ot;
    } });
    var B = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return B;
    }, set: function(ot) {
      B = ot;
    } });
    var $ = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return $;
    }, set: function(ot) {
      $ = ot;
    } });
    var q = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return q;
    }, set: function(ot) {
      q = ot;
    } });
    var U = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return U;
    }, set: function(ot) {
      U = ot;
    } });
    var F = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return F;
    }, set: function(ot) {
      F = ot;
    } });
    var mt = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return mt;
    }, set: function(ot) {
      mt = ot;
    } }), this;
  };
  A.prototype.clone = function() {
    return new A(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, A.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, b.setHeaderFunction = function(M) {
    return x.call(this), this.internal.__cell__.headerFunction = typeof M == "function" ? M : void 0, this;
  }, b.getTextDimensions = function(M, B) {
    x.call(this);
    var $ = (B = B || {}).fontSize || this.getFontSize(), q = B.font || this.getFont(), U = B.scaleFactor || this.internal.scaleFactor, F = 0, mt = 0, ot = 0, yt = this;
    if (!Array.isArray(M) && typeof M != "string") {
      if (typeof M != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      M = String(M);
    }
    var st = B.maxWidth;
    st > 0 ? typeof M == "string" ? M = this.splitTextToSize(M, st) : Object.prototype.toString.call(M) === "[object Array]" && (M = M.reduce(function(Mt, Qt) {
      return Mt.concat(yt.splitTextToSize(Qt, st));
    }, [])) : M = Array.isArray(M) ? M : [M];
    for (var gt = 0; gt < M.length; gt++) F < (ot = this.getStringUnitWidth(M[gt], { font: q }) * $) && (F = ot);
    return F !== 0 && (mt = M.length), { w: F /= U, h: Math.max((mt * $ * this.getLineHeightFactor() - $ * (this.getLineHeightFactor() - 1)) / U, 0) };
  }, b.cellAddPage = function() {
    x.call(this), this.addPage();
    var M = this.internal.__cell__.margins || g;
    return this.internal.__cell__.lastCell = new A(M.left, M.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var v = b.cell = function() {
    var M;
    M = arguments[0] instanceof A ? arguments[0] : new A(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), x.call(this);
    var B = this.internal.__cell__.lastCell, $ = this.internal.__cell__.padding, q = this.internal.__cell__.margins || g, U = this.internal.__cell__.tableHeaderRow, F = this.internal.__cell__.printHeaders;
    return B.lineNumber !== void 0 && (B.lineNumber === M.lineNumber ? (M.x = (B.x || 0) + (B.width || 0), M.y = B.y || 0) : B.y + B.height + M.height + q.bottom > this.getPageHeight() ? (this.cellAddPage(), M.y = q.top, F && U && (this.printHeaderRow(M.lineNumber, !0), M.y += U[0].height)) : M.y = B.y + B.height || M.y), M.text[0] !== void 0 && (this.rect(M.x, M.y, M.width, M.height, y === !0 ? "FD" : void 0), M.align === "right" ? this.text(M.text, M.x + M.width - $, M.y + $, { align: "right", baseline: "top" }) : M.align === "center" ? this.text(M.text, M.x + M.width / 2, M.y + $, { align: "center", baseline: "top", maxWidth: M.width - $ - $ }) : this.text(M.text, M.x + $, M.y + $, { align: "left", baseline: "top", maxWidth: M.width - $ - $ })), this.internal.__cell__.lastCell = M, this;
  };
  b.table = function(M, B, $, q, U) {
    if (x.call(this), !$) throw new Error("No data for PDF table.");
    var F, mt, ot, yt, st = [], gt = [], Mt = [], Qt = {}, Ht = {}, pe = [], jt = [], Tt = (U = U || {}).autoSize || !1, le = U.printHeaders !== !1, ne = U.css && U.css["font-size"] !== void 0 ? 16 * U.css["font-size"] : U.fontSize || 12, at = U.margins || Object.assign({ width: this.getPageWidth() }, g), lt = typeof U.padding == "number" ? U.padding : 3, Pt = U.headerBackgroundColor || "#c8c8c8", bt = U.headerTextColor || "#000";
    if (P.call(this), this.internal.__cell__.printHeaders = le, this.internal.__cell__.margins = at, this.internal.__cell__.table_font_size = ne, this.internal.__cell__.padding = lt, this.internal.__cell__.headerBackgroundColor = Pt, this.internal.__cell__.headerTextColor = bt, this.setFontSize(ne), q == null) gt = st = Object.keys($[0]), Mt = st.map(function() {
      return "left";
    });
    else if (Array.isArray(q) && ir(q[0]) === "object") for (st = q.map(function(ee) {
      return ee.name;
    }), gt = q.map(function(ee) {
      return ee.prompt || ee.name || "";
    }), Mt = q.map(function(ee) {
      return ee.align || "left";
    }), F = 0; F < q.length; F += 1) Ht[q[F].name] = q[F].width * (19.049976 / 25.4);
    else Array.isArray(q) && typeof q[0] == "string" && (gt = st = q, Mt = st.map(function() {
      return "left";
    }));
    if (Tt || Array.isArray(q) && typeof q[0] == "string") for (F = 0; F < st.length; F += 1) {
      for (Qt[yt = st[F]] = $.map(function(ee) {
        return ee[yt];
      }), this.setFont(void 0, "bold"), pe.push(this.getTextDimensions(gt[F], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), mt = Qt[yt], this.setFont(void 0, "normal"), ot = 0; ot < mt.length; ot += 1) pe.push(this.getTextDimensions(mt[ot], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      Ht[yt] = Math.max.apply(null, pe) + lt + lt, pe = [];
    }
    if (le) {
      var Jt = {};
      for (F = 0; F < st.length; F += 1) Jt[st[F]] = {}, Jt[st[F]].text = gt[F], Jt[st[F]].align = Mt[F];
      var Yt = l.call(this, Jt, Ht);
      jt = st.map(function(ee) {
        return new A(M, B, Ht[ee], Yt, Jt[ee].text, void 0, Jt[ee].align);
      }), this.setTableHeaderRow(jt), this.printHeaderRow(1, !1);
    }
    var te = q.reduce(function(ee, be) {
      return ee[be.name] = be.align, ee;
    }, {});
    for (F = 0; F < $.length; F += 1) {
      "rowStart" in U && U.rowStart instanceof Function && U.rowStart({ row: F, data: $[F] }, this);
      var Ut = l.call(this, $[F], Ht);
      for (ot = 0; ot < st.length; ot += 1) {
        var se = $[F][st[ot]];
        "cellStart" in U && U.cellStart instanceof Function && U.cellStart({ row: F, col: ot, data: se }, this), v.call(this, new A(M, B, Ht[st[ot]], Ut, se, F + 2, te[st[ot]]));
      }
    }
    return this.internal.__cell__.table_x = M, this.internal.__cell__.table_y = B, this;
  };
  var l = function(M, B) {
    var $ = this.internal.__cell__.padding, q = this.internal.__cell__.table_font_size, U = this.internal.scaleFactor;
    return Object.keys(M).map(function(F) {
      var mt = M[F];
      return this.splitTextToSize(mt.hasOwnProperty("text") ? mt.text : mt, B[F] - $ - $);
    }, this).map(function(F) {
      return this.getLineHeightFactor() * F.length * q / U + $ + $;
    }, this).reduce(function(F, mt) {
      return Math.max(F, mt);
    }, 0);
  };
  b.setTableHeaderRow = function(M) {
    x.call(this), this.internal.__cell__.tableHeaderRow = M;
  }, b.printHeaderRow = function(M, B) {
    if (x.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var $;
    if (y = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var q = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new A(q[0], q[1], q[2], q[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var U = [], F = 0; F < this.internal.__cell__.tableHeaderRow.length; F += 1) {
      $ = this.internal.__cell__.tableHeaderRow[F].clone(), B && ($.y = this.internal.__cell__.margins.top || 0, U.push($)), $.lineNumber = M;
      var mt = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), v.call(this, $), this.setTextColor(mt);
    }
    U.length > 0 && this.setTableHeaderRow(U), this.setFont(void 0, "normal"), y = !1;
  };
}(pi.API);
var df = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, pf = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Yu = uf(pf), ff = [100, 200, 300, 400, 500, 600, 700, 800, 900], i0 = uf(ff);
function Ju(b) {
  var g = b.family.replace(/"|'/g, "").toLowerCase(), y = function(A) {
    return df[A = A || "normal"] ? A : "normal";
  }(b.style), x = function(A) {
    if (!A) return 400;
    if (typeof A == "number") return A >= 100 && A <= 900 && A % 100 == 0 ? A : 400;
    if (/^\d00$/.test(A)) return parseInt(A);
    switch (A) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(b.weight), P = function(A) {
    return typeof Yu[A = A || "normal"] == "number" ? A : "normal";
  }(b.stretch);
  return { family: g, style: y, weight: x, stretch: P, src: b.src || [], ref: b.ref || { name: g, style: [P, y, x].join(" ") } };
}
function Rp(b, g, y, x) {
  var P;
  for (P = y; P >= 0 && P < g.length; P += x) if (b[g[P]]) return b[g[P]];
  for (P = y; P >= 0 && P < g.length; P -= x) if (b[g[P]]) return b[g[P]];
}
var r0 = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Bp = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Op(b) {
  return [b.stretch, b.style, b.weight, b.family].join(" ");
}
function n0(b, g, y) {
  for (var x = (y = y || {}).defaultFontFamily || "times", P = Object.assign({}, r0, y.genericFontFamilies || {}), A = null, v = null, l = 0; l < g.length; ++l) if (P[(A = Ju(g[l])).family] && (A.family = P[A.family]), b.hasOwnProperty(A.family)) {
    v = b[A.family];
    break;
  }
  if (!(v = v || b[x])) throw new Error("Could not find a font-family for the rule '" + Op(A) + "' and default family '" + x + "'.");
  if (v = function(M, B) {
    if (B[M]) return B[M];
    var $ = Yu[M], q = $ <= Yu.normal ? -1 : 1, U = Rp(B, pf, $, q);
    if (!U) throw new Error("Could not find a matching font-stretch value for " + M);
    return U;
  }(A.stretch, v), v = function(M, B) {
    if (B[M]) return B[M];
    for (var $ = df[M], q = 0; q < $.length; ++q) if (B[$[q]]) return B[$[q]];
    throw new Error("Could not find a matching font-style for " + M);
  }(A.style, v), !(v = function(M, B) {
    if (B[M]) return B[M];
    if (M === 400 && B[500]) return B[500];
    if (M === 500 && B[400]) return B[400];
    var $ = i0[M], q = Rp(B, ff, $, M < 400 ? -1 : 1);
    if (!q) throw new Error("Could not find a matching font-weight for value " + M);
    return q;
  }(A.weight, v))) throw new Error("Failed to resolve a font for the rule '" + Op(A) + "'.");
  return v;
}
function jp(b) {
  return b.trimLeft();
}
function s0(b, g) {
  for (var y = 0; y < b.length; ) {
    if (b.charAt(y) === g) return [b.substring(0, y), b.substring(y + 1)];
    y += 1;
  }
  return null;
}
function a0(b) {
  var g = b.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return g === null ? null : [g[0], b.substring(g[0].length)];
}
var Fh, qp, Up, Vp = ["times"];
(function(b) {
  var g, y, x, P, A, v, l, M, B, $ = function(Q) {
    return Q = Q || {}, this.isStrokeTransparent = Q.isStrokeTransparent || !1, this.strokeOpacity = Q.strokeOpacity || 1, this.strokeStyle = Q.strokeStyle || "#000000", this.fillStyle = Q.fillStyle || "#000000", this.isFillTransparent = Q.isFillTransparent || !1, this.fillOpacity = Q.fillOpacity || 1, this.font = Q.font || "10px sans-serif", this.textBaseline = Q.textBaseline || "alphabetic", this.textAlign = Q.textAlign || "left", this.lineWidth = Q.lineWidth || 1, this.lineJoin = Q.lineJoin || "miter", this.lineCap = Q.lineCap || "butt", this.path = Q.path || [], this.transform = Q.transform !== void 0 ? Q.transform.clone() : new M(), this.globalCompositeOperation = Q.globalCompositeOperation || "normal", this.globalAlpha = Q.globalAlpha || 1, this.clip_path = Q.clip_path || [], this.currentPoint = Q.currentPoint || new v(), this.miterLimit = Q.miterLimit || 10, this.lastPoint = Q.lastPoint || new v(), this.lineDashOffset = Q.lineDashOffset || 0, this.lineDash = Q.lineDash || [], this.margin = Q.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = Q.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof Q.ignoreClearRect != "boolean" || Q.ignoreClearRect, this;
  };
  b.events.push(["initialized", function() {
    this.context2d = new q(this), g = this.internal.f2, y = this.internal.getCoordinateString, x = this.internal.getVerticalCoordinateString, P = this.internal.getHorizontalCoordinate, A = this.internal.getVerticalCoordinate, v = this.internal.Point, l = this.internal.Rectangle, M = this.internal.Matrix, B = new $();
  }]);
  var q = function(Q) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var pt = Q;
    Object.defineProperty(this, "pdf", { get: function() {
      return pt;
    } });
    var _t = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return _t;
    }, set: function(ie) {
      _t = !!ie;
    } });
    var Ct = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Ct;
    }, set: function(ie) {
      Ct = !!ie;
    } });
    var Dt = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return Dt;
    }, set: function(ie) {
      isNaN(ie) || (Dt = ie);
    } });
    var Ot = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return Ot;
    }, set: function(ie) {
      isNaN(ie) || (Ot = ie);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return B.margin;
    }, set: function(ie) {
      var K;
      typeof ie == "number" ? K = [ie, ie, ie, ie] : ((K = new Array(4))[0] = ie[0], K[1] = ie.length >= 2 ? ie[1] : K[0], K[2] = ie.length >= 3 ? ie[2] : K[0], K[3] = ie.length >= 4 ? ie[3] : K[1]), B.margin = K;
    } });
    var Vt = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return Vt;
    }, set: function(ie) {
      Vt = ie;
    } });
    var Wt = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return Wt;
    }, set: function(ie) {
      Wt = ie;
    } });
    var xe = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return xe;
    }, set: function(ie) {
      xe = ie;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return B;
    }, set: function(ie) {
      ie instanceof $ && (B = ie);
    } }), Object.defineProperty(this, "path", { get: function() {
      return B.path;
    }, set: function(ie) {
      B.path = ie;
    } });
    var ve = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return ve;
    }, set: function(ie) {
      ve = ie;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(ie) {
      var K;
      K = U(ie), this.ctx.fillStyle = K.style, this.ctx.isFillTransparent = K.a === 0, this.ctx.fillOpacity = K.a, this.pdf.setFillColor(K.r, K.g, K.b, { a: K.a }), this.pdf.setTextColor(K.r, K.g, K.b, { a: K.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(ie) {
      var K = U(ie);
      this.ctx.strokeStyle = K.style, this.ctx.isStrokeTransparent = K.a === 0, this.ctx.strokeOpacity = K.a, K.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (K.a, this.pdf.setDrawColor(K.r, K.g, K.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(ie) {
      ["butt", "round", "square"].indexOf(ie) !== -1 && (this.ctx.lineCap = ie, this.pdf.setLineCap(ie));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(ie) {
      isNaN(ie) || (this.ctx.lineWidth = ie, this.pdf.setLineWidth(ie));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(ie) {
      ["bevel", "round", "miter"].indexOf(ie) !== -1 && (this.ctx.lineJoin = ie, this.pdf.setLineJoin(ie));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(ie) {
      isNaN(ie) || (this.ctx.miterLimit = ie, this.pdf.setMiterLimit(ie));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(ie) {
      this.ctx.textBaseline = ie;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(ie) {
      ["right", "end", "center", "left", "start"].indexOf(ie) !== -1 && (this.ctx.textAlign = ie);
    } });
    var ke = null;
    function ze(ie, K) {
      if (ke === null) {
        var ci = function(Ue) {
          var oe = [];
          return Object.keys(Ue).forEach(function(ye) {
            Ue[ye].forEach(function(De) {
              var Ae = null;
              switch (De) {
                case "bold":
                  Ae = { family: ye, weight: "bold" };
                  break;
                case "italic":
                  Ae = { family: ye, style: "italic" };
                  break;
                case "bolditalic":
                  Ae = { family: ye, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  Ae = { family: ye };
              }
              Ae !== null && (Ae.ref = { name: ye, style: De }, oe.push(Ae));
            });
          }), oe;
        }(ie.getFontList());
        ke = function(Ue) {
          for (var oe = {}, ye = 0; ye < Ue.length; ++ye) {
            var De = Ju(Ue[ye]), Ae = De.family, $e = De.stretch, hi = De.style, si = De.weight;
            oe[Ae] = oe[Ae] || {}, oe[Ae][$e] = oe[Ae][$e] || {}, oe[Ae][$e][hi] = oe[Ae][$e][hi] || {}, oe[Ae][$e][hi][si] = De;
          }
          return oe;
        }(ci.concat(K));
      }
      return ke;
    }
    var Je = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return Je;
    }, set: function(ie) {
      ke = null, Je = ie;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(ie) {
      var K;
      if (this.ctx.font = ie, (K = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(ie)) !== null) {
        var ci = K[1], Ue = (K[2], K[3]), oe = K[4], ye = (K[5], K[6]), De = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(oe)[2];
        oe = Math.floor(De === "px" ? parseFloat(oe) * this.pdf.internal.scaleFactor : De === "em" ? parseFloat(oe) * this.pdf.getFontSize() : parseFloat(oe) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(oe);
        var Ae = function(Ke) {
          var ai, Pe, lr = [], ue = Ke.trim();
          if (ue === "") return Vp;
          if (ue in Bp) return [Bp[ue]];
          for (; ue !== ""; ) {
            switch (Pe = null, ai = (ue = jp(ue)).charAt(0)) {
              case '"':
              case "'":
                Pe = s0(ue.substring(1), ai);
                break;
              default:
                Pe = a0(ue);
            }
            if (Pe === null || (lr.push(Pe[0]), (ue = jp(Pe[1])) !== "" && ue.charAt(0) !== ",")) return Vp;
            ue = ue.replace(/^,/, "");
          }
          return lr;
        }(ye);
        if (this.fontFaces) {
          var $e = n0(ze(this.pdf, this.fontFaces), Ae.map(function(Ke) {
            return { family: Ke, stretch: "normal", weight: Ue, style: ci };
          }));
          this.pdf.setFont($e.ref.name, $e.ref.style);
        } else {
          var hi = "";
          (Ue === "bold" || parseInt(Ue, 10) >= 700 || ci === "bold") && (hi = "bold"), ci === "italic" && (hi += "italic"), hi.length === 0 && (hi = "normal");
          for (var si = "", _i = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, Ii = 0; Ii < Ae.length; Ii++) {
            if (this.pdf.internal.getFont(Ae[Ii], hi, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              si = Ae[Ii];
              break;
            }
            if (hi === "bolditalic" && this.pdf.internal.getFont(Ae[Ii], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) si = Ae[Ii], hi = "bold";
            else if (this.pdf.internal.getFont(Ae[Ii], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              si = Ae[Ii], hi = "normal";
              break;
            }
          }
          if (si === "") {
            for (var he = 0; he < Ae.length; he++) if (_i[Ae[he]]) {
              si = _i[Ae[he]];
              break;
            }
          }
          si = si === "" ? "Times" : si, this.pdf.setFont(si, hi);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(ie) {
      this.ctx.globalCompositeOperation = ie;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(ie) {
      this.ctx.globalAlpha = ie;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(ie) {
      this.ctx.lineDashOffset = ie, be.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(ie) {
      this.ctx.lineDash = ie, be.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(ie) {
      this.ctx.ignoreClearRect = !!ie;
    } });
  };
  q.prototype.setLineDash = function(Q) {
    this.lineDash = Q;
  }, q.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, q.prototype.fill = function() {
    Qt.call(this, "fill", !1);
  }, q.prototype.stroke = function() {
    Qt.call(this, "stroke", !1);
  }, q.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, q.prototype.moveTo = function(Q, pt) {
    if (isNaN(Q) || isNaN(pt)) throw ur.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var _t = this.ctx.transform.applyToPoint(new v(Q, pt));
    this.path.push({ type: "mt", x: _t.x, y: _t.y }), this.ctx.lastPoint = new v(Q, pt);
  }, q.prototype.closePath = function() {
    var Q = new v(0, 0), pt = 0;
    for (pt = this.path.length - 1; pt !== -1; pt--) if (this.path[pt].type === "begin" && ir(this.path[pt + 1]) === "object" && typeof this.path[pt + 1].x == "number") {
      Q = new v(this.path[pt + 1].x, this.path[pt + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new v(Q.x, Q.y);
  }, q.prototype.lineTo = function(Q, pt) {
    if (isNaN(Q) || isNaN(pt)) throw ur.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var _t = this.ctx.transform.applyToPoint(new v(Q, pt));
    this.path.push({ type: "lt", x: _t.x, y: _t.y }), this.ctx.lastPoint = new v(_t.x, _t.y);
  }, q.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), Qt.call(this, null, !0);
  }, q.prototype.quadraticCurveTo = function(Q, pt, _t, Ct) {
    if (isNaN(_t) || isNaN(Ct) || isNaN(Q) || isNaN(pt)) throw ur.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var Dt = this.ctx.transform.applyToPoint(new v(_t, Ct)), Ot = this.ctx.transform.applyToPoint(new v(Q, pt));
    this.path.push({ type: "qct", x1: Ot.x, y1: Ot.y, x: Dt.x, y: Dt.y }), this.ctx.lastPoint = new v(Dt.x, Dt.y);
  }, q.prototype.bezierCurveTo = function(Q, pt, _t, Ct, Dt, Ot) {
    if (isNaN(Dt) || isNaN(Ot) || isNaN(Q) || isNaN(pt) || isNaN(_t) || isNaN(Ct)) throw ur.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var Vt = this.ctx.transform.applyToPoint(new v(Dt, Ot)), Wt = this.ctx.transform.applyToPoint(new v(Q, pt)), xe = this.ctx.transform.applyToPoint(new v(_t, Ct));
    this.path.push({ type: "bct", x1: Wt.x, y1: Wt.y, x2: xe.x, y2: xe.y, x: Vt.x, y: Vt.y }), this.ctx.lastPoint = new v(Vt.x, Vt.y);
  }, q.prototype.arc = function(Q, pt, _t, Ct, Dt, Ot) {
    if (isNaN(Q) || isNaN(pt) || isNaN(_t) || isNaN(Ct) || isNaN(Dt)) throw ur.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (Ot = !!Ot, !this.ctx.transform.isIdentity) {
      var Vt = this.ctx.transform.applyToPoint(new v(Q, pt));
      Q = Vt.x, pt = Vt.y;
      var Wt = this.ctx.transform.applyToPoint(new v(0, _t)), xe = this.ctx.transform.applyToPoint(new v(0, 0));
      _t = Math.sqrt(Math.pow(Wt.x - xe.x, 2) + Math.pow(Wt.y - xe.y, 2));
    }
    Math.abs(Dt - Ct) >= 2 * Math.PI && (Ct = 0, Dt = 2 * Math.PI), this.path.push({ type: "arc", x: Q, y: pt, radius: _t, startAngle: Ct, endAngle: Dt, counterclockwise: Ot });
  }, q.prototype.arcTo = function(Q, pt, _t, Ct, Dt) {
    throw new Error("arcTo not implemented.");
  }, q.prototype.rect = function(Q, pt, _t, Ct) {
    if (isNaN(Q) || isNaN(pt) || isNaN(_t) || isNaN(Ct)) throw ur.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(Q, pt), this.lineTo(Q + _t, pt), this.lineTo(Q + _t, pt + Ct), this.lineTo(Q, pt + Ct), this.lineTo(Q, pt), this.lineTo(Q + _t, pt), this.lineTo(Q, pt);
  }, q.prototype.fillRect = function(Q, pt, _t, Ct) {
    if (isNaN(Q) || isNaN(pt) || isNaN(_t) || isNaN(Ct)) throw ur.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!F.call(this)) {
      var Dt = {};
      this.lineCap !== "butt" && (Dt.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (Dt.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(Q, pt, _t, Ct), this.fill(), Dt.hasOwnProperty("lineCap") && (this.lineCap = Dt.lineCap), Dt.hasOwnProperty("lineJoin") && (this.lineJoin = Dt.lineJoin);
    }
  }, q.prototype.strokeRect = function(Q, pt, _t, Ct) {
    if (isNaN(Q) || isNaN(pt) || isNaN(_t) || isNaN(Ct)) throw ur.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    mt.call(this) || (this.beginPath(), this.rect(Q, pt, _t, Ct), this.stroke());
  }, q.prototype.clearRect = function(Q, pt, _t, Ct) {
    if (isNaN(Q) || isNaN(pt) || isNaN(_t) || isNaN(Ct)) throw ur.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(Q, pt, _t, Ct));
  }, q.prototype.save = function(Q) {
    Q = typeof Q != "boolean" || Q;
    for (var pt = this.pdf.internal.getCurrentPageInfo().pageNumber, _t = 0; _t < this.pdf.internal.getNumberOfPages(); _t++) this.pdf.setPage(_t + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(pt), Q) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Ct = new $(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Ct;
    }
  }, q.prototype.restore = function(Q) {
    Q = typeof Q != "boolean" || Q;
    for (var pt = this.pdf.internal.getCurrentPageInfo().pageNumber, _t = 0; _t < this.pdf.internal.getNumberOfPages(); _t++) this.pdf.setPage(_t + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(pt), Q && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, q.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var U = function(Q) {
    var pt, _t, Ct, Dt;
    if (Q.isCanvasGradient === !0 && (Q = Q.getColor()), !Q) return { r: 0, g: 0, b: 0, a: 0, style: Q };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(Q)) pt = 0, _t = 0, Ct = 0, Dt = 0;
    else {
      var Ot = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(Q);
      if (Ot !== null) pt = parseInt(Ot[1]), _t = parseInt(Ot[2]), Ct = parseInt(Ot[3]), Dt = 1;
      else if ((Ot = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(Q)) !== null) pt = parseInt(Ot[1]), _t = parseInt(Ot[2]), Ct = parseInt(Ot[3]), Dt = parseFloat(Ot[4]);
      else {
        if (Dt = 1, typeof Q == "string" && Q.charAt(0) !== "#") {
          var Vt = new sf(Q);
          Q = Vt.ok ? Vt.toHex() : "#000000";
        }
        Q.length === 4 ? (pt = Q.substring(1, 2), pt += pt, _t = Q.substring(2, 3), _t += _t, Ct = Q.substring(3, 4), Ct += Ct) : (pt = Q.substring(1, 3), _t = Q.substring(3, 5), Ct = Q.substring(5, 7)), pt = parseInt(pt, 16), _t = parseInt(_t, 16), Ct = parseInt(Ct, 16);
      }
    }
    return { r: pt, g: _t, b: Ct, a: Dt, style: Q };
  }, F = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, mt = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  q.prototype.fillText = function(Q, pt, _t, Ct) {
    if (isNaN(pt) || isNaN(_t) || typeof Q != "string") throw ur.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Ct = isNaN(Ct) ? void 0 : Ct, !F.call(this)) {
      var Dt = Ut(this.ctx.transform.rotation), Ot = this.ctx.transform.scaleX;
      lt.call(this, { text: Q, x: pt, y: _t, scale: Ot, angle: Dt, align: this.textAlign, maxWidth: Ct });
    }
  }, q.prototype.strokeText = function(Q, pt, _t, Ct) {
    if (isNaN(pt) || isNaN(_t) || typeof Q != "string") throw ur.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!mt.call(this)) {
      Ct = isNaN(Ct) ? void 0 : Ct;
      var Dt = Ut(this.ctx.transform.rotation), Ot = this.ctx.transform.scaleX;
      lt.call(this, { text: Q, x: pt, y: _t, scale: Ot, renderingMode: "stroke", angle: Dt, align: this.textAlign, maxWidth: Ct });
    }
  }, q.prototype.measureText = function(Q) {
    if (typeof Q != "string") throw ur.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var pt = this.pdf, _t = this.pdf.internal.scaleFactor, Ct = pt.internal.getFontSize(), Dt = pt.getStringUnitWidth(Q) * Ct / pt.internal.scaleFactor, Ot = function(Vt) {
      var Wt = (Vt = Vt || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return Wt;
      } }), this;
    };
    return new Ot({ width: Dt *= Math.round(96 * _t / 72 * 1e4) / 1e4 });
  }, q.prototype.scale = function(Q, pt) {
    if (isNaN(Q) || isNaN(pt)) throw ur.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var _t = new M(Q, 0, 0, pt, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(_t);
  }, q.prototype.rotate = function(Q) {
    if (isNaN(Q)) throw ur.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var pt = new M(Math.cos(Q), Math.sin(Q), -Math.sin(Q), Math.cos(Q), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(pt);
  }, q.prototype.translate = function(Q, pt) {
    if (isNaN(Q) || isNaN(pt)) throw ur.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var _t = new M(1, 0, 0, 1, Q, pt);
    this.ctx.transform = this.ctx.transform.multiply(_t);
  }, q.prototype.transform = function(Q, pt, _t, Ct, Dt, Ot) {
    if (isNaN(Q) || isNaN(pt) || isNaN(_t) || isNaN(Ct) || isNaN(Dt) || isNaN(Ot)) throw ur.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var Vt = new M(Q, pt, _t, Ct, Dt, Ot);
    this.ctx.transform = this.ctx.transform.multiply(Vt);
  }, q.prototype.setTransform = function(Q, pt, _t, Ct, Dt, Ot) {
    Q = isNaN(Q) ? 1 : Q, pt = isNaN(pt) ? 0 : pt, _t = isNaN(_t) ? 0 : _t, Ct = isNaN(Ct) ? 1 : Ct, Dt = isNaN(Dt) ? 0 : Dt, Ot = isNaN(Ot) ? 0 : Ot, this.ctx.transform = new M(Q, pt, _t, Ct, Dt, Ot);
  };
  var ot = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  q.prototype.drawImage = function(Q, pt, _t, Ct, Dt, Ot, Vt, Wt, xe) {
    var ve = this.pdf.getImageProperties(Q), ke = 1, ze = 1, Je = 1, ie = 1;
    Ct !== void 0 && Wt !== void 0 && (Je = Wt / Ct, ie = xe / Dt, ke = ve.width / Ct * Wt / Ct, ze = ve.height / Dt * xe / Dt), Ot === void 0 && (Ot = pt, Vt = _t, pt = 0, _t = 0), Ct !== void 0 && Wt === void 0 && (Wt = Ct, xe = Dt), Ct === void 0 && Wt === void 0 && (Wt = ve.width, xe = ve.height);
    for (var K, ci = this.ctx.transform.decompose(), Ue = Ut(ci.rotate.shx), oe = new M(), ye = (oe = (oe = (oe = oe.multiply(ci.translate)).multiply(ci.skew)).multiply(ci.scale)).applyToRectangle(new l(Ot - pt * Je, Vt - _t * ie, Ct * ke, Dt * ze)), De = yt.call(this, ye), Ae = [], $e = 0; $e < De.length; $e += 1) Ae.indexOf(De[$e]) === -1 && Ae.push(De[$e]);
    if (Mt(Ae), this.autoPaging) for (var hi = Ae[0], si = Ae[Ae.length - 1], _i = hi; _i < si + 1; _i++) {
      this.pdf.setPage(_i);
      var Ii = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], he = _i === 1 ? this.posY + this.margin[0] : this.margin[0], Ke = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], ai = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Pe = _i === 1 ? 0 : Ke + (_i - 2) * ai;
      if (this.ctx.clip_path.length !== 0) {
        var lr = this.path;
        K = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = gt(K, this.posX + this.margin[3], -Pe + he + this.ctx.prevPageLastElemOffset), Ht.call(this, "fill", !0), this.path = lr;
      }
      var ue = JSON.parse(JSON.stringify(ye));
      ue = gt([ue], this.posX + this.margin[3], -Pe + he + this.ctx.prevPageLastElemOffset)[0];
      var ni = (_i > hi || _i < si) && ot.call(this);
      ni && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ii, ai, null).clip().discardPath()), this.pdf.addImage(Q, "JPEG", ue.x, ue.y, ue.w, ue.h, null, null, Ue), ni && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(Q, "JPEG", ye.x, ye.y, ye.w, ye.h, null, null, Ue);
  };
  var yt = function(Q, pt, _t) {
    var Ct = [];
    pt = pt || this.pdf.internal.pageSize.width, _t = _t || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var Dt = this.posY + this.ctx.prevPageLastElemOffset;
    switch (Q.type) {
      default:
      case "mt":
      case "lt":
        Ct.push(Math.floor((Q.y + Dt) / _t) + 1);
        break;
      case "arc":
        Ct.push(Math.floor((Q.y + Dt - Q.radius) / _t) + 1), Ct.push(Math.floor((Q.y + Dt + Q.radius) / _t) + 1);
        break;
      case "qct":
        var Ot = se(this.ctx.lastPoint.x, this.ctx.lastPoint.y, Q.x1, Q.y1, Q.x, Q.y);
        Ct.push(Math.floor((Ot.y + Dt) / _t) + 1), Ct.push(Math.floor((Ot.y + Ot.h + Dt) / _t) + 1);
        break;
      case "bct":
        var Vt = ee(this.ctx.lastPoint.x, this.ctx.lastPoint.y, Q.x1, Q.y1, Q.x2, Q.y2, Q.x, Q.y);
        Ct.push(Math.floor((Vt.y + Dt) / _t) + 1), Ct.push(Math.floor((Vt.y + Vt.h + Dt) / _t) + 1);
        break;
      case "rect":
        Ct.push(Math.floor((Q.y + Dt) / _t) + 1), Ct.push(Math.floor((Q.y + Q.h + Dt) / _t) + 1);
    }
    for (var Wt = 0; Wt < Ct.length; Wt += 1) for (; this.pdf.internal.getNumberOfPages() < Ct[Wt]; ) st.call(this);
    return Ct;
  }, st = function() {
    var Q = this.fillStyle, pt = this.strokeStyle, _t = this.font, Ct = this.lineCap, Dt = this.lineWidth, Ot = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = Q, this.strokeStyle = pt, this.font = _t, this.lineCap = Ct, this.lineWidth = Dt, this.lineJoin = Ot;
  }, gt = function(Q, pt, _t) {
    for (var Ct = 0; Ct < Q.length; Ct++) switch (Q[Ct].type) {
      case "bct":
        Q[Ct].x2 += pt, Q[Ct].y2 += _t;
      case "qct":
        Q[Ct].x1 += pt, Q[Ct].y1 += _t;
      case "mt":
      case "lt":
      case "arc":
      default:
        Q[Ct].x += pt, Q[Ct].y += _t;
    }
    return Q;
  }, Mt = function(Q) {
    return Q.sort(function(pt, _t) {
      return pt - _t;
    });
  }, Qt = function(Q, pt) {
    for (var _t, Ct, Dt = this.fillStyle, Ot = this.strokeStyle, Vt = this.lineCap, Wt = this.lineWidth, xe = Math.abs(Wt * this.ctx.transform.scaleX), ve = this.lineJoin, ke = JSON.parse(JSON.stringify(this.path)), ze = JSON.parse(JSON.stringify(this.path)), Je = [], ie = 0; ie < ze.length; ie++) if (ze[ie].x !== void 0) for (var K = yt.call(this, ze[ie]), ci = 0; ci < K.length; ci += 1) Je.indexOf(K[ci]) === -1 && Je.push(K[ci]);
    for (var Ue = 0; Ue < Je.length; Ue++) for (; this.pdf.internal.getNumberOfPages() < Je[Ue]; ) st.call(this);
    if (Mt(Je), this.autoPaging) for (var oe = Je[0], ye = Je[Je.length - 1], De = oe; De < ye + 1; De++) {
      this.pdf.setPage(De), this.fillStyle = Dt, this.strokeStyle = Ot, this.lineCap = Vt, this.lineWidth = xe, this.lineJoin = ve;
      var Ae = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], $e = De === 1 ? this.posY + this.margin[0] : this.margin[0], hi = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], si = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], _i = De === 1 ? 0 : hi + (De - 2) * si;
      if (this.ctx.clip_path.length !== 0) {
        var Ii = this.path;
        _t = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = gt(_t, this.posX + this.margin[3], -_i + $e + this.ctx.prevPageLastElemOffset), Ht.call(this, Q, !0), this.path = Ii;
      }
      if (Ct = JSON.parse(JSON.stringify(ke)), this.path = gt(Ct, this.posX + this.margin[3], -_i + $e + this.ctx.prevPageLastElemOffset), pt === !1 || De === 0) {
        var he = (De > oe || De < ye) && ot.call(this);
        he && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ae, si, null).clip().discardPath()), Ht.call(this, Q, pt), he && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = Wt;
    }
    else this.lineWidth = xe, Ht.call(this, Q, pt), this.lineWidth = Wt;
    this.path = ke;
  }, Ht = function(Q, pt) {
    if ((Q !== "stroke" || pt || !mt.call(this)) && (Q === "stroke" || pt || !F.call(this))) {
      for (var _t, Ct, Dt = [], Ot = this.path, Vt = 0; Vt < Ot.length; Vt++) {
        var Wt = Ot[Vt];
        switch (Wt.type) {
          case "begin":
            Dt.push({ begin: !0 });
            break;
          case "close":
            Dt.push({ close: !0 });
            break;
          case "mt":
            Dt.push({ start: Wt, deltas: [], abs: [] });
            break;
          case "lt":
            var xe = Dt.length;
            if (Ot[Vt - 1] && !isNaN(Ot[Vt - 1].x) && (_t = [Wt.x - Ot[Vt - 1].x, Wt.y - Ot[Vt - 1].y], xe > 0)) {
              for (; xe >= 0; xe--) if (Dt[xe - 1].close !== !0 && Dt[xe - 1].begin !== !0) {
                Dt[xe - 1].deltas.push(_t), Dt[xe - 1].abs.push(Wt);
                break;
              }
            }
            break;
          case "bct":
            _t = [Wt.x1 - Ot[Vt - 1].x, Wt.y1 - Ot[Vt - 1].y, Wt.x2 - Ot[Vt - 1].x, Wt.y2 - Ot[Vt - 1].y, Wt.x - Ot[Vt - 1].x, Wt.y - Ot[Vt - 1].y], Dt[Dt.length - 1].deltas.push(_t);
            break;
          case "qct":
            var ve = Ot[Vt - 1].x + 2 / 3 * (Wt.x1 - Ot[Vt - 1].x), ke = Ot[Vt - 1].y + 2 / 3 * (Wt.y1 - Ot[Vt - 1].y), ze = Wt.x + 2 / 3 * (Wt.x1 - Wt.x), Je = Wt.y + 2 / 3 * (Wt.y1 - Wt.y), ie = Wt.x, K = Wt.y;
            _t = [ve - Ot[Vt - 1].x, ke - Ot[Vt - 1].y, ze - Ot[Vt - 1].x, Je - Ot[Vt - 1].y, ie - Ot[Vt - 1].x, K - Ot[Vt - 1].y], Dt[Dt.length - 1].deltas.push(_t);
            break;
          case "arc":
            Dt.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(Dt[Dt.length - 1].abs) && Dt[Dt.length - 1].abs.push(Wt);
        }
      }
      Ct = pt ? null : Q === "stroke" ? "stroke" : "fill";
      for (var ci = !1, Ue = 0; Ue < Dt.length; Ue++) if (Dt[Ue].arc) for (var oe = Dt[Ue].abs, ye = 0; ye < oe.length; ye++) {
        var De = oe[ye];
        De.type === "arc" ? Tt.call(this, De.x, De.y, De.radius, De.startAngle, De.endAngle, De.counterclockwise, void 0, pt, !ci) : Pt.call(this, De.x, De.y), ci = !0;
      }
      else if (Dt[Ue].close === !0) this.pdf.internal.out("h"), ci = !1;
      else if (Dt[Ue].begin !== !0) {
        var Ae = Dt[Ue].start.x, $e = Dt[Ue].start.y;
        bt.call(this, Dt[Ue].deltas, Ae, $e), ci = !0;
      }
      Ct && le.call(this, Ct), pt && ne.call(this);
    }
  }, pe = function(Q) {
    var pt = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, _t = pt * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return Q - _t;
      case "top":
        return Q + pt - _t;
      case "hanging":
        return Q + pt - 2 * _t;
      case "middle":
        return Q + pt / 2 - _t;
      case "ideographic":
        return Q;
      case "alphabetic":
      default:
        return Q;
    }
  }, jt = function(Q) {
    return Q + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  q.prototype.createLinearGradient = function() {
    var Q = function() {
    };
    return Q.colorStops = [], Q.addColorStop = function(pt, _t) {
      this.colorStops.push([pt, _t]);
    }, Q.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, Q.isCanvasGradient = !0, Q;
  }, q.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, q.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var Tt = function(Q, pt, _t, Ct, Dt, Ot, Vt, Wt, xe) {
    for (var ve = Yt.call(this, _t, Ct, Dt, Ot), ke = 0; ke < ve.length; ke++) {
      var ze = ve[ke];
      ke === 0 && (xe ? at.call(this, ze.x1 + Q, ze.y1 + pt) : Pt.call(this, ze.x1 + Q, ze.y1 + pt)), Jt.call(this, Q, pt, ze.x2, ze.y2, ze.x3, ze.y3, ze.x4, ze.y4);
    }
    Wt ? ne.call(this) : le.call(this, Vt);
  }, le = function(Q) {
    switch (Q) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, ne = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, at = function(Q, pt) {
    this.pdf.internal.out(y(Q) + " " + x(pt) + " m");
  }, lt = function(Q) {
    var pt;
    switch (Q.align) {
      case "right":
      case "end":
        pt = "right";
        break;
      case "center":
        pt = "center";
        break;
      case "left":
      case "start":
      default:
        pt = "left";
    }
    var _t = this.pdf.getTextDimensions(Q.text), Ct = pe.call(this, Q.y), Dt = jt.call(this, Ct) - _t.h, Ot = this.ctx.transform.applyToPoint(new v(Q.x, Ct)), Vt = this.ctx.transform.decompose(), Wt = new M();
    Wt = (Wt = (Wt = Wt.multiply(Vt.translate)).multiply(Vt.skew)).multiply(Vt.scale);
    for (var xe, ve, ke, ze = this.ctx.transform.applyToRectangle(new l(Q.x, Ct, _t.w, _t.h)), Je = Wt.applyToRectangle(new l(Q.x, Dt, _t.w, _t.h)), ie = yt.call(this, Je), K = [], ci = 0; ci < ie.length; ci += 1) K.indexOf(ie[ci]) === -1 && K.push(ie[ci]);
    if (Mt(K), this.autoPaging) for (var Ue = K[0], oe = K[K.length - 1], ye = Ue; ye < oe + 1; ye++) {
      this.pdf.setPage(ye);
      var De = ye === 1 ? this.posY + this.margin[0] : this.margin[0], Ae = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], $e = this.pdf.internal.pageSize.height - this.margin[2], hi = $e - this.margin[0], si = this.pdf.internal.pageSize.width - this.margin[1], _i = si - this.margin[3], Ii = ye === 1 ? 0 : Ae + (ye - 2) * hi;
      if (this.ctx.clip_path.length !== 0) {
        var he = this.path;
        xe = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = gt(xe, this.posX + this.margin[3], -1 * Ii + De), Ht.call(this, "fill", !0), this.path = he;
      }
      var Ke = gt([JSON.parse(JSON.stringify(Je))], this.posX + this.margin[3], -Ii + De + this.ctx.prevPageLastElemOffset)[0];
      Q.scale >= 0.01 && (ve = this.pdf.internal.getFontSize(), this.pdf.setFontSize(ve * Q.scale), ke = this.lineWidth, this.lineWidth = ke * Q.scale);
      var ai = this.autoPaging !== "text";
      if (ai || Ke.y + Ke.h <= $e) {
        if (ai || Ke.y >= De && Ke.x <= si) {
          var Pe = ai ? Q.text : this.pdf.splitTextToSize(Q.text, Q.maxWidth || si - Ke.x)[0], lr = gt([JSON.parse(JSON.stringify(ze))], this.posX + this.margin[3], -Ii + De + this.ctx.prevPageLastElemOffset)[0], ue = ai && (ye > Ue || ye < oe) && ot.call(this);
          ue && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _i, hi, null).clip().discardPath()), this.pdf.text(Pe, lr.x, lr.y, { angle: Q.angle, align: pt, renderingMode: Q.renderingMode }), ue && this.pdf.restoreGraphicsState();
        }
      } else Ke.y < $e && (this.ctx.prevPageLastElemOffset += $e - Ke.y);
      Q.scale >= 0.01 && (this.pdf.setFontSize(ve), this.lineWidth = ke);
    }
    else Q.scale >= 0.01 && (ve = this.pdf.internal.getFontSize(), this.pdf.setFontSize(ve * Q.scale), ke = this.lineWidth, this.lineWidth = ke * Q.scale), this.pdf.text(Q.text, Ot.x + this.posX, Ot.y + this.posY, { angle: Q.angle, align: pt, renderingMode: Q.renderingMode, maxWidth: Q.maxWidth }), Q.scale >= 0.01 && (this.pdf.setFontSize(ve), this.lineWidth = ke);
  }, Pt = function(Q, pt, _t, Ct) {
    _t = _t || 0, Ct = Ct || 0, this.pdf.internal.out(y(Q + _t) + " " + x(pt + Ct) + " l");
  }, bt = function(Q, pt, _t) {
    return this.pdf.lines(Q, pt, _t, null, null);
  }, Jt = function(Q, pt, _t, Ct, Dt, Ot, Vt, Wt) {
    this.pdf.internal.out([g(P(_t + Q)), g(A(Ct + pt)), g(P(Dt + Q)), g(A(Ot + pt)), g(P(Vt + Q)), g(A(Wt + pt)), "c"].join(" "));
  }, Yt = function(Q, pt, _t, Ct) {
    for (var Dt = 2 * Math.PI, Ot = Math.PI / 2; pt > _t; ) pt -= Dt;
    var Vt = Math.abs(_t - pt);
    Vt < Dt && Ct && (Vt = Dt - Vt);
    for (var Wt = [], xe = Ct ? -1 : 1, ve = pt; Vt > 1e-5; ) {
      var ke = ve + xe * Math.min(Vt, Ot);
      Wt.push(te.call(this, Q, ve, ke)), Vt -= Math.abs(ke - ve), ve = ke;
    }
    return Wt;
  }, te = function(Q, pt, _t) {
    var Ct = (_t - pt) / 2, Dt = Q * Math.cos(Ct), Ot = Q * Math.sin(Ct), Vt = Dt, Wt = -Ot, xe = Vt * Vt + Wt * Wt, ve = xe + Vt * Dt + Wt * Ot, ke = 4 / 3 * (Math.sqrt(2 * xe * ve) - ve) / (Vt * Ot - Wt * Dt), ze = Vt - ke * Wt, Je = Wt + ke * Vt, ie = ze, K = -Je, ci = Ct + pt, Ue = Math.cos(ci), oe = Math.sin(ci);
    return { x1: Q * Math.cos(pt), y1: Q * Math.sin(pt), x2: ze * Ue - Je * oe, y2: ze * oe + Je * Ue, x3: ie * Ue - K * oe, y3: ie * oe + K * Ue, x4: Q * Math.cos(_t), y4: Q * Math.sin(_t) };
  }, Ut = function(Q) {
    return 180 * Q / Math.PI;
  }, se = function(Q, pt, _t, Ct, Dt, Ot) {
    var Vt = Q + 0.5 * (_t - Q), Wt = pt + 0.5 * (Ct - pt), xe = Dt + 0.5 * (_t - Dt), ve = Ot + 0.5 * (Ct - Ot), ke = Math.min(Q, Dt, Vt, xe), ze = Math.max(Q, Dt, Vt, xe), Je = Math.min(pt, Ot, Wt, ve), ie = Math.max(pt, Ot, Wt, ve);
    return new l(ke, Je, ze - ke, ie - Je);
  }, ee = function(Q, pt, _t, Ct, Dt, Ot, Vt, Wt) {
    var xe, ve, ke, ze, Je, ie, K, ci, Ue, oe, ye, De, Ae, $e, hi = _t - Q, si = Ct - pt, _i = Dt - _t, Ii = Ot - Ct, he = Vt - Dt, Ke = Wt - Ot;
    for (ve = 0; ve < 41; ve++) Ue = (K = (ke = Q + (xe = ve / 40) * hi) + xe * ((Je = _t + xe * _i) - ke)) + xe * (Je + xe * (Dt + xe * he - Je) - K), oe = (ci = (ze = pt + xe * si) + xe * ((ie = Ct + xe * Ii) - ze)) + xe * (ie + xe * (Ot + xe * Ke - ie) - ci), ve == 0 ? (ye = Ue, De = oe, Ae = Ue, $e = oe) : (ye = Math.min(ye, Ue), De = Math.min(De, oe), Ae = Math.max(Ae, Ue), $e = Math.max($e, oe));
    return new l(Math.round(ye), Math.round(De), Math.round(Ae - ye), Math.round($e - De));
  }, be = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var Q, pt, _t = (Q = this.ctx.lineDash, pt = this.ctx.lineDashOffset, JSON.stringify({ lineDash: Q, lineDashOffset: pt }));
      this.prevLineDash !== _t && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = _t);
    }
  };
})(pi.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  var g = function(A) {
    var v, l, M, B, $, q, U, F, mt, ot;
    for (l = [], M = 0, B = (A += v = "\0\0\0\0".slice(A.length % 4 || 4)).length; B > M; M += 4) ($ = (A.charCodeAt(M) << 24) + (A.charCodeAt(M + 1) << 16) + (A.charCodeAt(M + 2) << 8) + A.charCodeAt(M + 3)) !== 0 ? (q = ($ = (($ = (($ = (($ = ($ - (ot = $ % 85)) / 85) - (mt = $ % 85)) / 85) - (F = $ % 85)) / 85) - (U = $ % 85)) / 85) % 85, l.push(q + 33, U + 33, F + 33, mt + 33, ot + 33)) : l.push(122);
    return function(yt, st) {
      for (var gt = st; gt > 0; gt--) yt.pop();
    }(l, v.length), String.fromCharCode.apply(String, l) + "~>";
  }, y = function(A) {
    var v, l, M, B, $, q = String, U = "length", F = 255, mt = "charCodeAt", ot = "slice", yt = "replace";
    for (A[ot](-2), A = A[ot](0, -2)[yt](/\s/g, "")[yt]("z", "!!!!!"), M = [], B = 0, $ = (A += v = "uuuuu"[ot](A[U] % 5 || 5))[U]; $ > B; B += 5) l = 52200625 * (A[mt](B) - 33) + 614125 * (A[mt](B + 1) - 33) + 7225 * (A[mt](B + 2) - 33) + 85 * (A[mt](B + 3) - 33) + (A[mt](B + 4) - 33), M.push(F & l >> 24, F & l >> 16, F & l >> 8, F & l);
    return function(st, gt) {
      for (var Mt = gt; Mt > 0; Mt--) st.pop();
    }(M, v[U]), q.fromCharCode.apply(q, M);
  }, x = function(A) {
    var v = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((A = A.replace(/\s/g, "")).indexOf(">") !== -1 && (A = A.substr(0, A.indexOf(">"))), A.length % 2 && (A += "0"), v.test(A) === !1) return "";
    for (var l = "", M = 0; M < A.length; M += 2) l += String.fromCharCode("0x" + (A[M] + A[M + 1]));
    return l;
  }, P = function(A) {
    for (var v = new Uint8Array(A.length), l = A.length; l--; ) v[l] = A.charCodeAt(l);
    return A = (v = Zu(v)).reduce(function(M, B) {
      return M + String.fromCharCode(B);
    }, "");
  };
  b.processDataByFilters = function(A, v) {
    var l = 0, M = A || "", B = [];
    for (typeof (v = v || []) == "string" && (v = [v]), l = 0; l < v.length; l += 1) switch (v[l]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        M = y(M), B.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        M = g(M), B.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        M = x(M), B.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        M = M.split("").map(function($) {
          return ("0" + $.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", B.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        M = P(M), B.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + v[l] + '" is not implemented');
    }
    return { data: M, reverseChain: B.reverse().join(" ") };
  };
}(pi.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  b.loadFile = function(g, y, x) {
    return function(P, A, v) {
      A = A !== !1, v = typeof v == "function" ? v : function() {
      };
      var l = void 0;
      try {
        l = function(M, B, $) {
          var q = new XMLHttpRequest(), U = 0, F = function(mt) {
            var ot = mt.length, yt = [], st = String.fromCharCode;
            for (U = 0; U < ot; U += 1) yt.push(st(255 & mt.charCodeAt(U)));
            return yt.join("");
          };
          if (q.open("GET", M, !B), q.overrideMimeType("text/plain; charset=x-user-defined"), B === !1 && (q.onload = function() {
            q.status === 200 ? $(F(this.responseText)) : $(void 0);
          }), q.send(null), B && q.status === 200) return F(q.responseText);
        }(P, A, v);
      } catch {
      }
      return l;
    }(g, y, x);
  }, b.loadImageFile = b.loadFile;
}(pi.API), function(b) {
  function g() {
    return (fi.html2canvas ? Promise.resolve(fi.html2canvas) : import("./html2canvas.esm-d2sM-0Wm-BdPOovWT.mjs")).catch(function(v) {
      return Promise.reject(new Error("Could not load html2canvas: " + v));
    }).then(function(v) {
      return v.default ? v.default : v;
    });
  }
  function y() {
    return (fi.DOMPurify ? Promise.resolve(fi.DOMPurify) : import("./purify.es-B7BPtUgm-D-kGXswo.mjs")).catch(function(v) {
      return Promise.reject(new Error("Could not load dompurify: " + v));
    }).then(function(v) {
      return v.default ? v.default : v;
    });
  }
  var x = function(v) {
    var l = ir(v);
    return l === "undefined" ? "undefined" : l === "string" || v instanceof String ? "string" : l === "number" || v instanceof Number ? "number" : l === "function" || v instanceof Function ? "function" : v && v.constructor === Array ? "array" : v && v.nodeType === 1 ? "element" : l === "object" ? "object" : "unknown";
  }, P = function(v, l) {
    var M = document.createElement(v);
    for (var B in l.className && (M.className = l.className), l.innerHTML && l.dompurify && (M.innerHTML = l.dompurify.sanitize(l.innerHTML)), l.style) M.style[B] = l.style[B];
    return M;
  }, A = function v(l) {
    var M = Object.assign(v.convert(Promise.resolve()), JSON.parse(JSON.stringify(v.template))), B = v.convert(Promise.resolve(), M);
    return B = (B = B.setProgress(1, v, 1, [v])).set(l);
  };
  (A.prototype = Object.create(Promise.prototype)).constructor = A, A.convert = function(v, l) {
    return v.__proto__ = l || A.prototype, v;
  }, A.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, A.prototype.from = function(v, l) {
    return this.then(function() {
      switch (l = l || function(M) {
        switch (x(M)) {
          case "string":
            return "string";
          case "element":
            return M.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(v)) {
        case "string":
          return this.then(y).then(function(M) {
            return this.set({ src: P("div", { innerHTML: v, dompurify: M }) });
          });
        case "element":
          return this.set({ src: v });
        case "canvas":
          return this.set({ canvas: v });
        case "img":
          return this.set({ img: v });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, A.prototype.to = function(v) {
    switch (v) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, A.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var v = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, l = function M(B, $) {
        for (var q = B.nodeType === 3 ? document.createTextNode(B.nodeValue) : B.cloneNode(!1), U = B.firstChild; U; U = U.nextSibling) $ !== !0 && U.nodeType === 1 && U.nodeName === "SCRIPT" || q.appendChild(M(U, $));
        return B.nodeType === 1 && (B.nodeName === "CANVAS" ? (q.width = B.width, q.height = B.height, q.getContext("2d").drawImage(B, 0, 0)) : B.nodeName !== "TEXTAREA" && B.nodeName !== "SELECT" || (q.value = B.value), q.addEventListener("load", function() {
          q.scrollTop = B.scrollTop, q.scrollLeft = B.scrollLeft;
        }, !0)), q;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      l.tagName === "BODY" && (v.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = P("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = P("div", { className: "html2pdf__container", style: v }), this.prop.container.appendChild(l), this.prop.container.firstChild.appendChild(P("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, A.prototype.toCanvas = function() {
    var v = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(v).then(g).then(function(l) {
      var M = Object.assign({}, this.opt.html2canvas);
      return delete M.onrendered, l(this.prop.container, M);
    }).then(function(l) {
      (this.opt.html2canvas.onrendered || function() {
      })(l), this.prop.canvas = l, document.body.removeChild(this.prop.overlay);
    });
  }, A.prototype.toContext2d = function() {
    var v = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(v).then(g).then(function(l) {
      var M = this.opt.jsPDF, B = this.opt.fontFaces, $ = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, q = Object.assign({ async: !0, allowTaint: !0, scale: $, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete q.onrendered, M.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, M.context2d.posX = this.opt.x, M.context2d.posY = this.opt.y, M.context2d.margin = this.opt.margin, M.context2d.fontFaces = B, B) for (var U = 0; U < B.length; ++U) {
        var F = B[U], mt = F.src.find(function(ot) {
          return ot.format === "truetype";
        });
        mt && M.addFont(mt.url, F.ref.name, F.ref.style);
      }
      return q.windowHeight = q.windowHeight || 0, q.windowHeight = q.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : q.windowHeight, M.context2d.save(!0), l(this.prop.container, q);
    }).then(function(l) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(l), this.prop.canvas = l, document.body.removeChild(this.prop.overlay);
    });
  }, A.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var v = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = v;
    });
  }, A.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, A.prototype.output = function(v, l, M) {
    return (M = M || "pdf").toLowerCase() === "img" || M.toLowerCase() === "image" ? this.outputImg(v, l) : this.outputPdf(v, l);
  }, A.prototype.outputPdf = function(v, l) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(v, l);
    });
  }, A.prototype.outputImg = function(v) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (v) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + v + '" is not supported.';
      }
    });
  }, A.prototype.save = function(v) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(v ? { filename: v } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, A.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, A.prototype.set = function(v) {
    if (x(v) !== "object") return this;
    var l = Object.keys(v || {}).map(function(M) {
      if (M in A.template.prop) return function() {
        this.prop[M] = v[M];
      };
      switch (M) {
        case "margin":
          return this.setMargin.bind(this, v.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = v.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, v.pageSize);
        default:
          return function() {
            this.opt[M] = v[M];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(l);
    });
  }, A.prototype.get = function(v, l) {
    return this.then(function() {
      var M = v in A.template.prop ? this.prop[v] : this.opt[v];
      return l ? l(M) : M;
    });
  }, A.prototype.setMargin = function(v) {
    return this.then(function() {
      switch (x(v)) {
        case "number":
          v = [v, v, v, v];
        case "array":
          if (v.length === 2 && (v = [v[0], v[1], v[0], v[1]]), v.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = v;
    }).then(this.setPageSize);
  }, A.prototype.setPageSize = function(v) {
    function l(M, B) {
      return Math.floor(M * B / 72 * 96);
    }
    return this.then(function() {
      (v = v || pi.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (v.inner = { width: v.width - this.opt.margin[1] - this.opt.margin[3], height: v.height - this.opt.margin[0] - this.opt.margin[2] }, v.inner.px = { width: l(v.inner.width, v.k), height: l(v.inner.height, v.k) }, v.inner.ratio = v.inner.height / v.inner.width), this.prop.pageSize = v;
    });
  }, A.prototype.setProgress = function(v, l, M, B) {
    return v != null && (this.progress.val = v), l != null && (this.progress.state = l), M != null && (this.progress.n = M), B != null && (this.progress.stack = B), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, A.prototype.updateProgress = function(v, l, M, B) {
    return this.setProgress(v ? this.progress.val + v : null, l || null, M ? this.progress.n + M : null, B ? this.progress.stack.concat(B) : null);
  }, A.prototype.then = function(v, l) {
    var M = this;
    return this.thenCore(v, l, function(B, $) {
      return M.updateProgress(null, null, 1, [B]), Promise.prototype.then.call(this, function(q) {
        return M.updateProgress(null, B), q;
      }).then(B, $).then(function(q) {
        return M.updateProgress(1), q;
      });
    });
  }, A.prototype.thenCore = function(v, l, M) {
    M = M || Promise.prototype.then, v && (v = v.bind(this)), l && (l = l.bind(this));
    var B = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : A.convert(Object.assign({}, this), Promise.prototype), $ = M.call(B, v, l);
    return A.convert($, this.__proto__);
  }, A.prototype.thenExternal = function(v, l) {
    return Promise.prototype.then.call(this, v, l);
  }, A.prototype.thenList = function(v) {
    var l = this;
    return v.forEach(function(M) {
      l = l.thenCore(M);
    }), l;
  }, A.prototype.catch = function(v) {
    v && (v = v.bind(this));
    var l = Promise.prototype.catch.call(this, v);
    return A.convert(l, this);
  }, A.prototype.catchExternal = function(v) {
    return Promise.prototype.catch.call(this, v);
  }, A.prototype.error = function(v) {
    return this.then(function() {
      throw new Error(v);
    });
  }, A.prototype.using = A.prototype.set, A.prototype.saveAs = A.prototype.save, A.prototype.export = A.prototype.output, A.prototype.run = A.prototype.then, pi.getPageSize = function(v, l, M) {
    if (ir(v) === "object") {
      var B = v;
      v = B.orientation, l = B.unit || l, M = B.format || M;
    }
    l = l || "mm", M = M || "a4", v = ("" + (v || "P")).toLowerCase();
    var $, q = ("" + M).toLowerCase(), U = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (l) {
      case "pt":
        $ = 1;
        break;
      case "mm":
        $ = 72 / 25.4;
        break;
      case "cm":
        $ = 72 / 2.54;
        break;
      case "in":
        $ = 72;
        break;
      case "px":
        $ = 0.75;
        break;
      case "pc":
      case "em":
        $ = 12;
        break;
      case "ex":
        $ = 6;
        break;
      default:
        throw "Invalid unit: " + l;
    }
    var F, mt = 0, ot = 0;
    if (U.hasOwnProperty(q)) mt = U[q][1] / $, ot = U[q][0] / $;
    else try {
      mt = M[1], ot = M[0];
    } catch {
      throw new Error("Invalid format: " + M);
    }
    if (v === "p" || v === "portrait") v = "p", ot > mt && (F = ot, ot = mt, mt = F);
    else {
      if (v !== "l" && v !== "landscape") throw "Invalid orientation: " + v;
      v = "l", mt > ot && (F = ot, ot = mt, mt = F);
    }
    return { width: ot, height: mt, unit: l, k: $, orientation: v };
  }, b.html = function(v, l) {
    (l = l || {}).callback = l.callback || function() {
    }, l.html2canvas = l.html2canvas || {}, l.html2canvas.canvas = l.html2canvas.canvas || this.canvas, l.jsPDF = l.jsPDF || this, l.fontFaces = l.fontFaces ? l.fontFaces.map(Ju) : null;
    var M = new A(l);
    return l.worker ? M : M.from(v).doCallback();
  };
}(pi.API), pi.API.addJS = function(b) {
  return Up = b, this.internal.events.subscribe("postPutResources", function() {
    Fh = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Fh + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), qp = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Up + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Fh !== void 0 && qp !== void 0 && this.internal.out("/Names <</JavaScript " + Fh + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  var g;
  b.events.push(["postPutResources", function() {
    var y = this, x = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var P = y.outline.render().split(/\r\n/), A = 0; A < P.length; A++) {
      var v = P[A], l = x.exec(v);
      if (l != null) {
        var M = l[1];
        y.internal.newObjectDeferredBegin(M, !1);
      }
      y.internal.write(v);
    }
    if (this.outline.createNamedDestinations) {
      var B = this.internal.pages.length, $ = [];
      for (A = 0; A < B; A++) {
        var q = y.internal.newObject();
        $.push(q);
        var U = y.internal.getPageInfo(A + 1);
        y.internal.write("<< /D[" + U.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var F = y.internal.newObject();
      for (y.internal.write("<< /Names [ "), A = 0; A < $.length; A++) y.internal.write("(page_" + (A + 1) + ")" + $[A] + " 0 R");
      y.internal.write(" ] >>", "endobj"), g = y.internal.newObject(), y.internal.write("<< /Dests " + F + " 0 R"), y.internal.write(">>", "endobj");
    }
  }]), b.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + g + " 0 R"));
  }]), b.events.push(["initialized", function() {
    var y = this;
    y.outline = { createNamedDestinations: !1, root: { children: [] } }, y.outline.add = function(x, P, A) {
      var v = { title: P, options: A, children: [] };
      return x == null && (x = this.root), x.children.push(v), v;
    }, y.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = y, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, y.outline.genIds_r = function(x) {
      x.id = y.internal.newObjectDeferred();
      for (var P = 0; P < x.children.length; P++) this.genIds_r(x.children[P]);
    }, y.outline.renderRoot = function(x) {
      this.objStart(x), this.line("/Type /Outlines"), x.children.length > 0 && (this.line("/First " + this.makeRef(x.children[0])), this.line("/Last " + this.makeRef(x.children[x.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, x)), this.objEnd();
    }, y.outline.renderItems = function(x) {
      for (var P = this.ctx.pdf.internal.getVerticalCoordinateString, A = 0; A < x.children.length; A++) {
        var v = x.children[A];
        this.objStart(v), this.line("/Title " + this.makeString(v.title)), this.line("/Parent " + this.makeRef(x)), A > 0 && this.line("/Prev " + this.makeRef(x.children[A - 1])), A < x.children.length - 1 && this.line("/Next " + this.makeRef(x.children[A + 1])), v.children.length > 0 && (this.line("/First " + this.makeRef(v.children[0])), this.line("/Last " + this.makeRef(v.children[v.children.length - 1])));
        var l = this.count = this.count_r({ count: 0 }, v);
        if (l > 0 && this.line("/Count " + l), v.options && v.options.pageNumber) {
          var M = y.internal.getPageInfo(v.options.pageNumber);
          this.line("/Dest [" + M.objId + " 0 R /XYZ 0 " + P(0) + " 0]");
        }
        this.objEnd();
      }
      for (var B = 0; B < x.children.length; B++) this.renderItems(x.children[B]);
    }, y.outline.line = function(x) {
      this.ctx.val += x + `\r
`;
    }, y.outline.makeRef = function(x) {
      return x.id + " 0 R";
    }, y.outline.makeString = function(x) {
      return "(" + y.internal.pdfEscape(x) + ")";
    }, y.outline.objStart = function(x) {
      this.ctx.val += `\r
` + x.id + ` 0 obj\r
<<\r
`;
    }, y.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, y.outline.count_r = function(x, P) {
      for (var A = 0; A < P.children.length; A++) x.count++, this.count_r(x, P.children[A]);
      return x.count;
    };
  }]);
}(pi.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  var g = [192, 193, 194, 195, 196, 197, 198, 199];
  b.processJPEG = function(y, x, P, A, v, l) {
    var M, B = this.decode.DCT_DECODE, $ = null;
    if (typeof y == "string" || this.__addimage__.isArrayBuffer(y) || this.__addimage__.isArrayBufferView(y)) {
      switch (y = v || y, y = this.__addimage__.isArrayBuffer(y) ? new Uint8Array(y) : y, (M = function(q) {
        for (var U, F = 256 * q.charCodeAt(4) + q.charCodeAt(5), mt = q.length, ot = { width: 0, height: 0, numcomponents: 1 }, yt = 4; yt < mt; yt += 2) {
          if (yt += F, g.indexOf(q.charCodeAt(yt + 1)) !== -1) {
            U = 256 * q.charCodeAt(yt + 5) + q.charCodeAt(yt + 6), ot = { width: 256 * q.charCodeAt(yt + 7) + q.charCodeAt(yt + 8), height: U, numcomponents: q.charCodeAt(yt + 9) };
            break;
          }
          F = 256 * q.charCodeAt(yt + 2) + q.charCodeAt(yt + 3);
        }
        return ot;
      }(y = this.__addimage__.isArrayBufferView(y) ? this.__addimage__.arrayBufferToBinaryString(y) : y)).numcomponents) {
        case 1:
          l = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          l = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          l = this.color_spaces.DEVICE_RGB;
      }
      $ = { data: y, width: M.width, height: M.height, colorSpace: l, bitsPerComponent: 8, filter: B, index: x, alias: P };
    }
    return $;
  };
}(pi.API);
var Ic, Rh, $p, Zp, Gp, o0 = function() {
  var b, g, y;
  function x(A) {
    var v, l, M, B, $, q, U, F, mt, ot, yt, st, gt, Mt;
    for (this.data = A, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, q = null; ; ) {
      switch (v = this.readUInt32(), mt = (function() {
        var Qt, Ht;
        for (Ht = [], Qt = 0; Qt < 4; ++Qt) Ht.push(String.fromCharCode(this.data[this.pos++]));
        return Ht;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(v);
          break;
        case "fcTL":
          q && this.animation.frames.push(q), this.pos += 4, q = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, $ = this.readUInt16(), B = this.readUInt16() || 100, q.delay = 1e3 * $ / B, q.disposeOp = this.data[this.pos++], q.blendOp = this.data[this.pos++], q.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (mt === "fdAT" && (this.pos += 4, v -= 4), A = (q != null ? q.data : void 0) || this.imgData, st = 0; 0 <= v ? st < v : st > v; 0 <= v ? ++st : --st) A.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (M = this.palette.length / 3, this.transparency.indexed = this.read(v), this.transparency.indexed.length > M) throw new Error("More transparent colors than palette size");
              if ((ot = M - this.transparency.indexed.length) > 0) for (gt = 0; 0 <= ot ? gt < ot : gt > ot; 0 <= ot ? ++gt : --gt) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(v)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(v);
          }
          break;
        case "tEXt":
          U = (yt = this.read(v)).indexOf(0), F = String.fromCharCode.apply(String, yt.slice(0, U)), this.text[F] = String.fromCharCode.apply(String, yt.slice(U + 1));
          break;
        case "IEND":
          return q && this.animation.frames.push(q), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (Mt = this.colorType) === 4 || Mt === 6, l = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * l, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += v;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  x.prototype.read = function(A) {
    var v, l;
    for (l = [], v = 0; 0 <= A ? v < A : v > A; 0 <= A ? ++v : --v) l.push(this.data[this.pos++]);
    return l;
  }, x.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, x.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, x.prototype.decodePixels = function(A) {
    var v = this.pixelBitlength / 8, l = new Uint8Array(this.width * this.height * v), M = 0, B = this;
    if (A == null && (A = this.imgData), A.length === 0) return new Uint8Array(0);
    function $(q, U, F, mt) {
      var ot, yt, st, gt, Mt, Qt, Ht, pe, jt, Tt, le, ne, at, lt, Pt, bt, Jt, Yt, te, Ut, se, ee = Math.ceil((B.width - q) / F), be = Math.ceil((B.height - U) / mt), Q = B.width == ee && B.height == be;
      for (lt = v * ee, ne = Q ? l : new Uint8Array(lt * be), Qt = A.length, at = 0, yt = 0; at < be && M < Qt; ) {
        switch (A[M++]) {
          case 0:
            for (gt = Jt = 0; Jt < lt; gt = Jt += 1) ne[yt++] = A[M++];
            break;
          case 1:
            for (gt = Yt = 0; Yt < lt; gt = Yt += 1) ot = A[M++], Mt = gt < v ? 0 : ne[yt - v], ne[yt++] = (ot + Mt) % 256;
            break;
          case 2:
            for (gt = te = 0; te < lt; gt = te += 1) ot = A[M++], st = (gt - gt % v) / v, Pt = at && ne[(at - 1) * lt + st * v + gt % v], ne[yt++] = (Pt + ot) % 256;
            break;
          case 3:
            for (gt = Ut = 0; Ut < lt; gt = Ut += 1) ot = A[M++], st = (gt - gt % v) / v, Mt = gt < v ? 0 : ne[yt - v], Pt = at && ne[(at - 1) * lt + st * v + gt % v], ne[yt++] = (ot + Math.floor((Mt + Pt) / 2)) % 256;
            break;
          case 4:
            for (gt = se = 0; se < lt; gt = se += 1) ot = A[M++], st = (gt - gt % v) / v, Mt = gt < v ? 0 : ne[yt - v], at === 0 ? Pt = bt = 0 : (Pt = ne[(at - 1) * lt + st * v + gt % v], bt = st && ne[(at - 1) * lt + (st - 1) * v + gt % v]), Ht = Mt + Pt - bt, pe = Math.abs(Ht - Mt), Tt = Math.abs(Ht - Pt), le = Math.abs(Ht - bt), jt = pe <= Tt && pe <= le ? Mt : Tt <= le ? Pt : bt, ne[yt++] = (ot + jt) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + A[M - 1]);
        }
        if (!Q) {
          var pt = ((U + at * mt) * B.width + q) * v, _t = at * lt;
          for (gt = 0; gt < ee; gt += 1) {
            for (var Ct = 0; Ct < v; Ct += 1) l[pt++] = ne[_t++];
            pt += (F - 1) * v;
          }
        }
        at++;
      }
    }
    return A = qg(A), B.interlaceMethod == 1 ? ($(0, 0, 8, 8), $(4, 0, 8, 8), $(0, 4, 4, 8), $(2, 0, 4, 4), $(0, 2, 2, 4), $(1, 0, 2, 2), $(0, 1, 1, 2)) : $(0, 0, 1, 1), l;
  }, x.prototype.decodePalette = function() {
    var A, v, l, M, B, $, q, U, F;
    for (l = this.palette, $ = this.transparency.indexed || [], B = new Uint8Array(($.length || 0) + l.length), M = 0, A = 0, v = q = 0, U = l.length; q < U; v = q += 3) B[M++] = l[v], B[M++] = l[v + 1], B[M++] = l[v + 2], B[M++] = (F = $[A++]) != null ? F : 255;
    return B;
  }, x.prototype.copyToImageData = function(A, v) {
    var l, M, B, $, q, U, F, mt, ot, yt, st;
    if (M = this.colors, ot = null, l = this.hasAlphaChannel, this.palette.length && (ot = (st = this._decodedPalette) != null ? st : this._decodedPalette = this.decodePalette(), M = 4, l = !0), mt = (B = A.data || A).length, q = ot || v, $ = U = 0, M === 1) for (; $ < mt; ) F = ot ? 4 * v[$ / 4] : U, yt = q[F++], B[$++] = yt, B[$++] = yt, B[$++] = yt, B[$++] = l ? q[F++] : 255, U = F;
    else for (; $ < mt; ) F = ot ? 4 * v[$ / 4] : U, B[$++] = q[F++], B[$++] = q[F++], B[$++] = q[F++], B[$++] = l ? q[F++] : 255, U = F;
  }, x.prototype.decode = function() {
    var A;
    return A = new Uint8Array(this.width * this.height * 4), this.copyToImageData(A, this.decodePixels()), A;
  };
  var P = function() {
    if (Object.prototype.toString.call(fi) === "[object Window]") {
      try {
        g = fi.document.createElement("canvas"), y = g.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return P(), b = function(A) {
    var v;
    if (P() === !0) return y.width = A.width, y.height = A.height, y.clearRect(0, 0, A.width, A.height), y.putImageData(A, 0, 0), (v = new Image()).src = g.toDataURL(), v;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, x.prototype.decodeFrames = function(A) {
    var v, l, M, B, $, q, U, F;
    if (this.animation) {
      for (F = [], l = $ = 0, q = (U = this.animation.frames).length; $ < q; l = ++$) v = U[l], M = A.createImageData(v.width, v.height), B = this.decodePixels(new Uint8Array(v.data)), this.copyToImageData(M, B), v.imageData = M, F.push(v.image = b(M));
      return F;
    }
  }, x.prototype.renderFrame = function(A, v) {
    var l, M, B;
    return l = (M = this.animation.frames)[v], B = M[v - 1], v === 0 && A.clearRect(0, 0, this.width, this.height), (B != null ? B.disposeOp : void 0) === 1 ? A.clearRect(B.xOffset, B.yOffset, B.width, B.height) : (B != null ? B.disposeOp : void 0) === 2 && A.putImageData(B.imageData, B.xOffset, B.yOffset), l.blendOp === 0 && A.clearRect(l.xOffset, l.yOffset, l.width, l.height), A.drawImage(l.image, l.xOffset, l.yOffset);
  }, x.prototype.animate = function(A) {
    var v, l, M, B, $, q, U = this;
    return l = 0, q = this.animation, B = q.numFrames, M = q.frames, $ = q.numPlays, (v = function() {
      var F, mt;
      if (F = l++ % B, mt = M[F], U.renderFrame(A, F), B > 1 && l / B < $) return U.animation._timeout = setTimeout(v, mt.delay);
    })();
  }, x.prototype.stopAnimation = function() {
    var A;
    return clearTimeout((A = this.animation) != null ? A._timeout : void 0);
  }, x.prototype.render = function(A) {
    var v, l;
    return A._png && A._png.stopAnimation(), A._png = this, A.width = this.width, A.height = this.height, v = A.getContext("2d"), this.animation ? (this.decodeFrames(v), this.animate(v)) : (l = v.createImageData(this.width, this.height), this.copyToImageData(l, this.decodePixels()), v.putImageData(l, 0, 0));
  }, x;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function l0(b) {
  var g = 0;
  if (b[g++] !== 71 || b[g++] !== 73 || b[g++] !== 70 || b[g++] !== 56 || (b[g++] + 1 & 253) != 56 || b[g++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var y = b[g++] | b[g++] << 8, x = b[g++] | b[g++] << 8, P = b[g++], A = P >> 7, v = 1 << (7 & P) + 1;
  b[g++], b[g++];
  var l = null, M = null;
  A && (l = g, M = v, g += 3 * v);
  var B = !0, $ = [], q = 0, U = null, F = 0, mt = null;
  for (this.width = y, this.height = x; B && g < b.length; ) switch (b[g++]) {
    case 33:
      switch (b[g++]) {
        case 255:
          if (b[g] !== 11 || b[g + 1] == 78 && b[g + 2] == 69 && b[g + 3] == 84 && b[g + 4] == 83 && b[g + 5] == 67 && b[g + 6] == 65 && b[g + 7] == 80 && b[g + 8] == 69 && b[g + 9] == 50 && b[g + 10] == 46 && b[g + 11] == 48 && b[g + 12] == 3 && b[g + 13] == 1 && b[g + 16] == 0) g += 14, mt = b[g++] | b[g++] << 8, g++;
          else for (g += 12; ; ) {
            if (!((at = b[g++]) >= 0)) throw Error("Invalid block size");
            if (at === 0) break;
            g += at;
          }
          break;
        case 249:
          if (b[g++] !== 4 || b[g + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var ot = b[g++];
          q = b[g++] | b[g++] << 8, U = b[g++], !(1 & ot) && (U = null), F = ot >> 2 & 7, g++;
          break;
        case 254:
          for (; ; ) {
            if (!((at = b[g++]) >= 0)) throw Error("Invalid block size");
            if (at === 0) break;
            g += at;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + b[g - 1].toString(16));
      }
      break;
    case 44:
      var yt = b[g++] | b[g++] << 8, st = b[g++] | b[g++] << 8, gt = b[g++] | b[g++] << 8, Mt = b[g++] | b[g++] << 8, Qt = b[g++], Ht = Qt >> 6 & 1, pe = 1 << (7 & Qt) + 1, jt = l, Tt = M, le = !1;
      Qt >> 7 && (le = !0, jt = g, Tt = pe, g += 3 * pe);
      var ne = g;
      for (g++; ; ) {
        var at;
        if (!((at = b[g++]) >= 0)) throw Error("Invalid block size");
        if (at === 0) break;
        g += at;
      }
      $.push({ x: yt, y: st, width: gt, height: Mt, has_local_palette: le, palette_offset: jt, palette_size: Tt, data_offset: ne, data_length: g - ne, transparent_index: U, interlaced: !!Ht, delay: q, disposal: F });
      break;
    case 59:
      B = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + b[g - 1].toString(16));
  }
  this.numFrames = function() {
    return $.length;
  }, this.loopCount = function() {
    return mt;
  }, this.frameInfo = function(lt) {
    if (lt < 0 || lt >= $.length) throw new Error("Frame index out of range.");
    return $[lt];
  }, this.decodeAndBlitFrameBGRA = function(lt, Pt) {
    var bt = this.frameInfo(lt), Jt = bt.width * bt.height, Yt = new Uint8Array(Jt);
    Wp(b, bt.data_offset, Yt, Jt);
    var te = bt.palette_offset, Ut = bt.transparent_index;
    Ut === null && (Ut = 256);
    var se = bt.width, ee = y - se, be = se, Q = 4 * (bt.y * y + bt.x), pt = 4 * ((bt.y + bt.height) * y + bt.x), _t = Q, Ct = 4 * ee;
    bt.interlaced === !0 && (Ct += 4 * y * 7);
    for (var Dt = 8, Ot = 0, Vt = Yt.length; Ot < Vt; ++Ot) {
      var Wt = Yt[Ot];
      if (be === 0 && (be = se, (_t += Ct) >= pt && (Ct = 4 * ee + 4 * y * (Dt - 1), _t = Q + (se + ee) * (Dt << 1), Dt >>= 1)), Wt === Ut) _t += 4;
      else {
        var xe = b[te + 3 * Wt], ve = b[te + 3 * Wt + 1], ke = b[te + 3 * Wt + 2];
        Pt[_t++] = ke, Pt[_t++] = ve, Pt[_t++] = xe, Pt[_t++] = 255;
      }
      --be;
    }
  }, this.decodeAndBlitFrameRGBA = function(lt, Pt) {
    var bt = this.frameInfo(lt), Jt = bt.width * bt.height, Yt = new Uint8Array(Jt);
    Wp(b, bt.data_offset, Yt, Jt);
    var te = bt.palette_offset, Ut = bt.transparent_index;
    Ut === null && (Ut = 256);
    var se = bt.width, ee = y - se, be = se, Q = 4 * (bt.y * y + bt.x), pt = 4 * ((bt.y + bt.height) * y + bt.x), _t = Q, Ct = 4 * ee;
    bt.interlaced === !0 && (Ct += 4 * y * 7);
    for (var Dt = 8, Ot = 0, Vt = Yt.length; Ot < Vt; ++Ot) {
      var Wt = Yt[Ot];
      if (be === 0 && (be = se, (_t += Ct) >= pt && (Ct = 4 * ee + 4 * y * (Dt - 1), _t = Q + (se + ee) * (Dt << 1), Dt >>= 1)), Wt === Ut) _t += 4;
      else {
        var xe = b[te + 3 * Wt], ve = b[te + 3 * Wt + 1], ke = b[te + 3 * Wt + 2];
        Pt[_t++] = xe, Pt[_t++] = ve, Pt[_t++] = ke, Pt[_t++] = 255;
      }
      --be;
    }
  };
}
function Wp(b, g, y, x) {
  for (var P = b[g++], A = 1 << P, v = A + 1, l = v + 1, M = P + 1, B = (1 << M) - 1, $ = 0, q = 0, U = 0, F = b[g++], mt = new Int32Array(4096), ot = null; ; ) {
    for (; $ < 16 && F !== 0; ) q |= b[g++] << $, $ += 8, F === 1 ? F = b[g++] : --F;
    if ($ < M) break;
    var yt = q & B;
    if (q >>= M, $ -= M, yt !== A) {
      if (yt === v) break;
      for (var st = yt < l ? yt : ot, gt = 0, Mt = st; Mt > A; ) Mt = mt[Mt] >> 8, ++gt;
      var Qt = Mt;
      if (U + gt + (st !== yt ? 1 : 0) > x) return void ur.log("Warning, gif stream longer than expected.");
      y[U++] = Qt;
      var Ht = U += gt;
      for (st !== yt && (y[U++] = Qt), Mt = st; gt--; ) Mt = mt[Mt], y[--Ht] = 255 & Mt, Mt >>= 8;
      ot !== null && l < 4096 && (mt[l++] = ot << 8 | Qt, l >= B + 1 && M < 12 && (++M, B = B << 1 | 1)), ot = yt;
    } else l = v + 1, B = (1 << (M = P + 1)) - 1, ot = null;
  }
  return U !== x && ur.log("Warning, gif stream shorter than expected."), y;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Ou(b) {
  var g, y, x, P, A, v = Math.floor, l = new Array(64), M = new Array(64), B = new Array(64), $ = new Array(64), q = new Array(65535), U = new Array(65535), F = new Array(64), mt = new Array(64), ot = [], yt = 0, st = 7, gt = new Array(64), Mt = new Array(64), Qt = new Array(64), Ht = new Array(256), pe = new Array(2048), jt = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], Tt = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], le = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ne = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], at = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], lt = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], Pt = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], bt = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], Jt = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function Yt(Q, pt) {
    for (var _t = 0, Ct = 0, Dt = new Array(), Ot = 1; Ot <= 16; Ot++) {
      for (var Vt = 1; Vt <= Q[Ot]; Vt++) Dt[pt[Ct]] = [], Dt[pt[Ct]][0] = _t, Dt[pt[Ct]][1] = Ot, Ct++, _t++;
      _t *= 2;
    }
    return Dt;
  }
  function te(Q) {
    for (var pt = Q[0], _t = Q[1] - 1; _t >= 0; ) pt & 1 << _t && (yt |= 1 << st), _t--, --st < 0 && (yt == 255 ? (Ut(255), Ut(0)) : Ut(yt), st = 7, yt = 0);
  }
  function Ut(Q) {
    ot.push(Q);
  }
  function se(Q) {
    Ut(Q >> 8 & 255), Ut(255 & Q);
  }
  function ee(Q, pt, _t, Ct, Dt) {
    for (var Ot, Vt = Dt[0], Wt = Dt[240], xe = function(oe, ye) {
      var De, Ae, $e, hi, si, _i, Ii, he, Ke, ai, Pe = 0;
      for (Ke = 0; Ke < 8; ++Ke) {
        De = oe[Pe], Ae = oe[Pe + 1], $e = oe[Pe + 2], hi = oe[Pe + 3], si = oe[Pe + 4], _i = oe[Pe + 5], Ii = oe[Pe + 6];
        var lr = De + (he = oe[Pe + 7]), ue = De - he, ni = Ae + Ii, Te = Ae - Ii, ki = $e + _i, vr = $e - _i, Me = hi + si, Ur = hi - si, qi = lr + Me, Ir = lr - Me, kr = ni + ki, ht = ni - ki;
        oe[Pe] = qi + kr, oe[Pe + 4] = qi - kr;
        var O = 0.707106781 * (ht + Ir);
        oe[Pe + 2] = Ir + O, oe[Pe + 6] = Ir - O;
        var V = 0.382683433 * ((qi = Ur + vr) - (ht = Te + ue)), it = 0.5411961 * qi + V, ct = 1.306562965 * ht + V, At = 0.707106781 * (kr = vr + Te), Et = ue + At, wt = ue - At;
        oe[Pe + 5] = wt + it, oe[Pe + 3] = wt - it, oe[Pe + 1] = Et + ct, oe[Pe + 7] = Et - ct, Pe += 8;
      }
      for (Pe = 0, Ke = 0; Ke < 8; ++Ke) {
        De = oe[Pe], Ae = oe[Pe + 8], $e = oe[Pe + 16], hi = oe[Pe + 24], si = oe[Pe + 32], _i = oe[Pe + 40], Ii = oe[Pe + 48];
        var xt = De + (he = oe[Pe + 56]), $t = De - he, re = Ae + Ii, Rt = Ae - Ii, fe = $e + _i, Ne = $e - _i, Ve = hi + si, ei = hi - si, mi = xt + Ve, He = xt - Ve, Ti = re + fe, Di = re - fe;
        oe[Pe] = mi + Ti, oe[Pe + 32] = mi - Ti;
        var Oi = 0.707106781 * (Di + He);
        oe[Pe + 16] = He + Oi, oe[Pe + 48] = He - Oi;
        var oi = 0.382683433 * ((mi = ei + Ne) - (Di = Rt + $t)), Ci = 0.5411961 * mi + oi, Ui = 1.306562965 * Di + oi, rr = 0.707106781 * (Ti = Ne + Rt), pr = $t + rr, fr = $t - rr;
        oe[Pe + 40] = fr + Ci, oe[Pe + 24] = fr - Ci, oe[Pe + 8] = pr + Ui, oe[Pe + 56] = pr - Ui, Pe++;
      }
      for (Ke = 0; Ke < 64; ++Ke) ai = oe[Ke] * ye[Ke], F[Ke] = ai > 0 ? ai + 0.5 | 0 : ai - 0.5 | 0;
      return F;
    }(Q, pt), ve = 0; ve < 64; ++ve) mt[jt[ve]] = xe[ve];
    var ke = mt[0] - _t;
    _t = mt[0], ke == 0 ? te(Ct[0]) : (te(Ct[U[Ot = 32767 + ke]]), te(q[Ot]));
    for (var ze = 63; ze > 0 && mt[ze] == 0; ) ze--;
    if (ze == 0) return te(Vt), _t;
    for (var Je, ie = 1; ie <= ze; ) {
      for (var K = ie; mt[ie] == 0 && ie <= ze; ) ++ie;
      var ci = ie - K;
      if (ci >= 16) {
        Je = ci >> 4;
        for (var Ue = 1; Ue <= Je; ++Ue) te(Wt);
        ci &= 15;
      }
      Ot = 32767 + mt[ie], te(Dt[(ci << 4) + U[Ot]]), te(q[Ot]), ie++;
    }
    return ze != 63 && te(Vt), _t;
  }
  function be(Q) {
    Q = Math.min(Math.max(Q, 1), 100), A != Q && (function(pt) {
      for (var _t = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Ct = 0; Ct < 64; Ct++) {
        var Dt = v((_t[Ct] * pt + 50) / 100);
        Dt = Math.min(Math.max(Dt, 1), 255), l[jt[Ct]] = Dt;
      }
      for (var Ot = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], Vt = 0; Vt < 64; Vt++) {
        var Wt = v((Ot[Vt] * pt + 50) / 100);
        Wt = Math.min(Math.max(Wt, 1), 255), M[jt[Vt]] = Wt;
      }
      for (var xe = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], ve = 0, ke = 0; ke < 8; ke++) for (var ze = 0; ze < 8; ze++) B[ve] = 1 / (l[jt[ve]] * xe[ke] * xe[ze] * 8), $[ve] = 1 / (M[jt[ve]] * xe[ke] * xe[ze] * 8), ve++;
    }(Q < 50 ? Math.floor(5e3 / Q) : Math.floor(200 - 2 * Q)), A = Q);
  }
  this.encode = function(Q, pt) {
    pt && be(pt), ot = new Array(), yt = 0, st = 7, se(65496), se(65504), se(16), Ut(74), Ut(70), Ut(73), Ut(70), Ut(0), Ut(1), Ut(1), Ut(0), se(1), se(1), Ut(0), Ut(0), function() {
      se(65499), se(132), Ut(0);
      for (var Ae = 0; Ae < 64; Ae++) Ut(l[Ae]);
      Ut(1);
      for (var $e = 0; $e < 64; $e++) Ut(M[$e]);
    }(), function(Ae, $e) {
      se(65472), se(17), Ut(8), se($e), se(Ae), Ut(3), Ut(1), Ut(17), Ut(0), Ut(2), Ut(17), Ut(1), Ut(3), Ut(17), Ut(1);
    }(Q.width, Q.height), function() {
      se(65476), se(418), Ut(0);
      for (var Ae = 0; Ae < 16; Ae++) Ut(Tt[Ae + 1]);
      for (var $e = 0; $e <= 11; $e++) Ut(le[$e]);
      Ut(16);
      for (var hi = 0; hi < 16; hi++) Ut(ne[hi + 1]);
      for (var si = 0; si <= 161; si++) Ut(at[si]);
      Ut(1);
      for (var _i = 0; _i < 16; _i++) Ut(lt[_i + 1]);
      for (var Ii = 0; Ii <= 11; Ii++) Ut(Pt[Ii]);
      Ut(17);
      for (var he = 0; he < 16; he++) Ut(bt[he + 1]);
      for (var Ke = 0; Ke <= 161; Ke++) Ut(Jt[Ke]);
    }(), se(65498), se(12), Ut(3), Ut(1), Ut(0), Ut(2), Ut(17), Ut(3), Ut(17), Ut(0), Ut(63), Ut(0);
    var _t = 0, Ct = 0, Dt = 0;
    yt = 0, st = 7, this.encode.displayName = "_encode_";
    for (var Ot, Vt, Wt, xe, ve, ke, ze, Je, ie, K = Q.data, ci = Q.width, Ue = Q.height, oe = 4 * ci, ye = 0; ye < Ue; ) {
      for (Ot = 0; Ot < oe; ) {
        for (ve = oe * ye + Ot, ze = -1, Je = 0, ie = 0; ie < 64; ie++) ke = ve + (Je = ie >> 3) * oe + (ze = 4 * (7 & ie)), ye + Je >= Ue && (ke -= oe * (ye + 1 + Je - Ue)), Ot + ze >= oe && (ke -= Ot + ze - oe + 4), Vt = K[ke++], Wt = K[ke++], xe = K[ke++], gt[ie] = (pe[Vt] + pe[Wt + 256 >> 0] + pe[xe + 512 >> 0] >> 16) - 128, Mt[ie] = (pe[Vt + 768 >> 0] + pe[Wt + 1024 >> 0] + pe[xe + 1280 >> 0] >> 16) - 128, Qt[ie] = (pe[Vt + 1280 >> 0] + pe[Wt + 1536 >> 0] + pe[xe + 1792 >> 0] >> 16) - 128;
        _t = ee(gt, B, _t, g, x), Ct = ee(Mt, $, Ct, y, P), Dt = ee(Qt, $, Dt, y, P), Ot += 32;
      }
      ye += 8;
    }
    if (st >= 0) {
      var De = [];
      De[1] = st + 1, De[0] = (1 << st + 1) - 1, te(De);
    }
    return se(65497), new Uint8Array(ot);
  }, b = b || 50, function() {
    for (var Q = String.fromCharCode, pt = 0; pt < 256; pt++) Ht[pt] = Q(pt);
  }(), g = Yt(Tt, le), y = Yt(lt, Pt), x = Yt(ne, at), P = Yt(bt, Jt), function() {
    for (var Q = 1, pt = 2, _t = 1; _t <= 15; _t++) {
      for (var Ct = Q; Ct < pt; Ct++) U[32767 + Ct] = _t, q[32767 + Ct] = [], q[32767 + Ct][1] = _t, q[32767 + Ct][0] = Ct;
      for (var Dt = -(pt - 1); Dt <= -Q; Dt++) U[32767 + Dt] = _t, q[32767 + Dt] = [], q[32767 + Dt][1] = _t, q[32767 + Dt][0] = pt - 1 + Dt;
      Q <<= 1, pt <<= 1;
    }
  }(), function() {
    for (var Q = 0; Q < 256; Q++) pe[Q] = 19595 * Q, pe[Q + 256 >> 0] = 38470 * Q, pe[Q + 512 >> 0] = 7471 * Q + 32768, pe[Q + 768 >> 0] = -11059 * Q, pe[Q + 1024 >> 0] = -21709 * Q, pe[Q + 1280 >> 0] = 32768 * Q + 8421375, pe[Q + 1536 >> 0] = -27439 * Q, pe[Q + 1792 >> 0] = -5329 * Q;
  }(), be(b);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function Oa(b, g) {
  if (this.pos = 0, this.buffer = b, this.datav = new DataView(b.buffer), this.is_with_alpha = !!g, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function Hp(b) {
  function g(Tt) {
    if (!Tt) throw Error("assert :P");
  }
  function y(Tt, le, ne) {
    for (var at = 0; 4 > at; at++) if (Tt[le + at] != ne.charCodeAt(at)) return !0;
    return !1;
  }
  function x(Tt, le, ne, at, lt) {
    for (var Pt = 0; Pt < lt; Pt++) Tt[le + Pt] = ne[at + Pt];
  }
  function P(Tt, le, ne, at) {
    for (var lt = 0; lt < at; lt++) Tt[le + lt] = ne;
  }
  function A(Tt) {
    return new Int32Array(Tt);
  }
  function v(Tt, le) {
    for (var ne = [], at = 0; at < Tt; at++) ne.push(new le());
    return ne;
  }
  function l(Tt, le) {
    var ne = [];
    return function at(lt, Pt, bt) {
      for (var Jt = bt[Pt], Yt = 0; Yt < Jt && (lt.push(bt.length > Pt + 1 ? [] : new le()), !(bt.length < Pt + 1)); Yt++) at(lt[Yt], Pt + 1, bt);
    }(ne, 0, Tt), ne;
  }
  var M = function() {
    var Tt = this;
    function le(r, a) {
      for (var h = 1 << a - 1 >>> 0; r & h; ) h >>>= 1;
      return h ? (r & h - 1) + h : r;
    }
    function ne(r, a, h, d, _) {
      g(!(d % h));
      do
        r[a + (d -= h)] = _;
      while (0 < d);
    }
    function at(r, a, h, d, _) {
      if (g(2328 >= _), 512 >= _) var w = A(512);
      else if ((w = A(_)) == null) return 0;
      return function(k, T, C, z, R, W) {
        var Z, G, nt = T, Y = 1 << C, J = A(16), tt = A(16);
        for (g(R != 0), g(z != null), g(k != null), g(0 < C), G = 0; G < R; ++G) {
          if (15 < z[G]) return 0;
          ++J[z[G]];
        }
        if (J[0] == R) return 0;
        for (tt[1] = 0, Z = 1; 15 > Z; ++Z) {
          if (J[Z] > 1 << Z) return 0;
          tt[Z + 1] = tt[Z] + J[Z];
        }
        for (G = 0; G < R; ++G) Z = z[G], 0 < z[G] && (W[tt[Z]++] = G);
        if (tt[15] == 1) return (z = new lt()).g = 0, z.value = W[0], ne(k, nt, 1, Y, z), Y;
        var ut, St = -1, It = Y - 1, Gt = 0, qt = 1, Zt = 1, Bt = 1 << C;
        for (G = 0, Z = 1, R = 2; Z <= C; ++Z, R <<= 1) {
          if (qt += Zt <<= 1, 0 > (Zt -= J[Z])) return 0;
          for (; 0 < J[Z]; --J[Z]) (z = new lt()).g = Z, z.value = W[G++], ne(k, nt + Gt, R, Bt, z), Gt = le(Gt, Z);
        }
        for (Z = C + 1, R = 2; 15 >= Z; ++Z, R <<= 1) {
          if (qt += Zt <<= 1, 0 > (Zt -= J[Z])) return 0;
          for (; 0 < J[Z]; --J[Z]) {
            if (z = new lt(), (Gt & It) != St) {
              for (nt += Bt, ut = 1 << (St = Z) - C; 15 > St && !(0 >= (ut -= J[St])); ) ++St, ut <<= 1;
              Y += Bt = 1 << (ut = St - C), k[T + (St = Gt & It)].g = ut + C, k[T + St].value = nt - T - St;
            }
            z.g = Z - C, z.value = W[G++], ne(k, nt + (Gt >> C), R, Bt, z), Gt = le(Gt, Z);
          }
        }
        return qt != 2 * tt[15] - 1 ? 0 : Y;
      }(r, a, h, d, _, w);
    }
    function lt() {
      this.value = this.g = 0;
    }
    function Pt() {
      this.value = this.g = 0;
    }
    function bt() {
      this.G = v(5, lt), this.H = A(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = v(Gr, Pt);
    }
    function Jt(r, a, h, d) {
      g(r != null), g(a != null), g(2147483648 > d), r.Ca = 254, r.I = 0, r.b = -8, r.Ka = 0, r.oa = a, r.pa = h, r.Jd = a, r.Yc = h + d, r.Zc = 4 <= d ? h + d - 4 + 1 : h, Ot(r);
    }
    function Yt(r, a) {
      for (var h = 0; 0 < a--; ) h |= Wt(r, 128) << a;
      return h;
    }
    function te(r, a) {
      var h = Yt(r, a);
      return Vt(r) ? -h : h;
    }
    function Ut(r, a, h, d) {
      var _, w = 0;
      for (g(r != null), g(a != null), g(4294967288 > d), r.Sb = d, r.Ra = 0, r.u = 0, r.h = 0, 4 < d && (d = 4), _ = 0; _ < d; ++_) w += a[h + _] << 8 * _;
      r.Ra = w, r.bb = d, r.oa = a, r.pa = h;
    }
    function se(r) {
      for (; 8 <= r.u && r.bb < r.Sb; ) r.Ra >>>= 8, r.Ra += r.oa[r.pa + r.bb] << En - 8 >>> 0, ++r.bb, r.u -= 8;
      _t(r) && (r.h = 1, r.u = 0);
    }
    function ee(r, a) {
      if (g(0 <= a), !r.h && a <= ps) {
        var h = pt(r) & ia[a];
        return r.u += a, se(r), h;
      }
      return r.h = 1, r.u = 0;
    }
    function be() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function Q() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function pt(r) {
      return r.Ra >>> (r.u & En - 1) >>> 0;
    }
    function _t(r) {
      return g(r.bb <= r.Sb), r.h || r.bb == r.Sb && r.u > En;
    }
    function Ct(r, a) {
      r.u = a, r.h = _t(r);
    }
    function Dt(r) {
      r.u >= ra && (g(r.u >= ra), se(r));
    }
    function Ot(r) {
      g(r != null && r.oa != null), r.pa < r.Zc ? (r.I = (r.oa[r.pa++] | r.I << 8) >>> 0, r.b += 8) : (g(r != null && r.oa != null), r.pa < r.Yc ? (r.b += 8, r.I = r.oa[r.pa++] | r.I << 8) : r.Ka ? r.b = 0 : (r.I <<= 8, r.b += 8, r.Ka = 1));
    }
    function Vt(r) {
      return Yt(r, 1);
    }
    function Wt(r, a) {
      var h = r.Ca;
      0 > r.b && Ot(r);
      var d = r.b, _ = h * a >>> 8, w = (r.I >>> d > _) + 0;
      for (w ? (h -= _, r.I -= _ + 1 << d >>> 0) : h = _ + 1, d = h, _ = 0; 256 <= d; ) _ += 8, d >>= 8;
      return d = 7 ^ _ + Nr[d], r.b -= d, r.Ca = (h << d) - 1, w;
    }
    function xe(r, a, h) {
      r[a + 0] = h >> 24 & 255, r[a + 1] = h >> 16 & 255, r[a + 2] = h >> 8 & 255, r[a + 3] = h >> 0 & 255;
    }
    function ve(r, a) {
      return r[a + 0] << 0 | r[a + 1] << 8;
    }
    function ke(r, a) {
      return ve(r, a) | r[a + 2] << 16;
    }
    function ze(r, a) {
      return ve(r, a) | ve(r, a + 2) << 16;
    }
    function Je(r, a) {
      var h = 1 << a;
      return g(r != null), g(0 < a), r.X = A(h), r.X == null ? 0 : (r.Mb = 32 - a, r.Xa = a, 1);
    }
    function ie(r, a) {
      g(r != null), g(a != null), g(r.Xa == a.Xa), x(a.X, 0, r.X, 0, 1 << a.Xa);
    }
    function K() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function ci(r, a, h, d) {
      g(h != null), g(d != null);
      var _ = h[0], w = d[0];
      return _ == 0 && (_ = (r * w + a / 2) / a), w == 0 && (w = (a * _ + r / 2) / r), 0 >= _ || 0 >= w ? 0 : (h[0] = _, d[0] = w, 1);
    }
    function Ue(r, a) {
      return r + (1 << a) - 1 >>> a;
    }
    function oe(r, a) {
      return ((4278255360 & r) + (4278255360 & a) >>> 0 & 4278255360) + ((16711935 & r) + (16711935 & a) >>> 0 & 16711935) >>> 0;
    }
    function ye(r, a) {
      Tt[a] = function(h, d, _, w, k, T, C) {
        var z;
        for (z = 0; z < k; ++z) {
          var R = Tt[r](T[C + z - 1], _, w + z);
          T[C + z] = oe(h[d + z], R);
        }
      };
    }
    function De() {
      this.ud = this.hd = this.jd = 0;
    }
    function Ae(r, a) {
      return ((4278124286 & (r ^ a)) >>> 1) + (r & a) >>> 0;
    }
    function $e(r) {
      return 0 <= r && 256 > r ? r : 0 > r ? 0 : 255 < r ? 255 : void 0;
    }
    function hi(r, a) {
      return $e(r + (r - a + 0.5 >> 1));
    }
    function si(r, a, h) {
      return Math.abs(a - h) - Math.abs(r - h);
    }
    function _i(r, a, h, d, _, w, k) {
      for (d = w[k - 1], h = 0; h < _; ++h) w[k + h] = d = oe(r[a + h], d);
    }
    function Ii(r, a, h, d, _) {
      var w;
      for (w = 0; w < h; ++w) {
        var k = r[a + w], T = k >> 8 & 255, C = 16711935 & (C = (C = 16711935 & k) + ((T << 16) + T));
        d[_ + w] = (4278255360 & k) + C >>> 0;
      }
    }
    function he(r, a) {
      a.jd = r >> 0 & 255, a.hd = r >> 8 & 255, a.ud = r >> 16 & 255;
    }
    function Ke(r, a, h, d, _, w) {
      var k;
      for (k = 0; k < d; ++k) {
        var T = a[h + k], C = T >>> 8, z = T, R = 255 & (R = (R = T >>> 16) + ((r.jd << 24 >> 24) * (C << 24 >> 24) >>> 5));
        z = 255 & (z = (z = z + ((r.hd << 24 >> 24) * (C << 24 >> 24) >>> 5)) + ((r.ud << 24 >> 24) * (R << 24 >> 24) >>> 5)), _[w + k] = (4278255360 & T) + (R << 16) + z;
      }
    }
    function ai(r, a, h, d, _) {
      Tt[a] = function(w, k, T, C, z, R, W, Z, G) {
        for (C = W; C < Z; ++C) for (W = 0; W < G; ++W) z[R++] = _(T[d(w[k++])]);
      }, Tt[r] = function(w, k, T, C, z, R, W) {
        var Z = 8 >> w.b, G = w.Ea, nt = w.K[0], Y = w.w;
        if (8 > Z) for (w = (1 << w.b) - 1, Y = (1 << Z) - 1; k < T; ++k) {
          var J, tt = 0;
          for (J = 0; J < G; ++J) J & w || (tt = d(C[z++])), R[W++] = _(nt[tt & Y]), tt >>= Z;
        }
        else Tt["VP8LMapColor" + h](C, z, nt, Y, R, W, k, T, G);
      };
    }
    function Pe(r, a, h, d, _) {
      for (h = a + h; a < h; ) {
        var w = r[a++];
        d[_++] = w >> 16 & 255, d[_++] = w >> 8 & 255, d[_++] = w >> 0 & 255;
      }
    }
    function lr(r, a, h, d, _) {
      for (h = a + h; a < h; ) {
        var w = r[a++];
        d[_++] = w >> 16 & 255, d[_++] = w >> 8 & 255, d[_++] = w >> 0 & 255, d[_++] = w >> 24 & 255;
      }
    }
    function ue(r, a, h, d, _) {
      for (h = a + h; a < h; ) {
        var w = (k = r[a++]) >> 16 & 240 | k >> 12 & 15, k = k >> 0 & 240 | k >> 28 & 15;
        d[_++] = w, d[_++] = k;
      }
    }
    function ni(r, a, h, d, _) {
      for (h = a + h; a < h; ) {
        var w = (k = r[a++]) >> 16 & 248 | k >> 13 & 7, k = k >> 5 & 224 | k >> 3 & 31;
        d[_++] = w, d[_++] = k;
      }
    }
    function Te(r, a, h, d, _) {
      for (h = a + h; a < h; ) {
        var w = r[a++];
        d[_++] = w >> 0 & 255, d[_++] = w >> 8 & 255, d[_++] = w >> 16 & 255;
      }
    }
    function ki(r, a, h, d, _, w) {
      if (w == 0) for (h = a + h; a < h; ) xe(d, ((w = r[a++])[0] >> 24 | w[1] >> 8 & 65280 | w[2] << 8 & 16711680 | w[3] << 24) >>> 0), _ += 32;
      else x(d, _, r, a, h);
    }
    function vr(r, a) {
      Tt[a][0] = Tt[r + "0"], Tt[a][1] = Tt[r + "1"], Tt[a][2] = Tt[r + "2"], Tt[a][3] = Tt[r + "3"], Tt[a][4] = Tt[r + "4"], Tt[a][5] = Tt[r + "5"], Tt[a][6] = Tt[r + "6"], Tt[a][7] = Tt[r + "7"], Tt[a][8] = Tt[r + "8"], Tt[a][9] = Tt[r + "9"], Tt[a][10] = Tt[r + "10"], Tt[a][11] = Tt[r + "11"], Tt[a][12] = Tt[r + "12"], Tt[a][13] = Tt[r + "13"], Tt[a][14] = Tt[r + "0"], Tt[a][15] = Tt[r + "0"];
    }
    function Me(r) {
      return r == ho || r == Go || r == Wo || r == Ho;
    }
    function Ur() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function qi() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function Ir() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new Ur(), this.f.kb = new qi(), this.sd = null;
    }
    function kr() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ht() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function O(r) {
      return alert("todo:WebPSamplerProcessPlane"), r.T;
    }
    function V(r, a) {
      var h = r.T, d = a.ba.f.RGBA, _ = d.eb, w = d.fb + r.ka * d.A, k = ui[a.ba.S], T = r.y, C = r.O, z = r.f, R = r.N, W = r.ea, Z = r.W, G = a.cc, nt = a.dc, Y = a.Mc, J = a.Nc, tt = r.ka, ut = r.ka + r.T, St = r.U, It = St + 1 >> 1;
      for (tt == 0 ? k(T, C, null, null, z, R, W, Z, z, R, W, Z, _, w, null, null, St) : (k(a.ec, a.fc, T, C, G, nt, Y, J, z, R, W, Z, _, w - d.A, _, w, St), ++h); tt + 2 < ut; tt += 2) G = z, nt = R, Y = W, J = Z, R += r.Rc, Z += r.Rc, w += 2 * d.A, k(T, (C += 2 * r.fa) - r.fa, T, C, G, nt, Y, J, z, R, W, Z, _, w - d.A, _, w, St);
      return C += r.fa, r.j + ut < r.o ? (x(a.ec, a.fc, T, C, St), x(a.cc, a.dc, z, R, It), x(a.Mc, a.Nc, W, Z, It), h--) : 1 & ut || k(T, C, null, null, z, R, W, Z, z, R, W, Z, _, w + d.A, null, null, St), h;
    }
    function it(r, a, h) {
      var d = r.F, _ = [r.J];
      if (d != null) {
        var w = r.U, k = a.ba.S, T = k == co || k == Wo;
        a = a.ba.f.RGBA;
        var C = [0], z = r.ka;
        C[0] = r.T, r.Kb && (z == 0 ? --C[0] : (--z, _[0] -= r.width), r.j + r.ka + r.T == r.o && (C[0] = r.o - r.j - z));
        var R = a.eb;
        z = a.fb + z * a.A, r = sa(d, _[0], r.width, w, C, R, z + (T ? 0 : 3), a.A), g(h == C), r && Me(k) && bn(R, z, T, w, C, a.A);
      }
      return 0;
    }
    function ct(r) {
      var a = r.ma, h = a.ba.S, d = 11 > h, _ = h == Ea || h == lo || h == co || h == Zo || h == 12 || Me(h);
      if (a.memory = null, a.Ib = null, a.Jb = null, a.Nd = null, !Xn(a.Oa, r, _ ? 11 : 12)) return 0;
      if (_ && Me(h) && _e(), r.da) alert("todo:use_scaling");
      else {
        if (d) {
          if (a.Ib = O, r.Kb) {
            if (h = r.U + 1 >> 1, a.memory = A(r.U + 2 * h), a.memory == null) return 0;
            a.ec = a.memory, a.fc = 0, a.cc = a.ec, a.dc = a.fc + r.U, a.Mc = a.cc, a.Nc = a.dc + h, a.Ib = V, _e();
          }
        } else alert("todo:EmitYUV");
        _ && (a.Jb = it, d && Ft());
      }
      if (d && !Vi) {
        for (r = 0; 256 > r; ++r) dl[r] = 89858 * (r - 128) + go >> mo, rc[r] = -22014 * (r - 128) + go, yo[r] = -45773 * (r - 128), pl[r] = 113618 * (r - 128) + go >> mo;
        for (r = Ma; r < Yo; ++r) a = 76283 * (r - 16) + go >> mo, nc[r - Ma] = nn(a, 255), sc[r - Ma] = nn(a + 8 >> 4, 15);
        Vi = 1;
      }
      return 1;
    }
    function At(r) {
      var a = r.ma, h = r.U, d = r.T;
      return g(!(1 & r.ka)), 0 >= h || 0 >= d ? 0 : (h = a.Ib(r, a), a.Jb != null && a.Jb(r, a, h), a.Dc += h, 1);
    }
    function Et(r) {
      r.ma.memory = null;
    }
    function wt(r, a, h, d) {
      return ee(r, 8) != 47 ? 0 : (a[0] = ee(r, 14) + 1, h[0] = ee(r, 14) + 1, d[0] = ee(r, 1), ee(r, 3) != 0 ? 0 : !r.h);
    }
    function xt(r, a) {
      if (4 > r) return r + 1;
      var h = r - 2 >> 1;
      return (2 + (1 & r) << h) + ee(a, h) + 1;
    }
    function $t(r, a) {
      return 120 < a ? a - 120 : 1 <= (h = ((h = Qn[a - 1]) >> 4) * r + (8 - (15 & h))) ? h : 1;
      var h;
    }
    function re(r, a, h) {
      var d = pt(h), _ = r[a += 255 & d].g - 8;
      return 0 < _ && (Ct(h, h.u + 8), d = pt(h), a += r[a].value, a += d & (1 << _) - 1), Ct(h, h.u + r[a].g), r[a].value;
    }
    function Rt(r, a, h) {
      return h.g += r.g, h.value += r.value << a >>> 0, g(8 >= h.g), r.g;
    }
    function fe(r, a, h) {
      var d = r.xc;
      return g((a = d == 0 ? 0 : r.vc[r.md * (h >> d) + (a >> d)]) < r.Wb), r.Ya[a];
    }
    function Ne(r, a, h, d) {
      var _ = r.ab, w = r.c * a, k = r.C;
      a = k + a;
      var T = h, C = d;
      for (d = r.Ta, h = r.Ua; 0 < _--; ) {
        var z = r.gc[_], R = k, W = a, Z = T, G = C, nt = (C = d, T = h, z.Ea);
        switch (g(R < W), g(W <= z.nc), z.hc) {
          case 2:
            Uo(Z, G, (W - R) * nt, C, T);
            break;
          case 0:
            var Y = R, J = W, tt = C, ut = T, St = (Bt = z).Ea;
            Y == 0 && (Ia(Z, G, null, null, 1, tt, ut), _i(Z, G + 1, 0, 0, St - 1, tt, ut + 1), G += St, ut += St, ++Y);
            for (var It = 1 << Bt.b, Gt = It - 1, qt = Ue(St, Bt.b), Zt = Bt.K, Bt = Bt.w + (Y >> Bt.b) * qt; Y < J; ) {
              var ge = Zt, Le = Bt, ce = 1;
              for (na(Z, G, tt, ut - St, 1, tt, ut); ce < St; ) {
                var de = (ce & ~Gt) + It;
                de > St && (de = St), (0, yi[ge[Le++] >> 8 & 15])(Z, G + +ce, tt, ut + ce - St, de - ce, tt, ut + ce), ce = de;
              }
              G += St, ut += St, ++Y & Gt || (Bt += qt);
            }
            W != z.nc && x(C, T - nt, C, T + (W - R - 1) * nt, nt);
            break;
          case 1:
            for (nt = Z, J = G, St = (Z = z.Ea) - (ut = Z & ~(tt = (G = 1 << z.b) - 1)), Y = Ue(Z, z.b), It = z.K, z = z.w + (R >> z.b) * Y; R < W; ) {
              for (Gt = It, qt = z, Zt = new De(), Bt = J + ut, ge = J + Z; J < Bt; ) he(Gt[qt++], Zt), sn(Zt, nt, J, G, C, T), J += G, T += G;
              J < ge && (he(Gt[qt++], Zt), sn(Zt, nt, J, St, C, T), J += St, T += St), ++R & tt || (z += Y);
            }
            break;
          case 3:
            if (Z == C && G == T && 0 < z.b) {
              for (J = C, Z = nt = T + (W - R) * nt - (ut = (W - R) * Ue(z.Ea, z.b)), G = C, tt = T, Y = [], ut = (St = ut) - 1; 0 <= ut; --ut) Y[ut] = G[tt + ut];
              for (ut = St - 1; 0 <= ut; --ut) J[Z + ut] = Y[ut];
              Wr(z, R, W, C, nt, C, T);
            } else Wr(z, R, W, Z, G, C, T);
        }
        T = d, C = h;
      }
      C != h && x(d, h, T, C, w);
    }
    function Ve(r, a) {
      var h = r.V, d = r.Ba + r.c * r.C, _ = a - r.C;
      if (g(a <= r.l.o), g(16 >= _), 0 < _) {
        var w = r.l, k = r.Ta, T = r.Ua, C = w.width;
        if (Ne(r, _, h, d), _ = T = [T], g((h = r.C) < (d = a)), g(w.v < w.va), d > w.o && (d = w.o), h < w.j) {
          var z = w.j - h;
          h = w.j, _[0] += z * C;
        }
        if (h >= d ? h = 0 : (_[0] += 4 * w.v, w.ka = h - w.j, w.U = w.va - w.v, w.T = d - h, h = 1), h) {
          if (T = T[0], 11 > (h = r.ca).S) {
            var R = h.f.RGBA, W = (d = h.S, _ = w.U, w = w.T, z = R.eb, R.A), Z = w;
            for (R = R.fb + r.Ma * R.A; 0 < Z--; ) {
              var G = k, nt = T, Y = _, J = z, tt = R;
              switch (d) {
                case ao:
                  Mn(G, nt, Y, J, tt);
                  break;
                case Ea:
                  ms(G, nt, Y, J, tt);
                  break;
                case ho:
                  ms(G, nt, Y, J, tt), bn(J, tt, 0, Y, 1, 0);
                  break;
                case oo:
                  Ms(G, nt, Y, J, tt);
                  break;
                case lo:
                  ki(G, nt, Y, J, tt, 1);
                  break;
                case Go:
                  ki(G, nt, Y, J, tt, 1), bn(J, tt, 0, Y, 1, 0);
                  break;
                case co:
                  ki(G, nt, Y, J, tt, 0);
                  break;
                case Wo:
                  ki(G, nt, Y, J, tt, 0), bn(J, tt, 1, Y, 1, 0);
                  break;
                case Zo:
                  hn(G, nt, Y, J, tt);
                  break;
                case Ho:
                  hn(G, nt, Y, J, tt), _s(J, tt, Y, 1, 0);
                  break;
                case Ns:
                  Jn(G, nt, Y, J, tt);
                  break;
                default:
                  g(0);
              }
              T += C, R += W;
            }
            r.Ma += w;
          } else alert("todo:EmitRescaledRowsYUVA");
          g(r.Ma <= h.height);
        }
      }
      r.C = a, g(r.C <= r.i);
    }
    function ei(r) {
      var a;
      if (0 < r.ua) return 0;
      for (a = 0; a < r.Wb; ++a) {
        var h = r.Ya[a].G, d = r.Ya[a].H;
        if (0 < h[1][d[1] + 0].g || 0 < h[2][d[2] + 0].g || 0 < h[3][d[3] + 0].g) return 0;
      }
      return 1;
    }
    function mi(r, a, h, d, _, w) {
      if (r.Z != 0) {
        var k = r.qd, T = r.rd;
        for (g(pn[r.Z] != null); a < h; ++a) pn[r.Z](k, T, d, _, d, _, w), k = d, T = _, _ += w;
        r.qd = k, r.rd = T;
      }
    }
    function He(r, a) {
      var h = r.l.ma, d = h.Z == 0 || h.Z == 1 ? r.l.j : r.C;
      if (d = r.C < d ? d : r.C, g(a <= r.l.o), a > d) {
        var _ = r.l.width, w = h.ca, k = h.tb + _ * d, T = r.V, C = r.Ba + r.c * d, z = r.gc;
        g(r.ab == 1), g(z[0].hc == 3), Vo(z[0], d, a, T, C, w, k), mi(h, d, a, w, k, _);
      }
      r.C = r.Ma = a;
    }
    function Ti(r, a, h, d, _, w, k) {
      var T = r.$ / d, C = r.$ % d, z = r.m, R = r.s, W = h + r.$, Z = W;
      _ = h + d * _;
      var G = h + d * w, nt = 280 + R.ua, Y = r.Pb ? T : 16777216, J = 0 < R.ua ? R.Wa : null, tt = R.wc, ut = W < G ? fe(R, C, T) : null;
      g(r.C < w), g(G <= _);
      var St = !1;
      t: for (; ; ) {
        for (; St || W < G; ) {
          var It = 0;
          if (T >= Y) {
            var Gt = W - h;
            g((Y = r).Pb), Y.wd = Y.m, Y.xd = Gt, 0 < Y.s.ua && ie(Y.s.Wa, Y.s.vb), Y = T + Ll;
          }
          if (C & tt || (ut = fe(R, C, T)), g(ut != null), ut.Qb && (a[W] = ut.qb, St = !0), !St) if (Dt(z), ut.jc) {
            It = z, Gt = a;
            var qt = W, Zt = ut.pd[pt(It) & Gr - 1];
            g(ut.jc), 256 > Zt.g ? (Ct(It, It.u + Zt.g), Gt[qt] = Zt.value, It = 0) : (Ct(It, It.u + Zt.g - 256), g(256 <= Zt.value), It = Zt.value), It == 0 && (St = !0);
          } else It = re(ut.G[0], ut.H[0], z);
          if (z.h) break;
          if (St || 256 > It) {
            if (!St) if (ut.nd) a[W] = (ut.qb | It << 8) >>> 0;
            else {
              if (Dt(z), St = re(ut.G[1], ut.H[1], z), Dt(z), Gt = re(ut.G[2], ut.H[2], z), qt = re(ut.G[3], ut.H[3], z), z.h) break;
              a[W] = (qt << 24 | St << 16 | It << 8 | Gt) >>> 0;
            }
            if (St = !1, ++W, ++C >= d && (C = 0, ++T, k != null && T <= w && !(T % 16) && k(r, T), J != null)) for (; Z < W; ) It = a[Z++], J.X[(506832829 * It & 4294967295) >>> J.Mb] = It;
          } else if (280 > It) {
            if (It = xt(It - 256, z), Gt = re(ut.G[4], ut.H[4], z), Dt(z), Gt = $t(d, Gt = xt(Gt, z)), z.h) break;
            if (W - h < Gt || _ - W < It) break t;
            for (qt = 0; qt < It; ++qt) a[W + qt] = a[W + qt - Gt];
            for (W += It, C += It; C >= d; ) C -= d, ++T, k != null && T <= w && !(T % 16) && k(r, T);
            if (g(W <= _), C & tt && (ut = fe(R, C, T)), J != null) for (; Z < W; ) It = a[Z++], J.X[(506832829 * It & 4294967295) >>> J.Mb] = It;
          } else {
            if (!(It < nt)) break t;
            for (St = It - 280, g(J != null); Z < W; ) It = a[Z++], J.X[(506832829 * It & 4294967295) >>> J.Mb] = It;
            It = W, g(!(St >>> (Gt = J).Xa)), a[It] = Gt.X[St], St = !0;
          }
          St || g(z.h == _t(z));
        }
        if (r.Pb && z.h && W < _) g(r.m.h), r.a = 5, r.m = r.wd, r.$ = r.xd, 0 < r.s.ua && ie(r.s.vb, r.s.Wa);
        else {
          if (z.h) break t;
          k != null && k(r, T > w ? w : T), r.a = 0, r.$ = W - h;
        }
        return 1;
      }
      return r.a = 3, 0;
    }
    function Di(r) {
      g(r != null), r.vc = null, r.yc = null, r.Ya = null;
      var a = r.Wa;
      a != null && (a.X = null), r.vb = null, g(r != null);
    }
    function Oi() {
      var r = new Pa();
      return r == null ? null : (r.a = 0, r.xb = fo, vr("Predictor", "VP8LPredictors"), vr("Predictor", "VP8LPredictors_C"), vr("PredictorAdd", "VP8LPredictorsAdd"), vr("PredictorAdd", "VP8LPredictorsAdd_C"), Uo = Ii, sn = Ke, Mn = Pe, ms = lr, hn = ue, Jn = ni, Ms = Te, Tt.VP8LMapColor32b = fs, Tt.VP8LMapColor8b = ro, r);
    }
    function oi(r, a, h, d, _) {
      var w = 1, k = [r], T = [a], C = d.m, z = d.s, R = null, W = 0;
      t: for (; ; ) {
        if (h) for (; w && ee(C, 1); ) {
          var Z = k, G = T, nt = d, Y = 1, J = nt.m, tt = nt.gc[nt.ab], ut = ee(J, 2);
          if (nt.Oc & 1 << ut) w = 0;
          else {
            switch (nt.Oc |= 1 << ut, tt.hc = ut, tt.Ea = Z[0], tt.nc = G[0], tt.K = [null], ++nt.ab, g(4 >= nt.ab), ut) {
              case 0:
              case 1:
                tt.b = ee(J, 3) + 2, Y = oi(Ue(tt.Ea, tt.b), Ue(tt.nc, tt.b), 0, nt, tt.K), tt.K = tt.K[0];
                break;
              case 3:
                var St, It = ee(J, 8) + 1, Gt = 16 < It ? 0 : 4 < It ? 1 : 2 < It ? 2 : 3;
                if (Z[0] = Ue(tt.Ea, Gt), tt.b = Gt, St = Y = oi(It, 1, 0, nt, tt.K)) {
                  var qt, Zt = It, Bt = tt, ge = 1 << (8 >> Bt.b), Le = A(ge);
                  if (Le == null) St = 0;
                  else {
                    var ce = Bt.K[0], de = Bt.w;
                    for (Le[0] = Bt.K[0][0], qt = 1; qt < 1 * Zt; ++qt) Le[qt] = oe(ce[de + qt], Le[qt - 1]);
                    for (; qt < 4 * ge; ++qt) Le[qt] = 0;
                    Bt.K[0] = null, Bt.K[0] = Le, St = 1;
                  }
                }
                Y = St;
                break;
              case 2:
                break;
              default:
                g(0);
            }
            w = Y;
          }
        }
        if (k = k[0], T = T[0], w && ee(C, 1) && !(w = 1 <= (W = ee(C, 4)) && 11 >= W)) {
          d.a = 3;
          break t;
        }
        var Ce;
        if (Ce = w) e: {
          var ii, we, We, Ai = d, Mi = k, sr = T, ri = W, Xi = h, Gi = Ai.m, zi = Ai.s, Fi = [null], Qi = 1, Mr = 0, fn = ts[ri];
          i: for (; ; ) {
            if (Xi && ee(Gi, 1)) {
              var ar = ee(Gi, 3) + 2, Hr = Ue(Mi, ar), ws = Ue(sr, ar), oa = Hr * ws;
              if (!oi(Hr, ws, 0, Ai, Fi)) break i;
              for (Fi = Fi[0], zi.xc = ar, ii = 0; ii < oa; ++ii) {
                var Sr = Fi[ii] >> 8 & 65535;
                Fi[ii] = Sr, Sr >= Qi && (Qi = Sr + 1);
              }
            }
            if (Gi.h) break i;
            for (we = 0; 5 > we; ++we) {
              var Ri = hl[we];
              !we && 0 < ri && (Ri += 1 << ri), Mr < Ri && (Mr = Ri);
            }
            var Ss = v(Qi * fn, lt), Nn = Qi, Xr = v(Nn, bt);
            if (Xr == null) var Ar = null;
            else g(65536 >= Nn), Ar = Xr;
            var Rr = A(Mr);
            if (Ar == null || Rr == null || Ss == null) {
              Ai.a = 1;
              break i;
            }
            var Yi = Ss;
            for (ii = We = 0; ii < Qi; ++ii) {
              var Yr = Ar[ii], Pn = Yr.G, As = Yr.H, ac = 0, fl = 1, zr = 0;
              for (we = 0; 5 > we; ++we) {
                Ri = hl[we], Pn[we] = Yi, As[we] = We, !we && 0 < ri && (Ri += 1 << ri);
                n: {
                  var is, za = Ri, la = Ai, Da = Rr, Dl = Yi, Nl = We, _o = 0, vo = la.m, Fc = ee(vo, 1);
                  if (P(Da, 0, 0, za), Fc) {
                    var oc = ee(vo, 1) + 1, ph = ee(vo, 1), lc = ee(vo, ph == 0 ? 1 : 8);
                    Da[lc] = 1, oc == 2 && (Da[lc = ee(vo, 8)] = 1);
                    var Jo = 1;
                  } else {
                    var xo = A(19), Fl = ee(vo, 4) + 4;
                    if (19 < Fl) {
                      la.a = 3;
                      var Rl = 0;
                      break n;
                    }
                    for (is = 0; is < Fl; ++is) xo[Kl[is]] = ee(vo, 3);
                    var cc = void 0, Bl = void 0, hc = la, Ol = xo, Na = za, ca = Da, rs = 0, In = hc.m, Rc = 8, bo = v(128, lt);
                    r: for (; at(bo, 0, 7, Ol, 19); ) {
                      if (ee(In, 1)) {
                        var Hh = 2 + 2 * ee(In, 3);
                        if ((cc = 2 + ee(In, Hh)) > Na) break r;
                      } else cc = Na;
                      for (Bl = 0; Bl < Na && cc--; ) {
                        Dt(In);
                        var Bc = bo[0 + (127 & pt(In))];
                        Ct(In, In.u + Bc.g);
                        var tr = Bc.value;
                        if (16 > tr) ca[Bl++] = tr, tr != 0 && (Rc = tr);
                        else {
                          var Oc = tr == 16, jc = tr - 16, Ko = Tl[jc], wo = ee(In, Jl[jc]) + Ko;
                          if (Bl + wo > Na) break r;
                          for (var uc = Oc ? Rc : 0; 0 < wo--; ) ca[Bl++] = uc;
                        }
                      }
                      rs = 1;
                      break r;
                    }
                    rs || (hc.a = 3), Jo = rs;
                  }
                  (Jo = Jo && !vo.h) && (_o = at(Dl, Nl, 8, Da, za)), Jo && _o != 0 ? Rl = _o : (la.a = 3, Rl = 0);
                }
                if (Rl == 0) break i;
                if (fl && uo[we] == 1 && (fl = Yi[We].g == 0), ac += Yi[We].g, We += Rl, 3 >= we) {
                  var Qo, dc = Rr[0];
                  for (Qo = 1; Qo < Ri; ++Qo) Rr[Qo] > dc && (dc = Rr[Qo]);
                  zr += dc;
                }
              }
              if (Yr.nd = fl, Yr.Qb = 0, fl && (Yr.qb = (Pn[3][As[3] + 0].value << 24 | Pn[1][As[1] + 0].value << 16 | Pn[2][As[2] + 0].value) >>> 0, ac == 0 && 256 > Pn[0][As[0] + 0].value && (Yr.Qb = 1, Yr.qb += Pn[0][As[0] + 0].value << 8)), Yr.jc = !Yr.Qb && 6 > zr, Yr.jc) {
                var pc, ha = Yr;
                for (pc = 0; pc < Gr; ++pc) {
                  var So = pc, ua = ha.pd[So], fc = ha.G[0][ha.H[0] + So];
                  256 <= fc.value ? (ua.g = fc.g + 256, ua.value = fc.value) : (ua.g = 0, ua.value = 0, So >>= Rt(fc, 8, ua), So >>= Rt(ha.G[1][ha.H[1] + So], 16, ua), So >>= Rt(ha.G[2][ha.H[2] + So], 0, ua), Rt(ha.G[3][ha.H[3] + So], 24, ua));
                }
              }
            }
            zi.vc = Fi, zi.Wb = Qi, zi.Ya = Ar, zi.yc = Ss, Ce = 1;
            break e;
          }
          Ce = 0;
        }
        if (!(w = Ce)) {
          d.a = 3;
          break t;
        }
        if (0 < W) {
          if (z.ua = 1 << W, !Je(z.Wa, W)) {
            d.a = 1, w = 0;
            break t;
          }
        } else z.ua = 0;
        var jl = d, qc = k, fh = T, Ao = jl.s, Uc = Ao.xc;
        if (jl.c = qc, jl.i = fh, Ao.md = Ue(qc, Uc), Ao.wc = Uc == 0 ? -1 : (1 << Uc) - 1, h) {
          d.xb = Xo;
          break t;
        }
        if ((R = A(k * T)) == null) {
          d.a = 1, w = 0;
          break t;
        }
        w = (w = Ti(d, R, 0, k, T, T, null)) && !C.h;
        break t;
      }
      return w ? (_ != null ? _[0] = R : (g(R == null), g(h)), d.$ = 0, h || Di(z)) : Di(z), w;
    }
    function Ci(r, a) {
      var h = r.c * r.i, d = h + a + 16 * a;
      return g(r.c <= a), r.V = A(d), r.V == null ? (r.Ta = null, r.Ua = 0, r.a = 1, 0) : (r.Ta = r.V, r.Ua = r.Ba + h + a, 1);
    }
    function Ui(r, a) {
      var h = r.C, d = a - h, _ = r.V, w = r.Ba + r.c * h;
      for (g(a <= r.l.o); 0 < d; ) {
        var k = 16 < d ? 16 : d, T = r.l.ma, C = r.l.width, z = C * k, R = T.ca, W = T.tb + C * h, Z = r.Ta, G = r.Ua;
        Ne(r, k, _, w), Yl(Z, G, R, W, z), mi(T, h, h + k, R, W, C), d -= k, _ += k * r.c, h += k;
      }
      g(h == a), r.C = r.Ma = a;
    }
    function rr() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function pr() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function fr() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = A(4), this.Lb = A(4);
    }
    function $s() {
      this.Yb = function() {
        var r = [];
        return function a(h, d, _) {
          for (var w = _[d], k = 0; k < w && (h.push(_.length > d + 1 ? [] : 0), !(_.length < d + 1)); k++) a(h[k], d + 1, _);
        }(r, 0, [3, 11]), r;
      }();
    }
    function Ni() {
      this.jb = A(3), this.Wc = l([4, 8], $s), this.Xc = l([4, 17], $s);
    }
    function zo() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new A(4), this.od = new A(4);
    }
    function Zs() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Vr() {
      this.Na = this.la = 0;
    }
    function tn() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Do() {
      this.ad = A(384), this.Za = 0, this.Ob = A(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function en() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Zs()), this.Y = 0, this.ya = Array(new Do()), this.aa = 0, this.l = new os();
    }
    function br() {
      this.y = A(16), this.f = A(8), this.ea = A(8);
    }
    function Ua() {
      this.cb = this.a = 0, this.sc = "", this.m = new be(), this.Od = new rr(), this.Kc = new pr(), this.ed = new zo(), this.Qa = new fr(), this.Ic = this.$c = this.Aa = 0, this.D = new en(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = v(8, be), this.ia = 0, this.pb = v(4, tn), this.Pa = new Ni(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new br()), this.Hd = 0, this.rb = Array(new Vr()), this.sb = 0, this.wa = Array(new Zs()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Do()), this.L = this.aa = 0, this.gd = l([4, 2], Zs), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function os() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function dr() {
      var r = new Ua();
      return r != null && (r.a = 0, r.sc = "OK", r.cb = 0, r.Xb = 0, aa || (aa = fa)), r;
    }
    function $i(r, a, h) {
      return r.a == 0 && (r.a = a, r.sc = h, r.cb = 0), 0;
    }
    function ls(r, a, h) {
      return 3 <= h && r[a + 0] == 157 && r[a + 1] == 1 && r[a + 2] == 42;
    }
    function nr(r, a) {
      if (r == null) return 0;
      if (r.a = 0, r.sc = "OK", a == null) return $i(r, 2, "null VP8Io passed to VP8GetHeaders()");
      var h = a.data, d = a.w, _ = a.ha;
      if (4 > _) return $i(r, 7, "Truncated header.");
      var w = h[d + 0] | h[d + 1] << 8 | h[d + 2] << 16, k = r.Od;
      if (k.Rb = !(1 & w), k.td = w >> 1 & 7, k.yd = w >> 4 & 1, k.ub = w >> 5, 3 < k.td) return $i(r, 3, "Incorrect keyframe parameters.");
      if (!k.yd) return $i(r, 4, "Frame not displayable.");
      d += 3, _ -= 3;
      var T = r.Kc;
      if (k.Rb) {
        if (7 > _) return $i(r, 7, "cannot parse picture header");
        if (!ls(h, d, _)) return $i(r, 3, "Bad code word");
        T.c = 16383 & (h[d + 4] << 8 | h[d + 3]), T.Td = h[d + 4] >> 6, T.i = 16383 & (h[d + 6] << 8 | h[d + 5]), T.Ud = h[d + 6] >> 6, d += 7, _ -= 7, r.za = T.c + 15 >> 4, r.Ub = T.i + 15 >> 4, a.width = T.c, a.height = T.i, a.Da = 0, a.j = 0, a.v = 0, a.va = a.width, a.o = a.height, a.da = 0, a.ib = a.width, a.hb = a.height, a.U = a.width, a.T = a.height, P((w = r.Pa).jb, 0, 255, w.jb.length), g((w = r.Qa) != null), w.Cb = 0, w.Bb = 0, w.Fb = 1, P(w.Zb, 0, 0, w.Zb.length), P(w.Lb, 0, 0, w.Lb);
      }
      if (k.ub > _) return $i(r, 7, "bad partition length");
      Jt(w = r.m, h, d, k.ub), d += k.ub, _ -= k.ub, k.Rb && (T.Ld = Vt(w), T.Kd = Vt(w)), T = r.Qa;
      var C, z = r.Pa;
      if (g(w != null), g(T != null), T.Cb = Vt(w), T.Cb) {
        if (T.Bb = Vt(w), Vt(w)) {
          for (T.Fb = Vt(w), C = 0; 4 > C; ++C) T.Zb[C] = Vt(w) ? te(w, 7) : 0;
          for (C = 0; 4 > C; ++C) T.Lb[C] = Vt(w) ? te(w, 6) : 0;
        }
        if (T.Bb) for (C = 0; 3 > C; ++C) z.jb[C] = Vt(w) ? Yt(w, 8) : 255;
      } else T.Bb = 0;
      if (w.Ka) return $i(r, 3, "cannot parse segment header");
      if ((T = r.ed).zd = Vt(w), T.Tb = Yt(w, 6), T.wb = Yt(w, 3), T.Pc = Vt(w), T.Pc && Vt(w)) {
        for (z = 0; 4 > z; ++z) Vt(w) && (T.vd[z] = te(w, 6));
        for (z = 0; 4 > z; ++z) Vt(w) && (T.od[z] = te(w, 6));
      }
      if (r.L = T.Tb == 0 ? 0 : T.zd ? 1 : 2, w.Ka) return $i(r, 3, "cannot parse filter header");
      var R = _;
      if (_ = C = d, d = C + R, T = R, r.Xb = (1 << Yt(r.m, 2)) - 1, R < 3 * (z = r.Xb)) h = 7;
      else {
        for (C += 3 * z, T -= 3 * z, R = 0; R < z; ++R) {
          var W = h[_ + 0] | h[_ + 1] << 8 | h[_ + 2] << 16;
          W > T && (W = T), Jt(r.Jc[+R], h, C, W), C += W, T -= W, _ += 3;
        }
        Jt(r.Jc[+z], h, C, T), h = C < d ? 0 : 5;
      }
      if (h != 0) return $i(r, h, "cannot parse partitions");
      for (h = Yt(C = r.m, 7), _ = Vt(C) ? te(C, 4) : 0, d = Vt(C) ? te(C, 4) : 0, T = Vt(C) ? te(C, 4) : 0, z = Vt(C) ? te(C, 4) : 0, C = Vt(C) ? te(C, 4) : 0, R = r.Qa, W = 0; 4 > W; ++W) {
        if (R.Cb) {
          var Z = R.Zb[W];
          R.Fb || (Z += h);
        } else {
          if (0 < W) {
            r.pb[W] = r.pb[0];
            continue;
          }
          Z = h;
        }
        var G = r.pb[W];
        G.Sc[0] = Sn[nn(Z + _, 127)], G.Sc[1] = Fs[nn(Z + 0, 127)], G.Eb[0] = 2 * Sn[nn(Z + d, 127)], G.Eb[1] = 101581 * Fs[nn(Z + T, 127)] >> 16, 8 > G.Eb[1] && (G.Eb[1] = 8), G.Qc[0] = Sn[nn(Z + z, 117)], G.Qc[1] = Fs[nn(Z + C, 127)], G.lc = Z + C;
      }
      if (!k.Rb) return $i(r, 4, "Not a key frame.");
      for (Vt(w), k = r.Pa, h = 0; 4 > h; ++h) {
        for (_ = 0; 8 > _; ++_) for (d = 0; 3 > d; ++d) for (T = 0; 11 > T; ++T) z = Wt(w, vs[h][_][d][T]) ? Yt(w, 8) : tc[h][_][d][T], k.Wc[h][_].Yb[d][T] = z;
        for (_ = 0; 17 > _; ++_) k.Xc[h][_] = k.Wc[h][Fe[_]];
      }
      return r.kc = Vt(w), r.kc && (r.Bd = Yt(w, 8)), r.cb = 1;
    }
    function fa(r, a, h, d, _, w, k) {
      var T = a[_].Yb[h];
      for (h = 0; 16 > _; ++_) {
        if (!Wt(r, T[h + 0])) return _;
        for (; !Wt(r, T[h + 1]); ) if (T = a[++_].Yb[0], h = 0, _ == 16) return 16;
        var C = a[_ + 1].Yb;
        if (Wt(r, T[h + 2])) {
          var z = r, R = 0;
          if (Wt(z, (Z = T)[(W = h) + 3])) if (Wt(z, Z[W + 6])) {
            for (T = 0, W = 2 * (R = Wt(z, Z[W + 8])) + (Z = Wt(z, Z[W + 9 + R])), R = 0, Z = Dc[W]; Z[T]; ++T) R += R + Wt(z, Z[T]);
            R += 3 + (8 << W);
          } else Wt(z, Z[W + 7]) ? (R = 7 + 2 * Wt(z, 165), R += Wt(z, 145)) : R = 5 + Wt(z, 159);
          else R = Wt(z, Z[W + 4]) ? 3 + Wt(z, Z[W + 5]) : 2;
          T = C[2];
        } else R = 1, T = C[1];
        C = k + Cl[_], 0 > (z = r).b && Ot(z);
        var W, Z = z.b, G = (W = z.Ca >> 1) - (z.I >> Z) >> 31;
        --z.b, z.Ca += G, z.Ca |= 1, z.I -= (W + 1 & G) << Z, w[C] = ((R ^ G) - G) * d[(0 < _) + 0];
      }
      return 16;
    }
    function $r(r) {
      var a = r.rb[r.sb - 1];
      a.la = 0, a.Na = 0, P(r.zc, 0, 0, r.zc.length), r.ja = 0;
    }
    function ma(r, a) {
      if (r == null) return 0;
      if (a == null) return $i(r, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!r.cb && !nr(r, a)) return 0;
      if (g(r.cb), a.ac == null || a.ac(a)) {
        a.ob && (r.L = 0);
        var h = p[r.L];
        if (r.L == 2 ? (r.yb = 0, r.zb = 0) : (r.yb = a.v - h >> 4, r.zb = a.j - h >> 4, 0 > r.yb && (r.yb = 0), 0 > r.zb && (r.zb = 0)), r.Va = a.o + 15 + h >> 4, r.Hb = a.va + 15 + h >> 4, r.Hb > r.za && (r.Hb = r.za), r.Va > r.Ub && (r.Va = r.Ub), 0 < r.L) {
          var d = r.ed;
          for (h = 0; 4 > h; ++h) {
            var _;
            if (r.Qa.Cb) {
              var w = r.Qa.Lb[h];
              r.Qa.Fb || (w += d.Tb);
            } else w = d.Tb;
            for (_ = 0; 1 >= _; ++_) {
              var k = r.gd[h][_], T = w;
              if (d.Pc && (T += d.vd[0], _ && (T += d.od[0])), 0 < (T = 0 > T ? 0 : 63 < T ? 63 : T)) {
                var C = T;
                0 < d.wb && (C = 4 < d.wb ? C >> 2 : C >> 1) > 9 - d.wb && (C = 9 - d.wb), 1 > C && (C = 1), k.dd = C, k.tc = 2 * T + C, k.ld = 40 <= T ? 2 : 15 <= T ? 1 : 0;
              } else k.tc = 0;
              k.La = _;
            }
          }
        }
        h = 0;
      } else $i(r, 6, "Frame setup failed"), h = r.a;
      if (h = h == 0) {
        if (h) {
          r.$c = 0, 0 < r.Aa || (r.Ic = s);
          t: {
            h = r.Ic, d = 4 * (C = r.za);
            var z = 32 * C, R = C + 1, W = 0 < r.L ? C * (0 < r.Aa ? 2 : 1) : 0, Z = (r.Aa == 2 ? 2 : 1) * C;
            if ((k = d + 832 + (_ = 3 * (16 * h + p[r.L]) / 2 * z) + (w = r.Fa != null && 0 < r.Fa.length ? r.Kc.c * r.Kc.i : 0)) != k) h = 0;
            else {
              if (k > r.Vb) {
                if (r.Vb = 0, r.Ec = A(k), r.Fc = 0, r.Ec == null) {
                  h = $i(r, 1, "no memory during frame initialization.");
                  break t;
                }
                r.Vb = k;
              }
              k = r.Ec, T = r.Fc, r.Ac = k, r.Bc = T, T += d, r.Gd = v(z, br), r.Hd = 0, r.rb = v(R + 1, Vr), r.sb = 1, r.wa = W ? v(W, Zs) : null, r.Y = 0, r.D.Nb = 0, r.D.wa = r.wa, r.D.Y = r.Y, 0 < r.Aa && (r.D.Y += C), g(!0), r.oc = k, r.pc = T, T += 832, r.ya = v(Z, Do), r.aa = 0, r.D.ya = r.ya, r.D.aa = r.aa, r.Aa == 2 && (r.D.aa += C), r.R = 16 * C, r.B = 8 * C, C = (z = p[r.L]) * r.R, z = z / 2 * r.B, r.sa = k, r.ta = T + C, r.qa = r.sa, r.ra = r.ta + 16 * h * r.R + z, r.Ha = r.qa, r.Ia = r.ra + 8 * h * r.B + z, r.$c = 0, T += _, r.mb = w ? k : null, r.nb = w ? T : null, g(T + w <= r.Fc + r.Vb), $r(r), P(r.Ac, r.Bc, 0, d), h = 1;
            }
          }
          if (h) {
            if (a.ka = 0, a.y = r.sa, a.O = r.ta, a.f = r.qa, a.N = r.ra, a.ea = r.Ha, a.Vd = r.Ia, a.fa = r.R, a.Rc = r.B, a.F = null, a.J = 0, !no) {
              for (h = -255; 255 >= h; ++h) $o[255 + h] = 0 > h ? -h : h;
              for (h = -1020; 1020 >= h; ++h) hr[1020 + h] = -128 > h ? -128 : 127 < h ? 127 : h;
              for (h = -112; 112 >= h; ++h) Dn[112 + h] = -16 > h ? -16 : 15 < h ? 15 : h;
              for (h = -255; 510 >= h; ++h) wn[255 + h] = 0 > h ? 0 : 255 < h ? 255 : h;
              no = 1;
            }
            an = Za, ka = Va, zn = $a, on = ga, un = ya, zs = Ei, Ds = Ja, Ta = Aa, gs = cl, Kn = Ka, La = ll, ln = Ys, dn = Qa, Pi = Bo, ji = Xs, Ki = Es, gr = Gn, ys = kl, An[0] = Zn, An[1] = Ga, An[2] = ba, An[3] = Ha, An[4] = No, An[5] = wa, An[6] = cs, An[7] = Fo, An[8] = al, An[9] = Il, Rs[0] = sl, Rs[1] = Hs, Rs[2] = Ts, Rs[3] = Wa, Rs[4] = cr, Rs[5] = xa, Rs[6] = Zr, xs[0] = us, xs[1] = _a, xs[2] = ol, xs[3] = Ro, xs[4] = Ls, xs[5] = Xa, xs[6] = Sa, h = 1;
          } else h = 0;
        }
        h && (h = function(G, nt) {
          for (G.M = 0; G.M < G.Va; ++G.M) {
            var Y, J = G.Jc[G.M & G.Xb], tt = G.m, ut = G;
            for (Y = 0; Y < ut.za; ++Y) {
              var St = tt, It = ut, Gt = It.Ac, qt = It.Bc + 4 * Y, Zt = It.zc, Bt = It.ya[It.aa + Y];
              if (It.Qa.Bb ? Bt.$b = Wt(St, It.Pa.jb[0]) ? 2 + Wt(St, It.Pa.jb[2]) : Wt(St, It.Pa.jb[1]) : Bt.$b = 0, It.kc && (Bt.Ad = Wt(St, It.Bd)), Bt.Za = !Wt(St, 145) + 0, Bt.Za) {
                var ge = Bt.Ob, Le = 0;
                for (It = 0; 4 > It; ++It) {
                  var ce, de = Zt[0 + It];
                  for (ce = 0; 4 > ce; ++ce) {
                    de = po[Gt[qt + ce]][de];
                    for (var Ce = Ql[Wt(St, de[0])]; 0 < Ce; ) Ce = Ql[2 * Ce + Wt(St, de[Ce])];
                    de = -Ce, Gt[qt + ce] = de;
                  }
                  x(ge, Le, Gt, qt, 4), Le += 4, Zt[0 + It] = de;
                }
              } else de = Wt(St, 156) ? Wt(St, 128) ? 1 : 3 : Wt(St, 163) ? 2 : 0, Bt.Ob[0] = de, P(Gt, qt, de, 4), P(Zt, 0, de, 4);
              Bt.Dd = Wt(St, 142) ? Wt(St, 114) ? Wt(St, 183) ? 1 : 3 : 2 : 0;
            }
            if (ut.m.Ka) return $i(G, 7, "Premature end-of-partition0 encountered.");
            for (; G.ja < G.za; ++G.ja) {
              if (ut = J, St = (tt = G).rb[tt.sb - 1], Gt = tt.rb[tt.sb + tt.ja], Y = tt.ya[tt.aa + tt.ja], qt = tt.kc ? Y.Ad : 0) St.la = Gt.la = 0, Y.Za || (St.Na = Gt.Na = 0), Y.Hc = 0, Y.Gc = 0, Y.ia = 0;
              else {
                var ii, we;
                if (St = Gt, Gt = ut, qt = tt.Pa.Xc, Zt = tt.ya[tt.aa + tt.ja], Bt = tt.pb[Zt.$b], It = Zt.ad, ge = 0, Le = tt.rb[tt.sb - 1], de = ce = 0, P(It, ge, 0, 384), Zt.Za) var We = 0, Ai = qt[3];
                else {
                  Ce = A(16);
                  var Mi = St.Na + Le.Na;
                  if (Mi = aa(Gt, qt[1], Mi, Bt.Eb, 0, Ce, 0), St.Na = Le.Na = (0 < Mi) + 0, 1 < Mi) an(Ce, 0, It, ge);
                  else {
                    var sr = Ce[0] + 3 >> 3;
                    for (Ce = 0; 256 > Ce; Ce += 16) It[ge + Ce] = sr;
                  }
                  We = 1, Ai = qt[0];
                }
                var ri = 15 & St.la, Xi = 15 & Le.la;
                for (Ce = 0; 4 > Ce; ++Ce) {
                  var Gi = 1 & Xi;
                  for (sr = we = 0; 4 > sr; ++sr) ri = ri >> 1 | (Gi = (Mi = aa(Gt, Ai, Mi = Gi + (1 & ri), Bt.Sc, We, It, ge)) > We) << 7, we = we << 2 | (3 < Mi ? 3 : 1 < Mi ? 2 : It[ge + 0] != 0), ge += 16;
                  ri >>= 4, Xi = Xi >> 1 | Gi << 7, ce = (ce << 8 | we) >>> 0;
                }
                for (Ai = ri, We = Xi >> 4, ii = 0; 4 > ii; ii += 2) {
                  for (we = 0, ri = St.la >> 4 + ii, Xi = Le.la >> 4 + ii, Ce = 0; 2 > Ce; ++Ce) {
                    for (Gi = 1 & Xi, sr = 0; 2 > sr; ++sr) Mi = Gi + (1 & ri), ri = ri >> 1 | (Gi = 0 < (Mi = aa(Gt, qt[2], Mi, Bt.Qc, 0, It, ge))) << 3, we = we << 2 | (3 < Mi ? 3 : 1 < Mi ? 2 : It[ge + 0] != 0), ge += 16;
                    ri >>= 2, Xi = Xi >> 1 | Gi << 5;
                  }
                  de |= we << 4 * ii, Ai |= ri << 4 << ii, We |= (240 & Xi) << ii;
                }
                St.la = Ai, Le.la = We, Zt.Hc = ce, Zt.Gc = de, Zt.ia = 43690 & de ? 0 : Bt.ia, qt = !(ce | de);
              }
              if (0 < tt.L && (tt.wa[tt.Y + tt.ja] = tt.gd[Y.$b][Y.Za], tt.wa[tt.Y + tt.ja].La |= !qt), ut.Ka) return $i(G, 7, "Premature end-of-file encountered.");
            }
            if ($r(G), tt = nt, ut = 1, Y = (J = G).D, St = 0 < J.L && J.M >= J.zb && J.M <= J.Va, J.Aa == 0) t: {
              if (Y.M = J.M, Y.uc = St, ta(J, Y), ut = 1, Y = (we = J.D).Nb, St = (de = p[J.L]) * J.R, Gt = de / 2 * J.B, Ce = 16 * Y * J.R, sr = 8 * Y * J.B, qt = J.sa, Zt = J.ta - St + Ce, Bt = J.qa, It = J.ra - Gt + sr, ge = J.Ha, Le = J.Ia - Gt + sr, Xi = (ri = we.M) == 0, ce = ri >= J.Va - 1, J.Aa == 2 && ta(J, we), we.uc) for (Gi = (Mi = J).D.M, g(Mi.D.uc), we = Mi.yb; we < Mi.Hb; ++we) {
                We = we, Ai = Gi;
                var zi = (Fi = (Ri = Mi).D).Nb;
                ii = Ri.R;
                var Fi = Fi.wa[Fi.Y + We], Qi = Ri.sa, Mr = Ri.ta + 16 * zi * ii + 16 * We, fn = Fi.dd, ar = Fi.tc;
                if (ar != 0) if (g(3 <= ar), Ri.L == 1) 0 < We && Ki(Qi, Mr, ii, ar + 4), Fi.La && ys(Qi, Mr, ii, ar), 0 < Ai && ji(Qi, Mr, ii, ar + 4), Fi.La && gr(Qi, Mr, ii, ar);
                else {
                  var Hr = Ri.B, ws = Ri.qa, oa = Ri.ra + 8 * zi * Hr + 8 * We, Sr = Ri.Ha, Ri = Ri.Ia + 8 * zi * Hr + 8 * We;
                  zi = Fi.ld, 0 < We && (Ta(Qi, Mr, ii, ar + 4, fn, zi), Kn(ws, oa, Sr, Ri, Hr, ar + 4, fn, zi)), Fi.La && (ln(Qi, Mr, ii, ar, fn, zi), Pi(ws, oa, Sr, Ri, Hr, ar, fn, zi)), 0 < Ai && (Ds(Qi, Mr, ii, ar + 4, fn, zi), gs(ws, oa, Sr, Ri, Hr, ar + 4, fn, zi)), Fi.La && (La(Qi, Mr, ii, ar, fn, zi), dn(ws, oa, Sr, Ri, Hr, ar, fn, zi));
                }
              }
              if (J.ia && alert("todo:DitherRow"), tt.put != null) {
                if (we = 16 * ri, ri = 16 * (ri + 1), Xi ? (tt.y = J.sa, tt.O = J.ta + Ce, tt.f = J.qa, tt.N = J.ra + sr, tt.ea = J.Ha, tt.W = J.Ia + sr) : (we -= de, tt.y = qt, tt.O = Zt, tt.f = Bt, tt.N = It, tt.ea = ge, tt.W = Le), ce || (ri -= de), ri > tt.o && (ri = tt.o), tt.F = null, tt.J = null, J.Fa != null && 0 < J.Fa.length && we < ri && (tt.J = io(J, tt, we, ri - we), tt.F = J.mb, tt.F == null && tt.F.length == 0)) {
                  ut = $i(J, 3, "Could not decode alpha data.");
                  break t;
                }
                we < tt.j && (de = tt.j - we, we = tt.j, g(!(1 & de)), tt.O += J.R * de, tt.N += J.B * (de >> 1), tt.W += J.B * (de >> 1), tt.F != null && (tt.J += tt.width * de)), we < ri && (tt.O += tt.v, tt.N += tt.v >> 1, tt.W += tt.v >> 1, tt.F != null && (tt.J += tt.v), tt.ka = we - tt.j, tt.U = tt.va - tt.v, tt.T = ri - we, ut = tt.put(tt));
              }
              Y + 1 != J.Ic || ce || (x(J.sa, J.ta - St, qt, Zt + 16 * J.R, St), x(J.qa, J.ra - Gt, Bt, It + 8 * J.B, Gt), x(J.Ha, J.Ia - Gt, ge, Le + 8 * J.B, Gt));
            }
            if (!ut) return $i(G, 6, "Output aborted.");
          }
          return 1;
        }(r, a)), a.bc != null && a.bc(a), h &= 1;
      }
      return h ? (r.cb = 0, h) : 0;
    }
    function Tr(r, a, h, d, _) {
      _ = r[a + h + 32 * d] + (_ >> 3), r[a + h + 32 * d] = -256 & _ ? 0 > _ ? 0 : 255 : _;
    }
    function Gs(r, a, h, d, _, w) {
      Tr(r, a, 0, h, d + _), Tr(r, a, 1, h, d + w), Tr(r, a, 2, h, d - w), Tr(r, a, 3, h, d - _);
    }
    function Lr(r) {
      return (20091 * r >> 16) + r;
    }
    function Ln(r, a, h, d) {
      var _, w = 0, k = A(16);
      for (_ = 0; 4 > _; ++_) {
        var T = r[a + 0] + r[a + 8], C = r[a + 0] - r[a + 8], z = (35468 * r[a + 4] >> 16) - Lr(r[a + 12]), R = Lr(r[a + 4]) + (35468 * r[a + 12] >> 16);
        k[w + 0] = T + R, k[w + 1] = C + z, k[w + 2] = C - z, k[w + 3] = T - R, w += 4, a++;
      }
      for (_ = w = 0; 4 > _; ++_) T = (r = k[w + 0] + 4) + k[w + 8], C = r - k[w + 8], z = (35468 * k[w + 4] >> 16) - Lr(k[w + 12]), Tr(h, d, 0, 0, T + (R = Lr(k[w + 4]) + (35468 * k[w + 12] >> 16))), Tr(h, d, 1, 0, C + z), Tr(h, d, 2, 0, C - z), Tr(h, d, 3, 0, T - R), w++, d += 32;
    }
    function Ei(r, a, h, d) {
      var _ = r[a + 0] + 4, w = 35468 * r[a + 4] >> 16, k = Lr(r[a + 4]), T = 35468 * r[a + 1] >> 16;
      Gs(h, d, 0, _ + k, r = Lr(r[a + 1]), T), Gs(h, d, 1, _ + w, r, T), Gs(h, d, 2, _ - w, r, T), Gs(h, d, 3, _ - k, r, T);
    }
    function Va(r, a, h, d, _) {
      Ln(r, a, h, d), _ && Ln(r, a + 16, h, d + 4);
    }
    function $a(r, a, h, d) {
      ka(r, a + 0, h, d, 1), ka(r, a + 32, h, d + 128, 1);
    }
    function ga(r, a, h, d) {
      var _;
      for (r = r[a + 0] + 4, _ = 0; 4 > _; ++_) for (a = 0; 4 > a; ++a) Tr(h, d, a, _, r);
    }
    function ya(r, a, h, d) {
      r[a + 0] && on(r, a + 0, h, d), r[a + 16] && on(r, a + 16, h, d + 4), r[a + 32] && on(r, a + 32, h, d + 128), r[a + 48] && on(r, a + 48, h, d + 128 + 4);
    }
    function Za(r, a, h, d) {
      var _, w = A(16);
      for (_ = 0; 4 > _; ++_) {
        var k = r[a + 0 + _] + r[a + 12 + _], T = r[a + 4 + _] + r[a + 8 + _], C = r[a + 4 + _] - r[a + 8 + _], z = r[a + 0 + _] - r[a + 12 + _];
        w[0 + _] = k + T, w[8 + _] = k - T, w[4 + _] = z + C, w[12 + _] = z - C;
      }
      for (_ = 0; 4 > _; ++_) k = (r = w[0 + 4 * _] + 3) + w[3 + 4 * _], T = w[1 + 4 * _] + w[2 + 4 * _], C = w[1 + 4 * _] - w[2 + 4 * _], z = r - w[3 + 4 * _], h[d + 0] = k + T >> 3, h[d + 16] = z + C >> 3, h[d + 32] = k - T >> 3, h[d + 48] = z - C >> 3, d += 64;
    }
    function Ws(r, a, h) {
      var d, _ = a - 32, w = wr, k = 255 - r[_ - 1];
      for (d = 0; d < h; ++d) {
        var T, C = w, z = k + r[a - 1];
        for (T = 0; T < h; ++T) r[a + T] = C[z + r[_ + T]];
        a += 32;
      }
    }
    function Ga(r, a) {
      Ws(r, a, 4);
    }
    function _a(r, a) {
      Ws(r, a, 8);
    }
    function Hs(r, a) {
      Ws(r, a, 16);
    }
    function Ts(r, a) {
      var h;
      for (h = 0; 16 > h; ++h) x(r, a + 32 * h, r, a - 32, 16);
    }
    function Wa(r, a) {
      var h;
      for (h = 16; 0 < h; --h) P(r, a, r[a - 1], 16), a += 32;
    }
    function va(r, a, h) {
      var d;
      for (d = 0; 16 > d; ++d) P(a, h + 32 * d, r, 16);
    }
    function sl(r, a) {
      var h, d = 16;
      for (h = 0; 16 > h; ++h) d += r[a - 1 + 32 * h] + r[a + h - 32];
      va(d >> 5, r, a);
    }
    function cr(r, a) {
      var h, d = 8;
      for (h = 0; 16 > h; ++h) d += r[a - 1 + 32 * h];
      va(d >> 4, r, a);
    }
    function xa(r, a) {
      var h, d = 8;
      for (h = 0; 16 > h; ++h) d += r[a + h - 32];
      va(d >> 4, r, a);
    }
    function Zr(r, a) {
      va(128, r, a);
    }
    function Ye(r, a, h) {
      return r + 2 * a + h + 2 >> 2;
    }
    function ba(r, a) {
      var h, d = a - 32;
      for (d = new Uint8Array([Ye(r[d - 1], r[d + 0], r[d + 1]), Ye(r[d + 0], r[d + 1], r[d + 2]), Ye(r[d + 1], r[d + 2], r[d + 3]), Ye(r[d + 2], r[d + 3], r[d + 4])]), h = 0; 4 > h; ++h) x(r, a + 32 * h, d, 0, d.length);
    }
    function Ha(r, a) {
      var h = r[a - 1], d = r[a - 1 + 32], _ = r[a - 1 + 64], w = r[a - 1 + 96];
      xe(r, a + 0, 16843009 * Ye(r[a - 1 - 32], h, d)), xe(r, a + 32, 16843009 * Ye(h, d, _)), xe(r, a + 64, 16843009 * Ye(d, _, w)), xe(r, a + 96, 16843009 * Ye(_, w, w));
    }
    function Zn(r, a) {
      var h, d = 4;
      for (h = 0; 4 > h; ++h) d += r[a + h - 32] + r[a - 1 + 32 * h];
      for (d >>= 3, h = 0; 4 > h; ++h) P(r, a + 32 * h, d, 4);
    }
    function No(r, a) {
      var h = r[a - 1 + 0], d = r[a - 1 + 32], _ = r[a - 1 + 64], w = r[a - 1 - 32], k = r[a + 0 - 32], T = r[a + 1 - 32], C = r[a + 2 - 32], z = r[a + 3 - 32];
      r[a + 0 + 96] = Ye(d, _, r[a - 1 + 96]), r[a + 1 + 96] = r[a + 0 + 64] = Ye(h, d, _), r[a + 2 + 96] = r[a + 1 + 64] = r[a + 0 + 32] = Ye(w, h, d), r[a + 3 + 96] = r[a + 2 + 64] = r[a + 1 + 32] = r[a + 0 + 0] = Ye(k, w, h), r[a + 3 + 64] = r[a + 2 + 32] = r[a + 1 + 0] = Ye(T, k, w), r[a + 3 + 32] = r[a + 2 + 0] = Ye(C, T, k), r[a + 3 + 0] = Ye(z, C, T);
    }
    function cs(r, a) {
      var h = r[a + 1 - 32], d = r[a + 2 - 32], _ = r[a + 3 - 32], w = r[a + 4 - 32], k = r[a + 5 - 32], T = r[a + 6 - 32], C = r[a + 7 - 32];
      r[a + 0 + 0] = Ye(r[a + 0 - 32], h, d), r[a + 1 + 0] = r[a + 0 + 32] = Ye(h, d, _), r[a + 2 + 0] = r[a + 1 + 32] = r[a + 0 + 64] = Ye(d, _, w), r[a + 3 + 0] = r[a + 2 + 32] = r[a + 1 + 64] = r[a + 0 + 96] = Ye(_, w, k), r[a + 3 + 32] = r[a + 2 + 64] = r[a + 1 + 96] = Ye(w, k, T), r[a + 3 + 64] = r[a + 2 + 96] = Ye(k, T, C), r[a + 3 + 96] = Ye(T, C, C);
    }
    function wa(r, a) {
      var h = r[a - 1 + 0], d = r[a - 1 + 32], _ = r[a - 1 + 64], w = r[a - 1 - 32], k = r[a + 0 - 32], T = r[a + 1 - 32], C = r[a + 2 - 32], z = r[a + 3 - 32];
      r[a + 0 + 0] = r[a + 1 + 64] = w + k + 1 >> 1, r[a + 1 + 0] = r[a + 2 + 64] = k + T + 1 >> 1, r[a + 2 + 0] = r[a + 3 + 64] = T + C + 1 >> 1, r[a + 3 + 0] = C + z + 1 >> 1, r[a + 0 + 96] = Ye(_, d, h), r[a + 0 + 64] = Ye(d, h, w), r[a + 0 + 32] = r[a + 1 + 96] = Ye(h, w, k), r[a + 1 + 32] = r[a + 2 + 96] = Ye(w, k, T), r[a + 2 + 32] = r[a + 3 + 96] = Ye(k, T, C), r[a + 3 + 32] = Ye(T, C, z);
    }
    function Fo(r, a) {
      var h = r[a + 0 - 32], d = r[a + 1 - 32], _ = r[a + 2 - 32], w = r[a + 3 - 32], k = r[a + 4 - 32], T = r[a + 5 - 32], C = r[a + 6 - 32], z = r[a + 7 - 32];
      r[a + 0 + 0] = h + d + 1 >> 1, r[a + 1 + 0] = r[a + 0 + 64] = d + _ + 1 >> 1, r[a + 2 + 0] = r[a + 1 + 64] = _ + w + 1 >> 1, r[a + 3 + 0] = r[a + 2 + 64] = w + k + 1 >> 1, r[a + 0 + 32] = Ye(h, d, _), r[a + 1 + 32] = r[a + 0 + 96] = Ye(d, _, w), r[a + 2 + 32] = r[a + 1 + 96] = Ye(_, w, k), r[a + 3 + 32] = r[a + 2 + 96] = Ye(w, k, T), r[a + 3 + 64] = Ye(k, T, C), r[a + 3 + 96] = Ye(T, C, z);
    }
    function Il(r, a) {
      var h = r[a - 1 + 0], d = r[a - 1 + 32], _ = r[a - 1 + 64], w = r[a - 1 + 96];
      r[a + 0 + 0] = h + d + 1 >> 1, r[a + 2 + 0] = r[a + 0 + 32] = d + _ + 1 >> 1, r[a + 2 + 32] = r[a + 0 + 64] = _ + w + 1 >> 1, r[a + 1 + 0] = Ye(h, d, _), r[a + 3 + 0] = r[a + 1 + 32] = Ye(d, _, w), r[a + 3 + 32] = r[a + 1 + 64] = Ye(_, w, w), r[a + 3 + 64] = r[a + 2 + 64] = r[a + 0 + 96] = r[a + 1 + 96] = r[a + 2 + 96] = r[a + 3 + 96] = w;
    }
    function al(r, a) {
      var h = r[a - 1 + 0], d = r[a - 1 + 32], _ = r[a - 1 + 64], w = r[a - 1 + 96], k = r[a - 1 - 32], T = r[a + 0 - 32], C = r[a + 1 - 32], z = r[a + 2 - 32];
      r[a + 0 + 0] = r[a + 2 + 32] = h + k + 1 >> 1, r[a + 0 + 32] = r[a + 2 + 64] = d + h + 1 >> 1, r[a + 0 + 64] = r[a + 2 + 96] = _ + d + 1 >> 1, r[a + 0 + 96] = w + _ + 1 >> 1, r[a + 3 + 0] = Ye(T, C, z), r[a + 2 + 0] = Ye(k, T, C), r[a + 1 + 0] = r[a + 3 + 32] = Ye(h, k, T), r[a + 1 + 32] = r[a + 3 + 64] = Ye(d, h, k), r[a + 1 + 64] = r[a + 3 + 96] = Ye(_, d, h), r[a + 1 + 96] = Ye(w, _, d);
    }
    function ol(r, a) {
      var h;
      for (h = 0; 8 > h; ++h) x(r, a + 32 * h, r, a - 32, 8);
    }
    function Ro(r, a) {
      var h;
      for (h = 0; 8 > h; ++h) P(r, a, r[a - 1], 8), a += 32;
    }
    function hs(r, a, h) {
      var d;
      for (d = 0; 8 > d; ++d) P(a, h + 32 * d, r, 8);
    }
    function us(r, a) {
      var h, d = 8;
      for (h = 0; 8 > h; ++h) d += r[a + h - 32] + r[a - 1 + 32 * h];
      hs(d >> 4, r, a);
    }
    function Xa(r, a) {
      var h, d = 4;
      for (h = 0; 8 > h; ++h) d += r[a + h - 32];
      hs(d >> 3, r, a);
    }
    function Ls(r, a) {
      var h, d = 4;
      for (h = 0; 8 > h; ++h) d += r[a - 1 + 32 * h];
      hs(d >> 3, r, a);
    }
    function Sa(r, a) {
      hs(128, r, a);
    }
    function rn(r, a, h) {
      var d = r[a - h], _ = r[a + 0], w = 3 * (_ - d) + so[1020 + r[a - 2 * h] - r[a + h]], k = Ca[112 + (w + 4 >> 3)];
      r[a - h] = wr[255 + d + Ca[112 + (w + 3 >> 3)]], r[a + 0] = wr[255 + _ - k];
    }
    function Ya(r, a, h, d) {
      var _ = r[a + 0], w = r[a + h];
      return Fr[255 + r[a - 2 * h] - r[a - h]] > d || Fr[255 + w - _] > d;
    }
    function Cs(r, a, h, d) {
      return 4 * Fr[255 + r[a - h] - r[a + 0]] + Fr[255 + r[a - 2 * h] - r[a + h]] <= d;
    }
    function Si(r, a, h, d, _) {
      var w = r[a - 3 * h], k = r[a - 2 * h], T = r[a - h], C = r[a + 0], z = r[a + h], R = r[a + 2 * h], W = r[a + 3 * h];
      return 4 * Fr[255 + T - C] + Fr[255 + k - z] > d ? 0 : Fr[255 + r[a - 4 * h] - w] <= _ && Fr[255 + w - k] <= _ && Fr[255 + k - T] <= _ && Fr[255 + W - R] <= _ && Fr[255 + R - z] <= _ && Fr[255 + z - C] <= _;
    }
    function Xs(r, a, h, d) {
      var _ = 2 * d + 1;
      for (d = 0; 16 > d; ++d) Cs(r, a + d, h, _) && rn(r, a + d, h);
    }
    function Es(r, a, h, d) {
      var _ = 2 * d + 1;
      for (d = 0; 16 > d; ++d) Cs(r, a + d * h, 1, _) && rn(r, a + d * h, 1);
    }
    function Gn(r, a, h, d) {
      var _;
      for (_ = 3; 0 < _; --_) Xs(r, a += 4 * h, h, d);
    }
    function kl(r, a, h, d) {
      var _;
      for (_ = 3; 0 < _; --_) Es(r, a += 4, h, d);
    }
    function xn(r, a, h, d, _, w, k, T) {
      for (w = 2 * w + 1; 0 < _--; ) {
        if (Si(r, a, h, w, k)) if (Ya(r, a, h, T)) rn(r, a, h);
        else {
          var C = r, z = a, R = h, W = C[z - 2 * R], Z = C[z - R], G = C[z + 0], nt = C[z + R], Y = C[z + 2 * R], J = 27 * (ut = so[1020 + 3 * (G - Z) + so[1020 + W - nt]]) + 63 >> 7, tt = 18 * ut + 63 >> 7, ut = 9 * ut + 63 >> 7;
          C[z - 3 * R] = wr[255 + C[z - 3 * R] + ut], C[z - 2 * R] = wr[255 + W + tt], C[z - R] = wr[255 + Z + J], C[z + 0] = wr[255 + G - J], C[z + R] = wr[255 + nt - tt], C[z + 2 * R] = wr[255 + Y - ut];
        }
        a += d;
      }
    }
    function Wn(r, a, h, d, _, w, k, T) {
      for (w = 2 * w + 1; 0 < _--; ) {
        if (Si(r, a, h, w, k)) if (Ya(r, a, h, T)) rn(r, a, h);
        else {
          var C = r, z = a, R = h, W = C[z - R], Z = C[z + 0], G = C[z + R], nt = Ca[112 + ((Y = 3 * (Z - W)) + 4 >> 3)], Y = Ca[112 + (Y + 3 >> 3)], J = nt + 1 >> 1;
          C[z - 2 * R] = wr[255 + C[z - 2 * R] + J], C[z - R] = wr[255 + W + Y], C[z + 0] = wr[255 + Z - nt], C[z + R] = wr[255 + G - J];
        }
        a += d;
      }
    }
    function Ja(r, a, h, d, _, w) {
      xn(r, a, h, 1, 16, d, _, w);
    }
    function Aa(r, a, h, d, _, w) {
      xn(r, a, 1, h, 16, d, _, w);
    }
    function ll(r, a, h, d, _, w) {
      var k;
      for (k = 3; 0 < k; --k) Wn(r, a += 4 * h, h, 1, 16, d, _, w);
    }
    function Ys(r, a, h, d, _, w) {
      var k;
      for (k = 3; 0 < k; --k) Wn(r, a += 4, 1, h, 16, d, _, w);
    }
    function cl(r, a, h, d, _, w, k, T) {
      xn(r, a, _, 1, 8, w, k, T), xn(h, d, _, 1, 8, w, k, T);
    }
    function Ka(r, a, h, d, _, w, k, T) {
      xn(r, a, 1, _, 8, w, k, T), xn(h, d, 1, _, 8, w, k, T);
    }
    function Qa(r, a, h, d, _, w, k, T) {
      Wn(r, a + 4 * _, _, 1, 8, w, k, T), Wn(h, d + 4 * _, _, 1, 8, w, k, T);
    }
    function Bo(r, a, h, d, _, w, k, T) {
      Wn(r, a + 4, 1, _, 8, w, k, T), Wn(h, d + 4, 1, _, 8, w, k, T);
    }
    function Cn() {
      this.ba = new Ir(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ht(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function to() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Oo() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function jo() {
      this.ua = 0, this.Wa = new K(), this.vb = new K(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new bt(), this.yc = new lt();
    }
    function Pa() {
      this.xb = this.a = 0, this.l = new os(), this.ca = new Ir(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new Q(), this.Pb = 0, this.wd = new Q(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new jo(), this.ab = 0, this.gc = v(4, Oo), this.Oc = 0;
    }
    function eo() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new os(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function ds(r, a, h, d, _, w, k) {
      for (r = r == null ? 0 : r[a + 0], a = 0; a < k; ++a) _[w + a] = r + h[d + a] & 255, r = _[w + a];
    }
    function qo(r, a, h, d, _, w, k) {
      var T;
      if (r == null) ds(null, null, h, d, _, w, k);
      else for (T = 0; T < k; ++T) _[w + T] = r[a + T] + h[d + T] & 255;
    }
    function Js(r, a, h, d, _, w, k) {
      if (r == null) ds(null, null, h, d, _, w, k);
      else {
        var T, C = r[a + 0], z = C, R = C;
        for (T = 0; T < k; ++T) z = R + (C = r[a + T]) - z, R = h[d + T] + (-256 & z ? 0 > z ? 0 : 255 : z) & 255, z = C, _[w + T] = R;
      }
    }
    function io(r, a, h, d) {
      var _ = a.width, w = a.o;
      if (g(r != null && a != null), 0 > h || 0 >= d || h + d > w) return null;
      if (!r.Cc) {
        if (r.ga == null) {
          var k;
          if (r.ga = new eo(), (k = r.ga == null) || (k = a.width * a.o, g(r.Gb.length == 0), r.Gb = A(k), r.Uc = 0, r.Gb == null ? k = 0 : (r.mb = r.Gb, r.nb = r.Uc, r.rc = null, k = 1), k = !k), !k) {
            k = r.ga;
            var T = r.Fa, C = r.P, z = r.qc, R = r.mb, W = r.nb, Z = C + 1, G = z - 1, nt = k.l;
            if (g(T != null && R != null && a != null), pn[0] = null, pn[1] = ds, pn[2] = qo, pn[3] = Js, k.ca = R, k.tb = W, k.c = a.width, k.i = a.height, g(0 < k.c && 0 < k.i), 1 >= z) a = 0;
            else if (k.$a = T[C + 0] >> 0 & 3, k.Z = T[C + 0] >> 2 & 3, k.Lc = T[C + 0] >> 4 & 3, C = T[C + 0] >> 6 & 3, 0 > k.$a || 1 < k.$a || 4 <= k.Z || 1 < k.Lc || C) a = 0;
            else if (nt.put = At, nt.ac = ct, nt.bc = Et, nt.ma = k, nt.width = a.width, nt.height = a.height, nt.Da = a.Da, nt.v = a.v, nt.va = a.va, nt.j = a.j, nt.o = a.o, k.$a) t: {
              g(k.$a == 1), a = Oi();
              e: for (; ; ) {
                if (a == null) {
                  a = 0;
                  break t;
                }
                if (g(k != null), k.mc = a, a.c = k.c, a.i = k.i, a.l = k.l, a.l.ma = k, a.l.width = k.c, a.l.height = k.i, a.a = 0, Ut(a.m, T, Z, G), !oi(k.c, k.i, 1, a, null) || (a.ab == 1 && a.gc[0].hc == 3 && ei(a.s) ? (k.ic = 1, T = a.c * a.i, a.Ta = null, a.Ua = 0, a.V = A(T), a.Ba = 0, a.V == null ? (a.a = 1, a = 0) : a = 1) : (k.ic = 0, a = Ci(a, k.c)), !a)) break e;
                a = 1;
                break t;
              }
              k.mc = null, a = 0;
            }
            else a = G >= k.c * k.i;
            k = !a;
          }
          if (k) return null;
          r.ga.Lc != 1 ? r.Ga = 0 : d = w - h;
        }
        g(r.ga != null), g(h + d <= w);
        t: {
          if (a = (T = r.ga).c, w = T.l.o, T.$a == 0) {
            if (Z = r.rc, G = r.Vc, nt = r.Fa, C = r.P + 1 + h * a, z = r.mb, R = r.nb + h * a, g(C <= r.P + r.qc), T.Z != 0) for (g(pn[T.Z] != null), k = 0; k < d; ++k) pn[T.Z](Z, G, nt, C, z, R, a), Z = z, G = R, R += a, C += a;
            else for (k = 0; k < d; ++k) x(z, R, nt, C, a), Z = z, G = R, R += a, C += a;
            r.rc = Z, r.Vc = G;
          } else {
            if (g(T.mc != null), a = h + d, g((k = T.mc) != null), g(a <= k.i), k.C >= a) a = 1;
            else if (T.ic || Ft(), T.ic) {
              T = k.V, Z = k.Ba, G = k.c;
              var Y = k.i, J = (nt = 1, C = k.$ / G, z = k.$ % G, R = k.m, W = k.s, k.$), tt = G * Y, ut = G * a, St = W.wc, It = J < ut ? fe(W, z, C) : null;
              g(J <= tt), g(a <= Y), g(ei(W));
              e: for (; ; ) {
                for (; !R.h && J < ut; ) {
                  if (z & St || (It = fe(W, z, C)), g(It != null), Dt(R), 256 > (Y = re(It.G[0], It.H[0], R))) T[Z + J] = Y, ++J, ++z >= G && (z = 0, ++C <= a && !(C % 16) && He(k, C));
                  else {
                    if (!(280 > Y)) {
                      nt = 0;
                      break e;
                    }
                    Y = xt(Y - 256, R);
                    var Gt, qt = re(It.G[4], It.H[4], R);
                    if (Dt(R), !(J >= (qt = $t(G, qt = xt(qt, R))) && tt - J >= Y)) {
                      nt = 0;
                      break e;
                    }
                    for (Gt = 0; Gt < Y; ++Gt) T[Z + J + Gt] = T[Z + J + Gt - qt];
                    for (J += Y, z += Y; z >= G; ) z -= G, ++C <= a && !(C % 16) && He(k, C);
                    J < ut && z & St && (It = fe(W, z, C));
                  }
                  g(R.h == _t(R));
                }
                He(k, C > a ? a : C);
                break e;
              }
              !nt || R.h && J < tt ? (nt = 0, k.a = R.h ? 5 : 3) : k.$ = J, a = nt;
            } else a = Ti(k, k.V, k.Ba, k.c, k.i, a, Ui);
            if (!a) {
              d = 0;
              break t;
            }
          }
          h + d >= w && (r.Cc = 1), d = 1;
        }
        if (!d) return null;
        if (r.Cc && ((d = r.ga) != null && (d.mc = null), r.ga = null, 0 < r.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return r.nb + h * _;
    }
    function L(r, a, h, d, _, w) {
      for (; 0 < _--; ) {
        var k, T = r, C = a + (h ? 1 : 0), z = r, R = a + (h ? 0 : 3);
        for (k = 0; k < d; ++k) {
          var W = z[R + 4 * k];
          W != 255 && (W *= 32897, T[C + 4 * k + 0] = T[C + 4 * k + 0] * W >> 23, T[C + 4 * k + 1] = T[C + 4 * k + 1] * W >> 23, T[C + 4 * k + 2] = T[C + 4 * k + 2] * W >> 23);
        }
        a += w;
      }
    }
    function X(r, a, h, d, _) {
      for (; 0 < d--; ) {
        var w;
        for (w = 0; w < h; ++w) {
          var k = r[a + 2 * w + 0], T = 15 & (z = r[a + 2 * w + 1]), C = 4369 * T, z = (240 & z | z >> 4) * C >> 16;
          r[a + 2 * w + 0] = (240 & k | k >> 4) * C >> 16 & 240 | (15 & k | k << 4) * C >> 16 >> 4 & 15, r[a + 2 * w + 1] = 240 & z | T;
        }
        a += _;
      }
    }
    function ft(r, a, h, d, _, w, k, T) {
      var C, z, R = 255;
      for (z = 0; z < _; ++z) {
        for (C = 0; C < d; ++C) {
          var W = r[a + C];
          w[k + 4 * C] = W, R &= W;
        }
        a += h, k += T;
      }
      return R != 255;
    }
    function Lt(r, a, h, d, _) {
      var w;
      for (w = 0; w < _; ++w) h[d + w] = r[a + w] >> 8;
    }
    function Ft() {
      bn = L, _s = X, sa = ft, Yl = Lt;
    }
    function Kt(r, a, h) {
      Tt[r] = function(d, _, w, k, T, C, z, R, W, Z, G, nt, Y, J, tt, ut, St) {
        var It, Gt = St - 1 >> 1, qt = T[C + 0] | z[R + 0] << 16, Zt = W[Z + 0] | G[nt + 0] << 16;
        g(d != null);
        var Bt = 3 * qt + Zt + 131074 >> 2;
        for (a(d[_ + 0], 255 & Bt, Bt >> 16, Y, J), w != null && (Bt = 3 * Zt + qt + 131074 >> 2, a(w[k + 0], 255 & Bt, Bt >> 16, tt, ut)), It = 1; It <= Gt; ++It) {
          var ge = T[C + It] | z[R + It] << 16, Le = W[Z + It] | G[nt + It] << 16, ce = qt + ge + Zt + Le + 524296, de = ce + 2 * (ge + Zt) >> 3;
          Bt = de + qt >> 1, qt = (ce = ce + 2 * (qt + Le) >> 3) + ge >> 1, a(d[_ + 2 * It - 1], 255 & Bt, Bt >> 16, Y, J + (2 * It - 1) * h), a(d[_ + 2 * It - 0], 255 & qt, qt >> 16, Y, J + (2 * It - 0) * h), w != null && (Bt = ce + Zt >> 1, qt = de + Le >> 1, a(w[k + 2 * It - 1], 255 & Bt, Bt >> 16, tt, ut + (2 * It - 1) * h), a(w[k + 2 * It + 0], 255 & qt, qt >> 16, tt, ut + (2 * It + 0) * h)), qt = ge, Zt = Le;
        }
        1 & St || (Bt = 3 * qt + Zt + 131074 >> 2, a(d[_ + St - 1], 255 & Bt, Bt >> 16, Y, J + (St - 1) * h), w != null && (Bt = 3 * Zt + qt + 131074 >> 2, a(w[k + St - 1], 255 & Bt, Bt >> 16, tt, ut + (St - 1) * h)));
      };
    }
    function _e() {
      ui[ao] = El, ui[Ea] = ul, ui[oo] = Nc, ui[lo] = Ml, ui[co] = ec, ui[Zo] = zl, ui[Ns] = Bs, ui[ho] = ul, ui[Go] = Ml, ui[Wo] = ec, ui[Ho] = zl;
    }
    function Re(r) {
      return r & ~bs ? 0 > r ? 0 : 255 : r >> ic;
    }
    function Qe(r, a) {
      return Re((19077 * r >> 8) + (26149 * a >> 8) - 14234);
    }
    function gi(r, a, h) {
      return Re((19077 * r >> 8) - (6419 * a >> 8) - (13320 * h >> 8) + 8708);
    }
    function vi(r, a) {
      return Re((19077 * r >> 8) + (33050 * a >> 8) - 17685);
    }
    function bi(r, a, h, d, _) {
      d[_ + 0] = Qe(r, h), d[_ + 1] = gi(r, a, h), d[_ + 2] = vi(r, a);
    }
    function di(r, a, h, d, _) {
      d[_ + 0] = vi(r, a), d[_ + 1] = gi(r, a, h), d[_ + 2] = Qe(r, h);
    }
    function mr(r, a, h, d, _) {
      var w = gi(r, a, h);
      a = w << 3 & 224 | vi(r, a) >> 3, d[_ + 0] = 248 & Qe(r, h) | w >> 5, d[_ + 1] = a;
    }
    function Xe(r, a, h, d, _) {
      var w = 240 & vi(r, a) | 15;
      d[_ + 0] = 240 & Qe(r, h) | gi(r, a, h) >> 4, d[_ + 1] = w;
    }
    function Cr(r, a, h, d, _) {
      d[_ + 0] = 255, bi(r, a, h, d, _ + 1);
    }
    function xi(r, a, h, d, _) {
      di(r, a, h, d, _), d[_ + 3] = 255;
    }
    function Li(r, a, h, d, _) {
      bi(r, a, h, d, _), d[_ + 3] = 255;
    }
    function nn(r, a) {
      return 0 > r ? 0 : r > a ? a : r;
    }
    function Hn(r, a, h) {
      Tt[r] = function(d, _, w, k, T, C, z, R, W) {
        for (var Z = R + (-2 & W) * h; R != Z; ) a(d[_ + 0], w[k + 0], T[C + 0], z, R), a(d[_ + 1], w[k + 0], T[C + 0], z, R + h), _ += 2, ++k, ++C, R += 2 * h;
        1 & W && a(d[_ + 0], w[k + 0], T[C + 0], z, R);
      };
    }
    function Ks(r, a, h) {
      return h == 0 ? r == 0 ? a == 0 ? 6 : 5 : a == 0 ? 4 : 0 : h;
    }
    function Qs(r, a, h, d, _) {
      switch (r >>> 30) {
        case 3:
          ka(a, h, d, _, 0);
          break;
        case 2:
          zs(a, h, d, _);
          break;
        case 1:
          on(a, h, d, _);
      }
    }
    function ta(r, a) {
      var h, d, _ = a.M, w = a.Nb, k = r.oc, T = r.pc + 40, C = r.oc, z = r.pc + 584, R = r.oc, W = r.pc + 600;
      for (h = 0; 16 > h; ++h) k[T + 32 * h - 1] = 129;
      for (h = 0; 8 > h; ++h) C[z + 32 * h - 1] = 129, R[W + 32 * h - 1] = 129;
      for (0 < _ ? k[T - 1 - 32] = C[z - 1 - 32] = R[W - 1 - 32] = 129 : (P(k, T - 32 - 1, 127, 21), P(C, z - 32 - 1, 127, 9), P(R, W - 32 - 1, 127, 9)), d = 0; d < r.za; ++d) {
        var Z = a.ya[a.aa + d];
        if (0 < d) {
          for (h = -1; 16 > h; ++h) x(k, T + 32 * h - 4, k, T + 32 * h + 12, 4);
          for (h = -1; 8 > h; ++h) x(C, z + 32 * h - 4, C, z + 32 * h + 4, 4), x(R, W + 32 * h - 4, R, W + 32 * h + 4, 4);
        }
        var G = r.Gd, nt = r.Hd + d, Y = Z.ad, J = Z.Hc;
        if (0 < _ && (x(k, T - 32, G[nt].y, 0, 16), x(C, z - 32, G[nt].f, 0, 8), x(R, W - 32, G[nt].ea, 0, 8)), Z.Za) {
          var tt = k, ut = T - 32 + 16;
          for (0 < _ && (d >= r.za - 1 ? P(tt, ut, G[nt].y[15], 4) : x(tt, ut, G[nt + 1].y, 0, 4)), h = 0; 4 > h; h++) tt[ut + 128 + h] = tt[ut + 256 + h] = tt[ut + 384 + h] = tt[ut + 0 + h];
          for (h = 0; 16 > h; ++h, J <<= 2) tt = k, ut = T + es[h], An[Z.Ob[h]](tt, ut), Qs(J, Y, 16 * +h, tt, ut);
        } else if (tt = Ks(d, _, Z.Ob[0]), Rs[tt](k, T), J != 0) for (h = 0; 16 > h; ++h, J <<= 2) Qs(J, Y, 16 * +h, k, T + es[h]);
        for (h = Z.Gc, tt = Ks(d, _, Z.Dd), xs[tt](C, z), xs[tt](R, W), J = Y, tt = C, ut = z, 255 & (Z = h >> 0) && (170 & Z ? zn(J, 256, tt, ut) : un(J, 256, tt, ut)), Z = R, J = W, 255 & (h >>= 8) && (170 & h ? zn(Y, 320, Z, J) : un(Y, 320, Z, J)), _ < r.Ub - 1 && (x(G[nt].y, 0, k, T + 480, 16), x(G[nt].f, 0, C, z + 224, 8), x(G[nt].ea, 0, R, W + 224, 8)), h = 8 * w * r.B, G = r.sa, nt = r.ta + 16 * d + 16 * w * r.R, Y = r.qa, Z = r.ra + 8 * d + h, J = r.Ha, tt = r.Ia + 8 * d + h, h = 0; 16 > h; ++h) x(G, nt + h * r.R, k, T + 32 * h, 16);
        for (h = 0; 8 > h; ++h) x(Y, Z + h * r.B, C, z + 32 * h, 8), x(J, tt + h * r.B, R, W + 32 * h, 8);
      }
    }
    function ea(r, a, h, d, _, w, k, T, C) {
      var z = [0], R = [0], W = 0, Z = C != null ? C.kd : 0, G = C ?? new to();
      if (r == null || 12 > h) return 7;
      G.data = r, G.w = a, G.ha = h, a = [a], h = [h], G.gb = [G.gb];
      t: {
        var nt = a, Y = h, J = G.gb;
        if (g(r != null), g(Y != null), g(J != null), J[0] = 0, 12 <= Y[0] && !y(r, nt[0], "RIFF")) {
          if (y(r, nt[0] + 8, "WEBP")) {
            J = 3;
            break t;
          }
          var tt = ze(r, nt[0] + 4);
          if (12 > tt || 4294967286 < tt) {
            J = 3;
            break t;
          }
          if (Z && tt > Y[0] - 8) {
            J = 7;
            break t;
          }
          J[0] = tt, nt[0] += 12, Y[0] -= 12;
        }
        J = 0;
      }
      if (J != 0) return J;
      for (tt = 0 < G.gb[0], h = h[0]; ; ) {
        t: {
          var ut = r;
          Y = a, J = h;
          var St = z, It = R, Gt = nt = [0];
          if ((Bt = W = [W])[0] = 0, 8 > J[0]) J = 7;
          else {
            if (!y(ut, Y[0], "VP8X")) {
              if (ze(ut, Y[0] + 4) != 10) {
                J = 3;
                break t;
              }
              if (18 > J[0]) {
                J = 7;
                break t;
              }
              var qt = ze(ut, Y[0] + 8), Zt = 1 + ke(ut, Y[0] + 12);
              if (2147483648 <= Zt * (ut = 1 + ke(ut, Y[0] + 15))) {
                J = 3;
                break t;
              }
              Gt != null && (Gt[0] = qt), St != null && (St[0] = Zt), It != null && (It[0] = ut), Y[0] += 18, J[0] -= 18, Bt[0] = 1;
            }
            J = 0;
          }
        }
        if (W = W[0], nt = nt[0], J != 0) return J;
        if (Y = !!(2 & nt), !tt && W) return 3;
        if (w != null && (w[0] = !!(16 & nt)), k != null && (k[0] = Y), T != null && (T[0] = 0), k = z[0], nt = R[0], W && Y && C == null) {
          J = 0;
          break;
        }
        if (4 > h) {
          J = 7;
          break;
        }
        if (tt && W || !tt && !W && !y(r, a[0], "ALPH")) {
          h = [h], G.na = [G.na], G.P = [G.P], G.Sa = [G.Sa];
          t: {
            qt = r, J = a, tt = h;
            var Bt = G.gb;
            St = G.na, It = G.P, Gt = G.Sa, Zt = 22, g(qt != null), g(tt != null), ut = J[0];
            var ge = tt[0];
            for (g(St != null), g(Gt != null), St[0] = null, It[0] = null, Gt[0] = 0; ; ) {
              if (J[0] = ut, tt[0] = ge, 8 > ge) {
                J = 7;
                break t;
              }
              var Le = ze(qt, ut + 4);
              if (4294967286 < Le) {
                J = 3;
                break t;
              }
              var ce = 8 + Le + 1 & -2;
              if (Zt += ce, 0 < Bt && Zt > Bt) {
                J = 3;
                break t;
              }
              if (!y(qt, ut, "VP8 ") || !y(qt, ut, "VP8L")) {
                J = 0;
                break t;
              }
              if (ge[0] < ce) {
                J = 7;
                break t;
              }
              y(qt, ut, "ALPH") || (St[0] = qt, It[0] = ut + 8, Gt[0] = Le), ut += ce, ge -= ce;
            }
          }
          if (h = h[0], G.na = G.na[0], G.P = G.P[0], G.Sa = G.Sa[0], J != 0) break;
        }
        h = [h], G.Ja = [G.Ja], G.xa = [G.xa];
        t: if (Bt = r, J = a, tt = h, St = G.gb[0], It = G.Ja, Gt = G.xa, qt = J[0], ut = !y(Bt, qt, "VP8 "), Zt = !y(Bt, qt, "VP8L"), g(Bt != null), g(tt != null), g(It != null), g(Gt != null), 8 > tt[0]) J = 7;
        else {
          if (ut || Zt) {
            if (Bt = ze(Bt, qt + 4), 12 <= St && Bt > St - 12) {
              J = 3;
              break t;
            }
            if (Z && Bt > tt[0] - 8) {
              J = 7;
              break t;
            }
            It[0] = Bt, J[0] += 8, tt[0] -= 8, Gt[0] = Zt;
          } else Gt[0] = 5 <= tt[0] && Bt[qt + 0] == 47 && !(Bt[qt + 4] >> 5), It[0] = tt[0];
          J = 0;
        }
        if (h = h[0], G.Ja = G.Ja[0], G.xa = G.xa[0], a = a[0], J != 0) break;
        if (4294967286 < G.Ja) return 3;
        if (T == null || Y || (T[0] = G.xa ? 2 : 1), k = [k], nt = [nt], G.xa) {
          if (5 > h) {
            J = 7;
            break;
          }
          T = k, Z = nt, Y = w, r == null || 5 > h ? r = 0 : 5 <= h && r[a + 0] == 47 && !(r[a + 4] >> 5) ? (tt = [0], Bt = [0], St = [0], Ut(It = new Q(), r, a, h), wt(It, tt, Bt, St) ? (T != null && (T[0] = tt[0]), Z != null && (Z[0] = Bt[0]), Y != null && (Y[0] = St[0]), r = 1) : r = 0) : r = 0;
        } else {
          if (10 > h) {
            J = 7;
            break;
          }
          T = nt, r == null || 10 > h || !ls(r, a + 3, h - 3) ? r = 0 : (Z = r[a + 0] | r[a + 1] << 8 | r[a + 2] << 16, Y = 16383 & (r[a + 7] << 8 | r[a + 6]), r = 16383 & (r[a + 9] << 8 | r[a + 8]), 1 & Z || 3 < (Z >> 1 & 7) || !(Z >> 4 & 1) || Z >> 5 >= G.Ja || !Y || !r ? r = 0 : (k && (k[0] = Y), T && (T[0] = r), r = 1));
        }
        if (!r || (k = k[0], nt = nt[0], W && (z[0] != k || R[0] != nt))) return 3;
        C != null && (C[0] = G, C.offset = a - C.w, g(4294967286 > a - C.w), g(C.offset == C.ha - h));
        break;
      }
      return J == 0 || J == 7 && W && C == null ? (w != null && (w[0] |= G.na != null && 0 < G.na.length), d != null && (d[0] = k), _ != null && (_[0] = nt), 0) : J;
    }
    function Xn(r, a, h) {
      var d = a.width, _ = a.height, w = 0, k = 0, T = d, C = _;
      if (a.Da = r != null && 0 < r.Da, a.Da && (T = r.cd, C = r.bd, w = r.v, k = r.j, 11 > h || (w &= -2, k &= -2), 0 > w || 0 > k || 0 >= T || 0 >= C || w + T > d || k + C > _)) return 0;
      if (a.v = w, a.j = k, a.va = w + T, a.o = k + C, a.U = T, a.T = C, a.da = r != null && 0 < r.da, a.da) {
        if (!ci(T, C, h = [r.ib], w = [r.hb])) return 0;
        a.ib = h[0], a.hb = w[0];
      }
      return a.ob = r != null && r.ob, a.Kb = r == null || !r.Sd, a.da && (a.ob = a.ib < 3 * d / 4 && a.hb < 3 * _ / 4, a.Kb = 0), 1;
    }
    function Yn(r) {
      if (r == null) return 2;
      if (11 > r.S) {
        var a = r.f.RGBA;
        a.fb += (r.height - 1) * a.A, a.A = -a.A;
      } else a = r.f.kb, r = r.height, a.O += (r - 1) * a.fa, a.fa = -a.fa, a.N += (r - 1 >> 1) * a.Ab, a.Ab = -a.Ab, a.W += (r - 1 >> 1) * a.Db, a.Db = -a.Db, a.F != null && (a.J += (r - 1) * a.lb, a.lb = -a.lb);
      return 0;
    }
    function Er(r, a, h, d) {
      if (d == null || 0 >= r || 0 >= a) return 2;
      if (h != null) {
        if (h.Da) {
          var _ = h.cd, w = h.bd, k = -2 & h.v, T = -2 & h.j;
          if (0 > k || 0 > T || 0 >= _ || 0 >= w || k + _ > r || T + w > a) return 2;
          r = _, a = w;
        }
        if (h.da) {
          if (!ci(r, a, _ = [h.ib], w = [h.hb])) return 2;
          r = _[0], a = w[0];
        }
      }
      d.width = r, d.height = a;
      t: {
        var C = d.width, z = d.height;
        if (r = d.S, 0 >= C || 0 >= z || !(r >= ao && 13 > r)) r = 2;
        else {
          if (0 >= d.Rd && d.sd == null) {
            k = w = _ = a = 0;
            var R = (T = C * c[r]) * z;
            if (11 > r || (w = (z + 1) / 2 * (a = (C + 1) / 2), r == 12 && (k = (_ = C) * z)), (z = A(R + 2 * w + k)) == null) {
              r = 1;
              break t;
            }
            d.sd = z, 11 > r ? ((C = d.f.RGBA).eb = z, C.fb = 0, C.A = T, C.size = R) : ((C = d.f.kb).y = z, C.O = 0, C.fa = T, C.Fd = R, C.f = z, C.N = 0 + R, C.Ab = a, C.Cd = w, C.ea = z, C.W = 0 + R + w, C.Db = a, C.Ed = w, r == 12 && (C.F = z, C.J = 0 + R + 2 * w), C.Tc = k, C.lb = _);
          }
          if (a = 1, _ = d.S, w = d.width, k = d.height, _ >= ao && 13 > _) if (11 > _) r = d.f.RGBA, a &= (T = Math.abs(r.A)) * (k - 1) + w <= r.size, a &= T >= w * c[_], a &= r.eb != null;
          else {
            r = d.f.kb, T = (w + 1) / 2, R = (k + 1) / 2, C = Math.abs(r.fa), z = Math.abs(r.Ab);
            var W = Math.abs(r.Db), Z = Math.abs(r.lb), G = Z * (k - 1) + w;
            a &= C * (k - 1) + w <= r.Fd, a &= z * (R - 1) + T <= r.Cd, a = (a &= W * (R - 1) + T <= r.Ed) & C >= w & z >= T & W >= T, a &= r.y != null, a &= r.f != null, a &= r.ea != null, _ == 12 && (a &= Z >= w, a &= G <= r.Tc, a &= r.F != null);
          }
          else a = 0;
          r = a ? 0 : 2;
        }
      }
      return r != 0 || h != null && h.fd && (r = Yn(d)), r;
    }
    var Gr = 64, ia = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], ps = 24, En = 32, ra = 8, Nr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    ye("Predictor0", "PredictorAdd0"), Tt.Predictor0 = function() {
      return 4278190080;
    }, Tt.Predictor1 = function(r) {
      return r;
    }, Tt.Predictor2 = function(r, a, h) {
      return a[h + 0];
    }, Tt.Predictor3 = function(r, a, h) {
      return a[h + 1];
    }, Tt.Predictor4 = function(r, a, h) {
      return a[h - 1];
    }, Tt.Predictor5 = function(r, a, h) {
      return Ae(Ae(r, a[h + 1]), a[h + 0]);
    }, Tt.Predictor6 = function(r, a, h) {
      return Ae(r, a[h - 1]);
    }, Tt.Predictor7 = function(r, a, h) {
      return Ae(r, a[h + 0]);
    }, Tt.Predictor8 = function(r, a, h) {
      return Ae(a[h - 1], a[h + 0]);
    }, Tt.Predictor9 = function(r, a, h) {
      return Ae(a[h + 0], a[h + 1]);
    }, Tt.Predictor10 = function(r, a, h) {
      return Ae(Ae(r, a[h - 1]), Ae(a[h + 0], a[h + 1]));
    }, Tt.Predictor11 = function(r, a, h) {
      var d = a[h + 0];
      return 0 >= si(d >> 24 & 255, r >> 24 & 255, (a = a[h - 1]) >> 24 & 255) + si(d >> 16 & 255, r >> 16 & 255, a >> 16 & 255) + si(d >> 8 & 255, r >> 8 & 255, a >> 8 & 255) + si(255 & d, 255 & r, 255 & a) ? d : r;
    }, Tt.Predictor12 = function(r, a, h) {
      var d = a[h + 0];
      return ($e((r >> 24 & 255) + (d >> 24 & 255) - ((a = a[h - 1]) >> 24 & 255)) << 24 | $e((r >> 16 & 255) + (d >> 16 & 255) - (a >> 16 & 255)) << 16 | $e((r >> 8 & 255) + (d >> 8 & 255) - (a >> 8 & 255)) << 8 | $e((255 & r) + (255 & d) - (255 & a))) >>> 0;
    }, Tt.Predictor13 = function(r, a, h) {
      var d = a[h - 1];
      return (hi((r = Ae(r, a[h + 0])) >> 24 & 255, d >> 24 & 255) << 24 | hi(r >> 16 & 255, d >> 16 & 255) << 16 | hi(r >> 8 & 255, d >> 8 & 255) << 8 | hi(r >> 0 & 255, d >> 0 & 255)) >>> 0;
    };
    var Ia = Tt.PredictorAdd0;
    Tt.PredictorAdd1 = _i, ye("Predictor2", "PredictorAdd2"), ye("Predictor3", "PredictorAdd3"), ye("Predictor4", "PredictorAdd4"), ye("Predictor5", "PredictorAdd5"), ye("Predictor6", "PredictorAdd6"), ye("Predictor7", "PredictorAdd7"), ye("Predictor8", "PredictorAdd8"), ye("Predictor9", "PredictorAdd9"), ye("Predictor10", "PredictorAdd10"), ye("Predictor11", "PredictorAdd11"), ye("Predictor12", "PredictorAdd12"), ye("Predictor13", "PredictorAdd13");
    var na = Tt.PredictorAdd2;
    ai("ColorIndexInverseTransform", "MapARGB", "32b", function(r) {
      return r >> 8 & 255;
    }, function(r) {
      return r;
    }), ai("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(r) {
      return r;
    }, function(r) {
      return r >> 8 & 255;
    });
    var Uo, Wr = Tt.ColorIndexInverseTransform, fs = Tt.MapARGB, Vo = Tt.VP8LColorIndexInverseTransformAlpha, ro = Tt.MapAlpha, yi = Tt.VP8LPredictorsAdd = [];
    yi.length = 16, (Tt.VP8LPredictors = []).length = 16, (Tt.VP8LPredictorsAdd_C = []).length = 16, (Tt.VP8LPredictors_C = []).length = 16;
    var sn, Mn, ms, hn, Jn, Ms, an, ka, zs, zn, on, un, Ds, Ta, gs, Kn, La, ln, dn, Pi, ji, Ki, gr, ys, bn, _s, sa, Yl, $o = A(511), hr = A(2041), Dn = A(225), wn = A(767), no = 0, so = hr, Ca = Dn, wr = wn, Fr = $o, ao = 0, Ea = 1, oo = 2, lo = 3, co = 4, Zo = 5, Ns = 6, ho = 7, Go = 8, Wo = 9, Ho = 10, Jl = [2, 3, 7], Tl = [3, 3, 11], hl = [280, 256, 256, 256, 40], uo = [0, 1, 1, 1, 0], Kl = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Qn = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], ts = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Ll = 8, Sn = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], Fs = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], aa = null, Dc = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Cl = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Ql = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], tc = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], po = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], vs = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Fe = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], Rs = [], An = [], xs = [], Xo = 1, fo = 2, pn = [], ui = [];
    Kt("UpsampleRgbLinePair", bi, 3), Kt("UpsampleBgrLinePair", di, 3), Kt("UpsampleRgbaLinePair", Li, 4), Kt("UpsampleBgraLinePair", xi, 4), Kt("UpsampleArgbLinePair", Cr, 4), Kt("UpsampleRgba4444LinePair", Xe, 2), Kt("UpsampleRgb565LinePair", mr, 2);
    var El = Tt.UpsampleRgbLinePair, Nc = Tt.UpsampleBgrLinePair, ul = Tt.UpsampleRgbaLinePair, Ml = Tt.UpsampleBgraLinePair, ec = Tt.UpsampleArgbLinePair, zl = Tt.UpsampleRgba4444LinePair, Bs = Tt.UpsampleRgb565LinePair, mo = 16, go = 1 << mo - 1, Ma = -227, Yo = 482, ic = 6, bs = (256 << ic) - 1, Vi = 0, dl = A(256), pl = A(256), yo = A(256), rc = A(256), nc = A(Yo - Ma), sc = A(Yo - Ma);
    Hn("YuvToRgbRow", bi, 3), Hn("YuvToBgrRow", di, 3), Hn("YuvToRgbaRow", Li, 4), Hn("YuvToBgraRow", xi, 4), Hn("YuvToArgbRow", Cr, 4), Hn("YuvToRgba4444Row", Xe, 2), Hn("YuvToRgb565Row", mr, 2);
    var es = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], p = [0, 2, 8], t = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], s = 1;
    this.WebPDecodeRGBA = function(r, a, h, d, _) {
      var w = Ea, k = new Cn(), T = new Ir();
      k.ba = T, T.S = w, T.width = [T.width], T.height = [T.height];
      var C = T.width, z = T.height, R = new kr();
      if (R == null || r == null) var W = 2;
      else g(R != null), W = ea(r, a, h, R.width, R.height, R.Pd, R.Qd, R.format, null);
      if (W != 0 ? C = 0 : (C != null && (C[0] = R.width[0]), z != null && (z[0] = R.height[0]), C = 1), C) {
        T.width = T.width[0], T.height = T.height[0], d != null && (d[0] = T.width), _ != null && (_[0] = T.height);
        t: {
          if (d = new os(), (_ = new to()).data = r, _.w = a, _.ha = h, _.kd = 1, a = [0], g(_ != null), ((r = ea(_.data, _.w, _.ha, null, null, null, a, null, _)) == 0 || r == 7) && a[0] && (r = 4), (a = r) == 0) {
            if (g(k != null), d.data = _.data, d.w = _.w + _.offset, d.ha = _.ha - _.offset, d.put = At, d.ac = ct, d.bc = Et, d.ma = k, _.xa) {
              if ((r = Oi()) == null) {
                k = 1;
                break t;
              }
              if (function(Z, G) {
                var nt = [0], Y = [0], J = [0];
                e: for (; ; ) {
                  if (Z == null) return 0;
                  if (G == null) return Z.a = 2, 0;
                  if (Z.l = G, Z.a = 0, Ut(Z.m, G.data, G.w, G.ha), !wt(Z.m, nt, Y, J)) {
                    Z.a = 3;
                    break e;
                  }
                  if (Z.xb = fo, G.width = nt[0], G.height = Y[0], !oi(nt[0], Y[0], 1, Z, null)) break e;
                  return 1;
                }
                return g(Z.a != 0), 0;
              }(r, d)) {
                if (d = (a = Er(d.width, d.height, k.Oa, k.ba)) == 0) {
                  e: {
                    d = r;
                    i: for (; ; ) {
                      if (d == null) {
                        d = 0;
                        break e;
                      }
                      if (g(d.s.yc != null), g(d.s.Ya != null), g(0 < d.s.Wb), g((h = d.l) != null), g((_ = h.ma) != null), d.xb != 0) {
                        if (d.ca = _.ba, d.tb = _.tb, g(d.ca != null), !Xn(_.Oa, h, lo)) {
                          d.a = 2;
                          break i;
                        }
                        if (!Ci(d, h.width) || h.da) break i;
                        if ((h.da || Me(d.ca.S)) && Ft(), 11 > d.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), d.ca.f.kb.F != null && Ft()), d.Pb && 0 < d.s.ua && d.s.vb.X == null && !Je(d.s.vb, d.s.Wa.Xa)) {
                          d.a = 1;
                          break i;
                        }
                        d.xb = 0;
                      }
                      if (!Ti(d, d.V, d.Ba, d.c, d.i, h.o, Ve)) break i;
                      _.Dc = d.Ma, d = 1;
                      break e;
                    }
                    g(d.a != 0), d = 0;
                  }
                  d = !d;
                }
                d && (a = r.a);
              } else a = r.a;
            } else {
              if ((r = new dr()) == null) {
                k = 1;
                break t;
              }
              if (r.Fa = _.na, r.P = _.P, r.qc = _.Sa, nr(r, d)) {
                if ((a = Er(d.width, d.height, k.Oa, k.ba)) == 0) {
                  if (r.Aa = 0, h = k.Oa, g((_ = r) != null), h != null) {
                    if (0 < (C = 0 > (C = h.Md) ? 0 : 100 < C ? 255 : 255 * C / 100)) {
                      for (z = R = 0; 4 > z; ++z) 12 > (W = _.pb[z]).lc && (W.ia = C * t[0 > W.lc ? 0 : W.lc] >> 3), R |= W.ia;
                      R && (alert("todo:VP8InitRandom"), _.ia = 1);
                    }
                    _.Ga = h.Id, 100 < _.Ga ? _.Ga = 100 : 0 > _.Ga && (_.Ga = 0);
                  }
                  ma(r, d) || (a = r.a);
                }
              } else a = r.a;
            }
            a == 0 && k.Oa != null && k.Oa.fd && (a = Yn(k.ba));
          }
          k = a;
        }
        w = k != 0 ? null : 11 > w ? T.f.RGBA.eb : T.f.kb.y;
      } else w = null;
      return w;
    };
    var c = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function B(Tt, le) {
    for (var ne = "", at = 0; at < 4; at++) ne += String.fromCharCode(Tt[le++]);
    return ne;
  }
  function $(Tt, le) {
    return (Tt[le + 0] << 0 | Tt[le + 1] << 8 | Tt[le + 2] << 16) >>> 0;
  }
  function q(Tt, le) {
    return (Tt[le + 0] << 0 | Tt[le + 1] << 8 | Tt[le + 2] << 16 | Tt[le + 3] << 24) >>> 0;
  }
  new M();
  var U = [0], F = [0], mt = [], ot = new M(), yt = b, st = function(Tt, le) {
    var ne = {}, at = 0, lt = !1, Pt = 0, bt = 0;
    if (ne.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(pt, _t, Ct, Dt) {
      for (var Ot = 0; Ot < Dt; Ot++) if (pt[_t + Ot] != Ct.charCodeAt(Ot)) return !0;
      return !1;
    }(Tt, le, "RIFF", 4)) {
      var Jt, Yt;
      for (q(Tt, le += 4), le += 8; le < Tt.length; ) {
        var te = B(Tt, le), Ut = q(Tt, le += 4);
        le += 4;
        var se = Ut + (1 & Ut);
        switch (te) {
          case "VP8 ":
          case "VP8L":
            ne.frames[at] === void 0 && (ne.frames[at] = {}), (Q = ne.frames[at]).src_off = lt ? bt : le - 8, Q.src_size = Pt + Ut + 8, at++, lt && (lt = !1, Pt = 0, bt = 0);
            break;
          case "VP8X":
            (Q = ne.header = {}).feature_flags = Tt[le];
            var ee = le + 4;
            Q.canvas_width = 1 + $(Tt, ee), ee += 3, Q.canvas_height = 1 + $(Tt, ee), ee += 3;
            break;
          case "ALPH":
            lt = !0, Pt = se + 8, bt = le - 8;
            break;
          case "ANIM":
            (Q = ne.header).bgcolor = q(Tt, le), ee = le + 4, Q.loop_count = (Jt = Tt)[(Yt = ee) + 0] << 0 | Jt[Yt + 1] << 8, ee += 2;
            break;
          case "ANMF":
            var be, Q;
            (Q = ne.frames[at] = {}).offset_x = 2 * $(Tt, le), le += 3, Q.offset_y = 2 * $(Tt, le), le += 3, Q.width = 1 + $(Tt, le), le += 3, Q.height = 1 + $(Tt, le), le += 3, Q.duration = $(Tt, le), le += 3, be = Tt[le++], Q.dispose = 1 & be, Q.blend = be >> 1 & 1;
        }
        te != "ANMF" && (le += se);
      }
      return ne;
    }
  }(yt, 0);
  st.response = yt, st.rgbaoutput = !0, st.dataurl = !1;
  var gt = st.header ? st.header : null, Mt = st.frames ? st.frames : null;
  if (gt) {
    gt.loop_counter = gt.loop_count, U = [gt.canvas_height], F = [gt.canvas_width];
    for (var Qt = 0; Qt < Mt.length && Mt[Qt].blend != 0; Qt++) ;
  }
  var Ht = Mt[0], pe = ot.WebPDecodeRGBA(yt, Ht.src_off, Ht.src_size, F, U);
  Ht.rgba = pe, Ht.imgwidth = F[0], Ht.imgheight = U[0];
  for (var jt = 0; jt < F[0] * U[0] * 4; jt++) mt[jt] = pe[jt];
  return this.width = F, this.height = U, this.data = mt, this;
}
(function(b) {
  var g = function() {
    return typeof Zu == "function";
  }, y = function(U, F, mt, ot) {
    var yt = 4, st = v;
    switch (ot) {
      case b.image_compression.FAST:
        yt = 1, st = A;
        break;
      case b.image_compression.MEDIUM:
        yt = 6, st = l;
        break;
      case b.image_compression.SLOW:
        yt = 9, st = M;
    }
    U = x(U, F, mt, st);
    var gt = Zu(U, { level: yt });
    return b.__addimage__.arrayBufferToBinaryString(gt);
  }, x = function(U, F, mt, ot) {
    for (var yt, st, gt, Mt = U.length / F, Qt = new Uint8Array(U.length + Mt), Ht = $(), pe = 0; pe < Mt; pe += 1) {
      if (gt = pe * F, yt = U.subarray(gt, gt + F), ot) Qt.set(ot(yt, mt, st), gt + pe);
      else {
        for (var jt, Tt = Ht.length, le = []; jt < Tt; jt += 1) le[jt] = Ht[jt](yt, mt, st);
        var ne = q(le.concat());
        Qt.set(le[ne], gt + pe);
      }
      st = yt;
    }
    return Qt;
  }, P = function(U) {
    var F = Array.apply([], U);
    return F.unshift(0), F;
  }, A = function(U, F) {
    var mt, ot = [], yt = U.length;
    ot[0] = 1;
    for (var st = 0; st < yt; st += 1) mt = U[st - F] || 0, ot[st + 1] = U[st] - mt + 256 & 255;
    return ot;
  }, v = function(U, F, mt) {
    var ot, yt = [], st = U.length;
    yt[0] = 2;
    for (var gt = 0; gt < st; gt += 1) ot = mt && mt[gt] || 0, yt[gt + 1] = U[gt] - ot + 256 & 255;
    return yt;
  }, l = function(U, F, mt) {
    var ot, yt, st = [], gt = U.length;
    st[0] = 3;
    for (var Mt = 0; Mt < gt; Mt += 1) ot = U[Mt - F] || 0, yt = mt && mt[Mt] || 0, st[Mt + 1] = U[Mt] + 256 - (ot + yt >>> 1) & 255;
    return st;
  }, M = function(U, F, mt) {
    var ot, yt, st, gt, Mt = [], Qt = U.length;
    Mt[0] = 4;
    for (var Ht = 0; Ht < Qt; Ht += 1) ot = U[Ht - F] || 0, yt = mt && mt[Ht] || 0, st = mt && mt[Ht - F] || 0, gt = B(ot, yt, st), Mt[Ht + 1] = U[Ht] - gt + 256 & 255;
    return Mt;
  }, B = function(U, F, mt) {
    if (U === F && F === mt) return U;
    var ot = Math.abs(F - mt), yt = Math.abs(U - mt), st = Math.abs(U + F - mt - mt);
    return ot <= yt && ot <= st ? U : yt <= st ? F : mt;
  }, $ = function() {
    return [P, A, v, l, M];
  }, q = function(U) {
    var F = U.map(function(mt) {
      return mt.reduce(function(ot, yt) {
        return ot + Math.abs(yt);
      }, 0);
    });
    return F.indexOf(Math.min.apply(null, F));
  };
  b.processPNG = function(U, F, mt, ot) {
    var yt, st, gt, Mt, Qt, Ht, pe, jt, Tt, le, ne, at, lt, Pt, bt, Jt = this.decode.FLATE_DECODE, Yt = "";
    if (this.__addimage__.isArrayBuffer(U) && (U = new Uint8Array(U)), this.__addimage__.isArrayBufferView(U)) {
      if (U = (gt = new o0(U)).imgData, st = gt.bits, yt = gt.colorSpace, Qt = gt.colors, [4, 6].indexOf(gt.colorType) !== -1) {
        if (gt.bits === 8) {
          Tt = (jt = gt.pixelBitlength == 32 ? new Uint32Array(gt.decodePixels().buffer) : gt.pixelBitlength == 16 ? new Uint16Array(gt.decodePixels().buffer) : new Uint8Array(gt.decodePixels().buffer)).length, ne = new Uint8Array(Tt * gt.colors), le = new Uint8Array(Tt);
          var te, Ut = gt.pixelBitlength - gt.bits;
          for (Pt = 0, bt = 0; Pt < Tt; Pt++) {
            for (lt = jt[Pt], te = 0; te < Ut; ) ne[bt++] = lt >>> te & 255, te += gt.bits;
            le[Pt] = lt >>> te & 255;
          }
        }
        if (gt.bits === 16) {
          Tt = (jt = new Uint32Array(gt.decodePixels().buffer)).length, ne = new Uint8Array(Tt * (32 / gt.pixelBitlength) * gt.colors), le = new Uint8Array(Tt * (32 / gt.pixelBitlength)), at = gt.colors > 1, Pt = 0, bt = 0;
          for (var se = 0; Pt < Tt; ) lt = jt[Pt++], ne[bt++] = lt >>> 0 & 255, at && (ne[bt++] = lt >>> 16 & 255, lt = jt[Pt++], ne[bt++] = lt >>> 0 & 255), le[se++] = lt >>> 16 & 255;
          st = 8;
        }
        ot !== b.image_compression.NONE && g() ? (U = y(ne, gt.width * gt.colors, gt.colors, ot), pe = y(le, gt.width, 1, ot)) : (U = ne, pe = le, Jt = void 0);
      }
      if (gt.colorType === 3 && (yt = this.color_spaces.INDEXED, Ht = gt.palette, gt.transparency.indexed)) {
        var ee = gt.transparency.indexed, be = 0;
        for (Pt = 0, Tt = ee.length; Pt < Tt; ++Pt) be += ee[Pt];
        if ((be /= 255) === Tt - 1 && ee.indexOf(0) !== -1) Mt = [ee.indexOf(0)];
        else if (be !== Tt) {
          for (jt = gt.decodePixels(), le = new Uint8Array(jt.length), Pt = 0, Tt = jt.length; Pt < Tt; Pt++) le[Pt] = ee[jt[Pt]];
          pe = y(le, gt.width, 1);
        }
      }
      var Q = function(pt) {
        var _t;
        switch (pt) {
          case b.image_compression.FAST:
            _t = 11;
            break;
          case b.image_compression.MEDIUM:
            _t = 13;
            break;
          case b.image_compression.SLOW:
            _t = 14;
            break;
          default:
            _t = 12;
        }
        return _t;
      }(ot);
      return Jt === this.decode.FLATE_DECODE && (Yt = "/Predictor " + Q + " "), Yt += "/Colors " + Qt + " /BitsPerComponent " + st + " /Columns " + gt.width, (this.__addimage__.isArrayBuffer(U) || this.__addimage__.isArrayBufferView(U)) && (U = this.__addimage__.arrayBufferToBinaryString(U)), (pe && this.__addimage__.isArrayBuffer(pe) || this.__addimage__.isArrayBufferView(pe)) && (pe = this.__addimage__.arrayBufferToBinaryString(pe)), { alias: mt, data: U, index: F, filter: Jt, decodeParameters: Yt, transparency: Mt, palette: Ht, sMask: pe, predictor: Q, width: gt.width, height: gt.height, bitsPerComponent: st, colorSpace: yt };
    }
  };
})(pi.API), function(b) {
  b.processGIF89A = function(g, y, x, P) {
    var A = new l0(g), v = A.width, l = A.height, M = [];
    A.decodeAndBlitFrameRGBA(0, M);
    var B = { data: M, width: v, height: l }, $ = new Ou(100).encode(B, 100);
    return b.processJPEG.call(this, $, y, x, P);
  }, b.processGIF87A = b.processGIF89A;
}(pi.API), Oa.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var b = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(b);
    for (var g = 0; g < b; g++) {
      var y = this.datav.getUint8(this.pos++, !0), x = this.datav.getUint8(this.pos++, !0), P = this.datav.getUint8(this.pos++, !0), A = this.datav.getUint8(this.pos++, !0);
      this.palette[g] = { red: P, green: x, blue: y, quad: A };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, Oa.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var b = "bit" + this.bitPP, g = this.width * this.height * 4;
    this.data = new Uint8Array(g), this[b]();
  } catch (y) {
    ur.log("bit decode error:" + y);
  }
}, Oa.prototype.bit1 = function() {
  var b, g = Math.ceil(this.width / 8), y = g % 4;
  for (b = this.height - 1; b >= 0; b--) {
    for (var x = this.bottom_up ? b : this.height - 1 - b, P = 0; P < g; P++) for (var A = this.datav.getUint8(this.pos++, !0), v = x * this.width * 4 + 8 * P * 4, l = 0; l < 8 && 8 * P + l < this.width; l++) {
      var M = this.palette[A >> 7 - l & 1];
      this.data[v + 4 * l] = M.blue, this.data[v + 4 * l + 1] = M.green, this.data[v + 4 * l + 2] = M.red, this.data[v + 4 * l + 3] = 255;
    }
    y !== 0 && (this.pos += 4 - y);
  }
}, Oa.prototype.bit4 = function() {
  for (var b = Math.ceil(this.width / 2), g = b % 4, y = this.height - 1; y >= 0; y--) {
    for (var x = this.bottom_up ? y : this.height - 1 - y, P = 0; P < b; P++) {
      var A = this.datav.getUint8(this.pos++, !0), v = x * this.width * 4 + 2 * P * 4, l = A >> 4, M = 15 & A, B = this.palette[l];
      if (this.data[v] = B.blue, this.data[v + 1] = B.green, this.data[v + 2] = B.red, this.data[v + 3] = 255, 2 * P + 1 >= this.width) break;
      B = this.palette[M], this.data[v + 4] = B.blue, this.data[v + 4 + 1] = B.green, this.data[v + 4 + 2] = B.red, this.data[v + 4 + 3] = 255;
    }
    g !== 0 && (this.pos += 4 - g);
  }
}, Oa.prototype.bit8 = function() {
  for (var b = this.width % 4, g = this.height - 1; g >= 0; g--) {
    for (var y = this.bottom_up ? g : this.height - 1 - g, x = 0; x < this.width; x++) {
      var P = this.datav.getUint8(this.pos++, !0), A = y * this.width * 4 + 4 * x;
      if (P < this.palette.length) {
        var v = this.palette[P];
        this.data[A] = v.red, this.data[A + 1] = v.green, this.data[A + 2] = v.blue, this.data[A + 3] = 255;
      } else this.data[A] = 255, this.data[A + 1] = 255, this.data[A + 2] = 255, this.data[A + 3] = 255;
    }
    b !== 0 && (this.pos += 4 - b);
  }
}, Oa.prototype.bit15 = function() {
  for (var b = this.width % 3, g = parseInt("11111", 2), y = this.height - 1; y >= 0; y--) {
    for (var x = this.bottom_up ? y : this.height - 1 - y, P = 0; P < this.width; P++) {
      var A = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var v = (A & g) / g * 255 | 0, l = (A >> 5 & g) / g * 255 | 0, M = (A >> 10 & g) / g * 255 | 0, B = A >> 15 ? 255 : 0, $ = x * this.width * 4 + 4 * P;
      this.data[$] = M, this.data[$ + 1] = l, this.data[$ + 2] = v, this.data[$ + 3] = B;
    }
    this.pos += b;
  }
}, Oa.prototype.bit16 = function() {
  for (var b = this.width % 3, g = parseInt("11111", 2), y = parseInt("111111", 2), x = this.height - 1; x >= 0; x--) {
    for (var P = this.bottom_up ? x : this.height - 1 - x, A = 0; A < this.width; A++) {
      var v = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var l = (v & g) / g * 255 | 0, M = (v >> 5 & y) / y * 255 | 0, B = (v >> 11) / g * 255 | 0, $ = P * this.width * 4 + 4 * A;
      this.data[$] = B, this.data[$ + 1] = M, this.data[$ + 2] = l, this.data[$ + 3] = 255;
    }
    this.pos += b;
  }
}, Oa.prototype.bit24 = function() {
  for (var b = this.height - 1; b >= 0; b--) {
    for (var g = this.bottom_up ? b : this.height - 1 - b, y = 0; y < this.width; y++) {
      var x = this.datav.getUint8(this.pos++, !0), P = this.datav.getUint8(this.pos++, !0), A = this.datav.getUint8(this.pos++, !0), v = g * this.width * 4 + 4 * y;
      this.data[v] = A, this.data[v + 1] = P, this.data[v + 2] = x, this.data[v + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, Oa.prototype.bit32 = function() {
  for (var b = this.height - 1; b >= 0; b--) for (var g = this.bottom_up ? b : this.height - 1 - b, y = 0; y < this.width; y++) {
    var x = this.datav.getUint8(this.pos++, !0), P = this.datav.getUint8(this.pos++, !0), A = this.datav.getUint8(this.pos++, !0), v = this.datav.getUint8(this.pos++, !0), l = g * this.width * 4 + 4 * y;
    this.data[l] = A, this.data[l + 1] = P, this.data[l + 2] = x, this.data[l + 3] = v;
  }
}, Oa.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  b.processBMP = function(g, y, x, P) {
    var A = new Oa(g, !1), v = A.width, l = A.height, M = { data: A.getData(), width: v, height: l }, B = new Ou(100).encode(M, 100);
    return b.processJPEG.call(this, B, y, x, P);
  };
}(pi.API), Hp.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  b.processWEBP = function(g, y, x, P) {
    var A = new Hp(g), v = A.width, l = A.height, M = { data: A.getData(), width: v, height: l }, B = new Ou(100).encode(M, 100);
    return b.processJPEG.call(this, B, y, x, P);
  };
}(pi.API), pi.API.processRGBA = function(b, g, y) {
  for (var x = b.data, P = x.length, A = new Uint8Array(P / 4 * 3), v = new Uint8Array(P / 4), l = 0, M = 0, B = 0; B < P; B += 4) {
    var $ = x[B], q = x[B + 1], U = x[B + 2], F = x[B + 3];
    A[l++] = $, A[l++] = q, A[l++] = U, v[M++] = F;
  }
  var mt = this.__addimage__.arrayBufferToBinaryString(A);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(v), data: mt, index: g, alias: y, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: b.width, height: b.height };
}, pi.API.setLanguage = function(b) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[b] !== void 0 && (this.internal.languageSettings.languageCode = b, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, Ic = pi.API, Rh = Ic.getCharWidthsArray = function(b, g) {
  var y, x, P = (g = g || {}).font || this.internal.getFont(), A = g.fontSize || this.internal.getFontSize(), v = g.charSpace || this.internal.getCharSpace(), l = g.widths ? g.widths : P.metadata.Unicode.widths, M = l.fof ? l.fof : 1, B = g.kerning ? g.kerning : P.metadata.Unicode.kerning, $ = B.fof ? B.fof : 1, q = g.doKerning !== !1, U = 0, F = b.length, mt = 0, ot = l[0] || M, yt = [];
  for (y = 0; y < F; y++) x = b.charCodeAt(y), typeof P.metadata.widthOfString == "function" ? yt.push((P.metadata.widthOfGlyph(P.metadata.characterToGlyph(x)) + v * (1e3 / A) || 0) / 1e3) : (U = q && ir(B[x]) === "object" && !isNaN(parseInt(B[x][mt], 10)) ? B[x][mt] / $ : 0, yt.push((l[x] || ot) / M + U)), mt = x;
  return yt;
}, $p = Ic.getStringUnitWidth = function(b, g) {
  var y = (g = g || {}).fontSize || this.internal.getFontSize(), x = g.font || this.internal.getFont(), P = g.charSpace || this.internal.getCharSpace();
  return Ic.processArabic && (b = Ic.processArabic(b)), typeof x.metadata.widthOfString == "function" ? x.metadata.widthOfString(b, y, P) / y : Rh.apply(this, arguments).reduce(function(A, v) {
    return A + v;
  }, 0);
}, Zp = function(b, g, y, x) {
  for (var P = [], A = 0, v = b.length, l = 0; A !== v && l + g[A] < y; ) l += g[A], A++;
  P.push(b.slice(0, A));
  var M = A;
  for (l = 0; A !== v; ) l + g[A] > x && (P.push(b.slice(M, A)), l = 0, M = A), l += g[A], A++;
  return M !== A && P.push(b.slice(M, A)), P;
}, Gp = function(b, g, y) {
  y || (y = {});
  var x, P, A, v, l, M, B, $ = [], q = [$], U = y.textIndent || 0, F = 0, mt = 0, ot = b.split(" "), yt = Rh.apply(this, [" ", y])[0];
  if (M = y.lineIndent === -1 ? ot[0].length + 2 : y.lineIndent || 0) {
    var st = Array(M).join(" "), gt = [];
    ot.map(function(Qt) {
      (Qt = Qt.split(/\s*\n/)).length > 1 ? gt = gt.concat(Qt.map(function(Ht, pe) {
        return (pe && Ht.length ? `
` : "") + Ht;
      })) : gt.push(Qt[0]);
    }), ot = gt, M = $p.apply(this, [st, y]);
  }
  for (A = 0, v = ot.length; A < v; A++) {
    var Mt = 0;
    if (x = ot[A], M && x[0] == `
` && (x = x.substr(1), Mt = 1), U + F + (mt = (P = Rh.apply(this, [x, y])).reduce(function(Qt, Ht) {
      return Qt + Ht;
    }, 0)) > g || Mt) {
      if (mt > g) {
        for (l = Zp.apply(this, [x, P, g - (U + F), g]), $.push(l.shift()), $ = [l.pop()]; l.length; ) q.push([l.shift()]);
        mt = P.slice(x.length - ($[0] ? $[0].length : 0)).reduce(function(Qt, Ht) {
          return Qt + Ht;
        }, 0);
      } else $ = [x];
      q.push($), U = mt + M, F = yt;
    } else $.push(x), U += F + mt, F = yt;
  }
  return B = M ? function(Qt, Ht) {
    return (Ht ? st : "") + Qt.join(" ");
  } : function(Qt) {
    return Qt.join(" ");
  }, q.map(B);
}, Ic.splitTextToSize = function(b, g, y) {
  var x, P = (y = y || {}).fontSize || this.internal.getFontSize(), A = (function($) {
    if ($.widths && $.kerning) return { widths: $.widths, kerning: $.kerning };
    var q = this.internal.getFont($.fontName, $.fontStyle);
    return q.metadata.Unicode ? { widths: q.metadata.Unicode.widths || { 0: 1 }, kerning: q.metadata.Unicode.kerning || {} } : { font: q.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, y);
  x = Array.isArray(b) ? b : String(b).split(/\r?\n/);
  var v = 1 * this.internal.scaleFactor * g / P;
  A.textIndent = y.textIndent ? 1 * y.textIndent * this.internal.scaleFactor / P : 0, A.lineIndent = y.lineIndent;
  var l, M, B = [];
  for (l = 0, M = x.length; l < M; l++) B = B.concat(Gp.apply(this, [x[l], v, A]));
  return B;
}, function(b) {
  b.__fontmetrics__ = b.__fontmetrics__ || {};
  for (var g = "klmnopqrstuvwxyz", y = {}, x = {}, P = 0; P < g.length; P++) y[g[P]] = "0123456789abcdef"[P], x["0123456789abcdef"[P]] = g[P];
  var A = function(q) {
    return "0x" + parseInt(q, 10).toString(16);
  }, v = b.__fontmetrics__.compress = function(q) {
    var U, F, mt, ot, yt = ["{"];
    for (var st in q) {
      if (U = q[st], isNaN(parseInt(st, 10)) ? F = "'" + st + "'" : (st = parseInt(st, 10), F = (F = A(st).slice(2)).slice(0, -1) + x[F.slice(-1)]), typeof U == "number") U < 0 ? (mt = A(U).slice(3), ot = "-") : (mt = A(U).slice(2), ot = ""), mt = ot + mt.slice(0, -1) + x[mt.slice(-1)];
      else {
        if (ir(U) !== "object") throw new Error("Don't know what to do with value type " + ir(U) + ".");
        mt = v(U);
      }
      yt.push(F + mt);
    }
    return yt.push("}"), yt.join("");
  }, l = b.__fontmetrics__.uncompress = function(q) {
    if (typeof q != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var U, F, mt, ot, yt = {}, st = 1, gt = yt, Mt = [], Qt = "", Ht = "", pe = q.length - 1, jt = 1; jt < pe; jt += 1) (ot = q[jt]) == "'" ? U ? (mt = U.join(""), U = void 0) : U = [] : U ? U.push(ot) : ot == "{" ? (Mt.push([gt, mt]), gt = {}, mt = void 0) : ot == "}" ? ((F = Mt.pop())[0][F[1]] = gt, mt = void 0, gt = F[0]) : ot == "-" ? st = -1 : mt === void 0 ? y.hasOwnProperty(ot) ? (Qt += y[ot], mt = parseInt(Qt, 16) * st, st = 1, Qt = "") : Qt += ot : y.hasOwnProperty(ot) ? (Ht += y[ot], gt[mt] = parseInt(Ht, 16) * st, st = 1, mt = void 0, Ht = "") : Ht += ot;
    return yt;
  }, M = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: l("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, B = { Unicode: { Courier: M, "Courier-Bold": M, "Courier-BoldOblique": M, "Courier-Oblique": M, Helvetica: M, "Helvetica-Bold": M, "Helvetica-BoldOblique": M, "Helvetica-Oblique": M, "Times-Roman": M, "Times-Bold": M, "Times-BoldItalic": M, "Times-Italic": M } }, $ = { Unicode: { "Courier-Oblique": l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": l("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": l("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": l("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: l("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: l("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": l("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: l("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": l("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": l("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": l("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": l("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  b.events.push(["addFont", function(q) {
    var U = q.font, F = $.Unicode[U.postScriptName];
    F && (U.metadata.Unicode = {}, U.metadata.Unicode.widths = F.widths, U.metadata.Unicode.kerning = F.kerning);
    var mt = B.Unicode[U.postScriptName];
    mt && (U.metadata.Unicode.encoding = mt, U.encoding = mt.codePages[0]);
  }]);
}(pi.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  var g = function(y) {
    for (var x = y.length, P = new Uint8Array(x), A = 0; A < x; A++) P[A] = y.charCodeAt(A);
    return P;
  };
  b.API.events.push(["addFont", function(y) {
    var x = void 0, P = y.font, A = y.instance;
    if (!P.isStandardFont) {
      if (A === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + P.postScriptName + "').");
      if (typeof (x = A.existsFileInVFS(P.postScriptName) === !1 ? A.loadFile(P.postScriptName) : A.getFileFromVFS(P.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + P.postScriptName + "').");
      (function(v, l) {
        l = /^\x00\x01\x00\x00/.test(l) ? g(l) : g(lh(l)), v.metadata = b.API.TTFFont.open(l), v.metadata.Unicode = v.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, v.metadata.glyIdsUsed = [0];
      })(P, x);
    }
  }]);
}(pi), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(b) {
  function g() {
    return (fi.canvg ? Promise.resolve(fi.canvg) : import("./index.es-DIlDUQB2-DJKTPzH9.mjs")).catch(function(y) {
      return Promise.reject(new Error("Could not load canvg: " + y));
    }).then(function(y) {
      return y.default ? y.default : y;
    });
  }
  pi.API.addSvgAsImage = function(y, x, P, A, v, l, M, B) {
    if (isNaN(x) || isNaN(P)) throw ur.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(A) || isNaN(v)) throw ur.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var $ = document.createElement("canvas");
    $.width = A, $.height = v;
    var q = $.getContext("2d");
    q.fillStyle = "#fff", q.fillRect(0, 0, $.width, $.height);
    var U = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, F = this;
    return g().then(function(mt) {
      return mt.fromString(q, y, U);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(mt) {
      return mt.render(U);
    }).then(function() {
      F.addImage($.toDataURL("image/jpeg", 1), x, P, A, v, M, B);
    });
  };
}(), pi.API.putTotalPages = function(b) {
  var g, y = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (g = new RegExp(b, "g"), y = this.internal.getNumberOfPages()) : (g = new RegExp(this.pdfEscape16(b, this.internal.getFont()), "g"), y = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var x = 1; x <= this.internal.getNumberOfPages(); x++) for (var P = 0; P < this.internal.pages[x].length; P++) this.internal.pages[x][P] = this.internal.pages[x][P].replace(g, y);
  return this;
}, pi.API.viewerPreferences = function(b, g) {
  var y;
  b = b || {}, g = g || !1;
  var x, P, A, v = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, l = Object.keys(v), M = [], B = 0, $ = 0, q = 0;
  function U(mt, ot) {
    var yt, st = !1;
    for (yt = 0; yt < mt.length; yt += 1) mt[yt] === ot && (st = !0);
    return st;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(v)), this.internal.viewerpreferences.isSubscribed = !1), y = this.internal.viewerpreferences.configuration, b === "reset" || g === !0) {
    var F = l.length;
    for (q = 0; q < F; q += 1) y[l[q]].value = y[l[q]].defaultValue, y[l[q]].explicitSet = !1;
  }
  if (ir(b) === "object") {
    for (P in b) if (A = b[P], U(l, P) && A !== void 0) {
      if (y[P].type === "boolean" && typeof A == "boolean") y[P].value = A;
      else if (y[P].type === "name" && U(y[P].valueSet, A)) y[P].value = A;
      else if (y[P].type === "integer" && Number.isInteger(A)) y[P].value = A;
      else if (y[P].type === "array") {
        for (B = 0; B < A.length; B += 1) if (x = !0, A[B].length === 1 && typeof A[B][0] == "number") M.push(String(A[B] - 1));
        else if (A[B].length > 1) {
          for ($ = 0; $ < A[B].length; $ += 1) typeof A[B][$] != "number" && (x = !1);
          x === !0 && M.push([A[B][0] - 1, A[B][1] - 1].join(" "));
        }
        y[P].value = "[" + M.join(" ") + "]";
      } else y[P].value = y[P].defaultValue;
      y[P].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var mt, ot = [];
    for (mt in y) y[mt].explicitSet === !0 && (y[mt].type === "name" ? ot.push("/" + mt + " /" + y[mt].value) : ot.push("/" + mt + " " + y[mt].value));
    ot.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + ot.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = y, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(b) {
  var g = function() {
    var x = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', P = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), A = unescape(encodeURIComponent(x)), v = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), l = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), M = unescape(encodeURIComponent("</x:xmpmeta>")), B = A.length + v.length + l.length + P.length + M.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + B + " >>"), this.internal.write("stream"), this.internal.write(P + A + v + l + M), this.internal.write("endstream"), this.internal.write("endobj");
  }, y = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  b.addMetadata = function(x, P) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: x, namespaceuri: P || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", y), this.internal.events.subscribe("postPutResources", g)), this;
  };
}(pi.API), function(b) {
  var g = b.API, y = g.pdfEscape16 = function(A, v) {
    for (var l, M = v.metadata.Unicode.widths, B = ["", "0", "00", "000", "0000"], $ = [""], q = 0, U = A.length; q < U; ++q) {
      if (l = v.metadata.characterToGlyph(A.charCodeAt(q)), v.metadata.glyIdsUsed.push(l), v.metadata.toUnicode[l] = A.charCodeAt(q), M.indexOf(l) == -1 && (M.push(l), M.push([parseInt(v.metadata.widthOfGlyph(l), 10)])), l == "0") return $.join("");
      l = l.toString(16), $.push(B[4 - l.length], l);
    }
    return $.join("");
  }, x = function(A) {
    var v, l, M, B, $, q, U;
    for ($ = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, M = [], q = 0, U = (l = Object.keys(A).sort(function(F, mt) {
      return F - mt;
    })).length; q < U; q++) v = l[q], M.length >= 100 && ($ += `
` + M.length + ` beginbfchar
` + M.join(`
`) + `
endbfchar`, M = []), A[v] !== void 0 && A[v] !== null && typeof A[v].toString == "function" && (B = ("0000" + A[v].toString(16)).slice(-4), v = ("0000" + (+v).toString(16)).slice(-4), M.push("<" + v + "><" + B + ">"));
    return M.length && ($ += `
` + M.length + ` beginbfchar
` + M.join(`
`) + `
endbfchar
`), $ += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  g.events.push(["putFont", function(A) {
    (function(v) {
      var l = v.font, M = v.out, B = v.newObject, $ = v.putStream;
      if (l.metadata instanceof b.API.TTFFont && l.encoding === "Identity-H") {
        for (var q = l.metadata.Unicode.widths, U = l.metadata.subset.encode(l.metadata.glyIdsUsed, 1), F = "", mt = 0; mt < U.length; mt++) F += String.fromCharCode(U[mt]);
        var ot = B();
        $({ data: F, addLength1: !0, objectId: ot }), M("endobj");
        var yt = B();
        $({ data: x(l.metadata.toUnicode), addLength1: !0, objectId: yt }), M("endobj");
        var st = B();
        M("<<"), M("/Type /FontDescriptor"), M("/FontName /" + Tc(l.fontName)), M("/FontFile2 " + ot + " 0 R"), M("/FontBBox " + b.API.PDFObject.convert(l.metadata.bbox)), M("/Flags " + l.metadata.flags), M("/StemV " + l.metadata.stemV), M("/ItalicAngle " + l.metadata.italicAngle), M("/Ascent " + l.metadata.ascender), M("/Descent " + l.metadata.decender), M("/CapHeight " + l.metadata.capHeight), M(">>"), M("endobj");
        var gt = B();
        M("<<"), M("/Type /Font"), M("/BaseFont /" + Tc(l.fontName)), M("/FontDescriptor " + st + " 0 R"), M("/W " + b.API.PDFObject.convert(q)), M("/CIDToGIDMap /Identity"), M("/DW 1000"), M("/Subtype /CIDFontType2"), M("/CIDSystemInfo"), M("<<"), M("/Supplement 0"), M("/Registry (Adobe)"), M("/Ordering (" + l.encoding + ")"), M(">>"), M(">>"), M("endobj"), l.objectNumber = B(), M("<<"), M("/Type /Font"), M("/Subtype /Type0"), M("/ToUnicode " + yt + " 0 R"), M("/BaseFont /" + Tc(l.fontName)), M("/Encoding /" + l.encoding), M("/DescendantFonts [" + gt + " 0 R]"), M(">>"), M("endobj"), l.isAlreadyPutted = !0;
      }
    })(A);
  }]), g.events.push(["putFont", function(A) {
    (function(v) {
      var l = v.font, M = v.out, B = v.newObject, $ = v.putStream;
      if (l.metadata instanceof b.API.TTFFont && l.encoding === "WinAnsiEncoding") {
        for (var q = l.metadata.rawData, U = "", F = 0; F < q.length; F++) U += String.fromCharCode(q[F]);
        var mt = B();
        $({ data: U, addLength1: !0, objectId: mt }), M("endobj");
        var ot = B();
        $({ data: x(l.metadata.toUnicode), addLength1: !0, objectId: ot }), M("endobj");
        var yt = B();
        M("<<"), M("/Descent " + l.metadata.decender), M("/CapHeight " + l.metadata.capHeight), M("/StemV " + l.metadata.stemV), M("/Type /FontDescriptor"), M("/FontFile2 " + mt + " 0 R"), M("/Flags 96"), M("/FontBBox " + b.API.PDFObject.convert(l.metadata.bbox)), M("/FontName /" + Tc(l.fontName)), M("/ItalicAngle " + l.metadata.italicAngle), M("/Ascent " + l.metadata.ascender), M(">>"), M("endobj"), l.objectNumber = B();
        for (var st = 0; st < l.metadata.hmtx.widths.length; st++) l.metadata.hmtx.widths[st] = parseInt(l.metadata.hmtx.widths[st] * (1e3 / l.metadata.head.unitsPerEm));
        M("<</Subtype/TrueType/Type/Font/ToUnicode " + ot + " 0 R/BaseFont/" + Tc(l.fontName) + "/FontDescriptor " + yt + " 0 R/Encoding/" + l.encoding + " /FirstChar 29 /LastChar 255 /Widths " + b.API.PDFObject.convert(l.metadata.hmtx.widths) + ">>"), M("endobj"), l.isAlreadyPutted = !0;
      }
    })(A);
  }]);
  var P = function(A) {
    var v, l = A.text || "", M = A.x, B = A.y, $ = A.options || {}, q = A.mutex || {}, U = q.pdfEscape, F = q.activeFontKey, mt = q.fonts, ot = F, yt = "", st = 0, gt = "", Mt = mt[ot].encoding;
    if (mt[ot].encoding !== "Identity-H") return { text: l, x: M, y: B, options: $, mutex: q };
    for (gt = l, ot = F, Array.isArray(l) && (gt = l[0]), st = 0; st < gt.length; st += 1) mt[ot].metadata.hasOwnProperty("cmap") && (v = mt[ot].metadata.cmap.unicode.codeMap[gt[st].charCodeAt(0)]), v || gt[st].charCodeAt(0) < 256 && mt[ot].metadata.hasOwnProperty("Unicode") ? yt += gt[st] : yt += "";
    var Qt = "";
    return parseInt(ot.slice(1)) < 14 || Mt === "WinAnsiEncoding" ? Qt = U(yt, ot).split("").map(function(Ht) {
      return Ht.charCodeAt(0).toString(16);
    }).join("") : Mt === "Identity-H" && (Qt = y(yt, mt[ot])), q.isHex = !0, { text: Qt, x: M, y: B, options: $, mutex: q };
  };
  g.events.push(["postProcessText", function(A) {
    var v = A.text || "", l = [], M = { text: v, x: A.x, y: A.y, options: A.options, mutex: A.mutex };
    if (Array.isArray(v)) {
      var B = 0;
      for (B = 0; B < v.length; B += 1) Array.isArray(v[B]) && v[B].length === 3 ? l.push([P(Object.assign({}, M, { text: v[B][0] })).text, v[B][1], v[B][2]]) : l.push(P(Object.assign({}, M, { text: v[B] })).text);
      A.text = l;
    } else A.text = P(Object.assign({}, M, { text: v })).text;
  }]);
}(pi), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(b) {
  var g = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  b.existsFileInVFS = function(y) {
    return g.call(this), this.internal.vFS[y] !== void 0;
  }, b.addFileToVFS = function(y, x) {
    return g.call(this), this.internal.vFS[y] = x, this;
  }, b.getFileFromVFS = function(y) {
    return g.call(this), this.internal.vFS[y] !== void 0 ? this.internal.vFS[y] : null;
  };
}(pi.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(b) {
  b.__bidiEngine__ = b.prototype.__bidiEngine__ = function(x) {
    var P, A, v, l, M, B, $, q = g, U = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], F = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], mt = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, ot = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, yt = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], st = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), gt = !1, Mt = 0;
    this.__bidiEngine__ = {};
    var Qt = function(at) {
      var lt = at.charCodeAt(), Pt = lt >> 8, bt = ot[Pt];
      return bt !== void 0 ? q[256 * bt + (255 & lt)] : Pt === 252 || Pt === 253 ? "AL" : st.test(Pt) ? "L" : Pt === 8 ? "R" : "N";
    }, Ht = function(at) {
      for (var lt, Pt = 0; Pt < at.length; Pt++) {
        if ((lt = Qt(at.charAt(Pt))) === "L") return !1;
        if (lt === "R") return !0;
      }
      return !1;
    }, pe = function(at, lt, Pt, bt) {
      var Jt, Yt, te, Ut, se = lt[bt];
      switch (se) {
        case "L":
        case "R":
          gt = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          gt && (se = "AN");
          break;
        case "AL":
          gt = !0, se = "R";
          break;
        case "WS":
          se = "N";
          break;
        case "CS":
          bt < 1 || bt + 1 >= lt.length || (Jt = Pt[bt - 1]) !== "EN" && Jt !== "AN" || (Yt = lt[bt + 1]) !== "EN" && Yt !== "AN" ? se = "N" : gt && (Yt = "AN"), se = Yt === Jt ? Yt : "N";
          break;
        case "ES":
          se = (Jt = bt > 0 ? Pt[bt - 1] : "B") === "EN" && bt + 1 < lt.length && lt[bt + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (bt > 0 && Pt[bt - 1] === "EN") {
            se = "EN";
            break;
          }
          if (gt) {
            se = "N";
            break;
          }
          for (te = bt + 1, Ut = lt.length; te < Ut && lt[te] === "ET"; ) te++;
          se = te < Ut && lt[te] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (v && !l) {
            for (Ut = lt.length, te = bt + 1; te < Ut && lt[te] === "NSM"; ) te++;
            if (te < Ut) {
              var ee = at[bt], be = ee >= 1425 && ee <= 2303 || ee === 64286;
              if (Jt = lt[te], be && (Jt === "R" || Jt === "AL")) {
                se = "R";
                break;
              }
            }
          }
          se = bt < 1 || (Jt = lt[bt - 1]) === "B" ? "N" : Pt[bt - 1];
          break;
        case "B":
          gt = !1, P = !0, se = Mt;
          break;
        case "S":
          A = !0, se = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          gt = !1;
          break;
        case "BN":
          se = "N";
      }
      return se;
    }, jt = function(at, lt, Pt) {
      var bt = at.split("");
      return Pt && Tt(bt, Pt, { hiLevel: Mt }), bt.reverse(), lt && lt.reverse(), bt.join("");
    }, Tt = function(at, lt, Pt) {
      var bt, Jt, Yt, te, Ut, se = -1, ee = at.length, be = 0, Q = [], pt = Mt ? F : U, _t = [];
      for (gt = !1, P = !1, A = !1, Jt = 0; Jt < ee; Jt++) _t[Jt] = Qt(at[Jt]);
      for (Yt = 0; Yt < ee; Yt++) {
        if (Ut = be, Q[Yt] = pe(at, _t, Q, Yt), bt = 240 & (be = pt[Ut][mt[Q[Yt]]]), be &= 15, lt[Yt] = te = pt[be][5], bt > 0) if (bt === 16) {
          for (Jt = se; Jt < Yt; Jt++) lt[Jt] = 1;
          se = -1;
        } else se = -1;
        if (pt[be][6]) se === -1 && (se = Yt);
        else if (se > -1) {
          for (Jt = se; Jt < Yt; Jt++) lt[Jt] = te;
          se = -1;
        }
        _t[Yt] === "B" && (lt[Yt] = 0), Pt.hiLevel |= te;
      }
      A && function(Ct, Dt, Ot) {
        for (var Vt = 0; Vt < Ot; Vt++) if (Ct[Vt] === "S") {
          Dt[Vt] = Mt;
          for (var Wt = Vt - 1; Wt >= 0 && Ct[Wt] === "WS"; Wt--) Dt[Wt] = Mt;
        }
      }(_t, lt, ee);
    }, le = function(at, lt, Pt, bt, Jt) {
      if (!(Jt.hiLevel < at)) {
        if (at === 1 && Mt === 1 && !P) return lt.reverse(), void (Pt && Pt.reverse());
        for (var Yt, te, Ut, se, ee = lt.length, be = 0; be < ee; ) {
          if (bt[be] >= at) {
            for (Ut = be + 1; Ut < ee && bt[Ut] >= at; ) Ut++;
            for (se = be, te = Ut - 1; se < te; se++, te--) Yt = lt[se], lt[se] = lt[te], lt[te] = Yt, Pt && (Yt = Pt[se], Pt[se] = Pt[te], Pt[te] = Yt);
            be = Ut;
          }
          be++;
        }
      }
    }, ne = function(at, lt, Pt) {
      var bt = at.split(""), Jt = { hiLevel: Mt };
      return Pt || (Pt = []), Tt(bt, Pt, Jt), function(Yt, te, Ut) {
        if (Ut.hiLevel !== 0 && $) for (var se, ee = 0; ee < Yt.length; ee++) te[ee] === 1 && (se = yt.indexOf(Yt[ee])) >= 0 && (Yt[ee] = yt[se + 1]);
      }(bt, Pt, Jt), le(2, bt, lt, Pt, Jt), le(1, bt, lt, Pt, Jt), bt.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(at, lt, Pt) {
      if (function(Jt, Yt) {
        if (Yt) for (var te = 0; te < Jt.length; te++) Yt[te] = te;
        l === void 0 && (l = Ht(Jt)), B === void 0 && (B = Ht(Jt));
      }(at, lt), v || !M || B) if (v && M && l ^ B) Mt = l ? 1 : 0, at = jt(at, lt, Pt);
      else if (!v && M && B) Mt = l ? 1 : 0, at = ne(at, lt, Pt), at = jt(at, lt);
      else if (!v || l || M || B) {
        if (v && !M && l ^ B) at = jt(at, lt), l ? (Mt = 0, at = ne(at, lt, Pt)) : (Mt = 1, at = ne(at, lt, Pt), at = jt(at, lt));
        else if (v && l && !M && B) Mt = 1, at = ne(at, lt, Pt), at = jt(at, lt);
        else if (!v && !M && l ^ B) {
          var bt = $;
          l ? (Mt = 1, at = ne(at, lt, Pt), Mt = 0, $ = !1, at = ne(at, lt, Pt), $ = bt) : (Mt = 0, at = ne(at, lt, Pt), at = jt(at, lt), Mt = 1, $ = !1, at = ne(at, lt, Pt), $ = bt, at = jt(at, lt));
        }
      } else Mt = 0, at = ne(at, lt, Pt);
      else Mt = l ? 1 : 0, at = ne(at, lt, Pt);
      return at;
    }, this.__bidiEngine__.setOptions = function(at) {
      at && (v = at.isInputVisual, M = at.isOutputVisual, l = at.isInputRtl, B = at.isOutputRtl, $ = at.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(x), this.__bidiEngine__;
  };
  var g = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], y = new b.__bidiEngine__({ isInputVisual: !0 });
  b.API.events.push(["postProcessText", function(x) {
    var P = x.text, A = (x.x, x.y, x.options || {}), v = (x.mutex, A.lang, []);
    if (A.isInputVisual = typeof A.isInputVisual != "boolean" || A.isInputVisual, y.setOptions(A), Object.prototype.toString.call(P) === "[object Array]") {
      var l = 0;
      for (v = [], l = 0; l < P.length; l += 1) Object.prototype.toString.call(P[l]) === "[object Array]" ? v.push([y.doBidiReorder(P[l][0]), P[l][1], P[l][2]]) : v.push([y.doBidiReorder(P[l])]);
      x.text = v;
    } else x.text = y.doBidiReorder(P);
    y.setOptions({ isInputVisual: !0 });
  }]);
}(pi), pi.API.TTFFont = function() {
  function b(g) {
    var y;
    if (this.rawData = g, y = this.contents = new Pl(g), this.contents.pos = 4, y.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    y.pos = 0, this.parse(), this.subset = new S0(this), this.registerTTF();
  }
  return b.open = function(g) {
    return new b(g);
  }, b.prototype.parse = function() {
    return this.directory = new c0(this.contents), this.head = new u0(this), this.name = new g0(this), this.cmap = new mf(this), this.toUnicode = {}, this.hhea = new d0(this), this.maxp = new y0(this), this.hmtx = new _0(this), this.post = new f0(this), this.os2 = new p0(this), this.loca = new w0(this), this.glyf = new v0(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, b.prototype.registerTTF = function() {
    var g, y, x, P, A;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var v, l, M, B;
      for (B = [], v = 0, l = (M = this.bbox).length; v < l; v++) g = M[v], B.push(Math.round(g * this.scaleFactor));
      return B;
    }).call(this), this.stemV = 0, this.post.exists ? (x = 255 & (P = this.post.italic_angle), 32768 & (y = P >> 16) && (y = -(1 + (65535 ^ y))), this.italicAngle = +(y + "." + x)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (A = this.familyClass) === 1 || A === 2 || A === 3 || A === 4 || A === 5 || A === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, b.prototype.characterToGlyph = function(g) {
    var y;
    return ((y = this.cmap.unicode) != null ? y.codeMap[g] : void 0) || 0;
  }, b.prototype.widthOfGlyph = function(g) {
    var y;
    return y = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(g).advance * y;
  }, b.prototype.widthOfString = function(g, y, x) {
    var P, A, v, l;
    for (v = 0, A = 0, l = (g = "" + g).length; 0 <= l ? A < l : A > l; A = 0 <= l ? ++A : --A) P = g.charCodeAt(A), v += this.widthOfGlyph(this.characterToGlyph(P)) + x * (1e3 / y) || 0;
    return v * (y / 1e3);
  }, b.prototype.lineHeight = function(g, y) {
    var x;
    return y == null && (y = !1), x = y ? this.lineGap : 0, (this.ascender + x - this.decender) / 1e3 * g;
  }, b;
}();
var qa, Pl = function() {
  function b(g) {
    this.data = g ?? [], this.pos = 0, this.length = this.data.length;
  }
  return b.prototype.readByte = function() {
    return this.data[this.pos++];
  }, b.prototype.writeByte = function(g) {
    return this.data[this.pos++] = g;
  }, b.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, b.prototype.writeUInt32 = function(g) {
    return this.writeByte(g >>> 24 & 255), this.writeByte(g >> 16 & 255), this.writeByte(g >> 8 & 255), this.writeByte(255 & g);
  }, b.prototype.readInt32 = function() {
    var g;
    return (g = this.readUInt32()) >= 2147483648 ? g - 4294967296 : g;
  }, b.prototype.writeInt32 = function(g) {
    return g < 0 && (g += 4294967296), this.writeUInt32(g);
  }, b.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, b.prototype.writeUInt16 = function(g) {
    return this.writeByte(g >> 8 & 255), this.writeByte(255 & g);
  }, b.prototype.readInt16 = function() {
    var g;
    return (g = this.readUInt16()) >= 32768 ? g - 65536 : g;
  }, b.prototype.writeInt16 = function(g) {
    return g < 0 && (g += 65536), this.writeUInt16(g);
  }, b.prototype.readString = function(g) {
    var y, x;
    for (x = [], y = 0; 0 <= g ? y < g : y > g; y = 0 <= g ? ++y : --y) x[y] = String.fromCharCode(this.readByte());
    return x.join("");
  }, b.prototype.writeString = function(g) {
    var y, x, P;
    for (P = [], y = 0, x = g.length; 0 <= x ? y < x : y > x; y = 0 <= x ? ++y : --y) P.push(this.writeByte(g.charCodeAt(y)));
    return P;
  }, b.prototype.readShort = function() {
    return this.readInt16();
  }, b.prototype.writeShort = function(g) {
    return this.writeInt16(g);
  }, b.prototype.readLongLong = function() {
    var g, y, x, P, A, v, l, M;
    return g = this.readByte(), y = this.readByte(), x = this.readByte(), P = this.readByte(), A = this.readByte(), v = this.readByte(), l = this.readByte(), M = this.readByte(), 128 & g ? -1 * (72057594037927940 * (255 ^ g) + 281474976710656 * (255 ^ y) + 1099511627776 * (255 ^ x) + 4294967296 * (255 ^ P) + 16777216 * (255 ^ A) + 65536 * (255 ^ v) + 256 * (255 ^ l) + (255 ^ M) + 1) : 72057594037927940 * g + 281474976710656 * y + 1099511627776 * x + 4294967296 * P + 16777216 * A + 65536 * v + 256 * l + M;
  }, b.prototype.writeLongLong = function(g) {
    var y, x;
    return y = Math.floor(g / 4294967296), x = 4294967295 & g, this.writeByte(y >> 24 & 255), this.writeByte(y >> 16 & 255), this.writeByte(y >> 8 & 255), this.writeByte(255 & y), this.writeByte(x >> 24 & 255), this.writeByte(x >> 16 & 255), this.writeByte(x >> 8 & 255), this.writeByte(255 & x);
  }, b.prototype.readInt = function() {
    return this.readInt32();
  }, b.prototype.writeInt = function(g) {
    return this.writeInt32(g);
  }, b.prototype.read = function(g) {
    var y, x;
    for (y = [], x = 0; 0 <= g ? x < g : x > g; x = 0 <= g ? ++x : --x) y.push(this.readByte());
    return y;
  }, b.prototype.write = function(g) {
    var y, x, P, A;
    for (A = [], x = 0, P = g.length; x < P; x++) y = g[x], A.push(this.writeByte(y));
    return A;
  }, b;
}(), c0 = function() {
  var b;
  function g(y) {
    var x, P, A;
    for (this.scalarType = y.readInt(), this.tableCount = y.readShort(), this.searchRange = y.readShort(), this.entrySelector = y.readShort(), this.rangeShift = y.readShort(), this.tables = {}, P = 0, A = this.tableCount; 0 <= A ? P < A : P > A; P = 0 <= A ? ++P : --P) x = { tag: y.readString(4), checksum: y.readInt(), offset: y.readInt(), length: y.readInt() }, this.tables[x.tag] = x;
  }
  return g.prototype.encode = function(y) {
    var x, P, A, v, l, M, B, $, q, U, F, mt, ot;
    for (ot in F = Object.keys(y).length, M = Math.log(2), q = 16 * Math.floor(Math.log(F) / M), v = Math.floor(q / M), $ = 16 * F - q, (P = new Pl()).writeInt(this.scalarType), P.writeShort(F), P.writeShort(q), P.writeShort(v), P.writeShort($), A = 16 * F, B = P.pos + A, l = null, mt = [], y) for (U = y[ot], P.writeString(ot), P.writeInt(b(U)), P.writeInt(B), P.writeInt(U.length), mt = mt.concat(U), ot === "head" && (l = B), B += U.length; B % 4; ) mt.push(0), B++;
    return P.write(mt), x = 2981146554 - b(P.data), P.pos = l + 8, P.writeUInt32(x), P.data;
  }, b = function(y) {
    var x, P, A, v;
    for (y = gf.call(y); y.length % 4; ) y.push(0);
    for (A = new Pl(y), P = 0, x = 0, v = y.length; x < v; x = x += 4) P += A.readUInt32();
    return 4294967295 & P;
  }, g;
}(), h0 = {}.hasOwnProperty, Mo = function(b, g) {
  for (var y in g) h0.call(g, y) && (b[y] = g[y]);
  function x() {
    this.constructor = b;
  }
  return x.prototype = g.prototype, b.prototype = new x(), b.__super__ = g.prototype, b;
};
qa = function() {
  function b(g) {
    var y;
    this.file = g, y = this.file.directory.tables[this.tag], this.exists = !!y, y && (this.offset = y.offset, this.length = y.length, this.parse(this.file.contents));
  }
  return b.prototype.parse = function() {
  }, b.prototype.encode = function() {
  }, b.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, b;
}();
var u0 = function(b) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Mo(g, qa), g.prototype.tag = "head", g.prototype.parse = function(y) {
    return y.pos = this.offset, this.version = y.readInt(), this.revision = y.readInt(), this.checkSumAdjustment = y.readInt(), this.magicNumber = y.readInt(), this.flags = y.readShort(), this.unitsPerEm = y.readShort(), this.created = y.readLongLong(), this.modified = y.readLongLong(), this.xMin = y.readShort(), this.yMin = y.readShort(), this.xMax = y.readShort(), this.yMax = y.readShort(), this.macStyle = y.readShort(), this.lowestRecPPEM = y.readShort(), this.fontDirectionHint = y.readShort(), this.indexToLocFormat = y.readShort(), this.glyphDataFormat = y.readShort();
  }, g.prototype.encode = function(y) {
    var x;
    return (x = new Pl()).writeInt(this.version), x.writeInt(this.revision), x.writeInt(this.checkSumAdjustment), x.writeInt(this.magicNumber), x.writeShort(this.flags), x.writeShort(this.unitsPerEm), x.writeLongLong(this.created), x.writeLongLong(this.modified), x.writeShort(this.xMin), x.writeShort(this.yMin), x.writeShort(this.xMax), x.writeShort(this.yMax), x.writeShort(this.macStyle), x.writeShort(this.lowestRecPPEM), x.writeShort(this.fontDirectionHint), x.writeShort(y), x.writeShort(this.glyphDataFormat), x.data;
  }, g;
}(), Xp = function() {
  function b(g, y) {
    var x, P, A, v, l, M, B, $, q, U, F, mt, ot, yt, st, gt, Mt;
    switch (this.platformID = g.readUInt16(), this.encodingID = g.readShort(), this.offset = y + g.readInt(), q = g.pos, g.pos = this.offset, this.format = g.readUInt16(), this.length = g.readUInt16(), this.language = g.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (M = 0; M < 256; ++M) this.codeMap[M] = g.readByte();
        break;
      case 4:
        for (F = g.readUInt16(), U = F / 2, g.pos += 6, A = function() {
          var Qt, Ht;
          for (Ht = [], M = Qt = 0; 0 <= U ? Qt < U : Qt > U; M = 0 <= U ? ++Qt : --Qt) Ht.push(g.readUInt16());
          return Ht;
        }(), g.pos += 2, ot = function() {
          var Qt, Ht;
          for (Ht = [], M = Qt = 0; 0 <= U ? Qt < U : Qt > U; M = 0 <= U ? ++Qt : --Qt) Ht.push(g.readUInt16());
          return Ht;
        }(), B = function() {
          var Qt, Ht;
          for (Ht = [], M = Qt = 0; 0 <= U ? Qt < U : Qt > U; M = 0 <= U ? ++Qt : --Qt) Ht.push(g.readUInt16());
          return Ht;
        }(), $ = function() {
          var Qt, Ht;
          for (Ht = [], M = Qt = 0; 0 <= U ? Qt < U : Qt > U; M = 0 <= U ? ++Qt : --Qt) Ht.push(g.readUInt16());
          return Ht;
        }(), P = (this.length - g.pos + this.offset) / 2, l = function() {
          var Qt, Ht;
          for (Ht = [], M = Qt = 0; 0 <= P ? Qt < P : Qt > P; M = 0 <= P ? ++Qt : --Qt) Ht.push(g.readUInt16());
          return Ht;
        }(), M = st = 0, Mt = A.length; st < Mt; M = ++st) for (yt = A[M], x = gt = mt = ot[M]; mt <= yt ? gt <= yt : gt >= yt; x = mt <= yt ? ++gt : --gt) $[M] === 0 ? v = x + B[M] : (v = l[$[M] / 2 + (x - mt) - (U - M)] || 0) !== 0 && (v += B[M]), this.codeMap[x] = 65535 & v;
    }
    g.pos = q;
  }
  return b.encode = function(g, y) {
    var x, P, A, v, l, M, B, $, q, U, F, mt, ot, yt, st, gt, Mt, Qt, Ht, pe, jt, Tt, le, ne, at, lt, Pt, bt, Jt, Yt, te, Ut, se, ee, be, Q, pt, _t, Ct, Dt, Ot, Vt, Wt, xe, ve, ke;
    switch (bt = new Pl(), v = Object.keys(g).sort(function(ze, Je) {
      return ze - Je;
    }), y) {
      case "macroman":
        for (ot = 0, yt = function() {
          var ze = [];
          for (mt = 0; mt < 256; ++mt) ze.push(0);
          return ze;
        }(), gt = { 0: 0 }, A = {}, Jt = 0, se = v.length; Jt < se; Jt++) gt[Wt = g[P = v[Jt]]] == null && (gt[Wt] = ++ot), A[P] = { old: g[P], new: gt[g[P]] }, yt[P] = gt[g[P]];
        return bt.writeUInt16(1), bt.writeUInt16(0), bt.writeUInt32(12), bt.writeUInt16(0), bt.writeUInt16(262), bt.writeUInt16(0), bt.write(yt), { charMap: A, subtable: bt.data, maxGlyphID: ot + 1 };
      case "unicode":
        for (lt = [], q = [], Mt = 0, gt = {}, x = {}, st = B = null, Yt = 0, ee = v.length; Yt < ee; Yt++) gt[Ht = g[P = v[Yt]]] == null && (gt[Ht] = ++Mt), x[P] = { old: Ht, new: gt[Ht] }, l = gt[Ht] - P, st != null && l === B || (st && q.push(st), lt.push(P), B = l), st = P;
        for (st && q.push(st), q.push(65535), lt.push(65535), ne = 2 * (le = lt.length), Tt = 2 * Math.pow(Math.log(le) / Math.LN2, 2), U = Math.log(Tt / 2) / Math.LN2, jt = 2 * le - Tt, M = [], pe = [], F = [], mt = te = 0, be = lt.length; te < be; mt = ++te) {
          if (at = lt[mt], $ = q[mt], at === 65535) {
            M.push(0), pe.push(0);
            break;
          }
          if (at - (Pt = x[at].new) >= 32768) for (M.push(0), pe.push(2 * (F.length + le - mt)), P = Ut = at; at <= $ ? Ut <= $ : Ut >= $; P = at <= $ ? ++Ut : --Ut) F.push(x[P].new);
          else M.push(Pt - at), pe.push(0);
        }
        for (bt.writeUInt16(3), bt.writeUInt16(1), bt.writeUInt32(12), bt.writeUInt16(4), bt.writeUInt16(16 + 8 * le + 2 * F.length), bt.writeUInt16(0), bt.writeUInt16(ne), bt.writeUInt16(Tt), bt.writeUInt16(U), bt.writeUInt16(jt), Ot = 0, Q = q.length; Ot < Q; Ot++) P = q[Ot], bt.writeUInt16(P);
        for (bt.writeUInt16(0), Vt = 0, pt = lt.length; Vt < pt; Vt++) P = lt[Vt], bt.writeUInt16(P);
        for (xe = 0, _t = M.length; xe < _t; xe++) l = M[xe], bt.writeUInt16(l);
        for (ve = 0, Ct = pe.length; ve < Ct; ve++) Qt = pe[ve], bt.writeUInt16(Qt);
        for (ke = 0, Dt = F.length; ke < Dt; ke++) ot = F[ke], bt.writeUInt16(ot);
        return { charMap: x, subtable: bt.data, maxGlyphID: Mt + 1 };
    }
  }, b;
}(), mf = function(b) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Mo(g, qa), g.prototype.tag = "cmap", g.prototype.parse = function(y) {
    var x, P, A;
    for (y.pos = this.offset, this.version = y.readUInt16(), A = y.readUInt16(), this.tables = [], this.unicode = null, P = 0; 0 <= A ? P < A : P > A; P = 0 <= A ? ++P : --P) x = new Xp(y, this.offset), this.tables.push(x), x.isUnicode && this.unicode == null && (this.unicode = x);
    return !0;
  }, g.encode = function(y, x) {
    var P, A;
    return x == null && (x = "macroman"), P = Xp.encode(y, x), (A = new Pl()).writeUInt16(0), A.writeUInt16(1), P.table = A.data.concat(P.subtable), P;
  }, g;
}(), d0 = function(b) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Mo(g, qa), g.prototype.tag = "hhea", g.prototype.parse = function(y) {
    return y.pos = this.offset, this.version = y.readInt(), this.ascender = y.readShort(), this.decender = y.readShort(), this.lineGap = y.readShort(), this.advanceWidthMax = y.readShort(), this.minLeftSideBearing = y.readShort(), this.minRightSideBearing = y.readShort(), this.xMaxExtent = y.readShort(), this.caretSlopeRise = y.readShort(), this.caretSlopeRun = y.readShort(), this.caretOffset = y.readShort(), y.pos += 8, this.metricDataFormat = y.readShort(), this.numberOfMetrics = y.readUInt16();
  }, g;
}(), p0 = function(b) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Mo(g, qa), g.prototype.tag = "OS/2", g.prototype.parse = function(y) {
    if (y.pos = this.offset, this.version = y.readUInt16(), this.averageCharWidth = y.readShort(), this.weightClass = y.readUInt16(), this.widthClass = y.readUInt16(), this.type = y.readShort(), this.ySubscriptXSize = y.readShort(), this.ySubscriptYSize = y.readShort(), this.ySubscriptXOffset = y.readShort(), this.ySubscriptYOffset = y.readShort(), this.ySuperscriptXSize = y.readShort(), this.ySuperscriptYSize = y.readShort(), this.ySuperscriptXOffset = y.readShort(), this.ySuperscriptYOffset = y.readShort(), this.yStrikeoutSize = y.readShort(), this.yStrikeoutPosition = y.readShort(), this.familyClass = y.readShort(), this.panose = function() {
      var x, P;
      for (P = [], x = 0; x < 10; ++x) P.push(y.readByte());
      return P;
    }(), this.charRange = function() {
      var x, P;
      for (P = [], x = 0; x < 4; ++x) P.push(y.readInt());
      return P;
    }(), this.vendorID = y.readString(4), this.selection = y.readShort(), this.firstCharIndex = y.readShort(), this.lastCharIndex = y.readShort(), this.version > 0 && (this.ascent = y.readShort(), this.descent = y.readShort(), this.lineGap = y.readShort(), this.winAscent = y.readShort(), this.winDescent = y.readShort(), this.codePageRange = function() {
      var x, P;
      for (P = [], x = 0; x < 2; x = ++x) P.push(y.readInt());
      return P;
    }(), this.version > 1)) return this.xHeight = y.readShort(), this.capHeight = y.readShort(), this.defaultChar = y.readShort(), this.breakChar = y.readShort(), this.maxContext = y.readShort();
  }, g;
}(), f0 = function(b) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Mo(g, qa), g.prototype.tag = "post", g.prototype.parse = function(y) {
    var x, P, A;
    switch (y.pos = this.offset, this.format = y.readInt(), this.italicAngle = y.readInt(), this.underlinePosition = y.readShort(), this.underlineThickness = y.readShort(), this.isFixedPitch = y.readInt(), this.minMemType42 = y.readInt(), this.maxMemType42 = y.readInt(), this.minMemType1 = y.readInt(), this.maxMemType1 = y.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var v;
        for (P = y.readUInt16(), this.glyphNameIndex = [], v = 0; 0 <= P ? v < P : v > P; v = 0 <= P ? ++v : --v) this.glyphNameIndex.push(y.readUInt16());
        for (this.names = [], A = []; y.pos < this.offset + this.length; ) x = y.readByte(), A.push(this.names.push(y.readString(x)));
        return A;
      case 151552:
        return P = y.readUInt16(), this.offsets = y.read(P);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var l, M, B;
          for (B = [], v = l = 0, M = this.file.maxp.numGlyphs; 0 <= M ? l < M : l > M; v = 0 <= M ? ++l : --l) B.push(y.readUInt32());
          return B;
        }).call(this);
    }
  }, g;
}(), m0 = function(b, g) {
  this.raw = b, this.length = b.length, this.platformID = g.platformID, this.encodingID = g.encodingID, this.languageID = g.languageID;
}, g0 = function(b) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Mo(g, qa), g.prototype.tag = "name", g.prototype.parse = function(y) {
    var x, P, A, v, l, M, B, $, q, U, F;
    for (y.pos = this.offset, y.readShort(), x = y.readShort(), M = y.readShort(), P = [], v = 0; 0 <= x ? v < x : v > x; v = 0 <= x ? ++v : --v) P.push({ platformID: y.readShort(), encodingID: y.readShort(), languageID: y.readShort(), nameID: y.readShort(), length: y.readShort(), offset: this.offset + M + y.readShort() });
    for (B = {}, v = q = 0, U = P.length; q < U; v = ++q) A = P[v], y.pos = A.offset, $ = y.readString(A.length), l = new m0($, A), B[F = A.nameID] == null && (B[F] = []), B[A.nameID].push(l);
    this.strings = B, this.copyright = B[0], this.fontFamily = B[1], this.fontSubfamily = B[2], this.uniqueSubfamily = B[3], this.fontName = B[4], this.version = B[5];
    try {
      this.postscriptName = B[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = B[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = B[7], this.manufacturer = B[8], this.designer = B[9], this.description = B[10], this.vendorUrl = B[11], this.designerUrl = B[12], this.license = B[13], this.licenseUrl = B[14], this.preferredFamily = B[15], this.preferredSubfamily = B[17], this.compatibleFull = B[18], this.sampleText = B[19];
  }, g;
}(), y0 = function(b) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Mo(g, qa), g.prototype.tag = "maxp", g.prototype.parse = function(y) {
    return y.pos = this.offset, this.version = y.readInt(), this.numGlyphs = y.readUInt16(), this.maxPoints = y.readUInt16(), this.maxContours = y.readUInt16(), this.maxCompositePoints = y.readUInt16(), this.maxComponentContours = y.readUInt16(), this.maxZones = y.readUInt16(), this.maxTwilightPoints = y.readUInt16(), this.maxStorage = y.readUInt16(), this.maxFunctionDefs = y.readUInt16(), this.maxInstructionDefs = y.readUInt16(), this.maxStackElements = y.readUInt16(), this.maxSizeOfInstructions = y.readUInt16(), this.maxComponentElements = y.readUInt16(), this.maxComponentDepth = y.readUInt16();
  }, g;
}(), _0 = function(b) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Mo(g, qa), g.prototype.tag = "hmtx", g.prototype.parse = function(y) {
    var x, P, A, v, l, M, B;
    for (y.pos = this.offset, this.metrics = [], x = 0, M = this.file.hhea.numberOfMetrics; 0 <= M ? x < M : x > M; x = 0 <= M ? ++x : --x) this.metrics.push({ advance: y.readUInt16(), lsb: y.readInt16() });
    for (A = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var $, q;
      for (q = [], x = $ = 0; 0 <= A ? $ < A : $ > A; x = 0 <= A ? ++$ : --$) q.push(y.readInt16());
      return q;
    }(), this.widths = (function() {
      var $, q, U, F;
      for (F = [], $ = 0, q = (U = this.metrics).length; $ < q; $++) v = U[$], F.push(v.advance);
      return F;
    }).call(this), P = this.widths[this.widths.length - 1], B = [], x = l = 0; 0 <= A ? l < A : l > A; x = 0 <= A ? ++l : --l) B.push(this.widths.push(P));
    return B;
  }, g.prototype.forGlyph = function(y) {
    return y in this.metrics ? this.metrics[y] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[y - this.metrics.length] };
  }, g;
}(), gf = [].slice, v0 = function(b) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Mo(g, qa), g.prototype.tag = "glyf", g.prototype.parse = function() {
    return this.cache = {};
  }, g.prototype.glyphFor = function(y) {
    var x, P, A, v, l, M, B, $, q, U;
    return y in this.cache ? this.cache[y] : (v = this.file.loca, x = this.file.contents, P = v.indexOf(y), (A = v.lengthOf(y)) === 0 ? this.cache[y] = null : (x.pos = this.offset + P, l = (M = new Pl(x.read(A))).readShort(), $ = M.readShort(), U = M.readShort(), B = M.readShort(), q = M.readShort(), this.cache[y] = l === -1 ? new b0(M, $, U, B, q) : new x0(M, l, $, U, B, q), this.cache[y]));
  }, g.prototype.encode = function(y, x, P) {
    var A, v, l, M, B;
    for (l = [], v = [], M = 0, B = x.length; M < B; M++) A = y[x[M]], v.push(l.length), A && (l = l.concat(A.encode(P)));
    return v.push(l.length), { table: l, offsets: v };
  }, g;
}(), x0 = function() {
  function b(g, y, x, P, A, v) {
    this.raw = g, this.numberOfContours = y, this.xMin = x, this.yMin = P, this.xMax = A, this.yMax = v, this.compound = !1;
  }
  return b.prototype.encode = function() {
    return this.raw.data;
  }, b;
}(), b0 = function() {
  function b(g, y, x, P, A) {
    var v, l;
    for (this.raw = g, this.xMin = y, this.yMin = x, this.xMax = P, this.yMax = A, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], v = this.raw; l = v.readShort(), this.glyphOffsets.push(v.pos), this.glyphIDs.push(v.readUInt16()), 32 & l; ) v.pos += 1 & l ? 4 : 2, 128 & l ? v.pos += 8 : 64 & l ? v.pos += 4 : 8 & l && (v.pos += 2);
  }
  return b.prototype.encode = function() {
    var g, y, x;
    for (y = new Pl(gf.call(this.raw.data)), g = 0, x = this.glyphIDs.length; g < x; ++g) y.pos = this.glyphOffsets[g];
    return y.data;
  }, b;
}(), w0 = function(b) {
  function g() {
    return g.__super__.constructor.apply(this, arguments);
  }
  return Mo(g, qa), g.prototype.tag = "loca", g.prototype.parse = function(y) {
    var x, P;
    return y.pos = this.offset, x = this.file.head.indexToLocFormat, this.offsets = x === 0 ? (function() {
      var A, v;
      for (v = [], P = 0, A = this.length; P < A; P += 2) v.push(2 * y.readUInt16());
      return v;
    }).call(this) : (function() {
      var A, v;
      for (v = [], P = 0, A = this.length; P < A; P += 4) v.push(y.readUInt32());
      return v;
    }).call(this);
  }, g.prototype.indexOf = function(y) {
    return this.offsets[y];
  }, g.prototype.lengthOf = function(y) {
    return this.offsets[y + 1] - this.offsets[y];
  }, g.prototype.encode = function(y, x) {
    for (var P = new Uint32Array(this.offsets.length), A = 0, v = 0, l = 0; l < P.length; ++l) if (P[l] = A, v < x.length && x[v] == l) {
      ++v, P[l] = A;
      var M = this.offsets[l], B = this.offsets[l + 1] - M;
      B > 0 && (A += B);
    }
    for (var $ = new Array(4 * P.length), q = 0; q < P.length; ++q) $[4 * q + 3] = 255 & P[q], $[4 * q + 2] = (65280 & P[q]) >> 8, $[4 * q + 1] = (16711680 & P[q]) >> 16, $[4 * q] = (4278190080 & P[q]) >> 24;
    return $;
  }, g;
}(), S0 = function() {
  function b(g) {
    this.font = g, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return b.prototype.generateCmap = function() {
    var g, y, x, P, A;
    for (y in P = this.font.cmap.tables[0].codeMap, g = {}, A = this.subset) x = A[y], g[y] = P[x];
    return g;
  }, b.prototype.glyphsFor = function(g) {
    var y, x, P, A, v, l, M;
    for (P = {}, v = 0, l = g.length; v < l; v++) P[A = g[v]] = this.font.glyf.glyphFor(A);
    for (A in y = [], P) (x = P[A]) != null && x.compound && y.push.apply(y, x.glyphIDs);
    if (y.length > 0) for (A in M = this.glyphsFor(y)) x = M[A], P[A] = x;
    return P;
  }, b.prototype.encode = function(g, y) {
    var x, P, A, v, l, M, B, $, q, U, F, mt, ot, yt, st;
    for (P in x = mf.encode(this.generateCmap(), "unicode"), v = this.glyphsFor(g), F = { 0: 0 }, st = x.charMap) F[(M = st[P]).old] = M.new;
    for (mt in U = x.maxGlyphID, v) mt in F || (F[mt] = U++);
    return $ = function(gt) {
      var Mt, Qt;
      for (Mt in Qt = {}, gt) Qt[gt[Mt]] = Mt;
      return Qt;
    }(F), q = Object.keys($).sort(function(gt, Mt) {
      return gt - Mt;
    }), ot = function() {
      var gt, Mt, Qt;
      for (Qt = [], gt = 0, Mt = q.length; gt < Mt; gt++) l = q[gt], Qt.push($[l]);
      return Qt;
    }(), A = this.font.glyf.encode(v, ot, F), B = this.font.loca.encode(A.offsets, ot), yt = { cmap: this.font.cmap.raw(), glyf: A.table, loca: B, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(y) }, this.font.os2.exists && (yt["OS/2"] = this.font.os2.raw()), this.font.directory.encode(yt);
  }, b;
}();
pi.API.PDFObject = function() {
  var b;
  function g() {
  }
  return b = function(y, x) {
    return (Array(x + 1).join("0") + y).slice(-x);
  }, g.convert = function(y) {
    var x, P, A, v;
    if (Array.isArray(y)) return "[" + function() {
      var l, M, B;
      for (B = [], l = 0, M = y.length; l < M; l++) x = y[l], B.push(g.convert(x));
      return B;
    }().join(" ") + "]";
    if (typeof y == "string") return "/" + y;
    if (y != null && y.isString) return "(" + y + ")";
    if (y instanceof Date) return "(D:" + b(y.getUTCFullYear(), 4) + b(y.getUTCMonth(), 2) + b(y.getUTCDate(), 2) + b(y.getUTCHours(), 2) + b(y.getUTCMinutes(), 2) + b(y.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(y) === "[object Object]") {
      for (P in A = ["<<"], y) v = y[P], A.push("/" + P + " " + g.convert(v));
      return A.push(">>"), A.join(`
`);
    }
    return "" + y;
  }, g;
}();
const Wh = {
  "circle-radius": 8,
  "circle-color": "red",
  "circle-stroke-width": 1,
  "circle-stroke-color": "black"
}, uh = {
  style: {
    textSize: 16,
    textHaloColor: "#FFFFFF",
    textHaloWidth: 0.8,
    textColor: "#000000",
    fallbackTextFont: ["Open Sans Regular"]
  },
  visibility: "visible",
  position: "bottom-right"
}, dh = {
  image: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="none" stroke="white" stroke-width="1.5"/><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="#000000" fill-rule="evenodd"></path></svg>',
  imageName: "gl-export-north-icon",
  imageSizeFraction: 0.05,
  visibility: "visible",
  position: "top-right"
};
class yf {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(g, y = Gl.A4, x = 300, P = nl.PNG, A = Hl.mm, v = "map", l = "maplibregl-marker", M = Wh, B = "maplibregl-ctrl-attrib-inner", $ = uh, q = dh) {
    Zi(this, "map"), Zi(this, "width"), Zi(this, "height"), Zi(this, "dpi"), Zi(this, "format"), Zi(this, "unit"), Zi(this, "fileName"), Zi(this, "markerClassName"), Zi(this, "markerCirclePaint"), Zi(this, "attributionClassName"), Zi(this, "attributionOptions"), Zi(this, "northIconOptions"), this.map = g, this.width = y[0], this.height = y[1], this.dpi = x, this.format = P, this.unit = A, this.fileName = v, this.markerClassName = l, this.markerCirclePaint = M, this.attributionClassName = B, this.attributionOptions = $, this.northIconOptions = q;
  }
  renderMapPost(g) {
    return g;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(g) {
    const y = this.getMarkers();
    for (let x = 0; x < y.length; x++) {
      const P = y.item(x);
      if (!P) continue;
      const A = P.getAttribute("style");
      if (!A) continue;
      const v = /translate\(([^,]+)px,\s*([^,]+)px\)/, l = A.match(v);
      if (!l) continue;
      const M = parseInt(l[1]), B = parseInt(l[2]), $ = this.map.unproject([M, B]), q = `point${x}`;
      g.addSource(q, {
        type: "geojson",
        data: {
          type: "Point",
          coordinates: [$.lng, $.lat]
        }
      }), g.addLayer({
        id: q,
        source: q,
        type: "circle",
        paint: this.markerCirclePaint
      });
    }
    return g;
  }
  /**
   * Generate and download Map image
   */
  generate() {
    const g = this;
    JsLoadingOverlay.show({
      overlayBackgroundColor: "#5D5959",
      overlayOpacity: "0.6",
      spinnerIcon: "ball-spin",
      spinnerColor: "#2400FD",
      spinnerSize: "2x",
      overlayIDName: "overlay",
      spinnerIDName: "spinner",
      offsetX: 0,
      offsetY: 0,
      containerID: null,
      lockScroll: !1,
      overlayZIndex: 9998,
      spinnerZIndex: 9999
    });
    const y = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", {
      get() {
        return g.dpi / 96;
      }
    });
    const x = document.createElement("div");
    x.className = "hidden-map", document.body.appendChild(x);
    const P = document.createElement("div");
    P.style.width = this.toPixels(this.width), P.style.height = this.toPixels(this.height), x.appendChild(P);
    const A = this.map.getStyle();
    if (A && A.sources) {
      const l = A.sources;
      Object.keys(l).forEach((M) => {
        const B = l[M];
        Object.keys(B).forEach(($) => {
          B[$] || delete B[$];
        });
      });
    }
    let v = this.getRenderedMap(P, A);
    this.addNorthIconToMap(v).then(() => {
      v.once("idle", () => {
        this.addAttributions(v) ? v.once("idle", () => {
          v = this.renderMapPost(v), this.getMarkers().length === 0 ? this.exportImage(v, x, y) : (v = this.renderMarkers(v), v.once("idle", () => {
            this.exportImage(v, x, y);
          }));
        }) : (v = this.renderMapPost(v), this.getMarkers().length === 0 ? this.exportImage(v, x, y) : (v = this.renderMarkers(v), v.once("idle", () => {
          this.exportImage(v, x, y);
        })));
      });
    });
  }
  stripHtml(g) {
    const y = document.createElement("div");
    return y.innerHTML = g, y.textContent || y.innerText || "";
  }
  /**
   * Get icon width against exported map size by using fraction rate
   * @param renderMap Map object
   * @param fraction adjust icon size by using this fraction rate. Default is 8%
   * @returns Icon width calculated
   */
  getIconWidth(g, y) {
    const x = g.getContainer(), P = parseInt(x.style.width.replace("px", ""));
    return parseInt(`${P * y}`);
  }
  /**
   * Get element position's pixel values based on selected position setting
   * @param renderMap Map object
   * @param position Position of element inserted
   * @param offset Offset value to adjust position
   * @returns Pixels [width, height]
   */
  getElementPosition(g, y, x = 0) {
    const P = g.getContainer();
    let A = 0, v = 0;
    switch (y) {
      case "top-left":
        A = 0 + x, v = 0 + x;
        break;
      case "top-right":
        A = parseInt(P.style.width.replace("px", "")) - x, v = 0 + x;
        break;
      case "bottom-left":
        A = 0 + x, v = parseInt(P.style.height.replace("px", "")) - x;
        break;
      case "bottom-right":
        A = parseInt(P.style.width.replace("px", "")) - x, v = parseInt(P.style.height.replace("px", "")) - x;
        break;
    }
    return [A, v];
  }
  /**
   * Add North Icon SVG to map object
   * @param renderMap Map object
   * @returns void
   */
  addNorthIconImage(g) {
    const y = this.getIconWidth(g, this.northIconOptions.imageSizeFraction ?? 0.08);
    return new Promise((x) => {
      const P = new Image(y, y);
      P.onload = () => {
        this.northIconOptions.imageName && g.addImage(this.northIconOptions.imageName, P), x();
      };
      function A(v) {
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(v);
      }
      this.northIconOptions.image && (P.src = A(this.northIconOptions.image));
    });
  }
  /**
   * Add North Icon Symbol layer to renderMap object
   * @param renderMap Map object
   * @returns
   */
  addNorthIconToMap(g) {
    let y = this.northIconOptions.visibility ?? "visible";
    return g.getZoom() < 2 && this.width > this.height && (y = "none"), new Promise((x) => {
      this.addNorthIconImage(g).then(() => {
        const P = this.getIconWidth(
          g,
          this.northIconOptions.imageSizeFraction ?? 0.08
        ) * 0.8, A = this.getElementPosition(
          g,
          this.northIconOptions.position ?? "top-right",
          P
        ), v = g.unproject(A), l = this.northIconOptions.imageName ?? "gl-export-north-icon";
        g.addSource(l, {
          type: "geojson",
          data: {
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: [v.lng, v.lat]
            },
            properties: {}
          }
        }), g.addLayer({
          id: l,
          source: l,
          type: "symbol",
          layout: {
            "icon-image": l,
            "icon-size": 1,
            "icon-rotate": g.getBearing() * -1,
            "icon-allow-overlap": !0,
            "icon-ignore-placement": !0,
            visibility: y
          },
          paint: {}
        }), x();
      });
    });
  }
  addAttributions(g) {
    var y;
    if (!this.map.getStyle().glyphs) return !1;
    const x = g.getContainer(), P = this.attributionOptions.position ?? "bottom-right", A = this.getElementPosition(g, P, 5), v = A[0], l = g.unproject(A), M = x.getElementsByClassName(this.attributionClassName), B = [];
    if ((M == null ? void 0 : M.length) > 0) {
      const yt = M.item(0);
      if (yt)
        for (let st = 0; st < yt.children.length; st++) {
          const gt = yt.children.item(st);
          gt && B.push(this.stripHtml(gt.outerHTML));
        }
    } else {
      const yt = this.map.getStyle().sources;
      Object.keys(yt).forEach((st) => {
        const gt = yt[st];
        if ("attribution" in gt) {
          const Mt = gt.attribution;
          B.push(this.stripHtml(Mt));
        }
      });
    }
    if (B.length === 0) return !1;
    const $ = B.join(" | "), q = "attribution";
    g.addSource(q, {
      type: "geojson",
      data: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [l.lng, l.lat]
        },
        properties: {
          attribution: $
        }
      }
    });
    const U = this.map.getStyle().layers.filter(
      (yt) => yt.type === "symbol" && yt.layout && "text-font" in yt.layout
    ), F = U.length > 0 && U[0].layout ? U[0].layout["text-font"] : (y = this.attributionOptions.style) == null ? void 0 : y.fallbackTextFont;
    let mt = this.attributionOptions.visibility ?? "visible";
    g.getZoom() < 2 && this.width > this.height && (mt = "none");
    const ot = this.attributionOptions.style;
    return g.addLayer({
      id: q,
      source: q,
      type: "symbol",
      layout: {
        "text-field": ["get", "attribution"],
        "text-font": F,
        "text-max-width": parseInt(`${v / ot.textSize}`),
        "text-anchor": P,
        "text-justify": ["top-right", "bottom-right"].includes(P) ? "right" : "left",
        "text-size": ot.textSize,
        "text-allow-overlap": !0,
        visibility: mt
      },
      paint: {
        "text-halo-color": ot.textHaloColor,
        "text-halo-width": ot.textHaloWidth,
        "text-color": ot.textColor
      }
    }), !0;
  }
  exportImage(g, y, x) {
    var P;
    const A = g.getCanvas(), v = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case nl.PNG:
        this.toPNG(A, v);
        break;
      case nl.JPEG:
        this.toJPEG(A, v);
        break;
      case nl.PDF:
        this.toPDF(g, v);
        break;
      case nl.SVG:
        this.toSVG(A, v);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    g.remove(), (P = y.parentNode) == null || P.removeChild(y), Object.defineProperty(window, "devicePixelRatio", {
      get() {
        return x;
      }
    }), y.remove(), JsLoadingOverlay.hide();
  }
  /**
   * Convert canvas to PNG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toPNG(g, y) {
    const x = document.createElement("a");
    x.href = g.toDataURL(), x.download = y, x.click(), x.remove();
  }
  /**
   * Convert canvas to JPEG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toJPEG(g, y) {
    const x = g.toDataURL("image/jpeg", 0.85), P = document.createElement("a");
    P.href = x, P.download = y, P.click(), P.remove();
  }
  /**
   * Convert Map object to PDF
   * @param map Map object
   * @param fileName file name
   */
  toPDF(g, y) {
    const x = g.getCanvas(), P = new pi({
      orientation: this.width > this.height ? "l" : "p",
      unit: this.unit,
      compress: !0,
      format: [this.width, this.height]
    });
    P.addImage(
      x.toDataURL("image/png"),
      "png",
      0,
      0,
      this.width,
      this.height,
      void 0,
      "FAST"
    );
    const { lng: A, lat: v } = g.getCenter();
    P.setProperties({
      title: g.getStyle().name,
      subject: `center: [${A}, ${v}], zoom: ${g.getZoom()}`,
      creator: "Mapbox GL Export Plugin",
      author: "(c)Mapbox, (c)OpenStreetMap"
    }), P.save(y);
  }
  /**
   * Convert canvas to SVG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toSVG(g, y) {
    const x = g.toDataURL("image/png"), P = Number(this.toPixels(this.width, this.dpi).replace("px", "")), A = Number(this.toPixels(this.height, this.dpi).replace("px", "")), v = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${P}" 
      height="${A}" 
      viewBox="0 0 ${P} ${A}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${x}" width="${P}" height="${A}"></image>
    </svg>`, l = document.createElement("a");
    l.href = `data:application/xml,${encodeURIComponent(v)}`, l.download = y, l.click(), l.remove();
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(g, y = 96) {
    return this.unit === Hl.mm && (y /= 25.4), `${y * g}px`;
  }
}
class A0 extends yf {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(g, y = Gl.A4, x = 300, P = nl.PNG, A = Hl.mm, v = "map", l = Wh, M = uh, B = dh) {
    super(
      g,
      y,
      x,
      P,
      A,
      v,
      "maplibregl-marker",
      l,
      "maplibregl-ctrl-attrib-inner",
      M,
      B
    );
  }
  getRenderedMap(g, y) {
    const x = new cg.Map({
      container: g,
      style: y,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transfrom request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (x.setMaxPitch(85), x.setPitch(this.map.getPitch()));
    const P = (this.map.style.imageManager || {}).images || [];
    return Object.keys(P).forEach((A) => {
      P[A].data && x.addImage(A, P[A].data);
    }), x;
  }
  renderMapPost(g) {
    const y = this.map.getTerrain();
    return y && g.setTerrain({
      source: y.source,
      exaggeration: y.exaggeration
    }), g;
  }
}
class P0 {
  constructor(g) {
    Zi(this, "controlContainer"), Zi(this, "exportContainer"), Zi(this, "crosshair"), Zi(this, "printableArea"), Zi(this, "map"), Zi(this, "exportButton"), Zi(this, "options", {
      PageSize: Gl.A4,
      PageOrientation: zh.Landscape,
      Format: nl.PDF,
      DPI: Tp[300],
      Crosshair: !1,
      PrintableArea: !1,
      Local: "en",
      AllowedSizes: Object.keys(Gl),
      Filename: "map",
      markerCirclePaint: Wh,
      attributionOptions: uh,
      northIconOptions: dh
    }), Zi(this, "MAPLIB_CSS_PREFIX", "maplibregl"), g && (g.attributionOptions = Object.assign(
      uh,
      g.attributionOptions
    ), g.northIconOptions = Object.assign(dh, g.northIconOptions), this.options = Object.assign(this.options, g)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const g = this.options.Local ?? "en";
    return kg(g);
  }
  onAdd(g) {
    var y;
    this.map = g, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const x = document.createElement("TABLE");
    x.className = "print-table";
    const P = {};
    (y = this.options.AllowedSizes) == null || y.forEach(($) => {
      Gl[$] && (P[$] = Gl[$]);
    });
    const A = this.createSelection(
      P,
      this.getTranslation().PageSize,
      "page-size",
      this.options.PageSize,
      ($, q) => JSON.stringify($[q])
    );
    x.appendChild(A);
    const v = this.createSelection(
      zh,
      this.getTranslation().PageOrientation,
      "page-orientation",
      this.options.PageOrientation,
      ($, q) => $[q]
    );
    x.appendChild(v);
    const l = this.createSelection(
      nl,
      this.getTranslation().Format,
      "format-type",
      this.options.Format,
      ($, q) => $[q]
    );
    x.appendChild(l);
    const M = this.createSelection(
      Tp,
      this.getTranslation().DPI,
      "dpi-type",
      this.options.DPI,
      ($, q) => $[q]
    );
    x.appendChild(M), this.exportContainer.appendChild(x);
    const B = document.createElement("button");
    return B.type = "button", B.textContent = this.getTranslation().Generate, B.classList.add("generate-button"), B.addEventListener("click", () => {
      const $ = document.getElementById("mapbox-gl-export-page-size"), q = document.getElementById("mapbox-gl-export-page-orientation"), U = document.getElementById("mapbox-gl-export-format-type"), F = document.getElementById("mapbox-gl-export-dpi-type"), mt = q.value;
      let ot = JSON.parse($.value);
      mt === zh.Portrait && (ot = ot.reverse()), this.generateMap(
        g,
        ot,
        Number(F.value),
        U.value,
        Hl.mm,
        this.options.Filename
      );
    }), this.exportContainer.appendChild(B), this.controlContainer;
  }
  generateMap(g, y, x, P, A, v) {
    new A0(
      g,
      y,
      x,
      P,
      A,
      v,
      this.options.markerCirclePaint,
      this.options.attributionOptions,
      this.options.northIconOptions
    ).generate();
  }
  createSelection(g, y, x, P, A) {
    const v = document.createElement("label");
    v.textContent = y;
    const l = document.createElement("select");
    l.setAttribute("id", `mapbox-gl-export-${x}`), l.style.width = "100%", Object.keys(g).forEach((q) => {
      const U = document.createElement("option");
      U.setAttribute("value", A(g, q)), U.appendChild(document.createTextNode(q)), U.setAttribute("name", x), P === g[q] && (U.selected = !0), l.appendChild(U);
    }), l.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const M = document.createElement("TR"), B = document.createElement("TD"), $ = document.createElement("TD");
    return B.appendChild(v), $.appendChild(l), M.appendChild(B), M.appendChild($), M;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(g) {
    this.controlContainer && !this.controlContainer.contains(g.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(g) {
    this.options.Crosshair === !0 && (g === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new dg(this.map), this.crosshair.create()));
  }
  togglePrintableArea(g) {
    this.options.PrintableArea === !0 && (g === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new pg(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0)
      return;
    const g = document.getElementById("mapbox-gl-export-page-size"), y = document.getElementById("mapbox-gl-export-page-orientation").value;
    let x = JSON.parse(g.value);
    y === zh.Portrait && (x = x.reverse()), this.printableArea.updateArea(x[0], x[1]);
  }
}
(function(b) {
  var g = {};
  function y(x) {
    if (g[x]) return g[x].exports;
    var P = g[x] = { i: x, l: !1, exports: {} };
    return b[x].call(P.exports, P, P.exports, y), P.l = !0, P.exports;
  }
  y.m = b, y.c = g, y.d = function(x, P, A) {
    y.o(x, P) || Object.defineProperty(x, P, { enumerable: !0, get: A });
  }, y.r = function(x) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(x, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(x, "__esModule", { value: !0 });
  }, y.t = function(x, P) {
    if (1 & P && (x = y(x)), 8 & P || 4 & P && typeof x == "object" && x && x.__esModule) return x;
    var A = /* @__PURE__ */ Object.create(null);
    if (y.r(A), Object.defineProperty(A, "default", { enumerable: !0, value: x }), 2 & P && typeof x != "string") for (var v in x) y.d(A, v, (function(l) {
      return x[l];
    }).bind(null, v));
    return A;
  }, y.n = function(x) {
    var P = x && x.__esModule ? function() {
      return x.default;
    } : function() {
      return x;
    };
    return y.d(P, "a", P), P;
  }, y.o = function(x, P) {
    return Object.prototype.hasOwnProperty.call(x, P);
  }, y.p = "", y(y.s = 0);
})([function(b, g, y) {
  b.exports = y(1);
}, function(b, g) {
  function y(P, A) {
    for (var v = 0; v < A.length; v++) {
      var l = A[v];
      l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(P, l.key, l);
    }
  }
  var x = function() {
    function P() {
      (function(l, M) {
        if (!(l instanceof M)) throw new TypeError("Cannot call a class as a function");
      })(this, P), this.options = { overlayBackgroundColor: "#666666", overlayOpacity: 0.6, spinnerIcon: "ball-circus", spinnerColor: "#000", spinnerSize: "3x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetY: 0, offsetX: 0, lockScroll: !1, containerID: null, spinnerZIndex: 99999, overlayZIndex: 99998 }, this.stylesheetBaseURL = "https://cdn.jsdelivr.net/npm/load-awesome@1.1.0/css/", this.spinner = null, this.spinnerStylesheetURL = null, this.numberOfEmptyDivForSpinner = { "ball-8bits": 16, "ball-atom": 4, "ball-beat": 3, "ball-circus": 5, "ball-climbing-dot": 1, "ball-clip-rotate": 1, "ball-clip-rotate-multiple": 2, "ball-clip-rotate-pulse": 2, "ball-elastic-dots": 5, "ball-fall": 3, "ball-fussion": 4, "ball-grid-beat": 9, "ball-grid-pulse": 9, "ball-newton-cradle": 4, "ball-pulse": 3, "ball-pulse-rise": 5, "ball-pulse-sync": 3, "ball-rotate": 1, "ball-running-dots": 5, "ball-scale": 1, "ball-scale-multiple": 3, "ball-scale-pulse": 2, "ball-scale-ripple": 1, "ball-scale-ripple-multiple": 3, "ball-spin": 8, "ball-spin-clockwise": 8, "ball-spin-clockwise-fade": 8, "ball-spin-clockwise-fade-rotating": 8, "ball-spin-fade": 8, "ball-spin-fade-rotating": 8, "ball-spin-rotate": 2, "ball-square-clockwise-spin": 8, "ball-square-spin": 8, "ball-triangle-path": 3, "ball-zig-zag": 2, "ball-zig-zag-deflect": 2, cog: 1, "cube-transition": 2, fire: 3, "line-scale": 5, "line-scale-party": 5, "line-scale-pulse-out": 5, "line-scale-pulse-out-rapid": 5, "line-spin-clockwise-fade": 8, "line-spin-clockwise-fade-rotating": 8, "line-spin-fade": 8, "line-spin-fade-rotating": 8, pacman: 6, "square-jelly-box": 2, "square-loader": 1, "square-spin": 1, timer: 1, "triangle-skew-spin": 1 };
    }
    var A, v;
    return A = P, (v = [{ key: "show", value: function(l) {
      this.setOptions(l), this.addSpinnerStylesheet(), this.generateSpinnerElement(), this.options.lockScroll && (document.body.style.overflow = "hidden", document.documentElement.style.overflow = "hidden"), this.generateAndAddOverlayElement();
    } }, { key: "hide", value: function() {
      this.options.lockScroll && (document.body.style.overflow = "", document.documentElement.style.overflow = "");
      var l = document.getElementById("loading-overlay-stylesheet");
      l && (l.disabled = !0, l.parentNode.removeChild(l), document.getElementById(this.options.overlayIDName).remove(), document.getElementById(this.options.spinnerIDName).remove());
    } }, { key: "setOptions", value: function(l) {
      if (l !== void 0) for (var M in l) this.options[M] = l[M];
    } }, { key: "generateAndAddOverlayElement", value: function() {
      var l = "50%";
      this.options.offsetX !== 0 && (l = "calc(50% + " + this.options.offsetX + ")");
      var M = "50%";
      if (this.options.offsetY !== 0 && (M = "calc(50% + " + this.options.offsetY + ")"), this.options.containerID && document.body.contains(document.getElementById(this.options.containerID))) {
        var B = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: absolute; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, '; z-index: 50; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: absolute; top: ').concat(M, "; left: ").concat(l, '; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: 9999;">').concat(this.spinner, "</div>"), $ = document.getElementById(this.options.containerID);
        return $.style.position = "relative", void $.insertAdjacentHTML("beforeend", B);
      }
      var q = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: fixed; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, "; z-index: ").concat(this.options.overlayZIndex, '; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: fixed; top: ').concat(M, "; left: ").concat(l, "; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: ").concat(this.options.spinnerZIndex, ';">').concat(this.spinner, "</div>");
      document.body.insertAdjacentHTML("beforeend", q);
    } }, { key: "generateSpinnerElement", value: function() {
      var l = this, M = Object.keys(this.numberOfEmptyDivForSpinner).find(function($) {
        return $ === l.options.spinnerIcon;
      }), B = this.generateEmptyDivElement(this.numberOfEmptyDivForSpinner[M]);
      this.spinner = '<div style="color: '.concat(this.options.spinnerColor, '" class="la-').concat(this.options.spinnerIcon, " la-").concat(this.options.spinnerSize, '">').concat(B, "</div>");
    } }, { key: "addSpinnerStylesheet", value: function() {
      this.setSpinnerStylesheetURL();
      var l = document.createElement("link");
      l.setAttribute("id", "loading-overlay-stylesheet"), l.setAttribute("rel", "stylesheet"), l.setAttribute("type", "text/css"), l.setAttribute("href", this.spinnerStylesheetURL), document.getElementsByTagName("head")[0].appendChild(l);
    } }, { key: "setSpinnerStylesheetURL", value: function() {
      this.spinnerStylesheetURL = this.stylesheetBaseURL + this.options.spinnerIcon + ".min.css";
    } }, { key: "generateEmptyDivElement", value: function(l) {
      for (var M = "", B = 1; B <= l; B++) M += "<div></div>";
      return M;
    } }]) && y(A.prototype, v), P;
  }();
  window.JsLoadingOverlay = new x(), b.exports = JsLoadingOverlay;
}]);
class I0 extends yf {
  /**
   * Constructor
   * @param map MapboxMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(y, x = Gl.A4, P = 300, A = nl.PNG, v = Hl.mm, l = "map", M = Wh, B = uh, $ = dh, q) {
    super(
      y,
      x,
      P,
      A,
      v,
      l,
      "mapboxgl-marker",
      M,
      "mapboxgl-ctrl-attrib-inner",
      B,
      $
    );
    Eu(this, "accesstoken");
    this.accesstoken = q;
  }
  getRenderedMap(y, x) {
    var v;
    const P = new ag({
      accessToken: this.accesstoken || og,
      container: y,
      style: x,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transfrom request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    }), A = (this.map.style.imageManager || {}).images || [];
    return console.log(" ~ file: map-generator.ts:80 ~ MapGenerator ~ getRenderedMap ~ images:", A), A && ((v = Object.keys(A)) == null ? void 0 : v.length) > 0 && Object.keys(A).forEach((l) => {
      l && A[l].data && P.addImage(l, A[l].data);
    }), P;
  }
}
class L0 extends P0 {
  constructor(y) {
    super(y);
    Eu(this, "accessToken");
    this.MAPLIB_CSS_PREFIX = "mapboxgl", this.accessToken = y.accessToken;
  }
  generateMap(y, x, P, A, v, l) {
    new I0(
      y,
      x,
      P,
      A,
      v,
      l,
      this.options.markerCirclePaint,
      this.options.attributionOptions,
      this.options.northIconOptions,
      this.accessToken
    ).generate();
  }
}
export {
  nl as C,
  L0 as M,
  Gl as _,
  ir as p,
  zh as t,
  Tp as u
};
//# sourceMappingURL=index-Bkd3QruW.mjs.map
